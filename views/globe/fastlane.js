(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.fastlane = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

class CFGNode {
    constructor() {
        this.next = [];
        this.prev = [];
    }
}
class EntryNode extends CFGNode {}
class ExitNode extends CFGNode {}

function wrap(node) {
    const existingExitNode = findExitNode(node);
    const exitingEntryNode = findEntryNode(node);
    if (existingExitNode) {
        if (!exitingEntryNode)
            throw new Error("Found exit node but no entry node!");
        return {
            entryNode: exitingEntryNode,
            exitNode: existingExitNode,
            wasAlreadyWrapped: true
        };
    }
    const exitNode = new ExitNode();
    node.next.push(exitNode);
    exitNode.prev.push(node);

    return {
        entryNode: addEntryNode(exitNode),
        exitNode
    };
}

function unwrap({entryNode, exitNode, wasAlreadyWrapped}) {
    if (wasAlreadyWrapped)
        return;
    entryNode.next.forEach(next => next.prev.pop());
    exitNode.prev.forEach(prev => prev.next.pop());
}

exports.wrap = wrap;
exports.unwrap = unwrap;
exports.EntryNode = EntryNode;
exports.ExitNode = ExitNode;

function addEntryNode(node, entryNode = new EntryNode,
                      alreadyVisited = new Set()) {
    if (alreadyVisited.has(node))
        return;

    alreadyVisited.add(node);
    const prev = node.prev.filter(prev => !alreadyVisited.has(prev));

    if (prev.length === 0) {
        entryNode.next.push(node);
        node.prev.push(entryNode);
    }

    prev.forEach(prev => addEntryNode(prev, entryNode, alreadyVisited));
    return entryNode;
}

function findEntryNode(node) {
    const alreadyVisited = new Set();

    const queue = [node];

    while (queue.length !== 0) {
        const node = queue.pop();
        if (node instanceof EntryNode)
            return node;
        alreadyVisited.add(node);
        queue.push(...node.prev.filter(prev => !alreadyVisited.has(prev)));
    }
}


function findExitNode(node) {
    const alreadyVisited = new Set();

    const queue = [node];

    while (queue.length !== 0) {
        const node = queue.pop();
        if (node instanceof ExitNode)
            return node;
        alreadyVisited.add(node);
        queue.push(...node.next.filter(next => !alreadyVisited.has(next)));
    }
}

},{}],2:[function(require,module,exports){
"use strict";

const EventEmitter = require("events").EventEmitter;

const ComputeNode = require("./compute_node");

class ComputeGraph extends EventEmitter {
    constructor(entryNode, exitNode, nodeMap) {
        super();

        this._entryNode = entryNode;
        this._exitNode = exitNode;
        this._computeNodeMap = nodeMap;

        this._bufferNodeDependencies = new Map();
        this._bufferFeedbackInitialInputDependencies = new Map();
        this._allocationDependencies = new Set();
        this._updateTimer = null;
        this._updateTimers = new Map();
        var changedBuffers = [];
        this._onValueChange = buffer => {
            if (this._updateTimers.has(buffer))
                return;
            this._updateTimers.set(buffer, setTimeout(() => {
                this._handleBufferValueChange(buffer);
                this._updateTimers.delete(buffer);
            }, 0));
        };

        this._determineBufferNodeDependencies();
        this._determineBufferInitialFeedbackInputDependencies();
        this._attachValueChangedListeners();
        this._determineAllocationRelevantBuffers();
    }

    dispose() {
        this._detachValueChangedListeners();
        this.allNodes.forEach(node => node.platform.disposeNode ? node.platform.disposeNode(node) : undefined);
    }

    get entryNode() {
        return this._entryNode;
    }

    get exitNode() {
        return this._exitNode;
    }

    get allNodes() {
        return new Set([...this._computeNodeMap.values()]);
    }

    getComputeNodeForNode(node) {
        return this._computeNodeMap.get(node);
    }

    _determineBufferNodeDependencies(node = this._entryNode, parentDependencies = new Set()) {
        const dependencies = new Set();
        node.inputs.forEach(inputQueue => {
            if (inputQueue.initial.computed)
                return;

            this._addBufferNodeDependency(node, inputQueue.initial);
            dependencies.add(inputQueue.initial);
        });
        parentDependencies.forEach(inputDefinition => this._addBufferNodeDependency(node, inputDefinition));
        node.next.forEach(next => this._determineBufferNodeDependencies(next, new Set([...dependencies, ...parentDependencies])));
    }

    _addBufferNodeDependency(node, inputDefinition) {
        const buffer = inputDefinition.buffer;
        if (!this._bufferNodeDependencies.has(buffer))
            this._bufferNodeDependencies.set(buffer, new Set());
        this._bufferNodeDependencies.get(buffer).add(node);
    }

    _determineBufferInitialFeedbackInputDependencies(node = this._entryNode) {
        node.inputs.forEach(inputQueue => {
            if (!inputQueue.hasFeedback)
                return;

            const initialInput = inputQueue.initial;
            const dependencies =  initialInput.computed ? this._determineBufferDependencies(initialInput.source) : new Set([initialInput.buffer]);

            dependencies.forEach(buffer  => this._addBufferInitialFeedbackInputDependencies(inputQueue, buffer));
        });
        node.next.forEach(next => this._determineBufferInitialFeedbackInputDependencies(next));
    }

    _determineBufferDependencies(computeNode) {
        const buffers = new Set();
        this._bufferNodeDependencies.forEach((nodes, buffer) => {
            if (nodes.has(computeNode))
                buffers.add(buffer);
        });
        return buffers;
    }

    _addBufferInitialFeedbackInputDependencies(inputQueue, buffer) {
        if (!this._bufferFeedbackInitialInputDependencies.has(buffer))
            this._bufferFeedbackInitialInputDependencies.set(buffer, new Set());
        this._bufferFeedbackInitialInputDependencies.get(buffer).add(inputQueue);
    }

    _determineAllocationRelevantBuffers(node = this._entryNode) {
        node.allocationDependencies.forEach(allocationDependency => {
            this._allocationDependencies.add(allocationDependency);
        });
        node.next.forEach(next => this._determineAllocationRelevantBuffers(next));
    }

    _attachValueChangedListeners() {
        this._bufferNodeDependencies.forEach((_, buffer) => {
            buffer.on("change", this._onValueChange);
        });
    }

    _handleBufferValueChange(buffer) {
        if (this._allocationDependencies.has(buffer)) {
            this.emit("type-change");
            return;
        }

        const nodes = this._bufferNodeDependencies.get(buffer);
        if (nodes)
            nodes.forEach(node => node.dirty = true);

        const inputQueues = this._bufferFeedbackInitialInputDependencies.get(buffer);
        if (inputQueues)
            inputQueues.forEach(queue => queue.reset());

        const changedOutputs = new Set();
        this._exitNode.inputs.forEach((output, name) => {
            if (!output.computed)
                if (output.current.buffer === buffer)
                    changedOutputs.add(name);
            if (nodes.has(output.current.source))
                changedOutputs.add(name);

        });

        this.emit("value-change", changedOutputs);
    }

    _detachValueChangedListeners() {
        this._bufferNodeDependencies.forEach((_, buffer) => {
            buffer.removeListener("change", this._onValueChange);
        });
    }
}

exports = module.exports = ComputeGraph;

},{"./compute_node":3,"events":32}],3:[function(require,module,exports){
"use strict";

class ComputeNode {
    constructor(operator) {
        this.prev = [];
        this.next = [];

        this.inputs = new Map();
        this.outputs = new Map();

        this.allocations = new Set();
        this.allocationDependencies = new Map();

        this.result = null;
        this.memory = {};
        this.env = new Map();

        this.evaluate = null;

        this.operator = operator;
        this.dirty = true;
    }
}

exports = module.exports = ComputeNode;

},{}],4:[function(require,module,exports){
"use strict";

const assert = require("assert");

const deepEqual = require("deep-equal");

const worklist = require("./worklist");
const cfgUtils = require("./cfg_utils");
const ComputeGraph = require("./compute_graph");
const ComputeNode = require("./compute_node");
const toShadeValue = require("../util/to_shade_value");
const toFieldDescriptor = require("../util/to_field_descriptor");

class EntryNode extends ComputeNode {}
class ExitNode extends ComputeNode {}

class InputQueue {
	constructor(definition) {
		this._initial = definition;
		this._current = this._initial;
	}

	get hasFeedback() {
		return !!this._initial.feedback;
	}

	get initial() {
		return this._initial;
	}

	get current() {
		return this._current;
	}

	next() {
		const next = this._current;
		if (this._current.feedback)
			this._current = this._current.feedback;

		return next;
	}

	reset() {
		this._current = this._initial;
	}
}

function determineComputeGraph(requestedFieldNames, node) {
	const nodeOutputs = node.determineOutputs();
	const existingRequestedFields = requestedFieldNames[0] !== "*" ? new Map(requestedFieldNames.filter(name => nodeOutputs.has(name)).map(name => [name, nodeOutputs.get(name)])) : nodeOutputs;
	return buildComputeGraph(existingRequestedFields);
}

exports = module.exports = determineComputeGraph;


function buildComputeGraph(requestedFields) {
	const entryNode = new EntryNode();
	const exitNode = new ExitNode();

	const computeNodeMap = new Map();
	function buildComputeNode(node) {
		if (computeNodeMap.has(node))
			return computeNodeMap.get(node);

		const computeNode = new ComputeNode(node.operator);
		computeNode.name = node.operator.name;
		computeNodeMap.set(node, computeNode);

		node.prev.forEach(prev => {
			buildComputeNode(prev);
		});

		const usedInputs = node.determineUsedInputs();
		usedInputs.forEach((field, name)=> {
			if (field.computed) {
				const dependency = computeNodeMap.get(field.source);
				dependency.next = Array.from(new Set([...dependency.next, computeNode]));
				computeNode.prev = Array.from(new Set([...computeNode.prev, dependency]));
			}
			else {
				if (field.feedback && field.feedback.computed && field.feedback.source !== node) {
					const feedbackProvider = computeNodeMap.get(field.feedback.source);
					feedbackProvider.prev = [...new Set([...feedbackProvider.prev, computeNode])];
					computeNode.next = [...new Set([...computeNode.next, feedbackProvider])];
				}
			}
			const queue = createInputQueue(field, computeNodeMap);
			computeNode.inputs.set(name, queue);
			computeNode.env.set(name, field);
		});

		const allocations = node.operator.determineAllocations(usedInputs);
		allocations.forEach(allocation => {
			const sizeInput = {};
			allocation.dependencies.forEach(dependency => {
				const input = usedInputs.get(dependency);
				if (input.computed || input.feedback)
					throw new Error("Computed or feedback input for allocation relevant inputs is not yet supported! Input name: ", dependency);
				computeNode.allocationDependencies.set(input.name, computeNode.inputs.get(dependency).initial.buffer);
				sizeInput[dependency] = toShadeValue(computeNode.inputs.get(dependency).initial.buffer)
			});

			if (allocation.isTexture) {
				const size = allocation.size(sizeInput);
				allocation.width = size[0];
				allocation.height = size[1];
			} else {
				const elementType = toFieldDescriptor(allocation.elements.extra);
				if (elementType.type === undefined) {
					throw new Error("undefined element type for buffer " + allocation.propertyName);
				}
				allocation.elements.staticSize = allocation.size(sizeInput);
			}
		});
		computeNode.allocations = allocations;
		computeNode.outputs = node.determineOutputs();
		return computeNode;
	}

	function handleField(field) {
		if (field.computed)
			buildComputeNode(field.source);
		if (field.feedback)
			handleField(field.feedback);
	}

	requestedFields.forEach(handleField);

	computeNodeMap.forEach((computeNode, node) => {
		if (!node.operator.evaluate)
			computeNodeMap.delete(node);

		if (computeNode.prev.length === 0) {
			computeNode.prev.push(entryNode);
			entryNode.next.push(computeNode);
		}

		if (computeNode.next.length === 0) {
			computeNode.next.push(exitNode);
			exitNode.prev.push(computeNode);
		}
	});

	if (exitNode.prev.length === 0) {
		exitNode.prev.push(entryNode);
		entryNode.next.push(exitNode);
	}

	requestedFields.forEach((output, name) => {
		exitNode.inputs.set(name, createInputQueue(output, computeNodeMap));
	});

	if (!isAcyclic(exitNode))
		throw new Error("Cyclic dependency detected!");

	return new ComputeGraph(entryNode, exitNode, computeNodeMap);
}

function isAcyclic(node, current = new Set(), visited = new Set()) {
	if (current.has(node))
		return false;

	if (visited.has(node))
		return true;

	current.add(node);
	const acyclic = node.prev.every(prev => isAcyclic(prev, current, visited));
	current.delete(node);
	visited.add(node);
	return acyclic;
}

function createInputQueue(inputDefinition, computeNodeMap) {
	return new InputQueue(rewriteInputDefinition(inputDefinition, computeNodeMap));
}

function rewriteInputDefinition(inputDefinition, computeNodeMap, visited = new Map()) {
	if (visited.has(inputDefinition))
		return visited.get(inputDefinition);

	const newInputDefinition = Object.assign({}, inputDefinition);
	if (inputDefinition.computed) {
		newInputDefinition.source = computeNodeMap.get(inputDefinition.source);
	} else {
		newInputDefinition.buffer = inputDefinition.source.fields.get(inputDefinition.name);
	}
	visited.set(inputDefinition, newInputDefinition);
	if (inputDefinition.feedback)
		newInputDefinition.feedback = rewriteInputDefinition(inputDefinition.feedback, computeNodeMap);
	return newInputDefinition;
}

},{"../util/to_field_descriptor":22,"../util/to_shade_value":24,"./cfg_utils":1,"./compute_graph":2,"./compute_node":3,"./worklist":6,"assert":25,"deep-equal":29}],5:[function(require,module,exports){
"use strict";

const deepEqual = require("deep-equal");

const worklist = require("./worklist");
const cfgUtils = require("./cfg_utils");

function determineNodeInput(node) {
	const cfg = cfgUtils.wrap(node);

	try {
		const {inputs} = worklist(
			cfg, determineNodeOutput,
			{start: new Map(), equals: equalInputs, merge: mergeNodeInputs});
		inputs.forEach((inputs, node) => {
			node._cachedInputs = inputs;
		});
		return inputs.get(node);
	} catch (e) {
		throw e;
	} finally {
		cfgUtils.unwrap(cfg);
	}
}

exports = module.exports = determineNodeInput;

function determineNodeOutput(node, input) {
	if (node instanceof cfgUtils.EntryNode
		|| node instanceof cfgUtils.ExitNode)
		return {output: input, enqueue: true};

	try {
		const output = node.operator.determineFinalOutput(
			new Map([...input]), node);
		return {
			output: output, enqueue: true
		};
	} catch (_) {
		return {
			output: input, enqueue: true
		}
	}
}

function mergeNodeInputs(node, inputTables) {
	const fieldInputTable = new Map();
	if (node.fields) {
		node.fields.forEach((buffer, name) => {
			fieldInputTable.set(name, {
				name: name,
				type: buffer.type,
				shape: buffer.shape,
				isTexture: buffer.isTexture,
				computed: false
			});
		});
	}

	inputTables = inputTables.map(input => !input ? new Map() : input);

	const isFeedback = inputTables.map((possibleFeedbackInputTable, idx) => {
		if (isForwardReachable(node.prev[idx], node)) {
			const precedingInputTable
				= mergeMaps(...inputTables.slice(0, idx), fieldInputTable);
			return containsFeedbackForInputTable(possibleFeedbackInputTable, precedingInputTable);
		}
		return false;
	});

	const mergedInputTable = mergeMaps(...inputTables.filter((_, idx) => !isFeedback[idx]), fieldInputTable);
	const mergedFeedbackInputTable = mergeMaps(...inputTables.filter((_, idx) => isFeedback[idx]));
	mergedFeedbackInputTable.forEach(possibleFeedbackInput => {
		if (isValidFeedbackForInput(possibleFeedbackInput, mergedInputTable.get(possibleFeedbackInput.name))) {
			handleCyclicFeedback(possibleFeedbackInput);
			mergedInputTable.get(possibleFeedbackInput.name).feedback = possibleFeedbackInput;
		}
	});

	fieldInputTable.forEach(input => input.source = node);

	return mergedInputTable;
}

function isForwardReachable(nodeToReach, startNode, removedEdges = [],
							visited = new Set()) {
	visited.add(startNode);
	return startNode.next.some(nextNode => {
		if (removedEdges.find(edge => edge[0] === startNode
			&& edge[1] === nextNode))
			return false;
		if (nextNode === nodeToReach)
			return true;
		if (visited.has(nextNode))
			return false;

		visited.add(nextNode);
		return isForwardReachable(nodeToReach, nextNode, removedEdges, visited);
	});
}

function mergeMaps(...maps) {
	return new Map([].concat(...maps.map(m => Array.from(m))));
}

function containsFeedbackForInputTable(potentialFeedbackTable, inputTable) {
	return [...potentialFeedbackTable.values()].some(potentialFeedback => {
		return isValidFeedbackForInput(potentialFeedback,
			inputTable.get(potentialFeedback.name));
	});
}

function isValidFeedbackForInput(possibleFeedbackInput, input) {
	return input && input.source !== possibleFeedbackInput.source && input.type === possibleFeedbackInput.type;
}

function equalInputs(a, b) {
	if (a.size !== b.size)
		return;

	return [...a.values()].every(v => b.has(v.name) && equalProperties(v, b.get(v.name)));
}

function equalProperties(a, b) {
	for (let name in a) {
		if (!a[name] === b[name])
			return false;
	}

	return true;
}

function handleCyclicFeedback(input) {
	if (!input.feedback)
		return;

	const precedingFeedback = [];

	while (input.feedback) {
		const cyclicFeedback = precedingFeedback.find(feedback => {
			const oldFeedback = feedback.feedback;
			delete feedback.feedback;
			const isEqual = deepEqual(feedback, input.feedback);
			feedback.feedback = oldFeedback;
			return isEqual;
		});
		if (cyclicFeedback) {
			input.feedback = cyclicFeedback;
			return;
		}
		precedingFeedback.push(input.feedback);

		input = input.feedback;
	}
}

},{"./cfg_utils":1,"./worklist":6,"deep-equal":29}],6:[function(require,module,exports){
"use strict";

function worklist(
	{entryNode, exitNode}, transferFunction,
	{direction = "forward", start = new Set(), merge = union, equals = equalKeys}
	= {}) {
	var list = new Queue();

	let predecessors = getPredecessors;
	let successors = getSuccessors;

	if (direction === "forward") {
		list.push(entryNode);
	} else {
		list.push(exitNode);
		predecessors = getSuccessors;
		successors = getPredecessors;
	}

	const outputs = new Map();
	const inputs = new Map();

	while (list.length) {
		const node = list.shift();
		const pre = predecessors(node).map(n => outputs.get(n));
		const input = pre.length ? merge(node, pre) : start;
		inputs.set(node, input);
		const oldOutput = outputs.get(node);
		let newOutput = transferFunction(node, input, list, oldOutput);
		if (!newOutput || newOutput instanceof Set)
			newOutput = {output: newOutput, enqueue: true};
		outputs.set(node, newOutput.output);
		if (newOutput.enqueue
			&& (!oldOutput || !equals(newOutput.output, oldOutput)))
			successors(node).forEach(aSuccessor => list.push(aSuccessor));
	}

	return {outputs, inputs};
}

exports = module.exports = worklist;

class Queue extends Array {
	push(element) {
		const index = this.indexOf(element);
		if (index !== -1)
			this.splice(index, 1);
		super.push(element);
	}
}

function getPredecessors(node) {
	return node.prev;
}

function getSuccessors(node) {
	return node.next;
}

function union(_, pre) {
	return new Set([].concat(...pre.map(v => !v ? [] : Array.from(v))))
}

function equalKeys(a, b) {
	return a.size === b.size && [...a].every(v => b.has(v));
}

},{}],7:[function(require,module,exports){
"use strict";

const EventEmitter = require("events").EventEmitter;

const determineComputeGraph = require("../analysis/determine_compute_graph");

const cpuPlatform = require("../platform/cpu");
const debugPlatform = require("../platform/debug");
const Program = require("../execution/program");
const now = require("performance-now");

class InvalidProgram extends EventEmitter {
    constructor(node, error) {
        super("type-change");
        this.invalid = true;
        this.error = error;
        this._node = node;
        this._onTypeChange = () => {
            this.emit("invalid", this);
        };
        this._node.on("type-change", this._onTypeChange);
    }

    dispose() {
        this._node.removeListener("type-change", this._onTypeChange);
    }

    run() {
        return Promise.resolve();
    }
}

const platforms = {
    "cpu": cpuPlatform,
    "debug": debugPlatform
};

function createProgram(node, outputs, options = {forcePlatform: "cpu", benchmark: false}) {
    const start = now();
    const platform = platforms[options.forcePlatform];
    try {
        const graph = determineComputeGraph(outputs, node);
        const schedule = [new Set([graph.entryNode])];
        const allNodes = graph.allNodes;
        let layerIdx = 0;
        while (allNodes.size > 0) {
            if (!schedule[layerIdx])
                schedule[layerIdx] = new Set();
            allNodes.forEach(node => {
                if (node.prev.every(prev => {
                        return schedule.slice(0, layerIdx).some(layer => {
                            return layer.has(prev);
                        });
                    })) {

                    platform.compile(node, options);
                    node.platform = platform;
                    schedule[layerIdx].add(node);
                    allNodes.delete(node);
                }
            });
            ++layerIdx;
        }

        return new Program(node, graph, schedule, now() - start, options.benchmark);
    } catch (error) {
        return new InvalidProgram(node, error);
    }
}

exports.createProgram = createProgram;

},{"../analysis/determine_compute_graph":4,"../execution/program":9,"../platform/cpu":18,"../platform/debug":19,"events":32,"performance-now":39}],8:[function(require,module,exports){
"use strict";

const EventEmitter = require("events").EventEmitter;
const DisposeIfNoListener = require("../util/dispose_if_no_listener");

class ComputeRequest extends DisposeIfNoListener(EventEmitter) {
    constructor(program) {
        super("value");
        this.setMaxListeners(0);

        this._program = program;

        this._program.on("needs-update", this._onProgramNeedsUpdate.bind(this));
        this._program.on("invalid", this._invalidate.bind(this));

        setTimeout(() => {
            if (this._program.error)
                this.emit("error", this._program.error);
            else
                this._onProgramNeedsUpdate();
        }, 0);
    }

    dispose() {
        this._program.dispose();
    }

    _onProgramNeedsUpdate() {
        const pendingResult = new Promise((resolve, reject) => {
            this._program.run().then(resolve).catch(error => {
                this.emit("error", error);
                this._invalidate();
                reject(error);
            });
        });
        this.emit("value", pendingResult);
    }

    _invalidate() {
        this.emit("invalid");
    }
}

exports = module.exports = ComputeRequest;

},{"../util/dispose_if_no_listener":21,"events":32}],9:[function(require,module,exports){
"use strict";

const EventEmitter = require("events").EventEmitter;

const DisposeIfNoListeners = require("../util/dispose_if_no_listener");

const runner = require("./runner");
const Buffer = require("../field/buffer_accessor");

class Program extends DisposeIfNoListeners(EventEmitter) {
    constructor(node, computeGraph, schedule, compileTime, benchmark = true) {
        super("needs-update");
        this.setMaxListeners(0);

        this.time = compileTime;
        this._computeGraph = computeGraph;
        this._executionSchedule = schedule;
        this._node = node;
        this._needsUpdate = true;
        this._benchmark = benchmark;
        this._running = Promise.resolve();

        this._onValueChange = (changedOutputs) => {
            this._changedOutputs = changedOutputs;
            this._needsUpdate = true;
            this.emit("needs-update", this);
        };

        this._onTypeChange = () => {
            this.emit("invalid", this);
        };

        this._node.on("type-change", this._onTypeChange);
        this._computeGraph.on("value-change", this._onValueChange);
        this._computeGraph.on("type-change", this._onTypeChange);
    }

    dispose() {
        this._node.removeListener("type-change", this._onTypeChange);
        this._computeGraph.removeListener("value-change", this._onValueChange);
        this._computeGraph.removeListener("type-change", this._onTypeChange);
        this._computeGraph.dispose();
    }

    run(force = false) {
        if (!this._needsUpdate && !force)
            return Promise.resolve(this._buildResult());

        const changedOutputs = this._changedOutputs;
        this._changedOutputs = null;
        this._running = this._running.then(() => {
            return runner.run(this._executionSchedule, force).then(() => {
                const result = this._buildResult(changedOutputs);
                this._needsUpdate = false;

                if (this._benchmark) {
                    let overallTime = 0;
                    let times = [];
                    this._computeGraph.allNodes.forEach(node => {
                        times.push({name: node.name, time: node.time});
                        overallTime += node.time
                    });
                    result.__time = times;
                    result.__overallTime = overallTime;
                }
                return result;
            });
        });
        return this._running;
    }

    _buildResult(outputNames) {
        const result = {};
        this._computeGraph.exitNode.inputs.forEach((input, name) => {
            input = input.current;
            if (outputNames && !outputNames.has(name))
                return;

            if (input.computed)
                result[name] = Program.fromShadeValue(input.type, input.source.result[input.name]);
            else
                result[name] = Program.fromShadeValue(input.type, input.buffer);
        });
        return result;
    }

    static fromShadeValue(type, value) {
        if (value instanceof Buffer)
            return value;

        if (value.buffer)
            return new Buffer(type, value, value.shape.slice(0, value.shape.length -1));

        if (!Array.isArray(value))
            value = [value];

        const shape = [value.length];
        let elements = value[0];
        while (Array.isArray(elements)) {
            shape.push(elements.length);
            elements = value[0];
        }

        const buffer = type.allocate(shape);
        Program.toBuffer(buffer, value);

        return buffer;
    }

    static toBuffer(buffer, value) {
        for (let i = 0; i < value.length; ++i) {
            if (Array.isArray(value[i]))
                Program.toBuffer(buffer.pick(i), value[i]);
            else
                buffer.set(i, value[i]);
        }
    }
}

exports = module.exports = Program;


},{"../field/buffer_accessor":11,"../util/dispose_if_no_listener":21,"./runner":10,"events":32}],10:[function(require,module,exports){
"use strict";

function run(schedule, force) {
    schedule = [...schedule];
    if (schedule.length === 0)
        return Promise.resolve();
    return runNodes(schedule.shift(), force).then(() => {
        return run(schedule, force)
    });
}

exports.run = run;

function runNodes(nodes, force) {
    let dirtyNodes = [...nodes].filter(node => node.operator && node.operator.evaluate);
    dirtyNodes.forEach(node => node.time = 0);
    if (!force)
        dirtyNodes = dirtyNodes.filter(node => node.dirty);

    if (dirtyNodes.length === 1) {
        const node = dirtyNodes[0];
        return runDirect(node, prepareInputs(node));
    }

    return runWorker(dirtyNodes);
}

function runDirect(node, input) {
    return Promise.resolve(node.evaluateDirect(input, node.memory)).then(result => {
        node.result = result;
        node.time = result.__time;
        node.dirty = false;
    });
}

function runWorker(nodes) {
    const all = Promise.all(nodes.map(node => {
        const operatorInput = prepareInputs(node);

        if (node.evaluateWorker) {
            return node.evaluateWorker(operatorInput, node.memory).then(result => {
                node.result = result;
                node.time = result.__time;
                node.dirty = false;
            });
        }

        return runDirect(node, operatorInput);
    }));

    return all;
}

function prepareInputs(node) {
    const operatorInput = {};

    node.inputs.forEach((input, name)=> {
        input = input.next();
        if (input.computed)
            operatorInput[name] = node.platform.toPlatformValue(input.source.result[input.name]);
        else
            operatorInput[name] = node.platform.toPlatformValue(input.buffer);
    });

    return operatorInput;
}

},{}],11:[function(require,module,exports){
"use strict";

const EventEmitter = require("events").EventEmitter;
const ndarray = require("ndarray");

class BufferAccessor extends EventEmitter {
    constructor(type, data, shape, isTexture = false) {
        super();

        if (data.buffer)
            data = type.toSharedArrayBuffer(data);

        if (!shape || shape.length === 0)
            shape = [data.length / type.size];
        this._arrayShape = shape;
        if (data.data)
            this._ndarray = data;
        else
            this._ndarray = ndarray(data, [...shape, ...type.shape]);
        this._type = type;
        this._isTexture = isTexture;
    }

    get type() {
        return this._type;
    }

    get shape() {
        return this._ndarray.shape;
    }

    get data() {
        return this._ndarray.data;
    }

    set data(newData) {
        this._ndarray.data = newData;
        this.emit("change", this);
    }

    get length() {
        return this._ndarray.shape[0];
    }

    get isTexture() {
        return this._isTexture;
    }

    get(...args) {
        return this.type.valueFromBuffer(this._ndarray.pick(...args));
    }

    set(...args) {
        const value = args.pop();
        this.type.storeValueInBuffer(this._ndarray.pick(...args), value);
        this.emit("change", this)
    }

    pick(...args) {
        const shape = this._arrayShape.slice();
        shape.shift();
        return new BufferAccessor(this._type, this._ndarray.pick(...args), shape);
    }
}

exports = module.exports = BufferAccessor;

},{"events":32,"ndarray":37}],12:[function(require,module,exports){
(function (process,global){
"use strict";

const Shade = require("shade.js");

const BufferAccessor = require("./buffer_accessor");

if (!global.SharedArrayBuffer && !process.browser)
	global.SharedArrayBuffer = ArrayBuffer;

function createTypeDescriptor(name, typedArray, baseShape, valueFromBuffer,
							  storeValueInBuffer, fromArray) {
	let baseSize = baseShape.reduce((pre, cur) => pre * cur, 1);

	const allocate = function(shape) {
		shape = Array.isArray(shape) ? shape : [shape];
		const numElements = shape.reduce((pre, cur) => pre * cur, baseSize);
		const data = new typedArray(new SharedArrayBuffer(numElements *  typedArray.BYTES_PER_ELEMENT));

		return new BufferAccessor(this, data, shape);
	};

	return {
		name: name, shape: baseShape, size: baseSize, allocate: allocate,
		typedArray: typedArray,
		valueFromBuffer: valueFromBuffer,
		storeValueInBuffer: storeValueInBuffer,
		fromArray: fromArray,
		toSharedArrayBuffer: array => {
			if (array.buffer.constructor === SharedArrayBuffer)
				return array;

			var shared = new typedArray(new SharedArrayBuffer(array.length *  typedArray.BYTES_PER_ELEMENT));
			shared.set(array);
			return shared;
		}
	};
}

exports.float32 = createTypeDescriptor(
	"float32", Float32Array, [], buffer => buffer.get(0),
	(buffer, value) => buffer.set(value), v => v[0]);
exports.int32 = createTypeDescriptor(
	"int32", Int32Array, [], buffer => buffer.get(0),
	(buffer, value) => buffer.set(value), v => v[0]);
exports.uint8 = createTypeDescriptor(
	"uint8", Uint8Array, [], buffer => buffer.get(0),
	(buffer, value) => buffer.set(value), v => v[0]);

exports.vec2 = createTypeDescriptor(
	"vec2", Float32Array, [2],
	buffer => new Shade.Vec2(buffer.get(0), buffer.get(1)), (buffer, value) => {
		buffer.set(0, value.x);
		buffer.set(1, value.y);
	}, Shade.Vec2);
exports.vec3 = createTypeDescriptor(
	"vec3", Float32Array, [3],
	buffer => new Shade.Vec3(new Float32Array(buffer.data.buffer, buffer.offset * 4, 3)),
	(buffer, value) => {
		buffer.set(0, value.x);
		buffer.set(1, value.y);
		buffer.set(2, value.z);
	}, Shade.Vec3);
exports.vec4 = createTypeDescriptor(
	"vec4", Float32Array, [4],
	buffer => new Shade.Vec4(buffer.get(0), buffer.get(1), buffer.get(2),
							 buffer.get(3)),
	(buffer, value) => {
		buffer.set(0, value.x);
		buffer.set(1, value.y);
		buffer.set(2, value.z);
		buffer.set(3, value.w);
	}, Shade.Vec4);

exports.mat2 = createTypeDescriptor(
	"mat2", Float32Array, [2, 2],
	buffer => new Shade.Mat2(buffer.get(0, 0), buffer.get(0, 1),
							 buffer.get(1, 0), buffer.get(1, 1)),
	(buffer, value) => {
		buffer.set(0, 0, value.m11);
		buffer.set(0, 1, value.m21);
		buffer.set(1, 0, value.m12);
		buffer.set(1, 1, value.m22);
	}, Shade.Mat2);

exports.mat3 = createTypeDescriptor(
	"mat3", Float32Array, [3, 3],
	buffer => new Shade.Mat3(
		buffer.get(0, 0), buffer.get(0, 1), buffer.get(0, 2), buffer.get(1, 0),
		buffer.get(1, 1), buffer.get(1, 2), buffer.get(2, 0), buffer.get(2, 1),
		buffer.get(2, 2)),
	(buffer, value) => {
		buffer.set(0, 0, value.m11);
		buffer.set(0, 1, value.m21);
		buffer.set(0, 2, value.m31);
		buffer.set(1, 0, value.m12);
		buffer.set(1, 1, value.m22);
		buffer.set(1, 2, value.m32);
		buffer.set(2, 0, value.m13);
		buffer.set(2, 1, value.m23);
		buffer.set(2, 2, value.m33);
	}, Shade.Mat3);

exports.mat4 = createTypeDescriptor(
	"mat4", Float32Array, [4, 4],
	buffer => new Shade.Mat4(
		buffer.get(0, 0), buffer.get(0, 1), buffer.get(0, 2), buffer.get(0, 3),
		buffer.get(1, 0), buffer.get(1, 1), buffer.get(1, 2), buffer.get(1, 3),
		buffer.get(2, 0), buffer.get(2, 1), buffer.get(2, 2), buffer.get(2, 3),
		buffer.get(3, 0), buffer.get(3, 1), buffer.get(3, 2), buffer.get(3, 3)),
	(buffer, value) => {
		buffer.set(0, 0, value.m11);
		buffer.set(0, 1, value.m21);
		buffer.set(0, 2, value.m31);
		buffer.set(0, 3, value.m41);
		buffer.set(1, 0, value.m12);
		buffer.set(1, 1, value.m22);
		buffer.set(1, 2, value.m32);
		buffer.set(1, 3, value.m42);
		buffer.set(2, 0, value.m13);
		buffer.set(2, 1, value.m23);
		buffer.set(2, 2, value.m33);
		buffer.set(2, 3, value.m43);
		buffer.set(3, 0, value.m14);
		buffer.set(3, 1, value.m24);
		buffer.set(3, 2, value.m34);
		buffer.set(3, 3, value.m44);
	}, Shade.Mat4);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer_accessor":11,"_process":40,"shade.js":44}],13:[function(require,module,exports){
"use strict";

const assert = require("assert");
const EventEmitter = require("events").EventEmitter;

const NodeCollection = require("./node_collection");
const Operator = require("../operator/operator");
const compiler = require("../compiler");

const determineNodeInputs = require("../analysis/determine_node_inputs");

let count = 1;

class Node extends EventEmitter {
	constructor({name = "unnamed node " + count++, operator = Operator.defaultOperator} = {}) {
		super();
		this.setMaxListeners(0);

		this.name = name;
		this.next = [];
		this.prev = [];
		this.fields = new Map();
		this._operator = operator;
		this._cachedInputs = null;
	}

	get operator() {
		return this._operator;
	}

	set operator(operator) {
		this._operator = operator;
		this._typeChanged();
	}

	setField(name, buffer) {
		if (this.fields.has(name))
			this.fields.delete(name);

		this.fields.set(name, buffer);
		this._typeChanged();
		return this;
	}

	removeField(name) {
		this.fields.delete(name);
		this._typeChanged();
	}

	pipe(...destinations) {
		destinations.forEach(destination => {
			assert(destination instanceof Node);

			if (this.next.indexOf(destination) === -1) {
				assert(destination.prev.indexOf(this) === -1);
				this.next.push(destination);
				destination.prev.push(this);
				destination._typeChanged();
			}

			assert(destination.prev.indexOf(this) !== -1);
		});

		return new NodeCollection(destinations);
	}

	unpipe(...destinations) {
		if (destinations.length === 0)
			destinations = this.next.slice();
		destinations.forEach(destination => {
			assert(destination instanceof Node);

			const nextIdx = this.next.indexOf(destination);
			if (nextIdx !== -1) {
				const prevIdx = destination.prev.indexOf(this);
				assert(prevIdx !== -1);
				this.next.splice(nextIdx, 1);
				destination.prev.splice(prevIdx, 1);
				destination._typeChanged();
			}

			assert(destination.prev.indexOf(this) === -1);
		});
	}

	determineAvailableInputs() {
		if (this._cachedInputs)
			return this._cachedInputs;
		return determineNodeInputs(this);//.then(inputTable => this._inputTable = inputTable);
	}

	determineUsedInputs() {
		const inputs = this.determineAvailableInputs();
		return this.operator.determineUsedInputs(new Map([...inputs]), this);
	}

	determineOutputs() {
		const inputs = this.determineAvailableInputs();
		return this.operator.determineFinalOutput(new Map([...inputs]), this);
	}

	createProgramToCompute(outputs, options) {
		return compiler.createProgram(this, outputs, options);
	}

	_typeChanged(alreadyInformedNodes = new Set()) {
		this._cachedInputs = null;
		this.emit("type-change");
		this.next.forEach(next => {
			if (alreadyInformedNodes.has(next))
				return;
			alreadyInformedNodes.add(next);
			next._typeChanged(alreadyInformedNodes)
		});
	}
}

exports = module.exports = Node;

function isBackwardsReachable(nodeToReach, startNode,
							  visited = new Set()) {
	visited.add(startNode);
	return startNode.prev.some(prevNode => {
		if (prevNode === nodeToReach)
			return true;
		if (visited.has(prevNode))
			return false;

		visited.add(prevNode);
		return isBackwardsReachable(nodeToReach, prevNode, visited);
	});
}

},{"../analysis/determine_node_inputs":5,"../compiler":7,"../operator/operator":16,"./node_collection":14,"assert":25,"events":32}],14:[function(require,module,exports){
"use strict";

class NodeCollection extends Set {
	constructor(nodes, baseSet) {
		super(nodes);
		this._baseSet = baseSet;
	}

	pipe(...destinations) {
		this.forEach(node => node.pipe(...destinations));
		return new NodeCollection(destinations, this._baseSetComplement());
	}

	select(...filters) {
		let filter = node => {
			return filters.indexOf(node) !== -1
		};
		if (filters.length === 1 && typeof filters[0] === "function")
			filter = filters[0];

		return new NodeCollection([...this].filter(filter), this);
	}

	deselect() {
		if (this._baseSet)
			return new NodeCollection([...this, ...this._baseSet],
									  this._baseSet._baseSet);
		else
			return this;
	}

	_baseSetComplement() {
		if (this._baseSet)
			return new NodeCollection([...this._baseSet].filter(node => {
				return !this.has(node);
			}),
									  this._baseSet._baseSet);
		return null;
	}
}

exports = module.exports = NodeCollection;

},{}],15:[function(require,module,exports){
"use strict";

class FilterOperator {
    constructor(names = new Set(), type = FilterOperator.type.remove) {
        if (Array.isArray(names))
            this._names = new Set(names);
        else
            this._names = names;
        this._type = type;
    }

    determineUsedInputs() {
        return new Map();
    }

    determineFinalOutput(inputs) {
        const result = new Map();
        inputs.forEach((field, name) => {
            if ((this._type === FilterOperator.type.remove && !this._names.has(name)) || (this._type === FilterOperator.type.keep && this._names.has(name)))
                result.set(name, field);
        });
        return result;
    }

    determineAllocations() {
        return new Set();
    }
}

FilterOperator.type = {
    remove: "remove",
    keep: "keep"
};

exports = module.exports = FilterOperator;

},{}],16:[function(require,module,exports){
"use strict";

const assert = require("assert");
const Shade = require("shade.js");

const buildShadeOptions = require("../util/build_shade_options");
const toFieldDescriptor = require("../util/to_field_descriptor");

let count = 1;
const shadeOptions = {
    loc: true,
    validate: true,
    throwOnError: true,
    sanitize: true,
    entry: "evaluate"
};

class Operator {
    constructor({name = "unnamed operator " + count++, evaluate} = {}) {
        this.name = name;
        this.evaluate = evaluate;
    }

    determineUsedInputs(inputs) {
        if (!this.evaluate)
            return new Map();

        const usedParameters = Shade.determineUsedParameters(this.evaluate,  buildShadeOptions(inputs, shadeOptions));
        const used = [...inputs].filter(([name, field]) => {
            return usedParameters.shaderParameters.indexOf(name) !== -1;
        });
        return new Map(used);
    }

    determineFinalOutput(inputs, node) {
        if (!this.evaluate)
            return inputs;

        const returnTypeInfo = Shade.determineReturnType(this.evaluate, buildShadeOptions(inputs, shadeOptions));

        if (returnTypeInfo.type === Shade.TYPES.UNDEFINED)
            return inputs;

        if (returnTypeInfo.type === Shade.TYPES.OBJECT)
            return Object.keys(returnTypeInfo.properties).reduce((outputs, name) => {
                var field = toFieldDescriptor(returnTypeInfo.properties[name], name, node);
                field.computed = true;
                if (field.type === undefined)
                    return outputs;
                outputs.set(name, field);
                return outputs;
            }, new Map(inputs));

        throw new Error("Operator return type has to be undefined or object!");
    }

    determineAllocations(inputs) {
        if (!this.evaluate)
            return new Set();

        const workSet = new Shade.WorkingSet();
        workSet.parse(this.evaluate, shadeOptions);
        workSet.analyze(buildShadeOptions(inputs).inject, undefined, Object.assign({extractAllocations: true}, shadeOptions));
        return workSet.processingData.allocations || new Set();
    }
}

exports = module.exports = Operator;
exports.defaultOperator = new Operator({name: "fastlane-default-operator"});

},{"../util/build_shade_options":20,"../util/to_field_descriptor":22,"assert":25,"shade.js":44}],17:[function(require,module,exports){
"use strict";

class RenameOperator {
    constructor(renameMap) {
        this.name = "Rename Operator";
        this._renameMap = renameMap;
    }

    determineUsedInputs(inputs) {
        return new Map();
    }

    determineFinalOutput(inputs, node) {
        const result = new Map();
        inputs.forEach((field, name) => {
            if (this._renameMap.has(field.name))
                result.set(this._renameMap.get(field.name), field);

            result.set(name, field);
        });
        return result;
    }

    determineAllocations() {
        return new Set();
    }
}

exports = module.exports = RenameOperator;

},{}],18:[function(require,module,exports){
"use strict";

const Shade = require("shade.js");

const Buffer = require("../field/buffer_accessor");
const Types = require("../field/types");
const buildShadeOptions = require("../util/build_shade_options");
const toFieldDescriptor = require("../util/to_field_descriptor");

const shadeOptions = {
    loc: true,
    validate: true,
    throwOnError: true,
    sanitize: true,
    entry: "evaluate",
    extractAllocations: true
};

const workerSkeleton = `
    self.onmessage = function (event) {
        const input = event.data.input;
        const inputShapes = event.data.inputShapes;
        inputShapes.forEach((shape, name) => input[name].shape = shape);
        const memory = event.data.memory;
        const memoryShapes = event.data.memoryShapes;
        memoryShapes.forEach((shape, name) => memory[name].shape = shape);        
        const result = evaluate(input, memory);
        const buffers = [];
        const shapes = new Map();
        for (var name in result) {
            if (result[name].buffer) {
                buffers.push(result[name].buffer);
                shapes.set(name, result[name].shape);
            }
        }
        result.shapes = shapes;
        self.postMessage({result, shapes});
    }
    const evaluate = `;

const cache = new Map();

class CPUPlatform {
    compile(computeNode, options) {
        if (!computeNode.operator)
            return;

        const env = buildShadeOptions(computeNode.env).inject;
        const envKey = JSON.stringify(Object.assign({useSIMD: options.useSIMD}, env));
        const evaluateFn = computeNode.operator.evaluate.toString();
        if (cache.has(evaluateFn)) {
            const inputSignatureCache = cache.get(evaluateFn);
            const evaluateFunctions = inputSignatureCache.get(envKey);
            if (evaluateFunctions) {
                computeNode.evaluateDirect = evaluateFunctions.direct;
                if (options.useWebWorker) {
                    const workerInfo = this.createWebWorker(evaluateFunctions.src);
                    computeNode.evaluateWorker = workerInfo.fn;
                    computeNode.worker = workerInfo.worker;
                }
                computeNode.allocations.forEach(allocation => {
                    if (allocation.isTexture) {
                        const accessor = Types.vec4.allocate([allocation.width, allocation.height]);
                        computeNode.memory[allocation.propertyName] = accessor.data;
                        computeNode.memory[allocation.propertyName].shape = accessor.shape;
                    } else {
                        const descriptor = toFieldDescriptor(allocation.elements.extra);
                        const accessor = descriptor.type.allocate(allocation.elements.staticSize);
                        computeNode.memory[allocation.propertyName] = accessor.data;
                        computeNode.memory[allocation.propertyName].shape = accessor.shape;
                    }
                });
            }
        }
        if (!computeNode.evaluateDirect) {
            const workset = new Shade.WorkingSet();
            workset.parse(evaluateFn, shadeOptions);

            workset.analyze(env, undefined, shadeOptions);
            const memInject = {};
            computeNode.allocations.forEach(allocation => {
                if (allocation.isTexture) {
                    const accessor = Types.vec4.allocate([allocation.width, allocation.height]);
                    computeNode.memory[allocation.propertyName] = accessor.data;
                    computeNode.memory[allocation.propertyName].shape = accessor.shape;
                    memInject[allocation.propertyName] = {
                        type: Shade.TYPES.OBJECT,
                        kind: Shade.OBJECT_KINDS.TEXTURE,
                        width: allocation.width,
                        height: allocation.height
                    };
                } else {
                    const descriptor = toFieldDescriptor(allocation.elements.extra);
                    const accessor = descriptor.type.allocate(allocation.elements.staticSize);
                    computeNode.memory[allocation.propertyName] = accessor.data;
                    computeNode.memory[allocation.propertyName].shape = accessor.shape;
                    memInject[allocation.propertyName] = {
                        type: Shade.TYPES.ARRAY,
                        staticSize: allocation.elements.staticSize,
                        elements: allocation.elements,
                    };
                }
            });
            workset.injectMemory({
                extra: {
                    type: "object",
                    global: true,
                    properties: memInject
                }
            });
            if (!cache.has(evaluateFn))
                cache.set(evaluateFn, new Map());
            const inputSignatureCache = cache.get(evaluateFn);
            const evaluateFunctions = this.createEvaluateFunction(computeNode, workset, options);
            if (options.useWebWorker) {
                const workerInfo = this.createWebWorker(evaluateFunctions.src);
                evaluateFunctions.worker = workerInfo.fn;
                computeNode.worker = workerInfo.worker;
            }
            inputSignatureCache.set(envKey, evaluateFunctions);

            computeNode.evaluateDirect = evaluateFunctions.direct;
            computeNode.evaluateWorker = evaluateFunctions.worker;
        }
    }

    createEvaluateFunction(computeNode, workSet, options) {
        let name = computeNode.operator.name.replace(/ |-/g, '_');
        let src = workSet.compileToFastlane(Object.assign(options, {name: name}));
        let evaluateFunctions = {
            src: src
        };
        name = name + (options.useSIMD ? "_simd" : "");
        let newSrc = `(${src})//# sourceURL=${name}.js`;
        evaluateFunctions.direct = (0, eval)(newSrc);

        return evaluateFunctions;
    }

    createWebWorker(src) {
        const workerSrc = workerSkeleton + src;
        const blob = new Blob([workerSrc], {type: "text/javascript"});
        const url = URL.createObjectURL(blob);
        const worker = new Worker(url);
        URL.revokeObjectURL(url);
        return {
            worker: worker,
            fn: function (input, memory) {
                const data = {input, memory};
                let transfer = [];
                const inputShapes = new Map();
                const memoryShapes = new Map();
                for (let name in input) {
                    if (input[name].buffer) {
                        transfer.push(input[name].buffer);
                        inputShapes.set(name, input[name].shape);
                    }
                }
                for (let name in memory) {
                    if (memory[name].buffer) {
                        transfer.push(memory[name].buffer);
                        memoryShapes.set(name, memory[name].shape);
                    }
                }
                data.inputShapes = inputShapes;
                data.memoryShapes = memoryShapes;
                return new Promise(resolve => {
                    this.worker.postMessage(data);
                    this.worker.onmessage = function (event) {
                        const result = event.data.result;
                        const shapes = event.data.shapes;
                        shapes.forEach((shape, name) => result[name].shape = shape);
                        resolve(result);
                    }
                });
            }
        };
    }

    toPlatformValue(buffer) {
        if (buffer.buffer)
            return buffer;

        if (buffer.shape && buffer.shape.length === 1 && buffer.shape[0] === 1)
            return buffer.get(0);

        if (Array.isArray(buffer))
            return buffer;

        if (buffer instanceof Buffer) {
            const data = buffer._ndarray.data;
            data.shape = buffer.shape;
            return data;
        }

        return buffer;
    }

    disposeNode(computeNode) {
        if (computeNode.worker)
            computeNode.worker.terminate();
    }
}

exports = module.exports = new CPUPlatform();

},{"../field/buffer_accessor":11,"../field/types":12,"../util/build_shade_options":20,"../util/to_field_descriptor":22,"shade.js":44}],19:[function(require,module,exports){
(function (global){
"use strict";

const assert = require("assert");
const Shade = require("shade.js");

const buildShadeOptions = require("../util/build_shade_options");
const toFieldDescriptor = require("../util/to_field_descriptor");
const toShadeValue = require("../util/to_shade_value");

const shadeOptions = {
    entry: "evaluate",
    sanitize: true,
    extractAllocations: true
};

global.Vec2 = Shade.Vec2;
global.Vec3 = Shade.Vec3;
global.Vec4 = Shade.Vec4;
global.Mat2 = Shade.Mat2;
global.Mat3 = Shade.Mat3;
global.Mat4 = Shade.Mat4;


class DebugPlatform {
    compile(computeNode) {
        if (!computeNode.operator)
            return () => {};

        const workset = new Shade.WorkingSet();
        workset.parse(computeNode.operator.evaluate, shadeOptions);
        const env = buildShadeOptions(computeNode.env).inject;
        workset.analyze(env, undefined, shadeOptions);
        const memInject = {};
        computeNode.allocations.forEach(allocation => {
            if (allocation.isTexture) {
                const accessor = Types.vec4.allocate([allocation.width, allocation.height]);
                computeNode.memory[allocation.propertyName] = toShadeValue(accessor);
                // computeNode.memory[allocation.propertyName].shape = accessor.shape;
                memInject[allocation.propertyName] = {
                    type: Shade.TYPES.OBJECT,
                    kind: Shade.OBJECT_KINDS.TEXTURE,
                    width: allocation.width,
                    height: allocation.height
                };
            } else {
                const descriptor = toFieldDescriptor(allocation.elements.extra);
                const accessor = descriptor.type.allocate(allocation.elements.staticSize);
                computeNode.memory[allocation.propertyName] = toShadeValue(accessor);
                // computeNode.memory[allocation.propertyName].shape = accessor.shape;
                memInject[allocation.propertyName] = {
                    type: Shade.TYPES.ARRAY,
                    staticSize: allocation.elements.staticSize,
                    elements: allocation.elements,
                };
            }
        });
        workset.injectMemory({
            extra: {
                type: "object",
                global: true,
                properties: memInject
            }
        });

        const src = workset.toJavaScript();
        let name = computeNode.operator.name.replace(/ |-/g, '_');
        let newSrc = `(${src})//# sourceURL=${name}_debug.js`;
        computeNode.evaluateDirect = (0, eval)(newSrc);
    }

    toPlatformValue(buffer) {
        return toShadeValue(buffer);
    }
}

exports = module.exports = new DebugPlatform();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../util/build_shade_options":20,"../util/to_field_descriptor":22,"../util/to_shade_value":24,"assert":25,"shade.js":44}],20:[function(require,module,exports){
"use strict";

const toShadeType = require("./to_shade_type");

exports = module.exports = (inputs, options = {}) => {
    const env = [...inputs].reduce((env, [name, field]) => {
        env[name] = toShadeType(field);
        return env;
    }, {});

    return Object.assign({
        inject: {
            this: {type: "object", kind: "any", info: {}},
            evaluate: [{
                extra: {
                    type: "object",
                    global: true,
                    properties: env
                }
            }]
        }
    }, options);
};

},{"./to_shade_type":23}],21:[function(require,module,exports){
"use strict";

const DisposeIfNoListener = superclass => class extends superclass {
    constructor(eventName) {
        super();

        const callDispose = () => {
            if (this.dispose)
                this.dispose();
        };

        this.on("removeListener", () => {
            if (this.listenerCount(eventName) === 0)
                callDispose();
        });

        setTimeout(() => {
            if (this.listenerCount(eventName) === 0)
                callDispose();
        }, 0);
    }
};

exports = module.exports = DisposeIfNoListener;

},{}],22:[function(require,module,exports){
"use strict";

const Shade = require("shade.js");

const Types = require("../field/types");

const typeMap = new Map([
    [Shade.TYPES.INT, Types.int32],
    [Shade.TYPES.NUMBER, Types.float32],
    [Shade.OBJECT_KINDS.VEC2, Types.vec2],
    [Shade.OBJECT_KINDS.VEC3, Types.vec3],
    [Shade.OBJECT_KINDS.VEC4, Types.vec4],
    // [Shade.OBJECT_KINDS.MATRIX2, Types.mat2],
    [Shade.OBJECT_KINDS.MATRIX3, Types.mat3],
    [Shade.OBJECT_KINDS.MATRIX4, Types.mat4],
]);

exports = module.exports = (typeInfo, name, source) => {
    let type = typeInfo.kind || typeInfo.type;
    const shape = [];
    let flType = undefined;
    if (type === Shade.OBJECT_KINDS.TEXTURE) {
        flType = Types.vec4;
        shape.push(typeInfo.width);
        shape.push(typeInfo.height);
        shape.push(...flType.shape);

        return {
            name: name,
            type: flType,
            shape: shape,
            source: source,
            isTexture: true
        }
    }

    while (type === Shade.TYPES.ARRAY) {
        shape.push(typeInfo.staticSize);
        const elementTypeInfo = typeInfo.elements.extra;
        type = elementTypeInfo.kind || elementTypeInfo.type;
    }

    flType = typeMap.get(type);
    if (shape.length === 0)
        shape.push(1);

    shape.push(...flType.shape);

    return {
        name: name,
        type: flType,
        shape: shape,
        source: source
    };
};

},{"../field/types":12,"shade.js":44}],23:[function(require,module,exports){
"use strict";

const Shade = require("shade.js");

const Types = require("../field/types");

const typeMap = new Map([
    [Types.int32, {
        type: Shade.TYPES.INT
    }],
    [Types.float32, {
        type: Shade.TYPES.NUMBER
    }],

    [Types.vec2, {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.VEC2
    }],
    [Types.vec3, {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.VEC3
    }],
    [Types.vec4, {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.VEC4
    }],

    [Types.mat2, {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.MATRIX2
    }],
    [Types.mat3, {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.MATRIX3
    }],
    [Types.mat4, {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.MATRIX4
    }]
]);

exports = module.exports = function ({type, shape, accessors, isTexture}) {
    // if (!typeMap.has(type))
    //     throw new Error("Unsupported Type: " + type);
        
    if (shape[0] === 1) {
        const result = Object.assign({
            source: Shade.SOURCES.UNIFORM
        }, typeMap.get(type));
        if (accessors)
            result.accessors = accessors;
        return result;
    } else {
        if (shape.length === 3 && shape[2] === 4 && isTexture)
            return {
                type: Shade.TYPES.OBJECT,
                kind: Shade.OBJECT_KINDS.TEXTURE,
                accessors: accessors,
                width: shape[0],
                height: shape[1]
            };

        const arrayShape = shape.slice(0);
        const arraySize = arrayShape.shift();
        for (let i = 0; i < type.shape.length; ++i)
            arrayShape.pop();

        const shadeTypeInfo = {
            type: Shade.TYPES.ARRAY,
            elements: {
                extra: {}
            },
            staticSize: arraySize,
            source: Shade.SOURCES.UNIFORM
        };

        let elementTypeInfo = shadeTypeInfo.elements.extra;
        while (arrayShape.length > 0) {
            elementTypeInfo.type = Shade.TYPES.ARRAY;
            elementTypeInfo.staticSize = arrayShape.pop();
            elementTypeInfo.elements = {};
            elementTypeInfo.elements.extra = {};
            elementTypeInfo = elementTypeInfo.elements.extra;
        }

        Object.assign(elementTypeInfo, typeMap.get(type));
        if (accessors)
            shadeTypeInfo.accessors = accessors;

        return shadeTypeInfo;
    }
};

},{"../field/types":12,"shade.js":44}],24:[function(require,module,exports){
"use strict";

exports = module.exports = buffer => {
    if (buffer.shape && buffer.shape[0] === 1)
        return buffer.get(0);

    if (Array.isArray(buffer))
        return buffer;

    if (typeof buffer === "object")
        return new Proxy(buffer, {
            get: function (target, prop) {
                if (typeof prop === "string") {
                    if (prop === "width")
                        return target._arrayShape[0];
                    if (prop === "height")
                        return target._arrayShape[1];
                    const idx = parseInt(prop);
                    if (Number.isInteger(idx)) {
                        if (target._arrayShape.length > 1)
                            return new Proxy(target.pick(idx), this);
                        else
                            return target.get(idx);
                    }
                }
                return target[prop];
            },
            set: function (target, prop, value) {
                if (typeof prop === "string") {
                    const idx = parseInt(prop);
                    if (Number.isInteger(idx)) {
                        target.set(idx, value);
                        return true;
                    }
                }
                target[prop] = value;
                return true;
            }
        });

    return buffer;
};

},{}],25:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":42}],26:[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],27:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(array)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":26,"ieee754":33,"isarray":28}],28:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],29:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":30,"./lib/keys.js":31}],30:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],31:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],32:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],33:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],34:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],35:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],36:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],37:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":35,"is-buffer":36}],38:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":40}],39:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":40}],40:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],41:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],42:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":41,"_process":40,"inherits":34}],43:[function(require,module,exports){
(function (process,global){
"use strict";

if (!process.browser)
    global.Shade = require("shade.js");
else
    window.Shade = require("shade.js");

exports.Node = require("./graph/node");
exports.Operator = require("./operator/operator");
exports.RenameOperator = require("./operator/rename");
exports.FilterOperator = require("./operator/filter");
exports.Buffer = require("./field/buffer_accessor");
exports.Types = require("./field/types");
exports.ComputeRequest = require("./execution/compute_request");

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./execution/compute_request":8,"./field/buffer_accessor":11,"./field/types":12,"./graph/node":13,"./operator/filter":15,"./operator/operator":16,"./operator/rename":17,"_process":40,"shade.js":44}],44:[function(require,module,exports){
module.exports = require('./src/index.js');

},{"./src/index.js":183}],45:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/../../shadejs/node_modules/amdefine/amdefine.js")

},{"_process":40,"path":38}],46:[function(require,module,exports){
module.exports = require('./lib');

},{"./lib":50}],47:[function(require,module,exports){

var walkes = require('walkes');
var worklist = require('../');
var Set = require('../set');

module.exports = availableExpressions;

/*
So here is the story:
Each node is supposed to have a `Set` of expressions. And for each expression,
I want to save the `Set` of contained variables for easier killing.

Since JS has no records yet (see http://wiki.ecmascript.org/doku.php?id=strawman:records )
and no concept of structural equality, an expression represented by an AST node
is *never ever* equal to an structurally equal expression unless its the
identical node.
The same goes for `Set`s. Since they are just shimmed using normal Objects, they
are *never ever* equal, although they contain the exact same members.

So as a workaround, I `JSON.stringify` the expression to save it in the Set and
use a mapping table to get to the expression object and the corresponding set of
variables.

Of course, I could just use a custom Set implementation which uses a custom
equality check function. But I want to be forward-compatible with the upcoming
ES6 standard, which should provide a O(1) Sets, instead of the O(n) shim.
*/

function availableExpressions(cfg) {
	var expressionMap = {};

	function findExpressions(ast) {
		var expressions = new Set();
		// FIXME: just handling binary expressions so far
		walkes(ast, {
			Identifier: function () {
				return new Set(this.name);
			},
			Literal: function () {
				return new Set();
			},
			BinaryExpression: function (recurse) {
				var stringified = JSON.stringify(this);
				expressions.add(stringified);
				if (stringified in expressionMap) {
					return expressionMap[stringified].variables;
				}
				var right = recurse(this.right);
				var left = recurse(this.left);
				var variables = Set.union(left, right);
				expressionMap[stringified] = {
					expression: this,
					variables: variables
				};
				return variables;
			}
		});
		return expressions;
	}

	// run the algorithm
	var output = worklist(cfg, function (input, list) {
		if (this.type || !this.astNode)
			return input;
		var kill = this.kill = this.kill || findAssignments(this.astNode);
		var generate = this.generate = this.generate || findExpressions(this.astNode);
		var killed = new Set(input.values().filter(function (expr) {
			var variables = expressionMap[expr].variables;
			return !Set.intersect(variables, kill).size;
		}));
		return Set.union(killed, generate);
	}, {direction: 'forward', merge: worklist.merge(Set.intersect)});

	// go over all the nodes and push down the real objects into the output
	cfg[2].forEach(function (node) {
		var out = output.get(node);
		output.set(node, new Set(out.values().map(function (expr) {
			return expressionMap[expr].expression;
		})));
	});

	return output;
}

function findAssignments(ast) {
	var variables = new Set();
	walkes(ast, {
		AssignmentExpression: function (recurse) {
			if (this.left.type === 'Identifier')
				variables.add(this.left.name);
			recurse(this.right);
		},
		VariableDeclarator: function (recurse) {
			variables.add(this.id.name);
			if (this.init)
				recurse(this.init);
		}
	});
	return variables;
}


},{"../":50,"../set":52,"walkes":95}],48:[function(require,module,exports){

exports.liveVariables = require('./livevariables');
exports.availableExpressions = require('./availableexpressions');


},{"./availableexpressions":47,"./livevariables":49}],49:[function(require,module,exports){

var walkes = require('walkes');
var worklist = require('../');
var Set = require('../set');

module.exports = liveVariables;

function liveVariables(cfg) {
	return worklist(cfg, function (input) {
		if (this.type || !this.astNode)
			return input;

		return Set.union(new Set([this], input));
	}, {direction: 'forward',         merge: worklist.merge(Set.intersect)});
}

function findAssignments(astNode) {
	var variables = new Set();
	walkes(astNode, {
		AssignmentExpression: function (recurse) {
			if (this.left.type === 'Identifier')
				variables.add(this.left.name);
			recurse(this.right);
		},
		FunctionDeclaration: function () {},
		FunctionExpression: function () {},
		VariableDeclarator: function (recurse) {
			variables.add(this.id.name);
			if (this.init)
				recurse(this.init);
		}
	});
	return variables;
}
function findVariables(astNode) {
	var variables = new Set();
	walkes(astNode, {
		AssignmentExpression: function (recurse) {
			if (this.left.type !== 'Identifier')
				recurse(this.left);
			recurse(this.right);
		},
		FunctionDeclaration: function () {},
		FunctionExpression: function () {},
		Identifier: function () {
			variables.add(this.name);
		},
		MemberExpression: function (recurse) {
			recurse(this.object);
		},
		Property: function (recurse) {
			recurse(this.value);
		},
		VariableDeclarator: function (recurse) {
			recurse(this.init);
		}
	});
	return variables;
}


},{"../":50,"../set":52,"walkes":95}],50:[function(require,module,exports){

var Queue = require('./queue');
var Set = require('./set');

var exports = module.exports = worklist;

// expose the utilities to have them tested separately
exports.Queue = Queue;
exports.Set = Set;
exports.examples = require('./examples');

/**
 * Implementation of a general worklist algorithm
 * `cfg` is a control flow graph created by `esgraph`,
 * `transferFunction` gets called with (this = node, input, worklist)
 * it operates on the input `Set` and can return an output set, in which case
 * the worklist algorithm automatically enqueues all the successor nodes, or it
 * might return an {output: output, enqueue: false} object in which case it is
 * itself responsible to enqueue the successor nodes.
 * `options` defines the `direction`, a `merge` function and an `equals`
 * function which merge the inputs to a node and determine if a node has changed
 * its output respectively.
 * Returns a `Map` from node -> output
 */
function worklist(cfg, transferFunction, options) {
	options = options || {};
	var direction = options.direction || 'forward';
	var merge = options.merge || worklist.merge(Set.union);
	var equals = options.equals || Set.equals;
	var list = new Queue();
	if (direction === 'forward') {
		list.push(cfg[0]);
		var predecessors = worklist.predecessors;
		var successors = worklist.successors;
	} else {
		list.push(cfg[1]);
		var predecessors = worklist.successors;
		var successors = worklist.predecessors;
	}
	var start = options.start || new Set();

	var output = new Map();
	while (list.length) {
		var node = list.shift();
		var pre = predecessors(node)
			.map(function (n) {return output.get(n);})
		var input = pre.length ? merge(pre) : start;
		var oldOutput = output.get(node);
		var out = transferFunction.call(node, input, list, oldOutput);
		if (!out || out instanceof Set)
			out = {output: out, enqueue: true};
		output.set(node, out.output);
		if (out.enqueue && (!oldOutput || !equals(out.output, oldOutput)))
			successors(node).forEach(function (aSuccessor) {	list.push(aSuccessor);	});
	}
	return output;
};

worklist.predecessors = function (node) {
	return node.prev;
};

worklist.successors = function (node) {
	return node.next;
};

worklist.merge = function (fn) {
	return function (inputs) {
		if (inputs.length == 1)
			return new Set(inputs[0]);
		return inputs.reduce(fn);
	};
};


},{"./examples":48,"./queue":51,"./set":52}],51:[function(require,module,exports){

module.exports = Queue;

/**
 * This is a really small priority queue that makes sure that duplicate elements
 * are being inserted at the end
 */
function Queue() {
	var q = [];
	q.__proto__ = Queue.prototype;
	return q;
}

Queue.prototype = Object.create(Array.prototype);
Queue.prototype.push = function Queue_push(elem) {
	var pos = this.indexOf(elem);
	if (pos != -1)
		this.splice(pos, 1);
	Array.prototype.push.call(this, elem);
};

},{}],52:[function(require,module,exports){

module.exports = Set;

/**
 * ES6 Sets in `node --harmony` do not provide `.values()` or `for of` iteration
 * yet, so they are pretty useless :-(
 * This Set also does not use `Object.is`; we do not care about NaN, -0, +0
 */
function Set(elements) {
	this._values = [];
	if (Array.isArray(elements))
		elements.forEach(this.add.bind(this));
	else if (elements instanceof Set)
		elements._values.forEach(this.add.bind(this));
}
Object.defineProperty(Set.prototype, 'size', {
	enumerable: false,
	configurable: false,
	get: function () {
		return this._values.length;
	}
});
Set.prototype._i = function Set__i(elem) {
	return this._values.indexOf(elem);
};
Set.prototype.add = function Set_add(elem) {
	if (!this.has(elem))
		this._values.push(elem);
};
Set.prototype.has = function Set_has(elem) {
	return !!~this._i(elem);
};
Set.prototype.delete = function Set_delete(elem) {
	var i = this._i(elem);
	if (!~i)
		return;
	this._values.splice(i, 1);
};
Set.prototype.values = function Set_values() {
	return [].concat(this._values);
};

// forward some convenience functions from Array.prototype
[
	'some',
	'map',
	'every',
	'filter',
	'forEach'
].forEach(function (method) {
	Set.prototype[method] = function () {
		return Array.prototype[method].apply(this._values, arguments);
	}
});

// some convenience functions
Set.prototype.first = function Set_first() {
	return this._values[0];
};
Set.intersect = function intersect(a, b) {
	if (!a && b)
		return new Set(b);
	if (!b && a)
		return new Set(a);
	var s = new Set();
	a.forEach(function (val) {
		if (b.has(val))
			s.add(val);
	});
	return s;
};
Set.union = function union(a, b) {
	if (!a && b)
		return new Set(b);
	var s = new Set(a);
	if (b)
		b.forEach(s.add.bind(s));
	return s;
};
Set.equals = function equals(a, b) {
	if (a.size != b.size)
		return false;
	return a.every(function (val) {
		return b.has(val);
	});
};
Set.minus = function minus(a, b) {
	var s = new Set(a);
	b.forEach(s.delete.bind(s));
	return s;
};


},{}],53:[function(require,module,exports){
(function (Buffer){
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if it is array or isn't object
		if (typeof obj !== 'object' || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = target[key]; // source value
			val = obj[key]; // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
}

}).call(this,require("buffer").Buffer)

},{"buffer":27}],54:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Await: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value;
        if (func.async) {
            return generateAsyncPrefix(func, !prop.computed);
        } else {
            // avoid space before method name
            return generateStarSuffix(func) ? '*' : '';
        }
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + space + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));
        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class ' + stmt.id.name];
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                    ')'
                ];

                if (stmt.guard) {
                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            if (stmt['default']) {
                result = join(result, 'default');
                if (isStatement(stmt.declaration)) {
                    result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
                } else {
                    result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
                }
                return result;
            }

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export * FromClause ;
            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                generateIdentifier(stmt.id),
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, currentPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.delegate ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ExportBatchSpecifier: function (expr, precedence, flags) {
            return '*';
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags);
        },

        ArrayExpression: function (expr, precedence, flags) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            if (expr.id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(expr.id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            return this.ExportSpecifier(expr, precedence, flags);
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var result = [ expr.id.name ];
            if (expr.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(expr.name));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr,result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./package.json":56,"estraverse":55,"esutils":66,"source-map":85}],55:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportDeclaration: 'ExportDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportBatchSpecifier: [],
        ExportDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['id', 'name'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['id'],
        ImportNamespaceSpecifier: ['id'],
        ImportSpecifier: ['id', 'name'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.8.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],56:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "name": "escodegen",
        "raw": "escodegen@1.6.1",
        "rawSpec": "1.6.1",
        "scope": null,
        "spec": "1.6.1",
        "type": "version"
      },
      "/Users/jan/development/shadejs"
    ]
  ],
  "_from": "escodegen@1.6.1",
  "_id": "escodegen@1.6.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/escodegen",
  "_npmUser": {
    "email": "utatane.tea@gmail.com",
    "name": "constellation"
  },
  "_npmVersion": "2.0.0-alpha-5",
  "_phantomChildren": {},
  "_requested": {
    "name": "escodegen",
    "raw": "escodegen@1.6.1",
    "rawSpec": "1.6.1",
    "scope": null,
    "spec": "1.6.1",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.6.1.tgz",
  "_shasum": "367de17d8510540d12bc6dcb8b3f918391265815",
  "_shrinkwrap": null,
  "_spec": "escodegen@1.6.1",
  "_where": "/Users/jan/development/shadejs",
  "bin": {
    "escodegen": "./bin/escodegen.js",
    "esgenerate": "./bin/esgenerate.js"
  },
  "bugs": {
    "url": "https://github.com/estools/escodegen/issues"
  },
  "dependencies": {
    "esprima": "^1.2.2",
    "estraverse": "^1.9.1",
    "esutils": "^1.1.6",
    "optionator": "^0.5.0",
    "source-map": "~0.1.40"
  },
  "description": "ECMAScript code generator",
  "devDependencies": {
    "acorn-6to5": "^0.11.1-25",
    "bluebird": "^2.3.11",
    "bower-registry-client": "^0.2.1",
    "chai": "^1.10.0",
    "commonjs-everywhere": "^0.9.7",
    "esprima-moz": "*",
    "gulp": "^3.8.10",
    "gulp-eslint": "^0.2.0",
    "gulp-mocha": "^2.0.0",
    "semver": "^4.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "367de17d8510540d12bc6dcb8b3f918391265815",
    "tarball": "https://registry.npmjs.org/escodegen/-/escodegen-1.6.1.tgz"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "files": [
    "LICENSE.BSD",
    "LICENSE.source-map",
    "README.md",
    "bin",
    "escodegen.js",
    "package.json"
  ],
  "gitHead": "1ca664f68dcf220b76c9dc562b2337c5e0b4227d",
  "homepage": "http://github.com/estools/escodegen",
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/estools/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "main": "escodegen.js",
  "maintainers": [
    {
      "email": "utatane.tea@gmail.com",
      "name": "constellation"
    }
  ],
  "name": "escodegen",
  "optionalDependencies": {
    "source-map": "~0.1.40"
  },
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/escodegen.git"
  },
  "scripts": {
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "test": "gulp travis",
    "unit-test": "gulp test"
  },
  "version": "1.6.1"
}

},{}],57:[function(require,module,exports){

module.exports = dot;

function dot(cfg, options) {
	options = options || {};
	var counter = options.counter || 0;
	var source = options.source;

	var output = [];
	var nodes = cfg[2];
	var i;
	var node;

	// print all the nodes:
	for (i = 0; i < nodes.length; i++) {
		node = nodes[i];
		var label = node.label || node.type;
		if (!label && source && node.astNode.range) {
			var ast = node.astNode;
			var range = ast.range;
			var add = '';
			// special case some statements to get them properly printed
			if (ast.type === 'SwitchCase') {
				if (ast.test) {
					range = [range[0], ast.test.range[1]];
					add = ':';
				} else {
					range = [range[0], range[0]];
					add ='default:';
				}
			} else if (ast.type === 'ForInStatement') {
				range = [range[0], ast.right.range[1]];
				add = ')';
			} else if (ast.type === 'CatchClause') {
				range = [range[0], ast.param.range[1]];
				add = ')';
			}

			label = source.slice(range[0], range[1])
				.replace(/\n/g, '\\n')
				.replace(/\t/g, '    ')
				.replace(/"/g, '\\"') + add;
		}
		if (!label && node.astNode) {
			label = node.astNode.type;
		}
		output.push('n' + (counter + i) + ' [label="' + label + '"');
		if (~['entry', 'exit'].indexOf(node.type))
			output.push(', style="rounded"');
		output.push(']\n');
	}

	// print all the edges:
	for (i = 0; i < nodes.length; i++) {
		node = nodes[i];
		['normal', 'true', 'false', 'exception'].forEach(eachType);
	}
	function eachType(type) {
		var next = node[type];
		if (!next)
			return;

		output.push('n' + (counter + i) + ' -> n' + (counter + nodes.indexOf(next)) + ' [');
		if (type === 'exception')
			output.push('color="red", label="exception"');
		else if (~['true', 'false'].indexOf(type))
			output.push('label="' + type + '"');
		output.push(']\n');
	}

	if (options.counter !== undefined)
		options.counter+= nodes.length;

	return output.join('');
}


},{}],58:[function(require,module,exports){

var walker = require('walkes');

module.exports = ControlFlowGraph;
module.exports.dot = require('./dot');

// FIXME: switch/case with default before other cases?
// FIXME: catch creates a new scope, so should somehow be handled differently

// TODO: try/finally: finally follows try, but does not return to normal flow?

// TODO: labeled break/continue
// TODO: WithStatement

// TODO: avoid adding and deleting properties on ast nodes

/**
 * Returns [entry, exit] `FlowNode`s for the passed in AST
 */
function ControlFlowGraph(astNode, options) {
	options = options || {};
	var parentStack = [];
	var exitNode = new FlowNode(undefined, undefined, 'exit');
	var catchStack = [exitNode];
	var omitExceptions = !!options.omitExceptions;

	createNodes(astNode);
	linkSiblings(astNode);
	
	walker(astNode, {
		CatchClause: function (node, recurse) {
			node.cfg.connect(getEntry(node.body));
			recurse(node.body);
		},
		DoWhileStatement: function (node, recurse) {
			mayThrow(node.test);
			node.test.cfg
				.connect(getEntry(node.body), 'true')
				.connect(getSuccessor(node), 'false');
			recurse(node.body);
		},
		ExpressionStatement: connectNext,
		FunctionDeclaration: function () {},
		ForStatement: function (node, recurse) {
			if (node.test) {
				mayThrow(node.test);
				node.test.cfg
					.connect(getEntry(node.body), 'true')
					.connect(getSuccessor(node), 'false');
				if (node.update)
					node.update.cfg.connect(node.test.cfg);
			} else if (node.update)
				node.update.cfg.connect(getEntry(node.body));
			if (node.update)
				mayThrow(node.update);
			if (node.init) {
				mayThrow(node.init);
				node.init.cfg.connect(node.test && node.test.cfg || getEntry(node.body));
			}
			recurse(node.body);
		},
		ForInStatement: function (node, recurse) {
			mayThrow(node);
			node.cfg
				.connect(getEntry(node.body), 'true')
				.connect(getSuccessor(node), 'false');
			recurse(node.body);
		},
		IfStatement: function (node, recurse) {
			recurse(node.consequent);
			mayThrow(node.test);
			node.test.cfg.connect(getEntry(node.consequent), 'true');
			if (node.alternate) {
				recurse(node.alternate);
				node.test.cfg.connect(getEntry(node.alternate), 'false');
			} else {
				node.test.cfg.connect(getSuccessor(node), 'false');
			}
		},
		ReturnStatement: function (node) {
			mayThrow(node);
			node.cfg.connect(exitNode);
		},
		SwitchCase: function (node, recurse) {
			if (node.test) {
				// if this is a real case, connect `true` to the body
				// or the body of the next case
				var check = node;
				while (!check.consequent.length && check.cfg.nextSibling)
					check = check.cfg.nextSibling.astNode;

				node.cfg.connect(check.consequent.length && getEntry(check.consequent[0]) || getSuccessor(node.cfg.parent), 'true');

				// and connect false to the next `case`
				node.cfg.connect(getSuccessor(node), 'false');
			} else {
				// this is the `default` case, connect it to the body, or the
				// successor of the parent
				node.cfg.connect(node.consequent.length && getEntry(node.consequent[0]) || getSuccessor(node.cfg.parent));
			}
			node.consequent.forEach(recurse);
		},
		SwitchStatement: function (node, recurse) {
			node.cfg.connect(node.cases[0].cfg);
			node.cases.forEach(recurse);
		},
		ThrowStatement: function (node) {
			node.cfg.connect(getExceptionTarget(node), 'exception');
		},
		TryStatement: function (node, recurse) {

			var handler = node.handler && node.handler.cfg || getEntry(node.finalizer);
			catchStack.push(handler);
			recurse(node.block);
			catchStack.pop();

			if (node.handler)
				recurse(node.handler);
			if (node.finalizer) {
				//node.finalizer.cfg.connect(getSuccessor(node));
				recurse(node.finalizer);
			}
		},
		VariableDeclaration: connectNext,
		WhileStatement: function (node, recurse) {
			mayThrow(node.test);
			node.test.cfg
				.connect(getEntry(node.body), 'true')
				.connect(getSuccessor(node), 'false');
			recurse(node.body);
		}
	});
	
	var entryNode = new FlowNode(astNode, undefined, 'entry');
	entryNode.normal = getEntry(astNode);
	walker(astNode, {default: function (node, recurse) {
		if (!node.cfg)
			return;
		// ExpressionStatements should refer to their expression directly
		if (node.type === 'ExpressionStatement')
			node.cfg.astNode = node.expression;
		delete node.cfg;
		walker.checkProps(node, recurse);
	}});

	var allNodes = [];
	var reverseStack = [entryNode];
	var cfgNode;
	while (reverseStack.length) {
		cfgNode = reverseStack.pop();
		allNodes.push(cfgNode);
		cfgNode.next = [];
		['exception', 'false', 'true', 'normal'].forEach(eachType);
	}
	function eachType(type) {
		var next = cfgNode[type];
		if (!next)
			return;
		if (!~cfgNode.next.indexOf(next))
			cfgNode.next.push(next);
		if (!~next.prev.indexOf(cfgNode))
			next.prev.push(cfgNode);
		if (!~reverseStack.indexOf(next) && !next.next)
			reverseStack.push(next);
	}

	function getExceptionTarget() {
		return catchStack[catchStack.length - 1];
	}

	function mayThrow(node) {
		if (!omitExceptions && expressionThrows(node))
			node.cfg.connect(getExceptionTarget(node), 'exception');
	}
	function expressionThrows(astNode) {
		if (typeof astNode !== 'object' || 'FunctionExpression' === astNode.type)
			return false;
		if (astNode.type && ~throwTypes.indexOf(astNode.type))
			return true;
		var self = astNode;
		return Object.keys(self).some(function (key) {
			var prop = self[key];
			if (prop instanceof Array) {
				return prop.some(expressionThrows);
			} else if (typeof prop === 'object' && prop)
				return expressionThrows(prop);
			else
				return false;
		});
	}

	function getJumpTarget(astNode, types) {
		var parent = astNode.cfg.parent;
		while (!~types.indexOf(parent.type) && parent.cfg.parent)
			parent = parent.cfg.parent;
		return ~types.indexOf(parent.type) ? parent : null;
	}

	function connectNext(node) {
		mayThrow(node);
		node.cfg.connect(getSuccessor(node));
	}

	/**
	 * Returns the entry node of a statement
	 */
	function getEntry(astNode) {
		var target;
		switch (astNode.type) {
			case 'BreakStatement':
				target = getJumpTarget(astNode, breakTargets);
				return target ? getSuccessor(target) : exitNode;
			case 'ContinueStatement':
				target = getJumpTarget(astNode, continueTargets);
				switch (target.type) {
					case 'ForStatement':
						// continue goes to the update, test or body
						return target.update && target.update.cfg || target.test && target.test.cfg || getEntry(target.body);
					case 'ForInStatement':
						return target.cfg;
					case 'DoWhileStatement':
					/* falls through */
					case 'WhileStatement':
						return target.test.cfg;
				}
			// unreached
			/* falls through */
			case 'BlockStatement':
			/* falls through */
			case 'Program':
				return astNode.body.length && getEntry(astNode.body[0]) || getSuccessor(astNode);
			case 'DoWhileStatement':
				return getEntry(astNode.body);
			case 'EmptyStatement':
				return getSuccessor(astNode);
			case 'ForStatement':
				return astNode.init && astNode.init.cfg || astNode.test && astNode.test.cfg || getEntry(astNode.body);
			case 'FunctionDeclaration':
				return getSuccessor(astNode);
			case 'IfStatement':
				return astNode.test.cfg;
			case 'SwitchStatement':
				return getEntry(astNode.cases[0]);
			case 'TryStatement':
				return getEntry(astNode.block);
			case 'WhileStatement':
				return astNode.test.cfg;
			default:
				return astNode.cfg;
		}
	}
	/**
	 * Returns the successor node of a statement
	 */
	function getSuccessor(astNode) {
		// part of a block -> it already has a nextSibling
		if (astNode.cfg.nextSibling)
			return astNode.cfg.nextSibling;
		var parent = astNode.cfg.parent;
		if (!parent) // it has no parent -> exitNode
			return exitNode;
		switch (parent.type) {
			case 'DoWhileStatement':
				return parent.test.cfg;
			case 'ForStatement':
				return parent.update && parent.update.cfg || parent.test && parent.test.cfg || getEntry(parent.body);
			case 'ForInStatement':
				return parent.cfg;
			case 'TryStatement':
				return parent.finalizer && astNode !== parent.finalizer && getEntry(parent.finalizer) || getSuccessor(parent);
			case 'SwitchCase':
				// the sucessor of a statement at the end of a case block is
				// the entry of the next cases consequent
				if (!parent.cfg.nextSibling)
					return getSuccessor(parent);
				var check = parent.cfg.nextSibling.astNode;
				while (!check.consequent.length && check.cfg.nextSibling)
					check = check.cfg.nextSibling.astNode;
				// or the next statement after the switch, if there are no more cases
				return check.consequent.length && getEntry(check.consequent[0]) || getSuccessor(parent.parent);
			case 'WhileStatement':
				return parent.test.cfg;
			default:
				return getSuccessor(parent);
		}
	}

	/**
	 * Creates a FlowNode for every AST node
	 */
	function createNodes(astNode) {
		walker(astNode, { default: function (node, recurse) {
			var parent = parentStack.length ? parentStack[parentStack.length - 1] : undefined;
			createNode(node, parent);
			// do not recurse for FunctionDeclaration or any sub-expression
			if (node.type === 'FunctionDeclaration' || ~node.type.indexOf('Expression'))
				return;
			parentStack.push(node);
			walker.checkProps(node, recurse);
			parentStack.pop();
		}});
	}
	function createNode(astNode, parent) {
		if (!astNode.cfg)
			Object.defineProperty(astNode, 'cfg', {value: new FlowNode(astNode, parent), configurable: true});
	}

	/**
	 * Links in the next sibling for nodes inside a block
	 */
	function linkSiblings(astNode) {
		function backToFront(list, recurse) {
			// link all the children to the next sibling from back to front,
			// so the nodes already have .nextSibling
			// set when their getEntry is called
			for (var i = list.length - 1; i >= 0; i--) {
				var child = list[i];
				if (i < list.length - 1)
					child.cfg.nextSibling = getEntry(list[i + 1]);
				recurse(child);
			}
		}
		function BlockOrProgram(node, recurse) {
			backToFront(node.body, recurse);
		}
		walker(astNode, {
			BlockStatement: BlockOrProgram,
			Program: BlockOrProgram,
			FunctionDeclaration: function () {},
			FunctionExpression: function () {},
			SwitchCase: function (node, recurse) {
				backToFront(node.consequent, recurse);
			},
			SwitchStatement: function (node, recurse) {
				backToFront(node.cases, recurse);
			},
		});
	}
	return [entryNode, exitNode, allNodes];
}

function FlowNode(astNode, parent, type) {
	this.astNode = astNode;
	this.parent = parent;
	this.type = type;
	this.prev = [];
}
FlowNode.prototype.connect = function (next, type) {
	this[type || 'normal'] = next;
	return this;
};

var continueTargets = [
	'ForStatement',
	'ForInStatement',
	'DoWhileStatement',
	'WhileStatement'];
var breakTargets = continueTargets.concat(['SwitchStatement']);
var throwTypes = [
	'AssignmentExpression', // assigning to undef or non-writable prop
	'BinaryExpression', // instanceof and in on non-objects
	'CallExpression', // obviously
	'MemberExpression', // getters may throw
	'NewExpression', // obviously
	'UnaryExpression' // delete non-deletable prop
];


},{"./dot":57,"walkes":59}],59:[function(require,module,exports){
/* vim: set shiftwidth=2 tabstop=2 noexpandtab textwidth=80 wrap : */
"use strict";

module.exports = walker;

function walker(astNode, functionTable, offset) {
	function stop() { throw stop; }
	var recurse = function (astNode) {
		if (!astNode || typeof astNode !== 'object' || !astNode.type) {
			return astNode;
		}

		// range based recursion: only recurse when the astNode is in range
		if (offset !== undefined && astNode.range &&
		    (astNode.range[0] > offset || astNode.range[1] < offset)) {
			return astNode;
		}

		var fn = functionTable[astNode.type] || functionTable.default || checkProps;
		return fn(astNode, recurse, stop);
	};
	var ret;
	try {
		ret = recurse(astNode);
	} catch (e) {
		if (e !== stop)
			throw e;
	}
	return ret;
}

function checkProps(node, recurse) {
	var mapped = {};
	Object.keys(node).forEach(function (key) {
		var prop = node[key];
		var ret = prop;
		if (Array.isArray(prop)) {
			ret = prop.map(recurse);
		} else {
			ret = recurse(prop);
		}

		mapped[key] = ret;
	});
	return mapped;
}

walker.checkProps = checkProps;

},{}],60:[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwErrorTolerant: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseUnaryExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment, attacher;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 0x2E:  // . dot
        case 0x28:  // ( open bracket
        case 0x29:  // ) close bracket
        case 0x3B:  // ; semicolon
        case 0x2C:  // , comma
        case 0x7B:  // { open curly brace
        case 0x7D:  // } close curly brace
        case 0x5B:  // [
        case 0x5D:  // ]
        case 0x3A:  // :
        case 0x3F:  // ?
        case 0x7E:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 0x28) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 0x7B) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (U+003D) marks an assignment or comparison operator.
            if (code2 === 0x3D) {
                switch (code) {
                case 0x2B:  // +
                case 0x2D:  // -
                case 0x2F:  // /
                case 0x3C:  // <
                case 0x3E:  // >
                case 0x5E:  // ^
                case 0x7C:  // |
                case 0x25:  // %
                case 0x26:  // &
                case 0x2A:  // *
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };

                case 0x21: // !
                case 0x3D: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 0x3D) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
            }
        }

        // 4-character punctuator: >>>=

        ch4 = source.substr(index, 4);

        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 3-character punctuators: === !== >>> <<= >>=

        ch3 = ch4.substr(0, 3);

        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);

        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 1-character punctuators: < > = ! + - * % & | ^ /
        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var value;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }
        return value;
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                } else {
                    str += '\\';
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, pattern, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }


        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, range, value;

        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            });
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function Position(line, column) {
        this.line = line;
        this.column = column;
    }

    function SourceLocation(startLine, startColumn, line, column) {
        this.start = new Position(startLine, startColumn);
        this.end = new Position(line, column);
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        processComment: function (node) {
            var lastChild, trailingComments;

            if (node.type === Syntax.Program) {
                if (node.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                if (extra.trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.trailingComments;
                    extra.trailingComments = [];
                } else {
                    extra.trailingComments.length = 0;
                }
            } else {
                if (extra.bottomRightStack.length > 0 &&
                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                }
            }

            // Eating the stack.
            while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
                lastChild = extra.bottomRightStack.pop();
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                }
            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            }


            if (trailingComments) {
                node.trailingComments = trailingComments;
            }

            extra.bottomRightStack.push(node);
        },

        markEnd: function (node, startToken) {
            if (extra.range) {
                node.range = [startToken.start, index];
            }
            if (extra.loc) {
                node.loc = new SourceLocation(
                    startToken.startLineNumber === undefined ?  startToken.lineNumber : startToken.startLineNumber,
                    startToken.start - (startToken.startLineStart === undefined ?  startToken.lineStart : startToken.startLineStart),
                    lineNumber,
                    index - lineStart
                );
                this.postProcess(node);
            }

            if (extra.attachComment) {
                this.processComment(node);
            }
            return node;
        },

        postProcess: function (node) {
            if (extra.source) {
                node.loc.source = extra.source;
            }
            return node;
        },

        createArrayExpression: function (elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },

        createAssignmentExpression: function (operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                        Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createContinueStatement: function (label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },

        createDebuggerStatement: function () {
            return {
                type: Syntax.DebuggerStatement
            };
        },

        createDoWhileStatement: function (body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },

        createEmptyStatement: function () {
            return {
                type: Syntax.EmptyStatement
            };
        },

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },

        createForInStatement: function (left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },

        createFunctionDeclaration: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createFunctionExpression: function (id, params, defaults, body) {
            return {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: null,
                generator: false,
                expression: false
            };
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name
            };
        },

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },

        createLiteral: function (token) {
            return {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.start, token.end)
            };
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },

        createProgram: function (body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },

        createProperty: function (kind, key, value) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },

        createSwitchCase: function (test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },

        createSwitchStatement: function (discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },

        createUnaryExpression: function (operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument,
                prefix: true
            };
        },

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },

        createWithStatement: function (object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.start;
            error.lineNumber = token.lineNumber;
            error.column = token.start - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber,
            oldLineStart = lineStart, oldLookahead = lookahead;

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], startToken;

        startToken = lookahead;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body, startToken;

        previousStrict = strict;
        startToken = lookahead;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
    }

    function parseObjectPropertyKey() {
        var token, startToken;

        startToken = lookahead;
        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return delegate.markEnd(delegate.createLiteral(token), startToken);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }

    function parseObjectProperty() {
        var token, key, id, value, param, startToken;

        token = lookahead;
        startToken = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
            }
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;

        startToken = lookahead;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, startToken;

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        type = lookahead.type;
        startToken = lookahead;

        if (type === Token.Identifier) {
            expr =  delegate.createIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            expr = delegate.createLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = delegate.createThisExpression();
            } else {
                throwUnexpected(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = delegate.createLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = delegate.createLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = delegate.createLiteral(collectRegex());
            } else {
                expr = delegate.createLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpected(lex());
        }

        return delegate.markEnd(expr, startToken);
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, startToken;

        startToken = lookahead;
        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, startToken;

        startToken = lookahead;
        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('.')) {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                break;
            }
            delegate.markEnd(expr, startToken);
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                property = parseComputedMember();
                expr = delegate.createMemberExpression('[', expr, property);
            } else {
                property = parseNonComputedMember();
                expr = delegate.createMemberExpression('.', expr, property);
            }
            delegate.markEnd(expr, startToken);
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            expr = delegate.markEnd(expr, startToken);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                expr = delegate.createBinaryExpression(operator, left, right);
                markers.pop();
                marker = markers[markers.length - 1];
                delegate.markEnd(expr, marker);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
            marker = markers.pop();
            delegate.markEnd(expr, marker);
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
            delegate.markEnd(expr, startToken);
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, left, right, node, startToken;

        token = lookahead;
        startToken = lookahead;

        node = left = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(left)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
        }

        return node;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead;

        expr = parseAssignmentExpression();

        if (match(',')) {
            expr = delegate.createSequenceExpression([ expr ]);

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

            delegate.markEnd(expr, startToken);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, startToken;

        startToken = lookahead;
        expect('{');

        block = parseStatementList();

        expect('}');

        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, startToken;

        startToken = lookahead;
        token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
    }

    function parseVariableDeclaration(kind) {
        var init = null, id, startToken;

        startToken = lookahead;
        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, startToken;

        startToken = lookahead;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return delegate.createIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return delegate.createDoWhileStatement(body, test);
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return delegate.createWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations, startToken;

        startToken = lookahead;
        token = lex();
        declarations = parseVariableDeclarationList();

        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                delegate.createForStatement(init, test, update, body) :
                delegate.createForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return delegate.createContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return delegate.createBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return delegate.createReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return delegate.createReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return delegate.createReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return delegate.createWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, startToken;

        startToken = lookahead;
        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return delegate.createSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return delegate.createSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return delegate.createThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, startToken;

        startToken = lookahead;
        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return delegate.createTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return delegate.createDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            startToken;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }

        startToken = lookahead;

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return delegate.markEnd(parseEmptyStatement(), startToken);
            case '(':
                return delegate.markEnd(parseExpressionStatement(), startToken);
            default:
                break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return delegate.markEnd(parseBreakStatement(), startToken);
            case 'continue':
                return delegate.markEnd(parseContinueStatement(), startToken);
            case 'debugger':
                return delegate.markEnd(parseDebuggerStatement(), startToken);
            case 'do':
                return delegate.markEnd(parseDoWhileStatement(), startToken);
            case 'for':
                return delegate.markEnd(parseForStatement(), startToken);
            case 'function':
                return delegate.markEnd(parseFunctionDeclaration(), startToken);
            case 'if':
                return delegate.markEnd(parseIfStatement(), startToken);
            case 'return':
                return delegate.markEnd(parseReturnStatement(), startToken);
            case 'switch':
                return delegate.markEnd(parseSwitchStatement(), startToken);
            case 'throw':
                return delegate.markEnd(parseThrowStatement(), startToken);
            case 'try':
                return delegate.markEnd(parseTryStatement(), startToken);
            case 'var':
                return delegate.markEnd(parseVariableStatement(), startToken);
            case 'while':
                return delegate.markEnd(parseWhileStatement(), startToken);
            case 'with':
                return delegate.markEnd(parseWithStatement(), startToken);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
        }

        consumeSemicolon();

        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;

        startToken = lookahead;
        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
    }

    function parseParams(firstRestricted) {
        var param, params = [], token, stricted, paramSet, key, message;
        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead;
                param = parseVariableIdentifier();
                key = '$' + token.value;
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[key] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return {
            params: params,
            stricted: stricted,
            firstRestricted: firstRestricted,
            message: message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;

        startToken = lookahead;

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;

        startToken = lookahead;
        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, startToken;

        skipComment();
        peek();
        startToken = lookahead;
        strict = false;

        body = parseSourceElements();
        return delegate.markEnd(delegate.createProgram(body), startToken);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            token,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            token = lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '1.2.5';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],61:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = require('./package.json').version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./package.json":62}],62:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "estraverse@4.1.1",
      "/Users/jan/development/shadejs"
    ]
  ],
  "_from": "estraverse@4.1.1",
  "_id": "estraverse@4.1.1",
  "_inCache": true,
  "_location": "/estraverse",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "email": "utatane.tea@gmail.com",
    "name": "constellation"
  },
  "_npmVersion": "2.14.4",
  "_phantomChildren": {},
  "_requested": {
    "name": "estraverse",
    "raw": "estraverse@4.1.1",
    "rawSpec": "4.1.1",
    "scope": null,
    "spec": "4.1.1",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz",
  "_shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
  "_shrinkwrap": null,
  "_spec": "estraverse@4.1.1",
  "_where": "/Users/jan/development/shadejs",
  "bugs": {
    "url": "https://github.com/estools/estraverse/issues"
  },
  "dependencies": {},
  "description": "ECMAScript JS AST traversal functions",
  "devDependencies": {
    "chai": "^2.1.1",
    "coffee-script": "^1.8.0",
    "espree": "^1.11.0",
    "gulp": "^3.8.10",
    "gulp-bump": "^0.2.2",
    "gulp-filter": "^2.0.0",
    "gulp-git": "^1.0.1",
    "gulp-tag-version": "^1.2.1",
    "jshint": "^2.5.6",
    "mocha": "^2.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
    "tarball": "http://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "gitHead": "bbcccbfe98296585e4311c8755e1d00dcd581e3c",
  "homepage": "https://github.com/estools/estraverse",
  "installable": true,
  "license": "BSD-2-Clause",
  "main": "estraverse.js",
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "name": "estraverse",
  "optionalDependencies": {},
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/estraverse.git"
  },
  "scripts": {
    "lint": "jshint estraverse.js",
    "test": "npm run-script lint && npm run-script unit-test",
    "unit-test": "mocha --compilers coffee:coffee-script/register"
  },
  "version": "4.1.1"
}

},{}],63:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],64:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex, NON_ASCII_WHITESPACES;

    // See `tools/generate-identifier-regex.js`.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) ||    // 0..9
            (97 <= ch && ch <= 102) ||  // a..f
            (65 <= ch && ch <= 70);     // A..F
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],65:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierName(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierName(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":64}],66:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":63,"./code":64,"./keyword":65}],67:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":68,"./gl-matrix/mat2.js":69,"./gl-matrix/mat2d.js":70,"./gl-matrix/mat3.js":71,"./gl-matrix/mat4.js":72,"./gl-matrix/quat.js":73,"./gl-matrix/vec2.js":74,"./gl-matrix/vec3.js":75,"./gl-matrix/vec4.js":76}],68:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

module.exports = glMatrix;

},{}],69:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 


module.exports = mat2;

},{"./common.js":68}],70:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

module.exports = mat2d;

},{"./common.js":68}],71:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


module.exports = mat3;

},{"./common.js":68}],72:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;
    
    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,
      
      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];
      
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;
        
  return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


module.exports = mat4;

},{"./common.js":68}],73:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = quat;

},{"./common.js":68,"./mat3.js":71,"./vec3.js":75,"./vec4.js":76}],74:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

module.exports = vec2;

},{"./common.js":68}],75:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

module.exports = vec3;

},{"./common.js":68}],76:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = vec4;

},{"./common.js":68}],77:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],78:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * Creates a base function for methods like `_.forIn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = baseFor;

},{}],79:[function(require,module,exports){
(function (global){
/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = global.Array.prototype,
    objectProto = global.Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = global.Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(global, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates an hash object.
 *
 * @private
 * @returns {Object} Returns the new hash object.
 */
function Hash() {}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(hash, key) {
  return hashHas(hash, key) && delete hash[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @param {Object} hash The hash to query.
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(hash, key) {
  if (nativeCreate) {
    var result = hash[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @param {Object} hash The hash to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(hash, key) {
  return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 */
function hashSet(hash, key, value) {
  hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function MapCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.clear();
  while (++index < length) {
    var entry = values[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapClear() {
  this.__data__ = { 'hash': new Hash, 'map': Map ? new Map : [], 'string': new Hash };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapDelete(key) {
  var data = this.__data__;
  if (isKeyable(key)) {
    return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
  }
  return Map ? data.map['delete'](key) : assocDelete(data.map, key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapGet(key) {
  var data = this.__data__;
  if (isKeyable(key)) {
    return hashGet(typeof key == 'string' ? data.string : data.hash, key);
  }
  return Map ? data.map.get(key) : assocGet(data.map, key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapHas(key) {
  var data = this.__data__;
  if (isKeyable(key)) {
    return hashHas(typeof key == 'string' ? data.string : data.hash, key);
  }
  return Map ? data.map.has(key) : assocHas(data.map, key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache object.
 */
function mapSet(key, value) {
  var data = this.__data__;
  if (isKeyable(key)) {
    hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
  } else if (Map) {
    data.map.set(key, value);
  } else {
    assocSet(data.map, key, value);
  }
  return this;
}

/**
 * Removes `key` and its value from the associative array.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function assocDelete(array, key) {
  var index = assocIndexOf(array, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = array.length - 1;
  if (index == lastIndex) {
    array.pop();
  } else {
    splice.call(array, index, 1);
  }
  return true;
}

/**
 * Gets the associative array value for `key`.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function assocGet(array, key) {
  var index = assocIndexOf(array, key);
  return index < 0 ? undefined : array[index][1];
}

/**
 * Checks if an associative array value for `key` exists.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function assocHas(array, key) {
  return assocIndexOf(array, key) > -1;
}

/**
 * Gets the index at which the first occurrence of `key` is found in `array`
 * of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * Sets the associative array `key` to `value`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 */
function assocSet(array, key, value) {
  var index = assocIndexOf(array, key);
  if (index < 0) {
    array.push([key, value]);
  } else {
    array[index][1] = value;
  }
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'number' || type == 'boolean' ||
    (type == 'string' && value !== '__proto__') || value == null;
}

/**
 * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(funcToString.call(value));
  }
  return isObjectLike(value) &&
    (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
}

// Avoid inheriting from `Object.prototype` when possible.
Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;

// Add functions to the `MapCache`.
MapCache.prototype.clear = mapClear;
MapCache.prototype['delete'] = mapDelete;
MapCache.prototype.get = mapGet;
MapCache.prototype.has = mapHas;
MapCache.prototype.set = mapSet;

module.exports = MapCache;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],80:[function(require,module,exports){
(function (global){
/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var MapCache = require('lodash._mapcache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used for built-in method references. */
var arrayProto = global.Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function Stack(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.clear();
  while (++index < length) {
    var entry = values[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = { 'array': [], 'map': null };
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      array = data.array;

  return array ? assocDelete(array, key) : data.map['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  var data = this.__data__,
      array = data.array;

  return array ? assocGet(array, key) : data.map.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  var data = this.__data__,
      array = data.array;

  return array ? assocHas(array, key) : data.map.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache object.
 */
function stackSet(key, value) {
  var data = this.__data__,
      array = data.array;

  if (array) {
    if (array.length < (LARGE_ARRAY_SIZE - 1)) {
      assocSet(array, key, value);
    } else {
      data.array = null;
      data.map = new MapCache(array);
    }
  }
  var map = data.map;
  if (map) {
    map.set(key, value);
  }
  return this;
}

/**
 * Removes `key` and its value from the associative array.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function assocDelete(array, key) {
  var index = assocIndexOf(array, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = array.length - 1;
  if (index == lastIndex) {
    array.pop();
  } else {
    splice.call(array, index, 1);
  }
  return true;
}

/**
 * Gets the associative array value for `key`.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function assocGet(array, key) {
  var index = assocIndexOf(array, key);
  return index < 0 ? undefined : array[index][1];
}

/**
 * Checks if an associative array value for `key` exists.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function assocHas(array, key) {
  return assocIndexOf(array, key) > -1;
}

/**
 * Gets the index at which the first occurrence of `key` is found in `array`
 * of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * Sets the associative array `key` to `value`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 */
function assocSet(array, key, value) {
  var index = assocIndexOf(array, key);
  if (index < 0) {
    array.push([key, value]);
  } else {
    array[index][1] = value;
  }
}

/**
 * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

// Add functions to the `Stack` cache.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash._mapcache":79}],81:[function(require,module,exports){
(function (global){
/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var keys = require('lodash.keys'),
    rest = require('lodash.rest');

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/** Used for built-in method references. */
var objectProto = global.Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if ((!eq(objValue, value) ||
        (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object) {
  return copyObjectWith(source, props, object);
}

/**
 * This function is like `copyObject` except that it accepts a function to
 * customize copied values.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObjectWith(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index],
        newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return rest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = typeof customizer == 'function' ? (length--, customizer) : undefined;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null &&
    !(typeof value == 'function' && isFunction(value)) && isLength(getLength(value));
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Assigns own enumerable properties of source objects to the destination
 * object. Source objects are applied from left to right. Subsequent sources
 * overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function Foo() {
 *   this.c = 3;
 * }
 *
 * function Bar() {
 *   this.e = 5;
 * }
 *
 * Foo.prototype.d = 4;
 * Bar.prototype.f = 6;
 *
 * _.assign({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3, 'e': 5 }
 */
var assign = createAssigner(function(object, source) {
  copyObject(source, keys(source), object);
});

module.exports = assign;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash.keys":83,"lodash.rest":84}],82:[function(require,module,exports){
(function (global){
/**
 * lodash 4.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var Stack = require('lodash._stack'),
    arrayEach = require('lodash._arrayeach'),
    baseFor = require('lodash._basefor'),
    keys = require('lodash.keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
cloneableTags[dateTag] = cloneableTags[float32Tag] =
cloneableTags[float64Tag] = cloneableTags[int8Tag] =
cloneableTags[int16Tag] = cloneableTags[int32Tag] =
cloneableTags[mapTag] = cloneableTags[numberTag] =
cloneableTags[objectTag] = cloneableTags[regexpTag] =
cloneableTags[setTag] = cloneableTags[stringTag] =
cloneableTags[symbolTag] = cloneableTags[uint8Tag] =
cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] =
cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to an array.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the converted array.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the converted array.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var objectProto = global.Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = global.Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = global.Symbol,
    Uint8Array = global.Uint8Array,
    getOwnPropertySymbols = Object.getOwnPropertySymbols;

/* Built-in method references that are verified to be native. */
var Map = getNative(global, 'Map'),
    Set = getNative(global, 'Set');

/** Used to detect maps and sets. */
var mapCtorString = Map ? funcToString.call(Map) : '',
    setCtorString = Set ? funcToString.call(Set) : '';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = Symbol ? symbolProto.valueOf : undefined;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if ((!eq(objValue, value) ||
        (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      return cloneableTags[tag]
        ? initCloneByTag(value, tag, isDeep)
        : (object ? value : {});
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  // Recursively populate clone (susceptible to call stack limits).
  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
    assignValue(result, key, baseClone(subValue, isDeep, customizer, key, value, stack));
  });
  return isArr ? result : copySymbols(value, result);
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object;
      object.prototype = undefined;
    }
    return result || {};
  };
}());

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a clone of `buffer`.
 *
 * @private
 * @param {ArrayBuffer} buffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneBuffer(buffer) {
  var Ctor = buffer.constructor,
      result = new Ctor(buffer.byteLength),
      view = new Uint8Array(result);

  view.set(new Uint8Array(buffer));
  return result;
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map) {
  var Ctor = map.constructor;
  return arrayReduce(mapToArray(map), addMapEntry, new Ctor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var Ctor = regexp.constructor,
      result = new Ctor(regexp.source, reFlags.exec(regexp));

  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set) {
  var Ctor = set.constructor;
  return arrayReduce(setToArray(set), addSetEntry, new Ctor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return Symbol ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = typedArray.buffer,
      Ctor = typedArray.constructor;

  return new Ctor(isDeep ? cloneBuffer(buffer) : buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object) {
  return copyObjectWith(source, props, object);
}

/**
 * This function is like `copyObject` except that it accepts a function to
 * customize copied values.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObjectWith(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index],
        newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Creates an array of the own symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = getOwnPropertySymbols || function() {
  return [];
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
  return objectToString.call(value);
}

// Fallback for IE 11 providing `toStringTag` values for maps and sets.
if ((Map && getTag(new Map) != mapTag) || (Set && getTag(new Set) != setTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : null,
        ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';

    if (ctorString) {
      if (ctorString == mapCtorString) {
        return mapTag;
      }
      if (ctorString == setCtorString) {
        return setTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  var Ctor = object.constructor;
  return baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value);
}

/**
 * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(funcToString.call(value));
  }
  return isObjectLike(value) &&
    (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
}

module.exports = clone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"lodash._arrayeach":77,"lodash._basefor":78,"lodash._stack":80,"lodash.keys":83}],83:[function(require,module,exports){
(function (global){
/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    stringTag = '[object String]';

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/** Used for built-in method references. */
var objectProto = global.Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var getPrototypeOf = Object.getPrototypeOf,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object.keys;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
  // that are composed entirely of index properties, return `false` for
  // `hasOwnProperty` checks of them.
  return hasOwnProperty.call(object, key) ||
    (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
}

/**
 * The base implementation of `_.keys` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @type Function
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  return nativeKeys(Object(object));
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  return (isLength(length) && (isArray(object) || isString(object) || isArguments(object)))
    ? baseTimes(length, String)
    : null;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null &&
    !(typeof value == 'function' && isFunction(value)) && isLength(getLength(value));
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  var isProto = isPrototype(object);
  if (!(isProto || isArrayLike(object))) {
    return baseKeys(object);
  }
  var indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (baseHas(object, key) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
(function (global){
/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `global`. */
var freeParseInt = parseInt;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args ? args.length : 0;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/** Used for built-in method references. */
var objectProto = global.Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3');
 * // => 3
 */
function toInteger(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  var remainder = value % 1;
  return value === value ? (remainder ? value - remainder : value) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3);
 * // => 3
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3');
 * // => 3
 */
function toNumber(value) {
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = rest;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],85:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":91,"./source-map/source-map-generator":92,"./source-map/source-node":93}],86:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":94,"amdefine":45}],87:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":88,"amdefine":45}],88:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":45}],89:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":45}],90:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":94,"amdefine":45}],91:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  SourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, SourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":86,"./base64-vlq":87,"./binary-search":89,"./util":94,"amdefine":45}],92:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":86,"./base64-vlq":87,"./mapping-list":90,"./util":94,"amdefine":45}],93:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":92,"./util":94,"amdefine":45}],94:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":45}],95:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./lib":96,"dup":46}],96:[function(require,module,exports){

module.exports = walker;

function walker(astNode, functionTable, offset) {
	function stop() { throw stop; }
	var recurse = function (astNode) {
		if (!astNode || typeof astNode !== 'object' || !astNode.type)
			return astNode;
		// range based recursion: only recurse when the astNode is in range
		if (offset !== undefined && astNode.range &&
		    (astNode.range[0] > offset || astNode.range[1] < offset))
			return astNode;
		
		var fn = functionTable[astNode.type] || functionTable.default || checkProps;
		return fn.call(astNode, recurse, stop);
	}
	var ret;
	try {
		ret = recurse(astNode);
	} catch (e) {
		if (e !== stop)
			throw e;
	}
	return ret;
}

function checkProps(recurse) {
	var self = this;
	var mapped = {};
	Object.keys(self).forEach(function (key) {
		var prop = self[key];
		var ret = prop;
		if (Array.isArray(prop))
			ret = prop.map(recurse);
		else
			ret = recurse(prop);
		mapped[key] = ret;
	});
	return mapped;
}

walker.checkProps = checkProps;

},{}],97:[function(require,module,exports){
"use strict";

var Scope = require("../utils/scope");
var annotate = require("../utils/annotate");
var tojavaScript = require("../utils/to_javascript");
var inference = require("./typeinference/typeinference");
var Types = require("../interfaces").TYPES;
var staticTransformer = require("./constants/staticTransformer");
var determineReturnType = require("./determine_return_type");
var insertBufferAccessors = require("./insert_buffer_accessors");
var TypeInfo = require("../type-system/typeinfo");
var esprima = require("esprima");

function Analyzer(context, options) {
    this._context = context;
    this._options = options;
}

Analyzer.prototype.injectMainFunction = function (name, injectParameters) {
    if (!this._context.getScope().declares(name))
        return;

    // First parameter is set as global _env object to be accessible form BRDFs
    // This is a big hack, need better injection mechanism
    if (injectParameters[0] && injectParameters[0].extra) {
        var envAnnotation = new TypeInfo(injectParameters[0].extra);
        this._context.getScope().declare("_env");
        this._context.getScope().updateTypeInfo("_env", envAnnotation);
        var properties = injectParameters[0].extra.properties;
        var self = this;
        Object.keys(properties).forEach(function (property) {
            var accessors = properties[property].accessors;
            var kind = properties[property].kind;
            if (accessors) {
                if (accessors.get) {
                    var name = property + "_get";
                    self._context.getScope().declare(name);
                    self._context.getScope().updateTypeInfo(name, new TypeInfo({
                        type: "function"
                    }));
                    var ast = esprima.parse(accessors.get).body[0];
                    var scopedName = self._context.getScope().getIdentifier(name);
                    var safeName = scopedName.replace(/\./g, '_');
                    ast.id.name = safeName;
                    self._context.addSpecializedFunction(name, {
                        ast: ast,
                        info: {
                            extra: {
                                type: "object",
                                kind: "Vec3"
                            },
                            newName: self._context.getSafeUniqueName(safeName)
                        }
                    });
                    accessors.get = name;
                    // var name = property + "_get";
                    // self._context.getScope().declare(name);
                    // self._context.getScope().updateTypeInfo(name, new TypeInfo({
                    //     type: "function"
                    // }));
                    // var ast = esprima.parse(accessors.get);
                    // self._context.addFunctionTemplate(self._context.getScope().getIdentifier(name), ast.body[0]);
                    // self.specializeFunction(name, [new TypeInfo({
                    //     type: "array",
                    //     elements: {
                    //         extra: {
                    //             type: "float"
                    //         }
                    //     }
                    // }), kind === "Texture" ? new TypeInfo({type: "object", kind: "Vec2"}) : new TypeInfo({
                    //     type: "int"
                    // })]);
                    // accessors.get = name;
                }
                if (accessors.set) {
                    var name = property + "_set";
                    self._context.getScope().declare(name);
                    self._context.getScope().updateTypeInfo(name, new TypeInfo({
                        type: "function"
                    }));
                    var ast = esprima.parse(accessors.set);
                    self._context.addFunctionTemplate(self._context.getScope().getIdentifier(name), ast.body[0]);
                    self.specializeFunction(name, [new TypeInfo({
                        type: "array",
                        elements: {
                            extra: {
                                type: "float"
                            }
                        }
                    }), new TypeInfo({
                        type: "int"
                    }), new TypeInfo(properties[property].elements.extra)]);
                    accessors.set = name;
                }
            }
        });
    }

    this._context.root.globalParameters[name] = injectParameters;
    this.specializeFunction(name, injectParameters.map(function (parameter) {
        return new TypeInfo(parameter.extra)
    }), name);
};

Analyzer.prototype.specializeFunction = function (name, parameters, uniqueName) {
    var scopedIdentifier = this._context.getScope().getIdentifier(name);
    var signature = this.createSignature(scopedIdentifier, parameters);

    if (this._context.hasSpecializedFunction(signature))
        return this._context.getSpecializedFunction(signature).info;

    if (this._context.hasFunctionTemplate(scopedIdentifier)) {
        var template = this._context.getFunctionTemplate(scopedIdentifier);
        var globalUniqueName = uniqueName || this._context.getSafeUniqueName(scopedIdentifier.replace(/\./g, '_'));
        var specializedFunction = {};
        var templateCopy = JSON.parse(JSON.stringify(template));
        specializedFunction.ast = this.analyzeFunction(templateCopy, parameters);
        specializedFunction.info = specializedFunction.ast.extra.returnInfo;
        specializedFunction.info.newName = specializedFunction.ast.id.name = globalUniqueName;
        this._context.addSpecializedFunction(signature, specializedFunction);
        return specializedFunction.info;
    }

    throw new Error("Could not resolve function " + name);
};

Analyzer.prototype.createSignature = function (functionName, parameters) {
    return parameters.reduce(function(signature, parameter) {
        return signature + parameter.getTypeString();
    }, functionName);
};

Analyzer.prototype.analyzeFunction = function (functionAst, parameterTypeInfos) {
    var functionScope
        = new Scope(functionAst, this._context.getScope(), {name: functionAst.id.name});
    var functionAnnotation = annotate(functionAst);

    functionAst.params.forEach(function (parameter, idx) {
        var annotation = annotate(parameter);
        if (idx < parameterTypeInfos.length) {
            annotation.copyFrom(parameterTypeInfos[idx]);
            annotation.setDynamicValue();
        } else {
            annotation.setType(Types.UNDEFINED);
        }
    });

    functionScope.declareParameters(functionAst.params);

    this._context.pushScope(functionScope);

    functionAst.body = this.analyzeAst(functionAst.body);
    functionAst.params = functionAst.params.filter(function (param) {
        var annotation = annotate(param);
        return !annotation.isUndefined();
    });

    functionAnnotation.setReturnInfo(determineReturnType(functionAst.body));
    this._context.popScope();

    return functionAst;
};

Analyzer.prototype.analyzeAst = function (ast) {
    ast = inference.infer(ast, this._context, this._options, this);

    // Remove/Replace dead code and static expressions
    ast = staticTransformer.transform(ast, this._options);
    //functionASt.body = extractCapturedVariables(functionASt.body, this._context, this._options);

    // ast = this._options.extractUniformExpressions ? uniformAnalysis.extract(ast, this._options) : ast;

    //fnAstNode.body = options.semanticAnalysis ? semantics(fnAstNode.body, options) : fnAstNode.body;
    ast = insertBufferAccessors(this._context, ast);
    return ast;
};

Analyzer.prototype.injectMemory = function (ast, memory) {
    var memAnnotation = new TypeInfo(memory.extra);
    this._context.getScope().declare("__mem");
    this._context.getScope().updateTypeInfo("__mem", memAnnotation);
    this._context.root.globalParameters["__mem"] = memory;

    var properties = memory.extra.properties;
    var self = this;
    Object.keys(properties).forEach(function (property) {
        var accessors = properties[property].accessors;
        if (accessors) {
            if (accessors.get) {
                var name = property + "_get";
                self._context.getScope().declare(name);
                self._context.getScope().updateTypeInfo(name, new TypeInfo({
                    type: "function"
                }));
                var ast = esprima.parse(accessors.get).body[0];
                var scopedName = self._context.getScope().getIdentifier(name);
                var safeName = scopedName.replace(/\./g, '_');
                ast.id.name = safeName;
                self._context.addSpecializedFunction(name, {
                    ast: ast,
                    info: {
                        extra: {
                            type: "object",
                            kind: "Vec3"
                        },
                        newName: self._context.getSafeUniqueName(safeName)
                    }
                });
                accessors.get = name;
            }
            if (accessors.set) {
                var name = property + "_set";
                self._context.getScope().declare(name);
                self._context.getScope().updateTypeInfo(name, new TypeInfo({
                    type: "function"
                }));
                var ast = esprima.parse(accessors.set).body[0];
                var scopedName = self._context.getScope().getIdentifier(name);
                var safeName = scopedName.replace(/\./g, '_');
                ast.id.name = safeName;
                self._context.addSpecializedFunction(name, {
                    ast: ast,
                    info: {
                        extra: {
                            type: "object",
                            kind: "Vec3"
                        },
                        newName: self._context.getSafeUniqueName(safeName)
                    }
                });
                accessors.set = name;
            }
        }
    });
    var self = this;
    ast.body = ast.body.map(function (ast) {
        if (ast.type === "FunctionDeclaration" && ast.id.name === "evaluate") {
            var functionScope
                = new Scope(ast, self._context.getScope(), {name: ast.id.name});
            self._context.pushScope(functionScope);
            ast.params[ast.params.length] = {
                type: "Identifier",
                name: "__mem",
                extra: memory.extra
            };
            ast.body = self.analyzeAst(ast.body);
            // ast.body = insertBufferAccessors(self._context, ast.body);
            self._context.popScope();
        }
        return ast;

    });

    return this._context.getResult();
};

exports = module.exports = Analyzer;


},{"../interfaces":188,"../type-system/typeinfo":203,"../utils/annotate":204,"../utils/scope":207,"../utils/to_javascript":209,"./constants/staticTransformer":99,"./determine_return_type":102,"./insert_buffer_accessors":107,"./typeinference/typeinference":132,"esprima":60}],98:[function(require,module,exports){
(function(ns){

    var Syntax = require('estraverse').Syntax,
        annotate = require("../../utils").annotate;
        Shade = require("../../interfaces.js");


    var UnaryFunctions = {
        "!": function(a) { return !a; },
        "-": function(a) { return -a; },
        "+": function(a) { return +a; },
        "typeof": function(a) { return typeof a; },
        "void": function(a) { return void a; },
        "delete": function(a) { return true; }

    };

    var BinaryFunctions = {
        "+" : function(a,b) { return a + b; },
        "-" : function(a,b) { return a - b; },
        "/" : function(a,b) { return a / b; },
        "*" : function(a,b) { return a * b; },
        "%" : function(a,b) { return a % b; },

        "==" : function(a,b) { return a == b; },
        "!=" : function(a,b) { return a != b; },
        "===" : function(a,b) { return a === b; },
        "!==" : function(a,b) { return a !== b; },
        "<" : function(a,b) { return a < b; },
        "<=" : function(a,b) { return a <= b; },
        ">" : function(a,b) { return a > b; },
        ">=" : function(a,b) { return a >= b; }
    };


    /**
     *
     * @param node
     */
    function getConstantValue(node) {
        if (node.type === Syntax.Literal) {
            var value = node.raw !== undefined ? node.raw : node.value;
            var number = parseFloat(value);
            if (!isNaN(number))
                return number;
            value = node.value;
            switch(value) {
                case "true": return true;
                case "false": return false;
                case "null": return null;
                default: return value;
            }
        }
        if (node.type == Syntax.MemberExpression || node.type == Syntax.CallExpression  || node.type == Syntax.Identifier || node.type == Syntax.NewExpression || node.type == Syntax.LogicalExpression) {
            return annotate(node).getConstantValue();
        }
        if (node.type === Syntax.UnaryExpression) {
            if (node.operator == "typeof") {
                return annotate(node).getTypeString();
            }
            if(UnaryFunctions.hasOwnProperty(node.operator)) {
                return UnaryFunctions[node.operator](getConstantValue(node.argument));
            }
            Shade.throwError(node, "Unknown unary operator: " + node.operator);
        }
        if (node.type === Syntax.BinaryExpression) {
            if(BinaryFunctions.hasOwnProperty(node.operator)) {
                return BinaryFunctions[node.operator](getConstantValue(node.left), getConstantValue(node.right));
            }
            Shade.throwError(node, "Unknown binary operator: " + node.operator);
        }
        Shade.throwError(node, "Evaluating static value for node type: " + node.type);
    };


    function getConstantTruthValue(node) {
        var aNode = annotate(node);

        // !!undefined == false;
        if (aNode.isNullOrUndefined())
            return false;
        // !!{} == true
        if (aNode.isObject() || this.isFunction())
            return true;
        // In all other cases, it depends on the value,
        // thus we can only evaluate this for static objects
        if (aNode.hasConstantValue()) {
            return !!aNode.getConstantValue();
        }
        return undefined;
    }

    exports.getConstantValue = getConstantValue;
    exports.getConstantTruthValue = getConstantTruthValue;



}(exports));

},{"../../interfaces.js":188,"../../utils":206,"estraverse":61}],99:[function(require,module,exports){
(function (ns) {

    var common = require("../../base/common.js"),
        Shade = require("../../interfaces.js"),
        Base = require("../../base/index.js"),
        estraverse = require('estraverse');

    // var codegen = require('escodegen');

    var Syntax = common.Syntax,
        TYPES = Shade.TYPES,
        ANNO = common.ANNO;


    /**
     * Transform AST: Eliminate branches due to static conditions
     * and performs constant folding
     * @param {Object} ast
     * @returns Object
     */
    var transform = ns.transform = function (ast, opt) {
        var transformer = new Transformer(opt);
        return transformer.transform(ast);
    }

    var Transformer = function(opt) {
        opt = opt || {};

        this.foldConstants = opt.foldConstants !== undefined ? opt.foldConstants : true;

        this.controller = new estraverse.Controller();
    };

    Transformer.prototype = {
        transform: function (ast) {
            var that = this;
            return this.controller.replace(ast, {
                enter: function (node, parent) {
                    var typeInfo = ANNO(node);
                    if (!typeInfo.isValid()) {
                        return;
                    }

                    switch (node.type) {
                        case Syntax.IfStatement:
                            return that.handleIfStatement(node);
                        case Syntax.ConditionalExpression:
                            return that.handleConditionalExpression(node);
                        case Syntax.LogicalExpression:
                            return that.handleLogicalExpression(node);
                        case Syntax.AssignmentExpression:
                            return that.handleAssignmentExpression(node);
                        case Syntax.VariableDeclarator:
                            return that.handleVariableDeclarator(node);
                        case Syntax.NewExpression:
                            //case Syntax.CallExpression:
                            return that.handleNewExpression(node);
                        case Syntax.VariableDeclaration:
                            return that.handleVariableDeclaration(node);

                    }

                    if(that.foldConstants && isExpression(node.type, parent.type)) {
                        return that.foldConstantExpression(node);
                    }
                }
            });
        },


        handleIfStatement: function (node) {
            var test = ANNO(node.test);

            if (test.hasConstantValue() || test.canObject()) {
                this.controller.skip();
                var staticValue = test.getStaticTruthValue();
                if (staticValue === true) {
                    return transform(node.consequent);
                }
                if (staticValue === false) {
                    if (node.alternate) {
                        return this.transform(node.alternate);
                    }
                    return {
                        type: Syntax.EmptyStatement
                    }
                }
            }
        },


        handleConditionalExpression: function (node) {
            var test = ANNO(node.test);

            if (test.hasConstantValue() || test.canObject()) {
                this.controller.skip();
                var staticValue = test.getStaticTruthValue();
                if (staticValue === true) {
                    return this.transform(node.consequent);
                } else {
                    return this.transform(node.alternate);
                }
            }
        },

        handleLogicalExpression: function (node) {
            var left = ANNO(node.left);
            var right = ANNO(node.right);
            var leftBool = left.getStaticTruthValue();
            var rightBool = right.getStaticTruthValue();

            if (node.operator === "||") {
                if (leftBool === false) {
                    return node.right;
                }
                if (leftBool === true) {
                    return node.left;
                }
                // Left is dynamic, let's check right
                if (rightBool === false) {
                    return node.left;
                }
            } else if (node.operator === "&&") {
                if (leftBool === false) {
                    return node.left;
                }
                if (leftBool === true) {
                    return node.right;
                }
                // Left is dynamic, let's check right
                if (rightBool === true) {
                    // Now the result type is always the one of the left value
                    return node.left;
                }
                if (rightBool === false) {
                    // Now the result must be false
                    return {
                        type: Syntax.Literal,
                        value: "false",
                        extra: { type: "boolean"}
                    };
                }
            }
        },

        handleAssignmentExpression: function (node) {
            node.right = this.foldConstantExpression(node.right);
            return node;
        },
        handleNewExpression: function (node) {
            var args = node.arguments, newArgs = [];
            args.forEach(function (arg) {
                var typeInfo = ANNO(arg);
                if (isSimpleStatic(typeInfo)) {
                    newArgs.push(generateLiteralFromTypeInfo(typeInfo))
                } else {
                    newArgs.push(arg);
                }
            });
            node.arguments = newArgs;
            return node;
        },

        handleVariableDeclaration: function (node) {
            var declarations = node.declarations, newDeclarations = [], that = this;
            declarations.forEach(function (declaration) {
                var typeInfo = ANNO(declaration);
                if (!typeInfo.isUndefined()) {
                    newDeclarations.push(declaration);
                }
            });
            if (!newDeclarations.length) {
                return {
                    type: Syntax.EmptyStatement
                }
            }
            node.declarations = newDeclarations;
            return node;
        },
        handleVariableDeclarator: function (node) {
            if (node.init) {
                node.init = this.foldConstantExpression(node.init);
                return node;
            }
        },
        foldConstantExpression: function (node) {
            var anno = ANNO(node);
            if (this.foldConstants) {
                if (isSimpleStatic(anno)) {
                    return generateLiteralFromTypeInfo(anno);
                } else if (isStaticObject(anno)) {
                    return generateConstructorFromTypeInfo(anno);
                }
            }
            return node;
        }


    };

    function isSimpleStatic(typeInfo) {
        return typeInfo.hasConstantValue() && !(typeInfo.isObject() || typeInfo.isNullOrUndefined());
    }

     function isStaticObject(typeInfo) {
        return typeInfo.hasConstantValue() && typeInfo.isVector();
    }

    var c_expressions = [Syntax.BinaryExpression, Syntax.UnaryExpression, Syntax.MemberExpression];
    var c_parentLiteralExpressions = [Syntax.BinaryExpression, Syntax.ReturnStatement, Syntax.CallExpression];


    function isExpression(type, parentType) {
        if(type === Syntax.Identifier) {
            return c_parentLiteralExpressions.indexOf(parentType) !== -1;
        }
        return c_expressions.indexOf(type) !== -1;
    }


    function generateConstructorFromTypeInfo(typeInfo) {
        var value = typeInfo.getConstantValue(), size, name, arguments = [];
        switch(typeInfo.getKind()) {
            case "Vec2": size = 2; name = "Vec2"; break;
            case "Vec3": size = 3; name = "Vec3"; break;
            case "Vec4": size = 4; name = "Vec4"; break;
            default:
                throw new Error("Internal error in static transformation. Unknown kind: " + typeInfo.getKind());
        }


        for(var i = 0; i < size; ++i) {
            arguments.push(generateFloatLiteralFromValue(value.data[i]));
        }

        var result = {
            type: Syntax.NewExpression,
            callee: {
                type: Syntax.Identifier,
                name: name
            },
            arguments: arguments
        }
        ANNO(result).copyFrom(typeInfo);
        return result;
    }

    function generateFloatLiteralFromValue(value) {
        var needsSign = value < 0;

        var literal = { type: Syntax.Literal, value: needsSign ? -value : value };
        ANNO(literal).setType(Shade.TYPES.NUMBER);

        if (!needsSign)
            return literal;

        var expression = {
                type: Syntax.UnaryExpression,
                operator: "-",
                argument: literal
        }
        ANNO(expression).setType(Shade.TYPES.NUMBER);
        return expression;
    }

    function generateLiteralFromTypeInfo(typeInfo) {
        var value = typeInfo.getConstantValue();
        var isNegative = value < 0;

        var result = {
            type: Syntax.Literal,
            value: isNegative ? -value : value
        };
		var ti = ANNO(result);
		ti.copyFrom(typeInfo);

        if(isNegative) {
            result.extra.constantValue = -value;
            result = {
                type: Syntax.UnaryExpression,
                operator: "-",
                argument: result
            }
            ti = ANNO(result);
			ti.copyFrom(typeInfo);
        }
        return result;
    }









}(exports));

},{"../../base/common.js":140,"../../base/index.js":142,"../../interfaces.js":188,"estraverse":61}],100:[function(require,module,exports){
"use strict";

var util = require("util");

var Context = require("../base/context.js");
var common = require("../base/common.js");
var assert = require("assert");
var walk = require('estraverse');
var Shade = require("../interfaces.js");

// Shortcuts
var Syntax = common.Syntax;
var annotate = require("../utils/").annotate;

function AnalysisContext(program, options) {
	Context.call(this, program, options);

	assert.equal(program.type, Syntax.Program);

	this.root.globalParameters = {};
	this._functionTemplates = new Map();
	this._specializedFunctions = new Map();
	this.constants = null;
}

util.inherits(AnalysisContext, Context);

AnalysisContext.prototype.getFunctionTemplate = function (name) {
	return this._functionTemplates.get(name);
};

AnalysisContext.prototype.addFunctionTemplate = function (name, node) {
	this._functionTemplates.set(name, node);
};

AnalysisContext.prototype.hasFunctionTemplate = function (name) {
	return this._functionTemplates.has(name);
};

AnalysisContext.prototype.getSpecializedFunction = function (signature) {
	return this._specializedFunctions.get(signature);
};

AnalysisContext.prototype.addSpecializedFunction = function (signature, specializedFunction) {
	this._specializedFunctions.set(signature, specializedFunction);
};

AnalysisContext.prototype.hasSpecializedFunction = function (signature) {
	return this._specializedFunctions.has(signature);
};

AnalysisContext.prototype.getTypeInfo = function(node) {
	return common.getTypeInfo(node, this.getScope(), this.constants, true);
};

AnalysisContext.prototype.setConstants = function(c) {
	this.constants = c;
};

AnalysisContext.prototype.getResult = function() {
	// (Re-)add derived function to the program
	addDerivedMethods(this.root, this);
	return this.root;
};

AnalysisContext.prototype.declare = function(ast, inDeclaration) {
	var scope = this.getScope(), context = this;
	if (ast.type == Syntax.VariableDeclaration) {
		var declarations = ast.declarations;
		declarations.forEach(function(declaration) {
			var result = annotate(declaration);

			if (declaration.id.type != Syntax.Identifier) {
				throw new Error("Dynamic variable names are not yet supported");
			}
			var variableName = declaration.id.name;
			scope.declare(variableName, true, declaration);

			if (declaration.init) {
				var init = annotate(declaration.init);
				scope.updateTypeInfo(variableName, init, declaration);
				if (declaration.init.type == Syntax.AssignmentExpression) {
					context.declare(declaration.init, true);
				}
			} else {
				result.setType(Shade.TYPES.UNDEFINED);
			}
		})
	} else if (ast.type == Syntax.AssignmentExpression && inDeclaration) {
		var typeInfo = annotate(ast.right);

		if (ast.left.type != Syntax.Identifier) {
			throw new Error("Dynamic variable names are not yet supported");
		}
		var variableName = ast.left.name;
		scope.declare(variableName, true, annotate(ast));
		scope.updateTypeInfo(variableName, typeInfo, ast);
		if (ast.right.type == Syntax.AssignmentExpression) {
			context.declare(ast.right, true);
		}
	}
	return true;
};

function addDerivedMethods(program, context) {
	context._specializedFunctions.forEach(function (specializedFunction) {
		program.body.push(specializedFunction.ast);
	});

	walk.traverse(program, {
		enter: function(node) {
			if (node.type == Syntax.CallExpression) {
				if (node.extra && node.extra.newName) {
					node.callee.name = node.extra.newName;
				}
			}
		}
	});
}

exports = module.exports = AnalysisContext;

},{"../base/common.js":140,"../base/context.js":141,"../interfaces.js":188,"../utils/":206,"assert":25,"estraverse":61,"util":42}],101:[function(require,module,exports){
"use strict";

var Scope = require("../utils/scope");
var TypeSystem = require("../type-system/type-system.js");

exports = module.exports = function (ast) {
    var globalScope = new Scope(ast, null, {name: "global"});
    globalScope.declarePredefined("Math",
        TypeSystem.getPredefinedObject("Math"));
    globalScope.declarePredefined("Vec2",
        TypeSystem.getPredefinedObject("Vec2"));
    globalScope.declarePredefined("Vec3",
        TypeSystem.getPredefinedObject("Vec3"));
    globalScope.declarePredefined("Vec4",
        TypeSystem.getPredefinedObject("Vec4"));
    globalScope.declarePredefined("Mat3",
        TypeSystem.getPredefinedObject("Mat3"));
    globalScope.declarePredefined("Mat4",
        TypeSystem.getPredefinedObject("Mat4"));
    globalScope.declarePredefined("this",
        TypeSystem.getPredefinedObject("System"));
    globalScope.declarePredefined("Space",
        TypeSystem.getPredefinedObject("Space"));
    globalScope.declarePredefined("Object",
        TypeSystem.getPredefinedObject("Object"));
    globalScope.declarePredefined("Shade",
        TypeSystem.getPredefinedObject("Shade"));
    globalScope.declarePredefined("Array",
        TypeSystem.getPredefinedObject("Array"));
    globalScope.declarePredefined("Texture",
        TypeSystem.getPredefinedObject("Texture"));
    return globalScope;
};

},{"../type-system/type-system.js":202,"../utils/scope":207}],102:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var Types = require("../interfaces").TYPES;

function determineReturnType(func, opt) {
    var returnType = {
        type: Types.UNDEFINED
    };
    estraverse.traverse(func, {
        enter: function (node) {
            if (node.type === Syntax.ReturnStatement) {
                if (returnType.type !== Types.UNDEFINED)
                    throwIfNotSameType(node.argument.extra, returnType);
                else
                    returnType = node.argument.extra;
            }
        }
    });
    return returnType;
}

function throwIfNotSameType(actual, expected) {
    if (actual.type !== expected.type || actual.kind !== expected.kind)
        throw new Error("Return statements with different types are not supported!");

    if (actual.type === Types.Object) {
        Object.keys(actual.properties).forEach(function (prop) {
            throwIfNotSameType(actual.properties[prop], expected.properties[prop]);
        });
    }
}

exports = module.exports = function (program, opt) {
    return determineReturnType(program);
};

},{"../interfaces":188,"estraverse":61}],103:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var esgraph = require("esgraph");

var worklist = require("analyses");
var Set = worklist.Set;

var slicer = require("./slicer");
var Types = require("../interfaces").TYPES;
var utils = require("../utils");

function extractAllocationsInProgram(program) {
    var allocations = new Set();
    estraverse.traverse(program, {
        enter: function (node) {
            if (node.type === Syntax.FunctionDeclaration) {
                var localAllocations = extractAllocations(node, findAllocationsInFunction(node));
                allocations = Set.union(allocations, localAllocations);
            }
        }
    });

    return {
        ast: program,
        allocations: allocations
    }
}

function findAllocationsInFunction(node) {
    var allocations = new Set();
    var cfg = esgraph(node.body, {omitExceptions: true});
    cfg[2].forEach(function (cfgNode, idx) {
        if (cfgNode.type || !cfgNode.astNode)
            return;
        estraverse.traverse(cfgNode.astNode, {
            enter: function (astNode) {
                if (astNode.type === Syntax.AssignmentExpression) {
                    if (astNode.right.type === Syntax.NewExpression) {
                        if (astNode.right.callee.name === "Array") {
                            if (astNode.left.type === Syntax.Identifier)
                                allocations.add({
                                    cfgIndex: idx,
                                    astNode: astNode,
                                    varName: astNode.left.name,
                                    elementTypeInfo: JSON.parse(JSON.stringify(utils.annotate(astNode).getArrayElementType()))
                                });
                            if (astNode.left.computed) {
                                var node = astNode.left;
                                while (node.computed)
                                    node = node.object;
                                var allocation = allocations.values().find(function (allocation) {
                                    return allocation.varName === node.name;
                                });
                                node = astNode.left;
                                var subarrayInfo = allocation.elementTypeInfo;
                                while (node.computed) {
                                    subarrayInfo = subarrayInfo.extra.elements;
                                    node = node.object;
                                }
                                subarrayInfo.extra.astNode = astNode;
                            }
                        }
                        if (astNode.right.callee.name === "Texture") {
                            if (astNode.left.type === Syntax.Identifier)
                                allocations.add({
                                    cfgIndex: idx,
                                    astNode: astNode,
                                    varName: astNode.left.name,
                                    isTexture: true
                                });
                        }
                    }
                }
            }
        });
    });
    return allocations;
}

function extractAllocations(node, allocations) {
    var scope = new utils.Scope(node);
    return allocations.map(function (allocation) {
        var astCopy = JSON.parse(JSON.stringify(node));
        var cfg = esgraph(astCopy.body, {omitExceptions: true});
        var relevantNodes = slicer.slice(cfg, cfg[2][allocation.cfgIndex], allocation.varName);
        cfg[2].forEach(function (node) {
            if (node.type || !node.astNode)
                return;

            node.astNode._relevant = relevantNodes.has(node);
        });

        estraverse.replace(cfg[0].astNode, {
            enter: function (astNode, parent) {
                if (astNode.test && astNode.test._relevant === false)
                    this.remove();

                if (astNode.type === Syntax.ExpressionStatement
                    && astNode.expression._relevant === false)
                    this.remove();

                if (astNode._relevant === false)
                    this.remove();

                if (astNode === cfg[2][allocation.cfgIndex].astNode) {
                    if (utils.annotate(astNode).isTexture())
                        return {
                            type: Syntax.ReturnStatement,
                            argument: {
                                type: Syntax.ArrayExpression,
                                elements: astNode.right.arguments
                            }
                        };
                    return {
                        type: Syntax.ReturnStatement,
                        argument: astNode.right.arguments[0]
                    };
                }
            }
        });

        estraverse.replace(node, {
            enter: function (node) {
                if (node === allocation.astNode) {
                    if (node.right.type === Syntax.NewExpression) {
                        if (node.right.callee.name === "Array" || node.right.callee.name === "Texture") {
                            var propertyName = scope.getIdentifier(allocation.varName).replace(/\./g, '_');
                            var result = {
                                type: Syntax.MemberExpression,
                                object: {
                                    type: Syntax.Identifier,
                                    name: "__mem"
                                },
                                property: {
                                    type: Syntax.Identifier,
                                    name: propertyName
                                }
                            };
                            var anno = utils.annotate(result);
                            anno.setType(Types.OBJECT);
                            anno.setProperties({});
                            anno.setProperty(propertyName, utils.annotate(node.right).info);
                            node.right = result;
                            return node;
                        }
                    }
                }
            }
        });

        var envParamName = node.params.find(function (param) {
            if (param.extra.global)
                return true;
        });

        var extractParameters = require("./extract_parameters");

        // this is soooo bad! but necessary because extractParameters requires a program not a function due to global scope bs.
        var fakeProgram = {
            body: [astCopy],
            type: "Program"
        };

        return {
            propertyName: scope.getIdentifier(allocation.varName).replace(/\./g, '_'),
            elements: allocation.elementTypeInfo,
            isTexture: allocation.isTexture,
            dependencies: extractParameters(fakeProgram, {entry: astCopy.id.name}).shaderParameters,
            size: new Function(envParamName.name, utils.toJavaScript(astCopy.body))
        };
    });
}

exports = module.exports = function (program, opt) {
    opt = opt || {};
    return extractAllocationsInProgram(program);
};

},{"../interfaces":188,"../utils":206,"./extract_parameters":105,"./slicer":114,"analyses":46,"esgraph":58,"estraverse":61}],104:[function(require,module,exports){
"use strict";

var walk = require("estraverse");
var Syntax = walk.Syntax;

var annotate = require("../utils/annotate");
var Scope = require("../utils/scope");

// todo: I don't like using the context's scope stack here!
module.exports = exports = function(prg, context) {
    context.addFunctionTemplate("global", prg);
    function extractFunctions(ast) {
        walk.replace(ast, {
            enter: function(node) {
                if (node.type == Syntax.FunctionDeclaration
                    || node.type == Syntax.FunctionExpression) {
                    node.id = node.id || {
                            name: context.getSafeUniqueName("anonymousFunction")
                        };
                    var localName = node.id.name;
                    var parentScope = context.getScope();
                    var annotation = annotate(node);
                    annotation.setType(Shade.TYPES.FUNCTION);
                    annotation.setFunctionName(localName);
                    parentScope.declare(localName);
                    parentScope.updateTypeInfo(localName, annotation);

                    var newScope
                        = new Scope(node, parentScope, {name: localName});
                    context.addFunctionTemplate(newScope.toString(), node);
                    context.pushScope(newScope);
                    extractFunctions(node.body);
                }
            },
            leave: function(node) {
                if (node.type == Syntax.FunctionDeclaration) {
                    context.popScope();
                    return {type: Syntax.EmptyStatement};
                }

                if (node.type == Syntax.FunctionExpression) {
                    context.popScope();
                    return {type: Syntax.Identifier, name: node.id.name};
                }
            }
        });
        ast.body = ast.body.filter(function(a) {
            return a.type != Syntax.EmptyStatement;
        });
    }

    extractFunctions(prg);
};


},{"../utils/annotate":204,"../utils/scope":207,"estraverse":61}],105:[function(require,module,exports){
"use strict";

var walk = require('estraverse');
var Scope = require("./../utils/scope.js");
var Syntax = walk.Syntax;

var derivedSystemParameters = {
    normalizedCoords: ["coords"],
    height: ["coords"],
    width: ["coords"]
};

function merge(result, other) {
    var i, param;
    for (var container in result) {
        for(i = 0; i < other[container].length; i++) {
            param = other[container][i];
            if (result[container].indexOf(param) == -1) {
                result[container].push(param);
            }
        }
    }
}

function addSystemParameter(parameterName, container, parameterMap) {
    // Is parameter already in container?
    if (container.indexOf(parameterName) != -1)
        return;

    if (parameterMap && parameterMap.hasOwnProperty(parameterName)) {
        var requiredParameters = parameterMap[parameterName];
        requiredParameters.forEach(function (param) {
            addSystemParameter(param, container, parameterMap);
        });
        return;
    }
    container.push(parameterName);
}

var findParametersInFunction = function (functionName, program, environmentObjectPosition, analyzedCalls) {
    var scope = new Scope(program, null, {name: "global"});
    var scopeStack = [scope];

    var result = {
        shaderParameters: [],
        systemParameters: []
    };
    analyzedCalls = analyzedCalls || {};

    var activeParam = null;

    var controller = new walk.Controller();
    controller.traverse(program, {
        enter: function (node) {
            var scope;
            switch (node.type) {
                case Syntax.FunctionDeclaration:
                    var parentScope = scopeStack[scopeStack.length - 1];
                    parentScope.declare(node.id.name, false);
                    scope = new Scope(node, parentScope, {name: node.id.name });
                    scopeStack.push(scope);
                    if (parentScope.getIdentifier(node.id.name) === functionName) {
                        if (environmentObjectPosition !== -1 && node.params.length > environmentObjectPosition)
                            activeParam = node.params[environmentObjectPosition].name;
                    }
                    else {
                        if (!activeParam)
                            this.skip()
                    }
                    break;
                case Syntax.CallExpression:
                    var pos = node.arguments.reduce(function (prev, curr, index) {
                        if (curr.name && curr.name == activeParam)
                            return index;
                        return prev;
                    }, -1);
                    scope = scopeStack[scopeStack.length - 1];
                    var id = scope.getIdentifier(node.callee.name);
                    if (id && !analyzedCalls[id]) {
                        analyzedCalls[id] = true;
                        merge(result, findParametersInFunction(id, program, pos, analyzedCalls));
                    }
                    break;
                default:
            }
        },
        leave: function (node) {
            var type = node.type;
            switch (type) {
                case Syntax.FunctionDeclaration:
                    scopeStack.pop();
                    var parentScope = scopeStack[scopeStack.length - 1];
                    if (parentScope.getIdentifier(node.id.name) === functionName) {
                        activeParam = null;
                    }
                    break;
                case Syntax.MemberExpression:
                    var parameterName = node.property.name;
                    // In a specific parameter of the current method
                    if (activeParam && node.object.name == activeParam) {
                        addSystemParameter(parameterName, result.shaderParameters);
                    } // In 'this' is a system parameter
                    else if (node.object.type == Syntax.ThisExpression) {
                        addSystemParameter(parameterName, result.systemParameters, derivedSystemParameters);
                    } // In global variable '_env'
                    else if (node.object.name == "_env") {
                        addSystemParameter(parameterName, result.shaderParameters);
                    }
                    break;
            }
        }
    });

    return result;
};

exports = module.exports = function (program, opt) {
    opt = opt || {};
    var functionName = opt.entry ? "global." + opt.entry : "global.shade";
    var parameterPosition = opt.param || 0;

    return findParametersInFunction(functionName, program, parameterPosition);
};

},{"./../utils/scope.js":207,"estraverse":61}],106:[function(require,module,exports){
"use strict";

var sanitizer = require("./sanitizer/sanitizer.js");
var Analyzer = require("./analyzer");
var validate = require("./validation");

var resolver = require("../resolve/resolve.js");
var uniformAnalysis = require("./uniformExpressions/uniformAnalysis.js");
var AnalysisContext = require("./context.js");
var spaceTransformer
	= require("../generate/space/transform.js").SpaceTransformer;
var walk = require('estraverse');
var Syntax = walk.Syntax;
var resolve = require("./require/resolver");
var toJavaScript = require("../utils/to_javascript");

var extractFunctionTemplates = require("./extract_function_templates");
var createGlobalScope = require("./create_global_scope");

exports.analyze = function(ast, processingData, options) {
	options = options || {};
	processingData = processingData || {};

	ast = options.sanitize ? sanitizer.sanitize(ast, options) : ast;
	ast = resolve(ast);

	var context = new AnalysisContext(ast, options);
	context.pushScope(createGlobalScope(ast));
	extractFunctionTemplates(ast, context);
	var analyzer = new Analyzer(context, options);
	analyzer.analyzeAst(ast);

	if (options.entry)
		analyzer.injectMainFunction(
			options.entry,
			(options.inject && options.inject[options.entry]) || []);

	ast = context.getResult();

	if (options.extractAllocations) {
		var extractAllocations = require("./extract_allocations");
		var result = extractAllocations(ast);
		ast = result.ast;
		processingData.allocations = result.allocations;
	}
	
	// ast = options.implementation ?
	// 	resolver.resolveClosuresPostTypeInference(ast, options.implementation,
	// 		processingData, options) : ast;
    //

	// check for remaining code the completeness of annotations
	if (options.validate)
		validate(ast);

	if (options.transformSpaces)
		processingData.spaceInfo = spaceTransformer.transformAast(ast, options);

	return ast;
};

exports.injectMemory = function (ast, mem, options) {
	var context = new AnalysisContext(ast, options);
	context.pushScope(createGlobalScope(ast));
	// extractFunctionTemplates(ast, context);
	var analyzer = new Analyzer(context, options);
	// analyzer.analyzeAst(ast);
	// analyzer.injectMainFunction(
	// 	options.entry,
		// (options.inject && options.inject[options.entry]) || []);
	return analyzer.injectMemory(ast, mem);
};
},{"../generate/space/transform.js":181,"../resolve/resolve.js":193,"../utils/to_javascript":209,"./analyzer":97,"./context.js":100,"./create_global_scope":101,"./extract_allocations":103,"./extract_function_templates":104,"./require/resolver":108,"./sanitizer/sanitizer.js":111,"./uniformExpressions/uniformAnalysis.js":134,"./validation":139,"estraverse":61}],107:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var ANNO = require("../utils/annotate");
var TypeInfo = require("../type-system/typeinfo");

exports = module.exports = function (context, ast) {
    return estraverse.replace(ast, {
        enter: function (parent) {
            var replacementNode = null;
            if (parent.type === Syntax.AssignmentExpression && parent.left.type === Syntax.MemberExpression) {
                var resultType = context.getTypeInfo(parent);
                estraverse.traverse(parent.left, {
                    leave: function (node) {
                        if (node.type === Syntax.MemberExpression) {
                            var objectAnnotation = context.getTypeInfo(node.object);
                            if (objectAnnotation.isArray()) {
                                estraverse.traverse(node, {
                                    leave: function (node) {
                                        var objectAnnotation = context.getTypeInfo(node.object);
                                        if (node.type === Syntax.MemberExpression && node.computed === true) {
                                            if (objectAnnotation.info.accessors && objectAnnotation.info.accessors.set) {
                                                var name = context.getScope().getIdentifier(objectAnnotation.info.accessors.set).replace(/\./g, '_');
                                                replacementNode = {
                                                    type: Syntax.CallExpression,
                                                    callee: {
                                                        type: Syntax.Identifier,
                                                        name: name
                                                    },
                                                    arguments: [node.object],
                                                    setter: true,
                                                    extra: resultType.info
                                                };
                                            }
                                            if (replacementNode)
                                                replacementNode.arguments.push(node.property);
                                        }
                                    }
                                });
                                if (replacementNode)
                                    replacementNode.arguments.push(parent.right);
                            }
                        }
                        this.skip();
                    }
                });
                if (replacementNode) {
                    this.skip();
                    return replacementNode;
                }
            } else {
                if (parent.type === Syntax.CallExpression && parent.callee.type === Syntax.MemberExpression) {
                    var objectAnnotation = context.getTypeInfo(parent.callee.object);
                    if (objectAnnotation.isTexture() && objectAnnotation.info.accessors && objectAnnotation.info.accessors.get) {
                        var name = context.getScope().getIdentifier(objectAnnotation.info.accessors.get).replace(/\./g, '_');
                        var resultType = context.getTypeInfo(parent);
                        replacementNode = {
                            type: Syntax.CallExpression,
                            callee: {
                                type: Syntax.Identifier,
                                name: name
                            },
                            getter: true,
                            arguments: [parent.callee.object, parent.arguments[0]],
                            extra: resultType.info
                        };
                    }

                } else {
                    var objectAnnotation = context.getTypeInfo(parent.object);
                    if (parent.type === Syntax.MemberExpression && objectAnnotation.isArray()) {
                        var resultType = context.getTypeInfo(parent);
                        var replacementNode = null;
                        estraverse.traverse(parent, {
                            leave: function (node) {
                                if (node.type === Syntax.MemberExpression) {
                                    if (objectAnnotation.isArray()) {
                                        estraverse.traverse(node, {
                                            leave: function (node) {
                                                var objectAnnotation = context.getTypeInfo(node.object);
                                                if (node.type === Syntax.MemberExpression && node.computed === true) {
                                                    if (objectAnnotation.info.accessors && objectAnnotation.info.accessors.get) {
                                                        var name = context.getScope().getIdentifier(objectAnnotation.info.accessors.get).replace(/\./g, '_');
                                                        replacementNode = {
                                                            type: Syntax.CallExpression,
                                                            callee: {
                                                                type: Syntax.Identifier,
                                                                name: name
                                                            },
                                                            getter: true,
                                                            arguments: [node.object, node.property],
                                                            extra: resultType.info
                                                        };
                                                    }
                                                    if (replacementNode)
                                                        replacementNode.arguments.push(node.property);
                                                }
                                            }
                                        });
                                    }
                                }
                                this.skip();
                            }
                        });
                    }
                }
                if (replacementNode) {
                    this.skip();
                    return replacementNode;
                }
            }
        }
    });
};
},{"../type-system/typeinfo":203,"../utils/annotate":204,"estraverse":61}],108:[function(require,module,exports){
"use strict";

var traverse = require("estraverse");
var esprima = require("esprima");
var Syntax = traverse.Syntax;

var PluginRegistry = require("../../plugin_registry");

exports = module.exports = function (program) {
    var moduleAstMap = resolveRequireCalls(program);
    injectModules(program, moduleAstMap);
    replaceAssignments(program);
    return program;
};

function resolveRequireCalls(ast, moduleMap) {
    var moduleAstMap = new Map();
    traverse.traverse(ast, {
        enter: function (node) {
            if (node.type === Syntax.CallExpression
                && node.callee.name === "require") {
                // todo: check this !
                var name = node.arguments[0].value;
                if (moduleAstMap.has(name))
                    return;
                var code = PluginRegistry.getModule(name);
                var moduleAst = parseModule(name, code);
                moduleAstMap.set(name, moduleAst);
                resolveRequireCalls(moduleAst, moduleAstMap, moduleMap);
            }
        }
    });
    return moduleAstMap;
}

function injectModules(program, moduleAstMap) {
    var variableDeclarations = {
        type: Syntax.VariableDeclaration,
        declarations: [],
        kind: "var"
    };
    moduleAstMap.forEach(function (ast, name) {
        variableDeclarations.declarations.push({
            type: Syntax.VariableDeclarator,
            id: {
                type: Syntax.Identifier,
                name: name + "_" + "exports"
            },
            init: {
                type: Syntax.ObjectExpression,
                properties: []
            }
        });
        ast.body.forEach(function (ast) {
            program.body.push(ast);
        });
    });
    if (variableDeclarations.declarations.length > 0)
        program.body.unshift(variableDeclarations);
}

function replaceAssignments(program) {
    traverse.replace(program, {
        enter: function(node) {
            if (node.type === Syntax.ExpressionStatement) {
                if (node.expression.type === Syntax.AssignmentExpression) {
                    node = node.expression;
                    if (node.right.type === Syntax.CallExpression
                        && node.right.callee.name === "require") {
                        var name = node.right.arguments[0].value;

                        return {
                           type: Syntax.ExpressionStatement,
                            expression: {
                                type: Syntax.AssignmentExpression,
                                operator: "=",
                                left: {
                                    type: Syntax.Identifier,
                                    name: node.left.name
                                },
                                right: {
                                    type: Syntax.Identifier,
                                    name: name + "_" + "exports"
                                }
                            }
                        };
                    }
                }
            }
        }
    });
}

function parseModule(name, source) {
    var fnMap = new Map();
    var ast = esprima.parse(source);
    traverse.traverse(ast, {
        enter: function(node) {
            if (node.type === Syntax.FunctionDeclaration) {
                var newName = name + "_" + node.id.name;
                fnMap.set(node.id.name, newName);
                node.id.name = newName;
            }
            if (node.type === Syntax.Identifier && node.name === "exports") {
                node.name = name + "_" + "exports";
            }
        }
    });

    traverse.traverse(ast, {
        enter: function(node) {
            if (node.type === Syntax.CallExpression && fnMap.has(node.callee.name)) {
                node.callee.name = fnMap.get(node.callee.name);
            }
        }
    });
    return ast;
}

},{"../../plugin_registry":189,"esprima":60,"estraverse":61}],109:[function(require,module,exports){
"use strict";

var walk = require("estraverse");
var Syntax = walk.Syntax;

function DeclarationSimplifier() {
    this.declarationStack = [];
}

DeclarationSimplifier.prototype.execute = function(root) {
    var self = this;
    walk.replace(
        root,
        {
            enter: function (node) {
                switch (node.type) {
                    case Syntax.FunctionExpression:
                    case Syntax.FunctionDeclaration:
                    case Syntax.Program:
                        self.declarationStack.push([]);
                        break;
                    case Syntax.VariableDeclarator:
                        self.addDeclaredIdentifier(node.id.name);
                        break;
                }
            },
            leave: function (node, parent) {
                switch (node.type) {
                    case Syntax.FunctionExpression:
                    case Syntax.FunctionDeclaration:
                    case Syntax.Program:
                        return self.addTopDeclaration(node, parent);
                        break;
                    case Syntax.VariableDeclaration:
                        return self.removeMidCodeDeclaration(node, parent);
                        break;
                }
            }
        });
    return root;
};

DeclarationSimplifier.prototype.addDeclaredIdentifier = function(name) {
    var topStack = this.declarationStack[this.declarationStack.length - 1];
    if (topStack.indexOf(name) === -1)
        topStack.push(name);
};

DeclarationSimplifier.prototype.addTopDeclaration = function(node) {
    var declarations = this.declarationStack.pop();

    if (declarations.length === 0)
        return node;

    var declarationStatement
        = {type: Syntax.VariableDeclaration, declarations: [], kind: "var"};

    declarations.forEach(function (declaration) {
        declarationStatement.declarations.push({
            type: Syntax.VariableDeclarator,
            id: {type: Syntax.Identifier, name: declaration},
            init: null
        })
    });

    if (node.type == Syntax.Program)
        node.body.unshift(declarationStatement);
    else if (node.body.body)
        node.body.body.unshift(declarationStatement);
    return node;
};

DeclarationSimplifier.prototype.removeMidCodeDeclaration = function(node,
                                                                    parent) {
    var newNode;
    var isForInit = (parent.type === Syntax.ForStatement && parent.init === node);
    if (isForInit)
        newNode
            = {type: Syntax.SequenceExpression, expressions: [], loc: node.loc};
    else
        newNode = {type: Syntax.BlockStatement, body: [], loc: node.loc};

    node.declarations.forEach(function (declaration) {
        if (!declaration.init)
            return;

        var expression = {
            type: Syntax.AssignmentExpression,
            operator: "=",
            left: declaration.id,
            right: declaration.init,
            loc: declaration.loc
        };

        if (isForInit) {
            newNode.expressions.push(expression);
        }
        else {
            var statement = {
                type: Syntax.ExpressionStatement,
                expression: expression,
                loc: declaration.loc
            };
            newNode.body.push(statement);
        }
    });

    if (isForInit && newNode.expressions.length == 1)
        return newNode.expressions[0];

    return newNode;
};

exports = module.exports = DeclarationSimplifier;

},{"estraverse":61}],110:[function(require,module,exports){
"use strict";

var walk = require("estraverse");
var Syntax = walk.Syntax;

function RedundantBlocksRemover() {}

RedundantBlocksRemover.prototype.execute = function(root) {
    var self = this;
    walk.replace(
        root,
        {
            leave: function (node, parent) {
                switch (node.type) {
                    case Syntax.FunctionExpression:
                    case Syntax.FunctionDeclaration:
                    case Syntax.Program:
                    case Syntax.BlockStatement:
                        return self.removeRedundantBlocks(node);
                        break;
                }
            }
        });
    return root;
};

RedundantBlocksRemover.prototype.removeRedundantBlocks = function (node) {
    if (Array.isArray(node.body))
        node.body = node.body.map(function (node) {
            if(node.type == Syntax.BlockStatement)
                return node.body;
            return node;
        }).reduce(function (result, b) {
            if (Array.isArray(b))
                result.push.apply(result, b);
            else
                result.push(b);
            return result;
        }, []);

    return node;
};

exports = module.exports = RedundantBlocksRemover;

},{"estraverse":61}],111:[function(require,module,exports){
"use strict";

var assert = require("assert");

var DeclarationSimplifier = require("./declaration_simplifier");
var StatementSimplefier = require("./statement_simplifier");
var RedundantBlocksRemover  = require("./redundant_blocks_remover");

exports.sanitize = function(ast, opt) {
	var declarationSimplifier = new DeclarationSimplifier();
	var statementSimplifier = new StatementSimplefier();
	var redundantBlocksRemover = new RedundantBlocksRemover();
	ast = declarationSimplifier.execute(ast);
	ast = statementSimplifier.execute(ast);
	ast = redundantBlocksRemover.execute(ast);
	return ast;
};

},{"./declaration_simplifier":109,"./redundant_blocks_remover":110,"./statement_simplifier":112,"assert":25}],112:[function(require,module,exports){
"use strict";

var util = require("util");

var walk = require("estraverse");
var Syntax = walk.Syntax;
var VisitorOption = walk.VisitorOption;

var StatementSplitTraverser = require("./statement_split_traverser");

function StatementSimplifier() {
    StatementSplitTraverser.call(this);
	this.skipExtraction.forInitUpdate = true;
	this.statementIdentifierInfo = {};
}

util.inherits(StatementSimplifier, StatementSplitTraverser);

StatementSimplifier.prototype.onGatherSplitInfo = function() {
	this.statementIdentifierInfo = {};
};

StatementSimplifier.prototype.statementSplitEnter = function(node, parent) {
	switch (node.type) {
	case Syntax.FunctionExpression:
		return VisitorOption.Skip;
	case Syntax.Identifier:
		return this.identifierEnter(node, parent);
	case Syntax.AssignmentExpression:
	case Syntax.UpdateExpression:
		return this.assignmentEnter(node, parent);
	}
};

StatementSimplifier.prototype.statementSplitExit = function(node, parent) {
	switch (node.type) {
	case Syntax.AssignmentExpression:
	case Syntax.UpdateExpression:
		return this.assignmentExit(node, parent);
		break;
	}
};

StatementSimplifier.prototype.identifierEnter = function(node, parent) {
	if (parent.type == Syntax.MemberExpression)
		return;
	if (parent.type == Syntax.AssignmentExpression && parent.left == node)
		return;
	var name = node.name;
	if (!this.statementIdentifierInfo[name])
		this.statementIdentifierInfo[name] = {reads: [], lastWrite: null};
	this.statementIdentifierInfo[name].reads.push(node);
};

StatementSimplifier.prototype.assignmentEnter = function(node, parent) {
	if (parent.type == Syntax.ExpressionStatement)
		return;
	if ((node.left || node.argument).type != Syntax.Identifier)
		throw Shade.throwError(
			node,
			"We only support nested assignments for simple identifiers, not objects or arrays.");

	if (node.type == Syntax.UpdateExpression) {
		var usePrevValue = !node.prefix;
		node = {type: Syntax.AssignmentExpression,
				operator: "=",
				left: {
					type: Syntax.Identifier,
					name: node.argument.name,
					loc: node.argument.loc
				},
				right: {type: Syntax.BinaryExpression,
						operator: node.operator == "++" ? "+" : "-",
						left: {
							type: Syntax.Identifier,
							name: node.argument.name,
							loc: node.argument.loc
						},
						right: {type: Syntax.Literal, value: 1} },
						loc: node.loc,
						_usePrevValue: usePrevValue };

	} else if (node.type == Syntax.AssignmentExpression
			   && node.operator != "=") {
		var binaryOperator = node.operator.substr(0, node.operator.length - 1);
		node.operator = "=";
		node.right = {type: Syntax.BinaryExpression,
					  operator: binaryOperator,
					  left: {
						  type: Syntax.Identifier,
						  name: node.left.name,
						  loc: node.right.loc
					  },
					  right: node.right,
					  loc: node.right.loc };
	}
	var name = node.left.name;
	var entry = this.statementIdentifierInfo[name];
	if (entry && entry.reads.length > 0)
		node._preIdentifierWriter = entry.lastWrite;
	return node;
};

StatementSimplifier.prototype.assignmentExit = function(node, parent) {
	if (parent.type == Syntax.ExpressionStatement)
		return;

	var readOldValue = node._usePrevValue;
	delete node._usePrevValue;

	var oldName = node.left.name;
	if (!this.statementIdentifierInfo[oldName]) {
		this.statementIdentifierInfo[oldName] = {reads: [], lastWrite: null};
	}

	var entry = this.statementIdentifierInfo[oldName];

	var readReplace = {type: Syntax.Identifier, name: oldName, loc: node.loc};
	if (readOldValue || (node._preIdentifierWriter !== undefined
						 && node._preIdentifierWriter == entry.lastWrite)) {
		var newName = this.getFreeName();
		if (!entry.lastWrite) {
			var copyAssignment
				= {type: Syntax.AssignmentExpression,
				   left: {type: Syntax.Identifier, name: newName},
				   right: {type: Syntax.Identifier, name: oldName},
				   operator: "=" };
			this.assignmentsToBePrepended.unshift(copyAssignment);
		} else {
			entry.lastWrite.left.name = newName;
		}
		for (var i = 0; i < entry.reads.length; ++i) {
			entry.reads[i].name = newName;
		}
	}
	entry.reads = [];
	delete node._preIdentifierWriter;
	entry.lastWrite = node;

	if (readOldValue)
		readReplace.name = newName;
	else
		this.statementIdentifierInfo[oldName].reads.push(readReplace);

	this.assignmentsToBePrepended.push(node);
	return readReplace;
};

exports = module.exports = StatementSimplifier;

},{"./statement_split_traverser":113,"estraverse":61,"util":42}],113:[function(require,module,exports){
"use strict";

var assert = require("assert");
var deepExtend = require("deep-extend");

var walk = require("estraverse");
var Shade = require("../../interfaces");
var Types = Shade.TYPES;
var annotate = require("../../utils/annotate");

var Syntax = walk.Syntax;

var StatementSplitTraverser = function() {
	this.scopes = [];
	this.preContinueStatements = [];
	this.currentStatementTmpUsed = [];
	this.assignmentsToBePrepended = [];

	this.skipExtraction = {forInitUpdate: false}
};

StatementSplitTraverser.prototype.execute = function(root) {
	walk.replace(
		root,
		{enter: this.enterNode.bind(this), leave: this.exitNode.bind(this)});
	return root;
};

StatementSplitTraverser.prototype.gatherStatmentSplitInfo = function(node) {
	this.currentStatementTmpUsed = [];
	this.assignmentsToBePrepended = [];
	this.onGatherSplitInfo();
	return walk.replace(node, {
		enter: this.statementSplitEnter.bind(this),
		leave: this.statementSplitExit.bind(this)
	});
};

StatementSplitTraverser.prototype.statementSplitEnter = function(nodeParent) {
	// Implemented by subclass
};

StatementSplitTraverser.prototype.statementSplitExit = function(nodeParent) {
	// Implemented by subclass
};

StatementSplitTraverser.prototype.onGatherSplitInfo = function() {
	// Implemented by subclass
};

StatementSplitTraverser.prototype.isRedundant = function(node) {
	var result = true;
	walk.traverse(node, {
		enter: function(node) {
			switch (node.type) {
			case Syntax.AssignmentExpression:
			case Syntax.UpdateExpression:
			case Syntax.FunctionExpression:
			case Syntax.FunctionDeclaration:
			case Syntax.CallExpression:
				result = false;
				this.break();
			}
		}
	});
	return result;
};

StatementSplitTraverser.prototype.pushScope = function() {
	var newScope = {declared: [], tmpDeclared: [], tmpDeclaredTypes: []};
	this.scopes.push(newScope);
	return newScope;
};

StatementSplitTraverser.prototype.popScope = function() {
	return this.scopes.pop();
};

StatementSplitTraverser.prototype.getScope = function() {
	return this.scopes[this.scopes.length - 1];
};

StatementSplitTraverser.prototype.addPreContinueStatements = function(
	statements) {
	var last
		= this.preContinueStatements[this.preContinueStatements.length - 1];
	last.push.apply(last, statements);
};

StatementSplitTraverser.prototype.getPreContinueStatements = function() {
	return this.preContinueStatements[this.preContinueStatements.length - 1];
};

StatementSplitTraverser.prototype.enterNode = function(node, parent) {
	switch (node.type) {
	case Syntax.FunctionExpression:
	case Syntax.FunctionDeclaration:
	case Syntax.Program:
		var newScope = this.pushScope();
		if (node.params) {
			for (var i = 0; i < node.params.length; ++i) {
				newScope.declared.push(node.params[i].name);
			}
		}
		break;
	case Syntax.VariableDeclarator:
		this.addDeclaredIdentifier(node.id.name);
		break;
	case Syntax.ContinueStatement:
		return this.extendContinueStatement(node);
	case Syntax.ExpressionStatement:
		return this.performStatementSplit(node, [{pre: true}]);
	case Syntax.IfStatement:
		return this.performStatementSplit(node, [{prop: "test", pre: true}]);
	case Syntax.ReturnStatement:
		if (node.argument)
			return this.performStatementSplit(node,
											  [{prop: "argument", pre: true}]);
		break;
	case Syntax.WhileStatement:
		return this.performStatementSplit(
			node, [{prop: "test", pre: true, post: true}], "body");
	case Syntax.ForStatement:
		var extractions = [];

		if (!this.skipExtraction.forInitUpdate)
			extractions.push({prop: "init", pre: true, extract: true});

		extractions.push({prop: "test", pre: true, post: true});

		if (!this.skipExtraction.forInitUpdate)
			extractions.push({prop: "update", post: true, extract: true});

		return this.performStatementSplit(node, extractions, "body");
	case Syntax.DoWhileStatement:
		return this.performStatementSplit(node, [{prop: "test", post: true}],
										  "body");
	}
};

StatementSplitTraverser.prototype.exitNode = function(node, parent) {
	switch (node.type) {
	case Syntax.FunctionExpression:
	case Syntax.FunctionDeclaration:
		return this.addTmpDeclaration(node);
	case Syntax.Program:
		this.removeRedundantBlocks(node, "body");
		return this.addTmpDeclaration(node);
	case Syntax.BlockStatement:
		return this.removeRedundantBlocks(node, "body");
	case Syntax.SwitchCase:
		return this.removeRedundantBlocks(node, "consequent");
	case Syntax.ContinueStatement:
		delete node._extended;
		break;
	case Syntax.WhileStatement:
	case Syntax.ForStatement:
	case Syntax.DoWhileStatement:
		if (node._preContinueStacked) {
			delete node._preContinueStacked;
			this.preContinueStatements.pop();
		}
		break;
	}
};

StatementSplitTraverser.prototype.addDeclaredIdentifier = function(name) {
	var declared = this.getScope().declared;
	if (declared.indexOf(name) == -1)
		declared.push(name);
};

StatementSplitTraverser.prototype.isNameDeclared = function(name, untyped) {
	var i = this.scopes.length;
	while (i--) {
		if (this.scopes[i].declared.indexOf(name) != -1)
			return true;
	}
	return untyped && this.getScope().tmpDeclared.indexOf(name) != -1;
};

StatementSplitTraverser.prototype.getFreeName = function(type, kind) {
	var resultIdx = 0;
	var untyped = (type === undefined);
	var result, prefix = this._getTypedPrefix(type, kind);
	do {
		result = prefix + resultIdx++;
	} while (this.isNameDeclared(result, untyped)
			 || this.currentStatementTmpUsed.indexOf(result) != -1);
	this.currentStatementTmpUsed.push(result);
	var scope = this.getScope();
	if (scope.tmpDeclared.indexOf(result) == -1) {
		scope.tmpDeclared.push(result);
		scope.tmpDeclaredTypes.push({type: type, kind: kind});
	}
	return result;
};

StatementSplitTraverser.prototype.getStatementTmpUsedCount = function() {
	return this.currentStatementTmpUsed.length;
};

StatementSplitTraverser.prototype.reduceStatementTmpUsed = function(newCount) {
	this.currentStatementTmpUsed.length = newCount;
};

StatementSplitTraverser.prototype.removeStatementTmpUsedAfter = function(name) {
	var idx = this.currentStatementTmpUsed.indexOf(name);
	if (idx == -1)
		return;
	idx++;
	var removeCount = this.currentStatementTmpUsed.length - idx;
	this.currentStatementTmpUsed.splice(idx, removeCount);
};

StatementSplitTraverser.prototype._getTypedPrefix = function(type, kind) {
	if (type === undefined)
		return "_tmp";
	switch (type) {
	case Types.BOOLEAN:
		return "_boolTmp";
	case Types.NUMBER:
		return "_numTmp";
	case Types.INT:
		return "_intTmp";
	case Types.STRING:
		return "_stringTmp";
	case Types.OBJECT:
		switch (kind) {
		case "Vec2":
			return "_vec2Tmp";
		case "Vec3":
			return "_vec3Tmp";
		case "Vec4":
			return "_vec4Tmp";
		case "Mat3":
			return "_mat3Tmp";
		case "Mat4":
			return "_mat4Tmp";
		}
	}
};

StatementSplitTraverser.prototype.performStatementSplit = function(
	node, subProperties, bodyProperty) {
	if (bodyProperty && !node._preContinueStacked) {
		this.preContinueStatements.push([]);
		node._preContinueStacked = true;
	}

	var originalNode = node, returnNode = node;
	var i = subProperties.length;
	while (i--) {
		var property = subProperties[i].prop;
		var target = originalNode;
		if (property)
			target = originalNode[property];
		if (property && subProperties[i].extract) {
			this.onGatherSplitInfo();
			this.currentStatementTmpUsed = [];
			this.assignmentsToBePrepended = target ? [target] : [];
			originalNode[property] = null;
		} else {
			target = this.gatherStatmentSplitInfo(target);
			if (property)
				originalNode[property] = target;
			else
				returnNode = target;
		}
		if (this.assignmentsToBePrepended.length > 0) {
			if (subProperties[i].pre) {
				returnNode = this.getSplittedStatementBlock(
					this.assignmentsToBePrepended, returnNode);
			}
			if (subProperties[i].post) {
				var body = originalNode[bodyProperty];
				var statements = this.getSplittedStatementBlock(
					this.assignmentsToBePrepended);
				if (body && body.type == Syntax.BlockStatement) {
					body.body.push(statements);
				} else {
					if (body)
						statements.body.unshift(body);
					originalNode[bodyProperty] = statements;
				}
				this.addPreContinueStatements(this.assignmentsToBePrepended);
			}
		}
	}
	return returnNode;
};

StatementSplitTraverser.prototype.extendContinueStatement = function(node) {
	if (node._extended)
		return;
	node._extended = true;
	var statements = this.getPreContinueStatements();
	if (statements.length == 0)
		return node;
	return this.getSplittedStatementBlock(statements, node);
};

StatementSplitTraverser.prototype.getSplittedStatementBlock
	= function(statements, node) {
		  var result
			  = {type: Syntax.BlockStatement, body: [], loc: node && node.loc};
		  for (var i = 0; i < statements.length; ++i) {
			  var assignment = deepExtend({}, statements[i]);
			  result.body.push({
				  type: Syntax.ExpressionStatement,
				  expression: assignment,
				  loc: assignment.loc
			  });
		  }
		  if (node && (node.type != Syntax.ExpressionStatement
					   || !this.isRedundant(node))) {
			  result.body.push(node);
		  }
		  return result;
	  };

StatementSplitTraverser.prototype.removeRedundantBlocks
	= function(node, propertyName) {
		  var list = node[propertyName];
		  var i = list.length;
		  while (i--) {
			  if (list[i].type == Syntax.BlockStatement) {
				  var args = [i, 1];
				  args.push.apply(args, list[i].body);
				  list.splice.apply(list, args);
			  }
		  }
		  return node;
	  };

StatementSplitTraverser.prototype.addTmpDeclaration = function(node) {
	var tmpDeclared = this.getScope().tmpDeclared,
		tmpDeclaredTypes = this.getScope().tmpDeclaredTypes;
	if (tmpDeclared.length == 0)
		return;
	var list;
	if (node.type == Syntax.Program)
		list = node.body;
	else
		list = node.body.body;
	var declaration = null;
	if (list[0].type == Syntax.VariableDeclaration)
		declaration = list[0];
	else {
		declaration
			= {type: Syntax.VariableDeclaration, declarations: [], kind: "var"};
		list.unshift(declaration);
	}
	for (var i = 0; i < tmpDeclared.length; ++i) {
		var declarator = {
			type: Syntax.VariableDeclarator,
			id: {type: Syntax.Identifier, name: tmpDeclared[i]},
			init: null
		};
		if (tmpDeclaredTypes[i].type !== undefined) {
			annotate(declarator)
				.setType(tmpDeclaredTypes[i].type, tmpDeclaredTypes[i].kind);
		}
		declaration.declarations.push(declarator);
	}

	this.popScope();
};

exports = module.exports = StatementSplitTraverser;

},{"../../interfaces":188,"../../utils/annotate":204,"assert":25,"deep-extend":53,"estraverse":61}],114:[function(require,module,exports){
"use strict";

var worklist = require("analyses");
var Set = worklist.Set;

var astTools = require("../utils/ast");
var dominance = require("../utils/dominance");

exports.slice = function (cfg, startNode, variableName) {
    var postDominators = dominance.computePostDominators(cfg);
    var initialSet = new Set([variableName]);

    var oldS = new Set();
    var R = directRelevantVariables(cfg, startNode, initialSet, postDominators);
    var S = getRelevantStatements(cfg);
    var B = getRelevantBranchStatements(cfg, S);

    while (!Set.equals(S, oldS)) {
        oldS = S;

        var newR = B.values().reduce(function(input, node) {
            var sR = directRelevantVariables(cfg, node, astTools.findVariableReferences(node.astNode));
            return mergeMap(input, sR);
        }, R);

        S = Set.union(B, getRelevantStatements(cfg));
        B = getRelevantBranchStatements(cfg, S);
        R = newR;
    }
    return S;
};

function directRelevantVariables(cfg, startNode, variables, postDominators) {
    var oldStart = cfg[1];
    var oldNext = startNode.next;

    cfg[1] = startNode;
    cfg[1].next = [];

    var R = worklist(cfg, function (input) {
        if (this.type || !this.astNode)
            return input;

        this.ref = this.ref || astTools.findVariableReferences(this.astNode);
        this.def = this.def || astTools.findVariableDefinitions(this.astNode);
        this.infl = this.infl || computeInfluence(this, postDominators.get(this));

        var result = null;
        if (Set.intersect(this.def, input).size) {
            this.directRelevant = true;
            result = Set.union(result, this.ref);
        }

        var self = this;
        var generated = new Set(input.values().filter(function (v) {
            return !self.def.has(v);
        }));
        return Set.union(result, generated);

    }, {direction: "backward", start: variables});

    cfg[1].next = oldNext;
    cfg[1] = oldStart;
    return R;
}

function getRelevantStatements(cfg) {
    return new Set(cfg[2].filter(function (node) {
        return node.directRelevant === true;
    }));
}
function getRelevantBranchStatements(cfg, S) {
    return new Set(cfg[2].filter(function (node) {
        return node.infl ? Set.intersect(node.infl, S).size : false;
    }));
}

function mergeMap(A, B) {
    var keys = B.keys();
    for(var i in keys) {
        var key = keys[i];
        if(A.has(key)) {
            var setA = A.get(key);
            var setB = B.get(key);
            A.set(key, Set.union(setA, setB));
        }
    }
    return A;
}

function computeInfluence(node, inverseDominators) {
    var result = new Set();
    if (node.next.length < 2)
        return result;

    findSetOfNodesOnPath(node.next, inverseDominators, result);

    return result;
}

function findSetOfNodesOnPath(fromArr, endSet, result) {
    for(var i = 0; i < fromArr.length; i++) {
        var node = fromArr[i];
        if(!(result.has(node) || endSet.has(node))) {
            result.add(node);
            findSetOfNodesOnPath(node.next, endSet, result);
        }
    }
}


},{"../utils/ast":137,"../utils/dominance":138,"analyses":46}],115:[function(require,module,exports){
// dependencies
var walker = require('walkes');
var worklist = require('analyses');
var common = require("../base/common.js");
var esgraph = require('esgraph');
var codegen = require('escodegen');
var astTools = require("./utils/ast");
var Shade = require("./../interfaces.js"),
    SpaceType = Shade.SpaceType,
    VectorType = Shade.VectorType,
    SpaceVectorType = Shade.SpaceVectorType;


// shortcuts
var Syntax = common.Syntax;
var Set = worklist.Set,
    Types = Shade.TYPES;

var ANNO = common.ANNO;
// defines


var c_resultPointOk = true, c_resultNormalOk = true,
    c_customFunctionPropagations = null, c_debug = false;

function analyze(functionAast, customFunctionPropagations) {
    var cfg = esgraph(functionAast.body, {omitExceptions: true});
    c_resultPointOk = true;
    c_resultNormalOk = true;
    c_customFunctionPropagations = customFunctionPropagations || {};
    var output = worklist(cfg, transferSpaceInfo, {
        direction: 'backward',
        start: null,
        merge: worklist.merge(mergeSpaceInfo)
    });
    var startNodeResult = output.get(cfg[0]);
    var result = {};
    var tranferEntry = {
        transferPointOk: c_resultPointOk,
        transferNormalOk: c_resultNormalOk,
        transferArgs: []
    };
    var transferSpaces = {};
    startNodeResult.forEach(function (elem) {
        var split = elem.split(";"), name = split[0], space = split[1] * 1;
        if (Shade.getSpaceFromSpaceVector(space) == SpaceType.RESULT) {
            transferSpaces[name] = true;
            return;
        }
        if (!result[name]) result[name] = [];
        result[name].push(space);
    });
    for (var i = 0; i < functionAast.params.length; ++i) {
        var name = functionAast.params[i].name;
        tranferEntry.transferArgs.push(transferSpaces[name]);
    }
    c_customFunctionPropagations[functionAast.id.name] = tranferEntry;
    return result;
}


function setSpaceInfo(ast, key, value) {
    if (!ast.spaceInfo)
        ast.spaceInfo = {};
    ast.spaceInfo[key] = value;
}
function setSpaceInfoSpaces(ast, key, spaces) {
    var values = spaces && spaces.filter(function (space) {
            return Shade.getSpaceFromSpaceVector(space) != SpaceType.RESULT
        });
    setSpaceInfo(ast, key, values);
}

/**
 * @param {Set} input
 * @this {FlowNode}
 * @returns {Set} output with respect to input
 */
function transferSpaceInfo(input) {
    if (this.type || !this.astNode) // Start and end node do not influence the result
        return input;

    // Local
    var kill = this.kill = this.kill || astTools.findVariableDefinitions(this.astNode, true);
    var generatedDependencies = this.generate = this.generate || generateSpaceDependencies(this.astNode, kill);
    //generate && console.log(this.label, generate);

    // Depends on input
    var depSpaceInfo = new Set(), finalSpaces = null, spaceTypes = null;
    setSpaceInfo(this.astNode, "transferSpaces", null);
    setSpaceInfo(this.astNode, "hasSpaceOverrides", generatedDependencies.dependencies.spaceOverrides.length > 0);
    if (generatedDependencies.def) {
        var def = generatedDependencies.def;
        setSpaceInfo(this.astNode, "def", def);
        spaceTypes = getSpaceVectorTypesFromInfo(input, def);
    }
    else {
        spaceTypes = new Set([SpaceVectorType.OBJECT])
        if (this.astNode.type == Syntax.ReturnStatement) {
            spaceTypes.add(SpaceVectorType.RESULT_NORMAL);
            spaceTypes.add(SpaceVectorType.RESULT_POINT);
        }
    }
    setSpaceInfoSpaces(this.astNode, "transferSpaces", spaceTypes);
    finalSpaces = createSpaceInfoFromDependencies(depSpaceInfo, generatedDependencies.dependencies, spaceTypes);
    setSpaceInfoSpaces(this.astNode, "finalSpaces", (finalSpaces && finalSpaces.size > 0) ? finalSpaces : null);

    input = new Set(input.filter(function (elem) {
        return !kill.has(elem.split(";")[0]);
    }));
    return mergeSpaceInfo(input, depSpaceInfo);
}

function getSpaceVectorTypesFromInfo(spaceInfo, identifier) {
    var set = new Set(spaceInfo.filter(function (elem) {
        return elem.split(";")[0] == identifier
    }).map(function (elem) {
        return elem.split(";")[1] * 1
    }));
    if (set.size == 0)
        set.add(SpaceVectorType.OBJECT);
    return set;
}
function isSpaceTypeValid(spaceType, dependencies) {
    var type = Shade.getVectorFromSpaceVector(spaceType);
    return type == VectorType.NONE || (type == VectorType.NORMAL && !dependencies.normalSpaceViolation)
        || (type == VectorType.POINT && !dependencies.pointSpaceViolation);
}

function createSpaceInfoFromDependencies(depSpaceInfo, dependencies, spaces) {
    var finalSpaces = new Set();
    dependencies.toObjectSet.forEach(function (name) {
        depSpaceInfo.add(name + ";" + SpaceVectorType.OBJECT);
    })
    spaces.forEach(function (spaceVector) {
        var space = Shade.getSpaceFromSpaceVector(spaceVector);
        var isValid = isSpaceTypeValid(spaceVector, dependencies);

        if (space != SpaceType.OBJECT && dependencies.hasDirectVec3SpaceOverride()) {
            if (space == SpaceType.RESULT)
                isValid = false;
            else
                throw new Error("Detection of repeated space conversion. Not supported!");
        }

        finalSpaces.add(spaceVector);

        if (!isValid && space == SpaceType.RESULT) {
            if (Shade.getVectorFromSpaceVector(spaceVector) == VectorType.NORMAL)
                c_resultNormalOk = false;
            else
                c_resultPointOk = false;
        }
        spaceVector = isValid ? spaceVector : SpaceVectorType.OBJECT;

        dependencies.propagateSet.forEach(function (name) {
            depSpaceInfo.add(name + ";" + spaceVector);
        });
    });
    var overrides = dependencies.spaceOverrides;
    for (var i = 0; i < overrides.length; ++i) {
        createSpaceInfoFromDependencies(depSpaceInfo, overrides[i].dependencies, new Set([overrides[i].space]));
    }
    return finalSpaces;
}


/**
 * Special merge function that merges entries with same names
 * to a new entry with top element Semantic.UNKNOWN
 * @param {Set} a
 * @param {Set} b
 * @returns {Set}
 */
function mergeSpaceInfo(a, b) {
    var s = a ? new Set(a) : new Set();
    if (b)
        b.forEach(
            function (elem) {
                s.add(elem);
            }
        );
    return s;
}

function SpaceDependencies() {
    this.normalSpaceViolation = false;
    this.pointSpaceViolation = false;
    this.propagateSet = new Set();
    this.toObjectSet = new Set();
    this.spaceOverrides = [];
}

SpaceDependencies.prototype.addSpaceOverride = function (space, fromObjectSpace, dependencies) {
    this.spaceOverrides.push({space: space, fromObjectSpace: fromObjectSpace, dependencies: dependencies})
}
SpaceDependencies.prototype.hasDirectVec3SpaceOverride = function () {
    var i = this.spaceOverrides.length;
    while (i--) {
        if (!this.spaceOverrides[i].fromObjectSpace)
            return true;
    }
    return false;
}


function generateSpaceDependencies(ast, defs) {
    var result = {def: null, dependencies: new SpaceDependencies()};
    if (!ast && !ast.type)
        return result;
    var defCount = defs.size;
    if (defCount > 1)
        throw new Error("Code not sanitized, found multiple definitions in one statement");
    if (defCount == 1)
        result.def = defs.values()[0];
    // TODO: Properly determine FLOAT3 statements
    var isFloat3Statement = ANNO(ast).getKind() == "Vec3";

    if (isFloat3Statement) {
        gatherSpaceDependencies(ast, result.dependencies);
        setSpaceInfo(ast, "propagateSet", result.dependencies.propagateSet.values());
        setSpaceInfo(ast, "normalSpaceViolation", result.dependencies.normalSpaceViolation);
        setSpaceInfo(ast, "pointSpaceViolation", result.dependencies.pointSpaceViolation);
    }
    else
        gatherObjectDependencies(ast, result.dependencies);

    return result;
}

function getSpaceConversion(callAst) {
    var callee = callAst.callee;
    if (callee.type == Syntax.MemberExpression && callee.object.type == Syntax.Identifier
        && callee.object.name == "Space") {
        var spaceType = 0;
        switch (callee.property.name) {
            case "transformPoint":
                spaceType = VectorType.POINT;
                break;
            case "transformDirection":
                spaceType = VectorType.NORMAL;
                break;
        }
        spaceType = spaceType << 3;
        if (spaceType) {
            var firstArg = callAst.arguments[0];

            if (firstArg.type != Syntax.MemberExpression || firstArg.object.type != Syntax.Identifier
                || firstArg.object.name != "Space" || firstArg.property.type != Syntax.Identifier)
                throw new Error("The first argument of '" + callee.property + "' must be a Space enum value.");
            switch (firstArg.property.name) {
                case "VIEW" :
                    spaceType += SpaceType.VIEW;
                    break;
                case "WORLD":
                    spaceType += SpaceType.WORLD;
                    break;
            }
            return spaceType;
        }
    }
    return null;
}

function handleSpaceOverride(callAst, result, fromObjectSpace) {
    var space = getSpaceConversion(callAst);
    if (space) {
        var subResult = new SpaceDependencies();
        gatherSpaceDependencies(callAst.arguments[1], subResult);
        result.addSpaceOverride(space, fromObjectSpace, subResult);
        setSpaceInfo(callAst, "spaceOverride", space);
        setSpaceInfo(callAst, "propagateSet", subResult.propagateSet.values());
        setSpaceInfo(callAst, "normalSpaceViolation", subResult.normalSpaceViolation);
        setSpaceInfo(callAst, "pointSpaceViolation", subResult.pointSpaceViolation);
        return true;
    }
    return false;
}

function gatherObjectDependencies(ast, result) {
    walker(ast, {
        VariableDeclaration: function () {
        },
        Identifier: function () {
            if (this.extra.kind == "Vec3") {
                result.toObjectSet.add(this.name);
            }

        },
        MemberExpression: function (recurse) {
            if (this.extra.kind == "Vec3") {
                if (this.object.type == Syntax.Identifier && this.property.type == Syntax.Identifier) {
                    if (this.object.extra.global)
                        result.propagateSet.add("env." + this.property.name);
                    else if (this.object.name !== "uexp") { // FIXME
                        throw new Error("Member Access of non 'env' object in space equation - not supported: " + codegen.generate(this));
                    }
                }
            }
            else {
                recurse(this.object);
                recurse(this.property);
            }
        },
        CallExpression: function (recurse) {
            if (handleSpaceOverride(this, result, true))
                return;
            recurse(this.callee);
            this.arguments.map(recurse);
        }
    });
}

function isVector3(node) {
    return ANNO(node).isOfKind("Vec3")
}


function gatherSpaceDependencies(ast, result) {
    walker(ast, {
        VariableDeclaration: function () {
        },
        AssignmentExpression: function (recurse) {
            recurse(this.right);
        },
        Identifier: function () {
            if (isVector3(this)) {
                result.propagateSet.add(this.name);
                setSpaceInfo(this, "propagate", true);
            }
        },
        NewExpression: function (recurse) {
            if (this.callee == "Vec3") {
                handleVec3Args(this.arguments, recurse, result, false);
            }
        },
        MemberExpression: function (recurse) {
            var object = this.object;
            var property = this.property;

            if (isVector3(this)) {
                if (object.type == Syntax.Identifier && property.type == Syntax.Identifier) {
                    if (ANNO(object).isGlobal()) {
                        result.propagateSet.add("env." + property.name);
                    } else if (object.name !== "uexp") { // FIXME
                        throw new Error("Member Access of non 'env' object in space equation - not supported.")
                    }
                    setSpaceInfo(this, "propagate", true);
                }
            }
            else {
                recurse(object);
                recurse(property);
            }
        },
        CallExpression: function (recurse) {
            if (handleSpaceOverride(this, result, false))
                return;
            if (this.callee.type == Syntax.MemberExpression) {
                result.pointSpaceViolation = true;
                var callObject = this.callee.object;
                var objectKind = ANNO(callObject).getKind(),
                    method = this.callee.property.name,
                    args = this.arguments;
                if (PropagationRules[objectKind] && PropagationRules[objectKind][method]) {
                    PropagationRules[objectKind][method](callObject, args, recurse, result);
                    return;
                }
                console.log("Unhandled: ", codegen.generate(this))
            } else if (this.callee.type == Syntax.Identifier) {
                var id = this.callee.name;
                var customEntry = c_customFunctionPropagations && c_customFunctionPropagations[id];
                if (customEntry) {
                    if (!customEntry.transferPointOk) result.pointSpaceViolation = true;
                    if (!customEntry.transferNormalOk) result.normalSpaceViolation = true;
                    var i = customEntry.transferArgs.length;
                    while (i--) {
                        if (customEntry.transferArgs[i])
                            recurse(this.arguments[i]);
                        else
                            gatherObjectDependencies(this.arguments[i], result);
                    }
                    return;
                }
            }
            result.pointSpaceViolation = true;
            result.normalSpaceViolation = true;
            gatherObjectDependencies(this, result);
            //this.arguments.forEach(function(arg){ gatherObjectDependencies(arg, result)});
        }
    });
}

function handleScaleOperator(callObject, args, recurse, result) {
    handleVec3Args(args, recurse, result, true);
    recurse(callObject);
}
function handleAddSubOperation(callObject, args, recurse, result) {
    handleVec3Args(args, recurse, result, false);
    recurse(callObject);
}

function handleVec3Args(args, recurse, result, scaling) {
    if (!scaling && args.length == 0) {
        result.normalSpaceViolation = true;
        return;
    }
    if (args.length > 1) {
        result.normalSpaceViolation = true;
        return;
    }
    if (args.length == 1) {
        if (isVector3(args[0])) {
            recurse(args[0]);
        }
        else if (scaling && typeIsScalar(args[0])) {
            gatherObjectDependencies(args[0], result);
        }
        else {
            result.normalSpaceViolation = true;
        }
    }
}

function typeIsScalar(node) {
    return ANNO(node).isNumber() || ANNO(node).isInt();
}


var PropagationRules = {
    "Vec3": {
        "add": handleAddSubOperation,
        "sub": handleAddSubOperation,
        "cross": handleAddSubOperation,
        "mul": handleScaleOperator,
        "div": handleScaleOperator,
        "normalize": handleScaleOperator
    }
}
module.exports = {
    analyze: analyze
};


},{"../base/common.js":140,"./../interfaces.js":188,"./utils/ast":137,"analyses":46,"escodegen":54,"esgraph":58,"walkes":95}],116:[function(require,module,exports){
// Dependencies
var assert = require("assert");
var common = require("../../base/common.js"),
    Shade = require("../../interfaces.js"),
    evaluator = require("../constants/evaluator.js"),
    estraverse = require('estraverse'),
    ErrorHandler = require("../../type-system/errors.js");

var codegen = require('escodegen');
var TypeInfo = require("../../type-system/typeinfo");
var TYPES = require("../../interfaces.js").TYPES;

// Shortcuts
var Syntax = common.Syntax;
var ANNO = common.ANNO;
var generateErrorInformation = ErrorHandler.generateErrorInformation;
var ERROR_TYPES = ErrorHandler.ERROR_TYPES;

var debug = false;

var handlers = {

    ArrayExpression: function (node, parent, context) {

        var result = ANNO(node), elements = context.getTypeInfo(node.elements);
        result.info.elements = result.info.elements || {};
        var elementType = ANNO(result.info.elements);

        result.setType(TYPES.ARRAY);
        elements.forEach(function (element, index) {
            if (index === 0) {
                elementType.copyFrom(element);
            } else {
                if (!elementType.setCommonType(elementType, element)) {
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "shade.js does not support inhomogeneous arrays: [", elements.map(function (e) {
                        return e.getTypeString()
                    }).join(", "), "]"));
                }
            }
        });
        result.setArraySize(elements.length);
    },

    /**
     * @param node
     */
    Literal: function (node) {
        var value = node.raw !== undefined ? node.raw : node.value,
            result = ANNO(node);

        var number = parseFloat(value);
        if (!isNaN(number)) {
            if (value.toString().indexOf(".") == -1) {
                result.setType(TYPES.INT);
            }
            else {
                result.setType(TYPES.NUMBER);
            }
        } else if (value === 'true' || value === 'false') {
            result.setType(TYPES.BOOLEAN);
        } else if (value === 'null') {
            result.setType(TYPES.NULL);
        } else {
            result.setType(TYPES.STRING);
        }
        if (!result.isNull()) {
            result.setConstantValue(evaluator.getConstantValue(node));
        }
    },

    /**
     * ExpressionStatement: Just copy the result from the actual expression
     */
    ExpressionStatement: function (node) {
        var result = ANNO(node),
            expression = ANNO(node.expression);
        result.copyFrom(expression);
    },


    /**
     * ReturnStatement: If return has an argument, copy the TypeInfo
     * form the argument, otherwise it's undefined. Inform the scope on
     * the return type of this return branch.
     */
    ReturnStatement: function (node, parent, context) {
        var result = ANNO(node),
            argument = context.getTypeInfo(node.argument);

        if (argument) {
            result.copyFrom(argument);
        } else {
            result.setType(TYPES.UNDEFINED);
        }
        context.getScope().returnInfo = result;
    },

    /**
     * NewExpression: Find the type of the Callee from
     * the scope and evaluate based on annotated parameters
     */
    NewExpression: function (node, parent, context) {
        var result = ANNO(node), scope = context.getScope();

        // Be on the safe side, assume result is static independently of former annotations
        result.setDynamicValue();

        var func = scope.type(node.callee);
        if (!func.isFunction()) {  // e.g. var a = undefined; a.unknown;
            result.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, node.callee.name, "is not a function"));
            return;
        }

        var constructor = func.ctor;
        assert(typeof constructor == "function");
        var args = context.getTypeInfo(node.arguments);
        try {
            var extra = constructor(result, args, scope);
            result.setFromExtra(extra);
        } catch (e) {
            result.setInvalid(e);
        }

    },


    /**
     * UnaryExpression
     */
    UnaryExpression: function (node, parent, context) {
        var result = ANNO(node),
            argument = context.getTypeInfo(node.argument),
            operator = node.operator;

        //noinspection FallthroughInSwitchStatementJS
        switch (operator) {
            case "!":
                result.setType(TYPES.BOOLEAN);
                if (argument.canObject()) {
                    result.setConstantValue(false); // !obj == false
                    return;
                }
                break;
            case "+":
            case "-":
                if (argument.canInt()) {
                    result.setType(TYPES.INT);
                } else if (argument.canNumber()) {
                    result.setType(TYPES.NUMBER);
                } else {
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.NAN_ERROR));
                }
                break;
            case "typeof":
                result.setType(TYPES.STRING);
                if (argument.isValid()) {
                    result.setConstantValue(argument.getJavaScriptTypeString());
                }
                return;

            case "~":
            case "void":
            case "delete":
            default:
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, operator, "is not supported."));
        }
        if (argument.hasConstantValue()) {
            result.setConstantValue(evaluator.getConstantValue(node));
        } else {
            result.setDynamicValue();
        }
    },

    /**
     * 'Undefined' is an identifier. Variables, names of functions and
     * member properties are handled within parent expressions
     */
    Identifier: function (node, parent, context) {
        if (node.name === "undefined") {
            ANNO(node).setType(TYPES.UNDEFINED);
            return;
        }
        if (!parent) {
            var info = context.getTypeInfo(node);
            ANNO(node).copyFrom(info);
        }
    },

    /**
     * BinaryExpression
     */
    BinaryExpression: function (node, parent, context) {
        //console.log(node.left, node.right);
        var left = context.getTypeInfo(node.left),
            right = context.getTypeInfo(node.right),
            result = ANNO(node),
            operator = node.operator,
            value;

        if (!(left.isValid() && right.isValid())) {
            result.setInvalid();
            return;
        }

        //noinspection FallthroughInSwitchStatementJS
        switch (operator) {
            case "+":
            case "-":
            case "*":
            case "/":
            case "%":
                // int 'op' int => int
                // int / int => number
                if (left.canInt() && right.canInt()) {
                    if (operator == "/")
                        result.setType(TYPES.NUMBER);
                    else
                        result.setType(TYPES.INT);
                }
                // int 'op' number => number
                else if (left.canInt() && right.isNumber() || right.canInt() && left.isNumber()) {
                    result.setType(TYPES.NUMBER);
                }
                // number 'op' number => number
                else if (left.isNumber() && right.isNumber()) {
                    result.setType(TYPES.NUMBER);
                    // int 'op' null => int
                }
                else if (left.isInt() && right.isNull() || right.isInt() && left.isNull()) {
                    result.setType(TYPES.INT);
                }
                // number 'op' null => number
                else if ((left.isNumber() && right.isNull()) || (right.isNumber() && left.isNull())) {
                    result.setType(TYPES.NUMBER);
                }
                else {
                    // NaN

                    var message = "";
                    // Special handling for undefined, as this is the main reason for this error
                    if (left.isNullOrUndefined()) {
                        message = codegen.generate(node.left) + " is undefined";
                    } else if (right.isNullOrUndefined()) {
                        message = codegen.generate(node.right) + " is undefined";
                    }
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.NAN_ERROR, message));
                }
                break;
            case "===":
            case "!==":
                result.setType(TYPES.BOOLEAN);
                if (left.isUndefined() || right.isUndefined()) {
                    value = left.isUndefined() && right.isUndefined();
                    result.setConstantValue(operator == "===" ? value : !value);
                    return;
                }
                break;
            case "==": // comparison
            case "!=":
            case ">":
            case "<":
            case ">=":
            case "<=":
                result.setType(TYPES.BOOLEAN);
                if (left.isUndefined() || right.isUndefined()) {
                    value = left.isUndefined() && right.isUndefined();
                    result.setConstantValue(operator == "!=" ? !value : value);
                    return;
                }
                break;
            default:
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, operator, "is not supported."));
                return;
        }
        if (left.hasConstantValue() && right.hasConstantValue()) {
            //console.log(left.getConstantValue(), operator, right.getConstantValue());
            result.setConstantValue(evaluator.getConstantValue(node));
        } else {
            result.setDynamicValue();
        }
    },

    UpdateExpression: function (node, parent, context) {
        var argument = context.getTypeInfo(node.argument),
            result = ANNO(node);
        if (argument.canNumber()) {
            result.copyFrom(argument);
            if (node.prefix && argument.hasConstantValue()) {
                if (node.operator == "++") {
                    result.setConstantValue(argument.getConstantValue() + 1)
                } else if (node.operator == "--") {
                    result.setConstantValue(argument.getConstantValue() - 1)
                } else {
                    throw new Error("Operator not supported: " + node.operator);
                }
            }
        } else {
            // e.g. var a = {}; a++;
            result.setInvalid(generateErrorInformation(node, ERROR_TYPES.NAN_ERROR));
        }
    },

    AssignmentExpression: function (node, parent, context) {
        var right = context.getTypeInfo(node.right),
            result = ANNO(node);

        result.copyFrom(right);
        result.setDynamicValue();
        result.clearUniformDependencies();

        if (node.left.type === Syntax.MemberExpression) {
            var object = context.getScope().type(node.left.object);
            if (object.isArray()) {
                var elementTypeInfo = ANNO(object.getArrayElementType());
                if (elementTypeInfo.getType() === TYPES.ANY) {
                    elementTypeInfo.copyFrom(result);
                } else {
                    // this sucks, make better handling of cast ops!!
                    if (elementTypeInfo.getType() !== result.getType() &&
                        elementTypeInfo.isNumber() && !result.canNumber())
                        throw new Error("Array has to be homogeneous!");
                }
            } else {
                var name = node.left.property.name;
                object.setProperty(name, result.info);
            }
        }
        // Check, if a assigned variable still has the same type as
        // before and update type of uninitialized variables.
        if (node.left.type == Syntax.Identifier && !context.inDeclaration() && right.isValid()) {
            var name = node.left.name;
            var scope = context.getScope();
            scope.updateTypeInfo(name, right, node);
        }
    },

    // TODO can we merge some of this with call expr somehow? or vice versa?
    MemberExpression: function (node, parent, context) {
        var resultType = context.getTypeInfo(node);
        var objectAnnotation = context.getTypeInfo(node.object),
            propertyAnnotation = ANNO(node.property),
            scope = context.getScope();

        if (!objectAnnotation.isValid()) {
            resultType.setInvalid();
            return;
        }

        //console.log("Member", node.object.name, node.property.name, node.computed);
        if (node.computed) {
            if (objectAnnotation.isArray()) {
                // Property is computed, thus it could be a variable
                var propertyType = context.getTypeInfo(node.property);
                assert(propertyType.canNumber(), "Expected 'int' or 'number' type for array accessor");

                var elementInfo = objectAnnotation.getArrayElementType();

                resultType.setType(elementInfo.extra.type, elementInfo.extra.kind);
                if (elementInfo.extra.type === "array") {
                    resultType.info.staticSize = elementInfo.extra.staticSize;
                    resultType.info.elements = elementInfo.extra.elements;
                }
                return;
            } else if (objectAnnotation.isTexture()) {
                resultType.setType(TYPES.ARRAY);
                resultType.info.elements = {
                    extra: {
                        type: TYPES.OBJECT,
                        kind: "Vec4"
                    }
                };
                return;
            } else {
                resultType.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "no array access to object yet"));
                return;
            }
        }
        var propertyName = node.property.name;

        var objectOfInterest = scope.type(node.object);
        if (!objectOfInterest) {
            resultType.setInvalid(generateErrorInformation(node, ERROR_TYPES.REFERENCE_ERROR, node.object.name + " is not defined"));
            return;
        }

        if (!objectOfInterest.isValid() || objectOfInterest.getType() == TYPES.UNDEFINED) {  // e.g. var a = undefined; a.unknown;
            resultType.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, "Cannot read property '" + propertyName + "' of undefined"));
            return;
        }
        if (!objectOfInterest.isObject()) { // e.g. var a = 5; a.unknown;
            resultType.setType(TYPES.UNDEFINED);
            return;
        }

        objectAnnotation.copyFrom(objectOfInterest);

        if (!objectOfInterest.hasProperty(propertyName)) {
            resultType.setType(TYPES.UNDEFINED);
            propertyAnnotation.setType(TYPES.UNDEFINED);
            return;
        }

        var propertyTypeInfo = objectOfInterest.getPropertyInfo(propertyName);
        propertyAnnotation.copyFrom(propertyTypeInfo);
        resultType.copyFrom(propertyAnnotation);

        // If we have a type, evaluate static value
        if (!propertyTypeInfo.canComputeStaticValue() || propertyTypeInfo.getType() === TYPES.FUNCTION) {
            debug && console.warn("No static evaluation exists for function", codegen.generate(node));
            return;
        }
        var staticValue = propertyTypeInfo.computeStaticValue(resultType, scope, objectOfInterest);
        if (staticValue !== undefined) {
            resultType.setConstantValue(staticValue);
        }
    },

    ThisExpression: function (node, parent, context) {
        var result = ANNO(node),
            scope = context.getScope(),
            thisType = scope.get("this");
        assert(thisType);
        result.copyFrom(thisType);
    },

    CallExpression: function (node, parent, context, analyzer) {
        var result = ANNO(node),
            scope = context.getScope(),
            args = context.getTypeInfo(node.arguments),
            extra, staticValue;

        if (result.getType() !== "any")
            return;

        if (!args.every(function (arg) {
                return arg.isValid()
            })) {
            result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Not all arguments types of call expression could be evaluated"));
            return;
        }
        // Be on the safe side, assume result is static independently of former annotations
        result.setDynamicValue();

        // Call on an object, e.g. Math.cos()
        if (node.callee.type == Syntax.MemberExpression) {

            var memberExpression = context.getTypeInfo(node.callee);
            if (!memberExpression.isValid()) {
                result.setInvalid();
                return;
            }

            var object = node.callee.object,
                propertyName = node.callee.property.name;

            var objectReference = scope.type(object);

            // This should already have been handled by parent MemberExpression
            assert(objectReference.isValid(), "No object info for:" + object);

            if (!memberExpression.isFunction()) { // e.g. Math.PI()
                var msg = codegen.generate(node.callee) + " is not a function";
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, msg));
                return;
            }

            var propertyHandler = objectReference.getPropertyInfo(propertyName);

            //assert(propertyHandler.canEvaluate(), "Internal: no handler registered for function '" + propertyName + "'");

            try {
                if (propertyHandler.canEvaluate())
                    extra = propertyHandler.evaluate(node, args, scope, objectReference);
                else
                    extra = analyzer.specializeFunction(propertyHandler.getFunctionName(), args);
                extra && result.setFromExtra(extra);
            } catch (e) {
                result.setInvalid(generateErrorInformation(node, e.message));
                return;
            }

            // If the evaluation methods already computed a constant value, we can skip that part
            if (result.hasConstantValue()) {
                return;
            }

            // If we have a type, evaluate static value
            if (!propertyHandler.canComputeStaticValue()) {
                debug && console.warn("No static evaluation exists for function", codegen.generate(node));
                return;
            }
            staticValue = propertyHandler.computeStaticValue(result, args, scope, objectReference);
            if (staticValue !== undefined) {
                result.setConstantValue(staticValue);
            }
            return;


        } else if (node.callee.type == Syntax.Identifier) {
            //var functionName = node.callee.getFunctionName();//node.callee.name;
            var func = scope.get(node.callee.name);
            if (!func) {
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.REFERENCE_ERROR, node.callee.name, "is not defined"));
                return;
            }
            if (!func.isFunction()) {
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, func.getTypeString(), "is not a function"));
                return;
            }
            try {
                extra = analyzer.specializeFunction(func.getFunctionName(), args);
                extra && result.setFromExtra(extra);
            } catch (e) {
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Failure in function call: ", e.message));
            }
            return;
        }
        result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Internal:", "Unhandled CallExpression", node.callee.type));
    },

    VariableDeclarator: function (node, parent, context) {
        var init = node.init ? context.getTypeInfo(node.init) : null,
            result = ANNO(node);
        if (init) {
            ANNO(node.init).copyFrom(init);
            result.copyFrom(init);
        }
    },

    VariableDeclaration: function (node, parent, context) {
        context.setInDeclaration(false);
    },

    LogicalExpression: function (node, parent, context) {
        var left = context.getTypeInfo(node.left),
            right = context.getTypeInfo(node.right),
            result = ANNO(node);


        // static: true || false, dynamic: undefined
        var leftBool = left.getStaticTruthValue(),
            rightBool = right.getStaticTruthValue(),
            operator = node.operator;

        if (operator === "||") {
            if (leftBool === false) {
                result.copyFrom(right);
                return;
            }
            if (leftBool === true) {
                result.copyFrom(left);
                return;
            }
            // Left is dynamic, let's check right
            if (rightBool === false) {
                // Now the result type is always the one of the left value
                result.copyFrom(left);
                return;
            }
        } else if (operator === "&&") {
            if (leftBool === false) {
                // T(x) == false => x && y == x
                result.copyFrom(left);
                return;
            }
            if (leftBool === true) {
                result.copyFrom(right);
                return;
            }
            // Left is dynamic, let's check right
            if (rightBool === true) {
                // Now the result type is always the one of the left value
                result.copyFrom(left);
                return;
            }
            if (rightBool === false) {
                // Now the result must be false
                result.setType(TYPES.BOOLEAN);
                result.setConstantValue(false);
                return;
            }
        }

        // If we can cast both sides to a common type, it's fine
        if (result.setCommonType(left, right)) {
            return;
        }
        result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Can't evaluate polymorphic logical expression"));
    },

    ConditionalExpression: function (node, parent, context) {
        var consequent = context.getTypeInfo(node.consequent),
            alternate = context.getTypeInfo(node.alternate),
            test = context.getTypeInfo(node.test),
            result = ANNO(node);

        var testResult = test.getStaticTruthValue();
        if (testResult === true) {
            result.copyFrom(consequent);
        } else if (testResult === false) {
            result.copyFrom(alternate);
        } else {
            if (result.setCommonType(consequent, alternate)) {
                result.setDynamicValue();
            } else {
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Can't evaluate polymorphic conditional expression"))
            }
        }

    },
    ObjectExpression: function (node, parent, context) {
        var result = ANNO(node);
        var properties = {};
        node.properties.forEach(function (property) {
            var p = properties[property.key.name] = property.value.extra;
        });
        result.setType(TYPES.OBJECT);
        result.setProperties(properties);
    },

    Property: function (node, parent, context) {
        var result = ANNO(node);
        result.copyFrom(context.getTypeInfo(node.value));
    }
};

module.exports = function (context, ast, propagatedConstants, analyzer) {

    if (!ast)
        throw Error("No node to analyze");

    var controller = new estraverse.Controller();

    context.setConstants(propagatedConstants || null);

    controller.traverse(ast, {
        enter: function (node) {
            if (node.type == Syntax.VariableDeclaration) {
                context.setInDeclaration(true);
            }
        },
        leave: function (node, parent) {
            if (handlers.hasOwnProperty(node.type)) {
                return handlers[node.type].call(this, node, parent, context, analyzer);
            } else {
                console.log("unhandled", node.type);
            }
            return null;
        }
    });
    context.setConstants(null);
};

},{"../../base/common.js":140,"../../interfaces.js":188,"../../type-system/errors.js":201,"../../type-system/typeinfo":203,"../constants/evaluator.js":98,"assert":25,"escodegen":54,"estraverse":61}],117:[function(require,module,exports){
"use strict";

var Shade = require("../../../interfaces.js");
var TYPES = Shade.TYPES;

function Array(result, args) {
    if (args.length > 1 || !args[0].canNumber())
        throw new Error("Only one arg of type number allowed");

    var size;
    if (args[0].hasConstantValue())
        size = args[0].getConstantValue();

    if (size)
        return {
            type: "array",
            staticSize: size,
            elements: {
                extra: {
                    type: "any"
                }
            }
        };

    return {
        type: "array",
        elements: {
            extra: {
                type: "any"
            }
        }
    };

}

Array.prototype.length = {
    type: TYPES.INT,
    computeStaticValue: function (result, scope, objectOfInterest) {
        return objectOfInterest.getArraySize();
    }
};

Array.prototype.shape = {
    type: TYPES.ARRAY,
    elements: {
        extra: {
            type: TYPES.INT
        }
    }
}

exports = module.exports = Array;

},{"../../../interfaces.js":188}],118:[function(require,module,exports){
"use strict";

var TypeSystem = require("../../../type-system/type-system.js");
var Scope = require("../../../utils").Scope;
var Base = require("../../../base/index.js");

var InferenceScope = function (node, parentScope, opt) {
	Scope.call(this, node, parentScope, opt);
};

Base.createClass(InferenceScope, Scope, {
	registerGlobals: function () {
		this.declarePredefined("Math", TypeSystem.getPredefinedObject("Math"));
		this.declarePredefined("Vec2", TypeSystem.getPredefinedObject("Vec2"));
		this.declarePredefined("Vec3", TypeSystem.getPredefinedObject("Vec3"));
		this.declarePredefined("Vec4", TypeSystem.getPredefinedObject("Vec4"));
		this.declarePredefined("Mat3", TypeSystem.getPredefinedObject("Mat3"));
		this.declarePredefined("Mat4", TypeSystem.getPredefinedObject("Mat4"));
		this.declarePredefined("this", TypeSystem.getPredefinedObject("System"));
		this.declarePredefined("Space", TypeSystem.getPredefinedObject("Space"));
		this.declarePredefined("Object", TypeSystem.getPredefinedObject("Object"));
		this.declarePredefined("Shade", TypeSystem.getPredefinedObject("Shade"));
		this.declarePredefined("Array", TypeSystem.getPredefinedObject("Array"));
		this.declarePredefined("Texture", TypeSystem.getPredefinedObject("Texture"));
	}
});

exports.InferenceScope = InferenceScope;


},{"../../../base/index.js":142,"../../../type-system/type-system.js":202,"../../../utils":206}],119:[function(require,module,exports){
var tools = require("./vec_tools");

var Mat3 = function Mat3(node, arguments) {
    return tools.evaluateConstructor("3x3", node, arguments);
};

tools.attachMethods(Mat3.prototype, ["invert", "transpose"], "3x3", "3x3");
tools.attachElementAccessor(Mat3.prototype, 3);
tools.attachColumnAccessor(Mat3.prototype, 3);
tools.attachMulMethod(Mat3.prototype, "3x3", 3);

exports = module.exports = Mat3;

},{"./vec_tools":131}],120:[function(require,module,exports){
var tools = require("./vec_tools");

var Mat4 = function Mat4(node, arguments) {
    return tools.evaluateConstructor("4x4", node, arguments);
};

tools.attachMethods(Mat4.prototype, ["invert", "transpose"], "4x4", "4x4");
tools.attachElementAccessor(Mat4.prototype, 4);
tools.attachColumnAccessor(Mat4.prototype, 4);
tools.attachMulMethod(Mat4.prototype, "4x4", 4);

exports = module.exports = Mat4;

},{"./vec_tools":131}],121:[function(require,module,exports){
var Shade = require("../../../interfaces.js"),
	TYPES = Shade.TYPES,
	Base = require("../../../base/index.js"),
	Tools = require("./tools.js");



var notStatic = function () {
};

var evaluateStatic = function (name) {
	return function (result, args) {
		if (Tools.allArgumentsAreStatic(args)) {
			var callArgs = args.map(function (a) {
				return a.getConstantValue();
			});
			return Math[name].apply(null, callArgs);
		}
	}
}

var evaluateMethod = function (name, paramCount, returnType) {
	/**
	 * @param {Annotation} result
	 * @param {Array.<Annotation>} args
	 * @param {Context} ctx
	 */
	return function (result, args, ctx) {
		if (paramCount != -1) { // Arbitrary number of arguments
			if (!args || args.length != paramCount) {
				throw new Error("Invalid number of parameters for Math." + name + ", expected " + paramCount);
			}
		}
		for (var i = 0; i < paramCount; i++) {
			if (!args[i].canNumber()) {
				throw new Error("Parameter " + (i + 1) + " has invalid type for Math." + name + ", expected 'number', but got " + args[i].getType());
			}
		}

		return {
			type: returnType || TYPES.NUMBER
		};
	}
};

var MathObject = {
	random: {
		type: TYPES.FUNCTION,
		evaluate: function (node, args) {
			if (args.length)
				throw new Error("Math.random has no parameters.");
			return {
				type: TYPES.NUMBER
			}
		},
		computeStaticValue: notStatic
	},
	abs: {
		type: TYPES.FUNCTION,
		evaluate: function (result, args) {
			Tools.checkParamCount(result.node, "Math.abs", [1], args.length);
			var typeInfo = {};
			if (args[0].canNumber()) {
				typeInfo.type = args[0].getType();
			}
			else {
				Error.throwError(result.node, "InvalidType for Math.abs");
			}
			// TODO: Static value
			return typeInfo;
		},
		computeStaticValue: evaluateStatic("abs")
	},


	// Non-standard methods
	clamp: {
		type: TYPES.FUNCTION,
		evaluate: function (result, args) {
			Tools.checkParamCount(result.node, "Math.clamp", [3], args.length);

			if (args[1].canNumber() && args[2].canNumber()) {
				var typeInfo = {};
				if (args[0].canNumber()) {
					typeInfo.type = TYPES.NUMBER;
				}
				else if (args[0].isVector()) {
					typeInfo.type = args[0].getType();
					typeInfo.kind = args[0].getKind();
				}
				return typeInfo;
			}
			Error.throwError(result.node, "Math.clamp not supported with argument types: " + args.map(function (arg) {
				return arg.getTypeString();
			}).join(", "));
		},
		computeStaticValue: evaluateStatic("clamp")

	},
	smoothstep: {
		type: TYPES.FUNCTION,
		evaluate: function (result, args, ctx) {
			Tools.checkParamCount(result.node, "Math.smoothstep", [3], args.length);

			if (args.every(function (e) {
					return e.canNumber();
				})) {
				return {type: TYPES.NUMBER};
			}
			if (args.every(function (e) {
					return e.isVector();
				})) {
				if (!(args[0].equals(args[1]) && args[1].equals(args[2]))) {
					throwError(result.node, "Math.smoothstep: All arguments have to have the same type: " + args.map(function (arg) {
						return arg.getTypeString();
					}).join(", "));
				}
				;
				return {
					type: TYPES.OBJECT,
					kind: args[0].getKind()
				}

			}
			;
			Error.throwError(result.node, "Math.smoothstep not supported with argument types: " + args.map(function (arg) {
				return arg.getTypeString();
			}).join(", "));
		},
		computeStaticValue: evaluateStatic("smoothstep")
	},
	step: {
		type: TYPES.FUNCTION,
		evaluate: function (result, args, ctx) {
			Tools.checkParamCount(result.node, "Shade.step", [2], args.length);

			if (Tools.allArgumentsCanNumber(args)) {
				return {type: TYPES.NUMBER}
			}
			Error.throwError(result.node, "Shade.step not supported with argument types: " + args.map(function (arg) {
				return arg.getTypeString();
			}).join(", "));
		},
		computeStaticValue: evaluateStatic("step")
	},
	fract:  {
			type: TYPES.FUNCTION,
			evaluate: function (result, args, ctx) {
				Tools.checkParamCount(result.node, "Shade.fract", [1], args.length);

				if (Tools.allArgumentsCanNumber(args)) {
					return {type: TYPES.NUMBER}
				}
				Error.throwError(result.node, "Shade.step not supported with argument types: " + args.map(function (arg) {
					return arg.getTypeString();
				}).join(", "));
		},
		computeStaticValue: evaluateStatic("fract")
	},

	mix: {
		type: TYPES.FUNCTION,
		evaluate: function (result, args, ctx) {
			Tools.checkParamCount(result.node, "Math.mix", [3], args.length);

			var cnt = Tools.Vec.checkAnyVecArgument(result.node, "Math.mix", args[0]);

			var typeInfo = {};
			Base.extend(typeInfo, Tools.Vec.getType(cnt));

			if (!args[1].equals(args[0]))
				Error.throwError(result.node, "Math.mix types of first two arguments do no match: got " + args[0].getTypeString() +
				" and " + args[1].getTypeString());
			if (!args[2].canNumber())
				Error.throwError(result.node, "Math.mix third argument is not a number.");

			return typeInfo;
		},
		computeStaticValue: evaluateStatic("mix")
	},
	saturate: {
		type: TYPES.FUNCTION,
		evaluate: function (result, args, ctx) {
			Tools.checkParamCount(result.node, "Shade.saturate", [1], args.length);

			var typeInfo = {
				type: TYPES.NUMBER
			}
			var arg = args[0];
			if (!arg.canNumber()) {
				Error.throwError(result.node, "Math.saturate not supported with argument type: " + arg.getTypeString());
			}
			return typeInfo;
		},
		computeStaticValue: evaluateStatic("saturate")
	}
};

var MathConstants = ["E", "PI", "LN2", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2"];
var OneParameterNumberMethods = ["acos", "asin", "atan", "cos", "exp", "log", "round", "sin", "sqrt", "tan", "ceil", "floor"];
var OneParameterIntMethods = [];
var TwoParameterNumberMethods = ["atan2", "pow"];
var ArbitraryParameterNumberMethods = ["max", "min"];

MathConstants.forEach(function (constant) {
	MathObject[constant] = {type: TYPES.NUMBER, constantValue: Math[constant]};
});

OneParameterNumberMethods.forEach(function (method) {
	MathObject[method] = {
		type: TYPES.FUNCTION, evaluate: evaluateMethod(method, 1), computeStaticValue: evaluateStatic(method)
	};
});

TwoParameterNumberMethods.forEach(function (method) {
	MathObject[method] = {
		type: TYPES.FUNCTION, evaluate: evaluateMethod(method, 2), computeStaticValue: evaluateStatic(method)
	};
});

OneParameterIntMethods.forEach(function (method) {
	MathObject[method] = {
		type: TYPES.FUNCTION, evaluate: evaluateMethod(method, 1, TYPES.INT), computeStaticValue: evaluateStatic(method)
	};
});

ArbitraryParameterNumberMethods.forEach(function (method) {
	MathObject[method] = {
		type: TYPES.FUNCTION, evaluate: evaluateMethod(method, -1), computeStaticValue: evaluateStatic(method)
	};
});


module.exports = {
	name: "Math",
	properties: MathObject
};





},{"../../../base/index.js":142,"../../../interfaces.js":188,"./tools.js":127}],122:[function(require,module,exports){
var Obj = function Object() {
	return {type: "object"};
};

module.exports = Obj;

},{}],123:[function(require,module,exports){
var Shade = require("../../../interfaces.js"), TYPES = Shade.TYPES,
	KINDS = Shade.OBJECT_KINDS

var ShadeObject = {};

Object.keys(Shade.ColorClosures)
	.forEach(function(closureName) {
		var params = Shade.ColorClosures[closureName].input;
		ShadeObject[closureName] = {
			type: TYPES.FUNCTION,
			name: closureName,
			evaluate: function(node,
							   args /*, context, objectReference, root */) {
				for (var i = 0; i < params.length; i++) {
					if (i >= args.length) {
						if (params[i].defaultValue != undefined) {
							continue;
						}
						Shade.throwError(node,
										 "Argument " + (i + 1) + " of Shade."
											 + closureName
											 + " is required but not given.");
					} else {
						// TODO(ksons): Need a more generic canCastTo method in
						// type system
						switch (params[i].semantic) {
						case Shade.SEMANTICS.COLOR:
							if (!args[i].canColor()) {
								Shade.throwError(
									node,
									"Argument " + (i + 1) + " of Shade."
										+ closureName
										+ " must evaluate to a color, found "
										+ args[i].getTypeString());
							}
							break;
						case Shade.SEMANTICS.NORMAL:
							if (!args[i].canNormal()) {
								Shade.throwError(
									node,
									"Argument " + (i + 1) + " of Shade."
										+ closureName
										+ " must evaluate to a normal, found "
										+ args[i].getTypeString());
							}
							break;
						default:
							// TODO(ksons): More type checks
						}
					}
				}
				return {type: TYPES.OBJECT, kind: KINDS.COLOR_CLOSURE};

			}
		}
	});

ShadeObject.mix = {
	type: TYPES.FUNCTION,
	evaluate: function() {
		return {type: TYPES.OBJECT, kind: KINDS.COLOR_CLOSURE};
	}
};

module.exports = {
	name: "Shade",
	properties: ShadeObject
};
},{"../../../interfaces.js":188}],124:[function(require,module,exports){
var Shade = require("../../../interfaces.js");
var TYPES = Shade.TYPES;

var SpaceObject = {
    transformDirection: {
        type: TYPES.FUNCTION,
        evaluate: function (result, args) {
            if (args.length != 2)
                throw new Error("transformDirection expects 2 parameters.");
            return {
                type: TYPES.OBJECT,
                kind: "Vec3"
            };
        }
    },
    transformPoint: {
        type: TYPES.FUNCTION,
        evaluate: function (result, args) {
            if (args.length != 2)
                throw new Error("transformPoint expects 2 parameters.");
            return {
                type: TYPES.OBJECT,
                kind: "Vec3"
            };
        }
    },
    VIEW: {type: TYPES.NUMBER},
    WORLD: {type: TYPES.NUMBER}
};

module.exports = {
    name: "Space",
    properties: SpaceObject
};

},{"../../../interfaces.js":188}],125:[function(require,module,exports){
var Shade = require("../../../interfaces.js"),
    Base = require("../../../base/index.js"),
    Tools = require("./tools.js");
var TypeInfo = require("../../../type-system/typeinfo.js");


var TYPES = Shade.TYPES,
    KINDS = Shade.OBJECT_KINDS;



function allowNumberOrVector(name) {
    return function (node, args) {
        Tools.checkParamCount(node, name, [1], args.length);
        var arg = args[0];
        if (arg.canNumber()) {
            return {
                type: arg.getType()
            }
        }
        if (arg.isVector()) {
            return {
                type: TYPES.OBJECT,
                kind: arg.getKind()
            }
        }
        Shade.throwError(node, "IllegalArgumentError: first argument of this." + name + " is of type: " + arg.getTypeString());
    }
}


var DerivativesMethods = {
    fwidth: {
        type: TYPES.FUNCTION,
        evaluate: allowNumberOrVector("fwidth")
    },
    dx: {
        type: TYPES.FUNCTION,
        evaluate: allowNumberOrVector("dx")
    },
    dy: {
        type: TYPES.FUNCTION,
        evaluate: allowNumberOrVector("dy")
    }
};

var System = {
    name: "System",
    properties: {
        normalizedCoords: {
            type: TYPES.OBJECT,
            kind: "Vec3",
            derived: true
        },
        coords: {
            type: TYPES.OBJECT,
            kind: "Vec3",
            derived: true
        },
        height: {
            type: TYPES.INT,
            derived: true
        },
        width: {
            type: TYPES.INT,
            derived: true
        }
    },
    setDerivatives: function (available) {
        if (available) {
            Base.extend(System.properties, DerivativesMethods);
        } else {
            for (var methodName in DerivativesMethods) {
                delete System.properties[methodName];
            }
        }
    }
};

module.exports = System;

},{"../../../base/index.js":142,"../../../interfaces.js":188,"../../../type-system/typeinfo.js":203,"./tools.js":127}],126:[function(require,module,exports){
"use strict";

var Shade = require("../../../interfaces.js");
var TYPES = Shade.TYPES;
var tools = require("./vec_tools");

function Texture(result, args, ctx) {
    var width, height;
    if (args[0].hasConstantValue())
        width = args[0].getConstantValue();
    if (args[1].hasConstantValue())
        height = args[0].getConstantValue();

    return {
        type: "object",
        kind: "Texture",
        width: width,
        height: height
    };
    // Shade.throwError(result.node, "Construction of Textures is not supported." );
}

tools.attachMethods(Texture.prototype, ['sample2D'], 4, 2);

Texture.prototype.width = {
    type: TYPES.INT
};
Texture.prototype.height = {
    type: TYPES.INT
};

exports = module.exports = Texture;

},{"../../../interfaces.js":188,"./vec_tools":131}],127:[function(require,module,exports){
(function(ns){
    var utils = require("../../../interface/utils");
    var Base = require("../../../base/index.js");
    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        VecBase = require("../../../base/vec.js");

    var allArgumentsAreConstant = function (args) {
        return args.every(function (arg) {
            return arg.hasConstantValue()
        });
    }

    ns.allArgumentsCanNumber = function(args) {
        return args.every(function (arg) {
            return arg.canNumber();
        });
    }

    ns.checkParamCount = function(node, name, allowed, is) {
        if (allowed.indexOf(is) == -1) {
            Shade.throwError(node, "Invalid number of parameters for " + name + ", expected " + allowed.join(" or ") + ", found: " + is);
        }
    }

    ns.singleAccessor = function (name, obj, validArgCounts, staticValueFunction) {
        return {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, ctx, callObject) {
                ns.checkParamCount(result.node, name, validArgCounts, args.length);
                var typeInfo =  args.length ? obj : { type: TYPES.NUMBER };

                if (staticValueFunction && callObject.hasConstantValue() && args.every(function(a) {return a.hasConstantValue(); })) {
                    typeInfo.staticValue = staticValueFunction(callObject.getConstantValue(), args);
                }
                return typeInfo;
            }
        }
    };

    ns.extend = Base.extend;

    var Vec = {
        TYPES: {
            1: { type: TYPES.NUMBER },
            2: { type: TYPES.OBJECT, kind: "Vec2" },
            3: { type: TYPES.OBJECT, kind: "Vec3" },
            4: { type: TYPES.OBJECT, kind: "Vec4" }
        },
        getType: function (destVector) {
            return Vec.TYPES[destVector];
        },
        getConstantValue: function (methodName, result, ctx, callObject) {
            if (callObject.hasConstantValue()) {
                var object = callObject.getConstantValue();
                return object[methodName];
            }
        },
        checkAnyVecArgument: function(astNode, methodName, arg){
            var cnt;

            if(arg.canNumber()) cnt = 1;
            else if(arg.isOfKind("Vec2")) cnt = 2;
            else if(arg.isOfKind("Vec3")) cnt = 3;
            else if(arg.isOfKind("Vec4")) cnt = 4;
            else Shade.throwError(astNode, "Invalid parameter for " + methodName + ", type '" +
                    arg.getTypeString() + "' is not supported");
            return cnt;
        },
        checkVecArguments: function(methodName, vecSize, withEmpty, argStart, result, args){
            withEmpty = (withEmpty || vecSize == 0);
            var allowed = [];
            for(var i = withEmpty ? 0 : 1; i <= vecSize; ++i) allowed.push(i + argStart);
            ns.checkParamCount(result.node, methodName, allowed, args.length);

            if(withEmpty && args.length - argStart == 0)
                return;

            if(args.length - argStart== 1 && args[0].canNumber())
                return;

            var idx = 0;
            for(var i = argStart; idx < vecSize && i < args.length; ++i){
                var arg= args[i], cnt;
                if(arg.canNumber()) cnt = 1;
                else if(arg.isOfKind("Vec2")) cnt = 2;
                else if(arg.isOfKind("Vec3")) cnt = 3;
                else if(arg.isOfKind("Vec4")) cnt = 4;
                else if(arg.isOfKind("Mat3")) cnt = 9;
                else if(arg.isOfKind("Mat4")) cnt = 16;
                else Shade.throwError(result.node, "Invalid parameter for " + methodName + ", type '" + arg.getTypeString() + "' is not supported");
                idx += cnt;
            }

            if(idx < vecSize)
                Shade.throwError(result.node, "Invalid parameters for " + methodName + ", expected " + vecSize + " scalar values, got " + idx);
            else if(i < args.length){
                Shade.throwError(result.node, "Invalid parameters for " + methodName + ", too many parameters");
            }
        },

        vecEvaluate: function(objectName, methodName, destVecSize, srcVecSize, result, args, ctx, callObject){
            //console.log("vecEvaluate", objectName, methodName, destVecSize, srcVecSize, args)
            Vec.checkVecArguments(objectName + "." + methodName, srcVecSize, false, 0, result, args);

            var typeInfo = {};
            Base.extend(typeInfo, Vec.getType(destVecSize));

            return typeInfo;
        },
        anyVecArgumentEvaluate: function (methodName, result, args, ctx, callObject) {
            ns.checkParamCount(result.node, methodName, [1], args.length);
            var arg = args[0];

            var typeInfo = {};
            var cnt = Vec.checkAnyVecArgument(result.node, methodName, arg);
            Base.extend(typeInfo, Vec.getType(cnt));

            return typeInfo;
        },

        optionalZeroEvaluate: function(objectName, methodName, destVecSize, zeroDestVecSize, srcVecSize, result, args, ctx, callObject) {
            var qualifiedName = objectName + "." + methodName;
            var typeInfo = {};

            if(args.length == 0){
                Base.extend(typeInfo, Vec.getType(zeroDestVecSize));
            }
            else{
                Vec.checkVecArguments(qualifiedName, srcVecSize, true, 0, result, args);
                Base.extend(typeInfo, Vec.getType(destVecSize));
            }
            return typeInfo;
        },

        swizzleEvaluate: function(objectName, vecSize, swizzle, withSetter, result, args, ctx, callObject) {
            if(withSetter){
                return Vec.optionalZeroEvaluate(objectName, swizzle, vecSize, swizzle.length, swizzle.length,
                    result, args, ctx, callObject);
            }
            else{
                return Vec.vecEvaluate(objectName, swizzle, swizzle.length, 0, result, args, ctx, callObject);
            }
        },
        swizzleOperatorEvaluate: function(objectName, vecSize, swizzle, operator, result, args, ctx, callObject) {
            return Vec.vecEvaluate(objectName, swizzle + operator, vecSize, swizzle.length, result, args, ctx, callObject);
        },
        getSwizzleEvaluate: function(objectName, vecSize, swizzle, withSetter){
            return  {
                type: TYPES.NUMBER,
                evaluate: Vec.swizzleEvaluate.bind(null, objectName, vecSize, swizzle, withSetter),
                computeStaticValue: Vec.getConstantValue.bind(null, swizzle)
            }
        },
        getSwizzleOperatorEvaluate: function(objectName, vecSize, swizzle, operator){
            return  {
                type: TYPES.FUNCTION,
                evaluate: Vec.swizzleOperatorEvaluate.bind(null, objectName, vecSize, swizzle, operator),
                computeStaticValue: Vec.getConstantValue.bind(null, swizzle + operator)
            }
        },
        attachSwizzles: function (instance, objectName, vecLength) {
            var utils = require("../../../interface/utils");

            utils.attachSwizzles(2, function (swizzle) {
                Object.defineProperty(instance, swizzle.join(""), {
                    get: (function (swizzle) {
                        return function () {
                            return  {
                                type: TYPES.NUMBER,
                                computeStaticValue: Vec.getConstantValue.bind(null, swizzle)
                            }
                        }
                    })(swizzle)
                });

                return  {
                    type: TYPES.NUMBER,
                    evaluate: Vec.swizzleEvaluate.bind(null, objectName, vecLength, swizzle),
                    computeStaticValue: Vec.getConstantValue.bind(null, swizzle)
                }
            });
        },
        attachVecMethods: function(instance, objectName, destVecSize, srcVecSize, methodNames){
            for(var i = 0; i < methodNames.length; ++i){
                    var methodName = methodNames[i];
                    instance[methodName] = {
                        type: TYPES.FUNCTION,
                        evaluate: Vec.vecEvaluate.bind(null, objectName, methodName, destVecSize, srcVecSize)
                    }
            }
        },

        getConstantValueFromConstructor: function(objectName, args){
            var argArray = [];
            var isStatic = true;
            args.forEach(function (param) {
                isStatic = isStatic && param.hasConstantValue();
                if (isStatic)
                    argArray.push(param.getConstantValue());
            });

            if (isStatic) {
                var v = new Shade[objectName]();
                Shade[objectName].apply(v, argArray);
                return v;
            }
            return undefined;
        },

        constructorEvaluate: function(objectName, vecSize) {
			var constructor = function (result, args) {
				Vec.checkVecArguments(objectName, vecSize, true, 0, result, args);
				var result = Base.extend({}, Vec.getType(vecSize));
				result.constantValue = Vec.getConstantValueFromConstructor(objectName, args);
				return result;
			}
			constructor.proto = {};
			return constructor;
		}


    };

    var Mat = {
        TYPES: {
            "Mat3": { type: { type: TYPES.OBJECT, kind: KINDS.MATRIX3 }, cols: 3, rows: 3 },
            "Mat4": { type: { type: TYPES.OBJECT, kind: KINDS.MATRIX4 }, cols: 4, rows: 4 }
        },
        getType: function(matName){
            return Mat.TYPES[matName].type;
        },
        getVecSize: function(matName){
            return Mat.TYPES[matName].cols * Mat.TYPES[matName].rows;
        },
        checkMatArguments: function(methodName, matName, withEmpty, result, args){
            if(args.length == 1 && (args[0].isOfKind(KINDS.MATRIX3) || args[0].isOfKind(KINDS.MATRIX4)))
                return;

            for(var i = 0; i < args.length; ++i){
                if(args[i].isOfKind(KINDS.MATRIX3) || args[i].isOfKind(KINDS.MATRIX4))
                    Shade.throwError(result.node, "Invalid parameter for " + methodName + ": Constructing Matrix from Matrix can only take one argument");
            }
            Vec.checkVecArguments(methodName, Mat.getVecSize(matName), withEmpty, 0, result, args);
        },

        matEvaluate: function(matName, methodName, result, args, ctx, callObject){
            Mat.checkMatArguments(matName + "." + methodName, matName, false, result, args);

            var typeInfo = {};
            Base.extend(typeInfo, Mat.getType(matName));

            return typeInfo;
        },

        matConstructorEvaluate: function(matName, result, args, ctx){
            Mat.checkMatArguments(matName, matName, true, result, args);
            return Vec.getConstructorTypeInfo(matName, Mat.getVecSize(matName), Mat.getType(matName), result, args);
        },

        attachMatMethods: function(instance, matName, methodNames){
            for(var i = 0; i < methodNames.length; ++i){
                var methodName = methodNames[i];
                instance[methodName] = {
                    type: TYPES.FUNCTION,
                    evaluate: Mat.matEvaluate.bind(null, matName, methodName)
                }
            }
        },
        colEvaluate: function(matName, result, args, ctx, callObject) {
            var qualifiedName = matName + ".col";
            var typeInfo = {};

            var cols = Mat.TYPES[matName].cols, rows = Mat.TYPES[matName].rows;

            if(args.length > 1){
                Vec.checkVecArguments(qualifiedName, rows, true, 1, result, args);
                Base.extend(typeInfo, Mat.getType(matName));
            }
            else{
                ns.checkParamCount(result.node, qualifiedName, [1], args.length);
                Base.extend(typeInfo, Vec.getType(rows));
            }
            if(!args[0].canNumber()){
                Shade.throwError(result.node, "Invalid parameter for " + qualifiedName + ", first parameter must be a number.");
            }

            // TODO: Vec.getConstantValue(typeInfo, "col", args, callObject);

            return typeInfo;
        }

    }

    ns.Vec = Vec;
    ns.Mat = Mat;
    ns.allArgumentsAreStatic = allArgumentsAreConstant;


}(exports));

},{"../../../base/index.js":142,"../../../base/vec.js":143,"../../../interface/utils":186,"../../../interfaces.js":188}],128:[function(require,module,exports){
var tools = require("./vec_tools");

var Vec2 = function Vec2(result, args) {
	return tools.evaluateConstructor(2, result, args);
};

tools.attachSwizzles(Vec2.prototype, 2);
tools.attachMethods(Vec2.prototype, ["add", "sub", "mul", "div", "mod"], 2, 2);
tools.attachMethods(Vec2.prototype, ["dot"], 1, 2);
tools.attachMethods(Vec2.prototype, ["normalize", "flip"], 2, 0);
tools.attachMethods(Vec2.prototype, ["length"], 1, 0);

exports = module.exports = Vec2;

},{"./vec_tools":131}],129:[function(require,module,exports){
var tools = require("./vec_tools");

var Vec3 = function Vec3(result, args) {
	return tools.evaluateConstructor(3, result, args);
};

tools.attachSwizzles(Vec3.prototype, 3);
tools.attachMethods(Vec3.prototype, ["add", "sub", "mul", "div", "mod", "reflect", "cross"], 3, 3);
tools.attachMethods(Vec3.prototype, ["dot"], 1, 3);
tools.attachMethods(Vec3.prototype, ["normalize", "flip"], 3, 0);
tools.attachMethods(Vec3.prototype, ["length"], 1, 0);

Vec3.prototype.refract = function (result, args) {
	if (args.length < 2)
		Shade.throwError(result.node, "Not enough parameters for refract.");

	var eta = args.pop();
	if (!eta || !eta.canNumber())
		Shade.throwError(result.node, "Invalid parameter for refract, expected a number got " + eta.getTypeString());

	//Tools.Vec.checkVecArguments("Vec3.refract", 3, false, 0, result, args);

	return {
		type: "object",
		kind: "Vec3"
	};
};

exports = module.exports = Vec3;

},{"./vec_tools":131}],130:[function(require,module,exports){
var tools = require("./vec_tools");

var Vec4 = function Vec4(result, args) {
	return tools.evaluateConstructor(4, result, args);
};

tools.attachSwizzles(Vec4.prototype, 4);
tools.attachMethods(Vec4.prototype, ["add", "sub", "mul", "div", "mod"], 4, 4);
tools.attachMethods(Vec4.prototype, ["dot"], 1, 4);
tools.attachMethods(Vec4.prototype, ["normalize", "flip"], 4, 0);
tools.attachMethods(Vec4.prototype, ["length"], 1, 0);

exports = module.exports = Vec4;

},{"./vec_tools":131}],131:[function(require,module,exports){
var utils = require("../../../interface/utils");
var Base = require("../../../base/index.js");
var Shade = require("../../../interfaces.js");
var TYPES = Shade.TYPES;
var Vec2 = require("../../../interfaces").Vec2;
var Vec3 = require("../../../interfaces").Vec3;
var Vec4 = require("../../../interfaces").Vec4;
var Mat2 = require("../../../interfaces").Mat2;
var Mat3 = require("../../../interfaces").Mat3;
var Mat4 = require("../../../interfaces").Mat4;

var sizeTypeMap = {
	1: {type: TYPES.NUMBER},
	2: {type: TYPES.OBJECT, kind: "Vec2"},
	3: {type: TYPES.OBJECT, kind: "Vec3"},
	4: {type: TYPES.OBJECT, kind: "Vec4"},
    "2x2": {type: TYPES.OBJECT, kind: "Mat2"},
    "3x3": {type: TYPES.OBJECT, kind: "Mat3"},
    "4x4": {type: TYPES.OBJECT, kind: "Mat4"}
};

var sizeConstructorMap = {
    2: Vec2,
    3: Vec3,
    4: Vec4,
    "2x2": Mat2,
    "3x3": Mat3,
    "4x4": Mat4
};

var kindSizeMap = {
    "Vec2": 2,
    "Vec3": 3,
    "Vec4": 4
};

function attachSwizzles(prototype, vecSize) {
	utils.attachSwizzles(vecSize, function(swizzle, idx) {
        Object.defineProperty(prototype, swizzle.join(""), {
            get: (function(swizzle) {
                return function() {
                    return Base.extend(sizeTypeMap[swizzle.length], {
                        computeStaticValue: getConstantValue.bind(null, swizzle.join(""))
                    });
                }
            })(swizzle)
        });
	});
}

function getConstantValue(methodName, result, ctx, callObject) {
	if (callObject.hasConstantValue())
		return callObject.getConstantValue()[methodName];
}

function attachMethods(prototype, methodNames, resultSize, argSize){
    for(var i = 0; i < methodNames.length; ++i) {
        var methodName = methodNames[i];
        prototype[methodName] = {
            type: TYPES.FUNCTION,
            evaluate: evaluate.bind(null, methodName, resultSize, argSize)
        }
    }
}

function evaluate(methodName, resultVecSize, argVecSize, result, args, ctx, callObject) {
    validateArguments();
    return Base.extend({}, sizeTypeMap[resultVecSize]);
}

function validateArguments(argVecSize, resulVecSize) {

}

function evaluateConstructor(size, result, args) {
    validateArguments();
    result = Base.extend({}, sizeTypeMap[size]);

    if (args.every(function (arg) { return arg.hasConstantValue() }))
        result.constantValue = new sizeConstructorMap[size](args.map(function (arg) { return arg.getConstantValue()}));

    return result;
}

// only square matrices
function attachElementAccessor(prototype, columnSize) {
    for (var rowIdx = 1; rowIdx <= columnSize; ++rowIdx)
        for (var columnIdx = 1; columnIdx <= columnSize; ++columnIdx)
            Object.defineProperty(
                prototype, "m" + rowIdx + "" + columnIdx, {
                    get: (function(rowIdx, columnIdx) {
                        return function () {
                            return Base.extend({type: TYPES.NUMBER}, {
                                computeStaticValue: getConstantValue.bind(null, "m" + rowIdx + "" + columnIdx)
                            });
                        }
                    })(rowIdx - 1, columnIdx - 1)
                });
}

function attachColumnAccessor(prototype, columnSize) {
    for (var columnIdx = 1; columnIdx <= columnSize; ++columnIdx) {
        Object.defineProperty(prototype, "c" + columnIdx, {
            get: (function(columnIdx) {
                return function() {
                    return Base.extend(sizeTypeMap[columnSize], {
                        computeStaticValue: getConstantValue.bind(null, "c" + columnIdx)
                    });
                }
            })(columnIdx - 1)
        });
    }
}

function attachMulMethod(prototype, size, columnSize) {
    prototype.mul = {
        type: TYPES.FUNCTION,
        evaluate: function (result, args) {
            if (args.length === 1) {
                if (args[0].getType() !== TYPES.OBJECT)
                    throw "nope";
                if (args[0].getKind() === sizeTypeMap[size].kind)
                    return sizeTypeMap[size];
            }

            var count = args.reduce(function (count, arg) {
                if (arg.getType() === "object")
                    return count + kindSizeMap[arg.getKind()];

                if (arg.canNumber())
                    return count + 1;

                throw "Cannot";
            }, 0);

            if (count !== columnSize)
                throw "Nope";

            return sizeTypeMap[count];
        }
    }
}

exports.attachSwizzles = attachSwizzles;
exports.attachMethods = attachMethods;
exports.evaluateConstructor = evaluateConstructor;
exports.attachElementAccessor = attachElementAccessor;
exports.attachColumnAccessor = attachColumnAccessor;
exports.attachMulMethod = attachMulMethod;
},{"../../../base/index.js":142,"../../../interface/utils":186,"../../../interfaces":188,"../../../interfaces.js":188}],132:[function(require,module,exports){
(function (ns) {

    // dependencies
    var assert = require('assert');
    var esgraph = require('esgraph');
    var worklist = require('analyses');
    var common = require("../../base/common.js");
    var Base = require("../../base/index.js");
    var codegen = require('escodegen');
    var annotateRight = require("./infer_expression.js");
    var InferenceScope = require("./registry/").InferenceScope;
    var System = require("./registry/system.js");
    var annotate = require("./../../utils").annotate;
    var walk = require('estraverse');
    var astTools = require("../utils/ast");
    var Shade = require("../../interfaces.js");
    var walkes = require('walkes');
    var validator = require('../validation');
    var TypeInfo = require("../../type-system/typeinfo.js");

    // shortcuts
    var Syntax = common.Syntax;
    var Set = worklist.Set;








    function findConstantsFor(ast, names, constantVariables) {
        var result = new Set(), annotation, name, formerValue;
        constantVariables = constantVariables ? constantVariables.values() : [];

        walkes(ast, {
            AssignmentExpression: function(recurse) {


                if (this.left.type != Syntax.Identifier) {
                    Shade.throwError(ast, "Can't find constant for computed left expression");
                }
                name = this.left.name;
                if(names.has(name)) {
                    annotation = annotate(this.right);
                    if(annotation.hasConstantValue()) {
                        switch(this.operator) {
                            case "=":
                                result.add({ name: name, constant: TypeInfo.copyStaticValue(annotation)});
                                break;
                            case "-=":
                            case "+=":
                            case "*=":
                            case "/=":
                                formerValue = constantVariables.filter(function(v){ return v.name == name; });
                                if(formerValue.length) {
                                    var c = formerValue[0].constant, v;
                                    switch(this.operator) {
                                        case "+=":
                                            v = c + TypeInfo.copyStaticValue(annotation);
                                            break;
                                        case "-=":
                                            v = c - TypeInfo.copyStaticValue(annotation);
                                            break;
                                        case "*=":
                                            v = c * TypeInfo.copyStaticValue(annotation);
                                            break;
                                        case "/=":
                                            v = c / TypeInfo.copyStaticValue(annotation);
                                            break;
                                    }
                                    result.add({ name: name, constant: v});
                                }
                                break;
                            default:
                                assert(!this.operator);
                        }

                    }
                }
                recurse(this.right);
            },

            VariableDeclarator: function(recurse) {
                name = this.id.name;
                if (this.init && names.has(name)) {
                    annotation = annotate(this.init);
                    if(annotation.hasConstantValue()) {
                        result.add({ name: name, constant: TypeInfo.copyStaticValue(annotation)});
                    }
                }
                recurse(this.init);
            },

            UpdateExpression: function(recurse) {
                if(this.argument.type == Syntax.Identifier) {
                    name = this.argument.name;
                    annotation = annotate(this);
                    if(annotation.hasConstantValue()) {
                        var value = TypeInfo.copyStaticValue(annotation);
                        if (!this.prefix) {
                            value = this.operator == "--" ? --value : ++value;
                        }
                        result.add({ name: name, constant: value});
                    }
                }
            }
        });

        return result;
    }



    /**
     *
     * @param ast
     * @param {AnalysisContext} context
     * @param {*} opt
     * @constructor
     */
    var TypeInference = function (ast, context, opt, analyzer) {
        opt = opt || {};
        this.analyzer = analyzer;
        this.context = context;

        this.propagateConstants = opt.propagateConstants || false;
    };

    Base.extend(TypeInference.prototype, {

        /**
         * @param {*} ast
         * @param {*} opt
         * @returns {*}
         */
        inferBody: function (ast, opt) {
             var cfg = esgraph(ast, { omitExceptions: true }),
                 context = this.context,
                 propagateConstants = this.propagateConstants;

        //console.log("infer body", cfg)
        var self = this
        var result = worklist(cfg,
            /**
             * @param {Set} input
             * @this {FlowNode}
             * @returns {*}
             */
                function (input) {

                if (!this.astNode || this.type) // Start and end node do not influence the result
                    return input;

                //console.log("Analyze", codegen.generate(this.astNode), this.astNode.type);

                // Local
                if(propagateConstants) {
                    this.kill = this.kill || astTools.findVariableDefinitions(this.astNode, true);
                }

                annotateRight(context, this.astNode, propagateConstants ? input : null, self.analyzer);

                this.decl = this.decl || context.declare(this.astNode);

                //context.computeConstants(this.astNode, input);

                if(!propagateConstants) {
                    return input;
                }



                var filteredInput = null, generate = null;
                if (this.kill.size) {
                    // Only if there's an assignment, we need to generate
                    generate = findConstantsFor(this.astNode, this.kill, propagateConstants ? input : null);
                    var that = this;
                    filteredInput = new Set(input.filter(function (elem) {
                            return !that.kill.some(function(tokill) { return elem.name == tokill });
                    }));
                }

                var result = Set.union(filteredInput || input, generate);
               // console.log("input:", input);
               // console.log("kill:", this.kill);
               // console.log("generate:", generate);
               // console.log("filteredInput:", filteredInput);
               // console.log("result:", result);
                return result;
            }
            , {
                direction: 'forward',
                merge: worklist.merge(function(a,b) {
                    if (!a && !b)
                        return null;
                    //console.log("Merge", a && a.values(), b && b.values())
                    var result = Set.intersect(a, b);
                    //console.log("Result", result && result.values())
                    return result;
                }),
                equals: function (a, b) {
                    if (a.size !== b.size)
                        return false;

                    var bvalues = b.values();
                    return a.values().every(function (v) {
                        return bvalues.some(function (bv) {
                            return bv.name === v.name && bv.constant === v.constant;
                        });
                    })
                }
            });
        //Tools.printMap(result, cfg);
        return ast;
        }

    });




    /**
     *
     * @param ast
     * @param {AnalysisContext} context
     * @param opt
     * @returns {*}
     */
    var inferProgram = function (ast, context, opt, analyzer) {
        opt = opt || {};
        //var globalScope = createGlobalScope(ast);
        //registerSystemInformation(globalScope, opt);

        var typeInference = new TypeInference(ast, context, opt, analyzer);
        var result = typeInference.inferBody(ast, opt);


        return result;
    };

    ns.infer = inferProgram;

}(exports));

},{"../../base/common.js":140,"../../base/index.js":142,"../../interfaces.js":188,"../../type-system/typeinfo.js":203,"../utils/ast":137,"../validation":139,"./../../utils":206,"./infer_expression.js":116,"./registry/":118,"./registry/system.js":125,"analyses":46,"assert":25,"escodegen":54,"esgraph":58,"estraverse":61,"walkes":95}],133:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var traverse = require('estraverse'),
        common = require("./../../base/common.js"),
        Shade = require("../../interfaces.js"),
        codegen = require('escodegen'),
        Set = require('analyses').Set,
        astTools = require('../utils/ast.js');


    // Shortcuts
    var Syntax = traverse.Syntax, ANNO = common.ANNO;

    function toMap(uniformSet) {
        var result = {};
        uniformSet && uniformSet.forEach(function(entry) {
            result[entry.name] = {
                dependencies: entry.dependencies,
                costs: entry.costs
            };
        });
        return result;
    }

    var allowedMemberCalls = ["Math", "Shade"];

    ns.generateUniformExpressions = function (ast, input) {

        var uniformVariables = toMap(input);

        traverse.traverse(ast, {
            leave: function (node, parent) {
                var result = ANNO(node);
                result.clearUniformDependencies();

                switch (node.type) {

                    // New uniforms can come via the env object
                    case Syntax.MemberExpression:
                        var propertyAnnotation = ANNO(node.property);
                        if (propertyAnnotation.getSource() == Shade.SOURCES.UNIFORM) {
                            result.setUniformDependencies(node.property.name);
                            result.setUniformCosts(0);
                            break;
                        }
                        if (ANNO(node.object).isUniformExpression() && propertyAnnotation.getType() !== "function") {
                            result.setUniformDependencies(ANNO(node.object).getUniformDependencies());
                            result.setUniformCosts(1);
                            break;
                        }

                        break;

                    case Syntax.Identifier:
                        // Not a variable
                        if(!astTools.isVariableReference(node, parent))
                            return;

                        // Not a variable on the right side
                        if(parent.type == Syntax.AssignmentExpression && parent.left == node)
                            return;

                        if(uniformVariables.hasOwnProperty(node.name)) {
                            var propagatedUniform = uniformVariables[node.name];
                            result.setUniformDependencies(propagatedUniform.dependencies);
                            result.setUniformCosts(propagatedUniform.costs);
                        }

                        break;
                    case Syntax.BinaryExpression:
                         var left = ANNO(node.left),
                             right = ANNO(node.right);

                        if (left.canUniformExpression() && right.canUniformExpression()) {
                            result.setUniformDependencies(left.getUniformDependencies(), right.getUniformDependencies());
                            result.setUniformCosts(left.getUniformCosts() + right.getUniformCosts() + 2);
                        }
                        break;
                    case Syntax.UnaryExpression:
                        var argument = ANNO(node.argument);

                        if(argument.isUniformExpression()) {
                            result.setUniformDependencies(argument.getUniformDependencies());
                            result.setUniformCosts(argument.getUniformCosts() + 1);
                        }
                        break;
                    case Syntax.CallExpression:
                        if(node.callee.type == Syntax.MemberExpression) {
                            var object = node.callee.object;
                            var args = node.arguments.map(function(arg) { return ANNO(arg);});

                            if(object.name && ~allowedMemberCalls.indexOf(object.name)) {
                                var dependencies = mergeUniformDependencies(args);
                                if(dependencies) {
                                    result.setUniformDependencies(dependencies);
                                    var costs = args.reduce(function(prev, next) { return prev + next.getUniformCosts(); }, 1);
                                    result.setUniformCosts(costs)
                                }
                            } else {
                                // TODO: CleanCode: Merge with above as soon as all differences are clear
                                var objectAnno = ANNO(object);
                                if(objectAnno.isUniformExpression()) {
                                    var dependencies = mergeUniformDependencies(args);
                                    if (dependencies || args.length == 0) {
                                        result.setUniformDependencies(dependencies, objectAnno.getUniformDependencies());
                                        var costs = args.reduce(function(prev, next) { return prev + next.getUniformCosts(); }, 1);
                                        result.setUniformCosts(costs)
                                    }
                                }  else {
                                    // console.log("No exp:", Shade.toJavaScript(node))
                                }
                            }
                        }
                        break;
                    case Syntax.NewExpression:
                        if(node.callee.type == Syntax.Identifier && node.callee.name !== "Array") {
                            var args = node.arguments.map(function(arg) { return ANNO(arg);});
                            var dependencies = mergeUniformDependencies(args);
                            if(dependencies) {
                                result.setUniformDependencies(dependencies);
                                var costs = args.reduce(function(prev, next) { return prev + next.getUniformCosts(); }, 1);
                                result.setUniformCosts(costs);
                            }
                        }
                        break;

                }
            }
        });

        var result = new Set();
        switch (ast.type) {
            case Syntax.AssignmentExpression:
                var right = ANNO(ast.right);
                if (right.isUniformExpression()) {
                    result.add({ name: ast.left.name, dependencies: right.getUniformDependencies(), costs: right.getUniformCosts() });
                }
                break;
            case Syntax.VariableDeclaration:
                ast.declarations.forEach(function (declaration) {
                    if (declaration.init) {
                        var init = ANNO(declaration.init);
                        if (init.isUniformExpression()) {
                            result.add({ name: declaration.id.name, dependencies: init.getUniformDependencies(), costs: init.getUniformCosts() });
                        }
                    }
                });
                break;
        }
        return result;
    }
    
    
    function atLeastOneArgumentIsUniform(args) {
        var allUniformOrStatic = true,
            oneUniform = false;

        for(var i = 0; i < args.length && allUniformOrStatic; i++) {
            var thisUniform = args[i].isUniformExpression();
            allUniformOrStatic = allUniformOrStatic && (thisUniform || args[i].hasConstantValue());
            oneUniform = oneUniform || thisUniform;
        }
        return allUniformOrStatic && oneUniform;
    };

    function mergeUniformDependencies(args) {
        var uniformDependencies = null;

        if(atLeastOneArgumentIsUniform(args)) {
            uniformDependencies = []
            for(var i = 0; i< args.length;i++) {
                if (args[i].isUniformExpression())        {
                    uniformDependencies = uniformDependencies.concat(args[i].getUniformDependencies());
                }
            }
        }
        return uniformDependencies;
    };

}(exports));

},{"../../interfaces.js":188,"../utils/ast.js":137,"./../../base/common.js":140,"analyses":46,"escodegen":54,"estraverse":61}],134:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var common = require("../../base/common.js");
    var esgraph = require('esgraph');
    var worklist = require('analyses');
    var evaluator = require('./evaluator.js');
    var transformer = require('./uniformTransformer.js');
    var astTools = require("../utils/ast");
    var assert = require("assert");

    // Shortcuts
    var Set = worklist.Set,
        Syntax = common.Syntax;

    /**
     * @param root
     * @param opt
     * @constructor
     */
    function UniformAnalysis(root, opt) {
        this.root = root;
        this.opt = opt || {};
    }


    UniformAnalysis.prototype = {
        analyzeBody: function (body) {
            var cfg = esgraph(body, { omitExceptions: true });


            var result = worklist(cfg,
            /**
             * @param {Set} input
             * @this {FlowNode}
             * @returns {*}
             */
                function (input) {

                if (!this.astNode || this.type) // Start and end node do not influence the result
                    return input;

                var generate = evaluator.generateUniformExpressions(this.astNode, input);
                this.kill = this.kill || astTools.findVariableDefinitions(this.astNode, true);

                var filteredInput = input;
                if (this.kill.size) {
                    var that = this;
                    filteredInput = new Set(input.filter(function (elem) {
                            return !that.kill.some(function(tokill) { return elem.name == tokill });
                    }));
                }

                var result = Set.union(filteredInput, generate);

//                console.log("input:", input);
//                console.log("kill:", this.kill);
//                console.log("generate:", generate);
//                console.log("filteredInput:", filteredInput);
//                //console.log("result:", result);
                return result;
                }, {
                direction: 'forward',
                merge: worklist.merge(function(a,b) {
                    if (!a && !b)
                        return null;
                    return Set.intersect(a, b);
                })
            });
            //Tools.printMap(result, cfg);

        },

        transform: function () {
            var result = transformer.transform(this.root, this.opt);
            return result;
        }
    };


    ns.extract = function (ast, opt) {

        assert(ast.type == Syntax.Program || ast.type == Syntax.BlockStatement);

        var analysis = new UniformAnalysis(ast, opt);

        // Propagate and analyze
        analysis.analyzeBody(ast.type == Syntax.Program ? ast.body : ast);

        // Transform
        return analysis.transform();
    };


}(exports));

},{"../../base/common.js":140,"../utils/ast":137,"./evaluator.js":133,"./uniformTransformer.js":136,"analyses":46,"assert":25,"esgraph":58}],135:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var annotate = require("../../utils").annotate;

    function getConstructor(kind){
        switch(kind){
            case "Vec2": return "Shade.Vec2"; break;
            case "Vec3": return "Shade.Vec3"; break;
            case "Vec4": return "Shade.Vec4"; break;
            case "Mat3": return "Shade.Mat3"; break;
            case "Mat4": return "Shade.Mat4"; break;
            default: throw "Unsupported object kind in uniform expression argument: " + kind;
        }
    }


    function isMathCall(node) {
        return (node.callee.type === Syntax.MemberExpression && node.callee.object.type === Syntax.Identifier && node.callee.object.name === "Math");
    }

    function isVecMathCall(node) {
        if(!isMathCall(node))
            return false;
        var firstArgument = annotate(node.arguments[0]);
        return firstArgument.isVector();
    }

    var leaveVisitor = function (node, parent, variables, controller) {
        if (node.type == Syntax.MemberExpression) {
            var object = annotate(node.object);
            if (node.object.type == Syntax.Identifier && object.isUniformExpression()) {
                if(variables.hasOwnProperty(node.object.name)) {
                //console.log("Found: " + node.object.name, variables[node.object.name]);
                    node.object = variables[node.object.name].code;
                }
            }
            if (object.isGlobal() && node.property.type == Syntax.Identifier) {
                var property = annotate(node.property);

                if(property.isObject()){
                    // Is the accessed parameter is a vector or matrix , we have to
                    // wrap the typed array in the respective constructor
                    var constructor = getConstructor(property.getKind());
                    return {
                        type: Syntax.NewExpression,
                        callee: { type: Syntax.Identifier, name: constructor},
                        arguments:  [node]
                    }
                }
                else if((parent == node) || parent.type != Syntax.MemberExpression){
                    // Is the accessed parameter is a scalar value, we have to
                    // access the first entry of the input array
                    return {
                        type: Syntax.MemberExpression,
                        computed: true,
                        object: node,
                        property: {
                            type: Syntax.Literal,
                            value: 0
                        }
                    }
                }
            }
        }

        if (node.type == Syntax.CallExpression) {
            if (isVecMathCall(node)) {
                node.callee.object.name = "Math";
            }
        }


        if (node.type == Syntax.Identifier) {
            if (~[Syntax.MemberExpression, Syntax.FunctionDeclaration, Syntax.VariableDeclarator].indexOf(parent.type))
                return;

            if (parent.type == Syntax.NewExpression && parent.callee == node)
                return;

            // Not a variable on the right side
            if (parent.type == Syntax.AssignmentExpression && parent.left == node)
                return;

            if(variables.hasOwnProperty(node.name)) {
                //console.log("Found: " + node.name, this[node.name]);
                var code = variables[node.name].code;
                return code;
            }
        }

        if (node.type == Syntax.NewExpression) {
            if (node.callee.type == Syntax.Identifier) {
                var name = node.callee.name;
                switch(name) {
                    case "Vec2":
                    case "Vec3":
                    case "Vec4":
                        node.callee.name = "Shade." + name;
                        break;

                }
            }
        }

        if (node.type == Syntax.ReturnStatement) {
            var anno = annotate(node.argument);
            if(anno.isObject()){
                node.argument = { type: Syntax.CallExpression,
                    callee: {
                        type: Syntax.MemberExpression,
                        object: node.argument,
                        property: {type: Syntax.Identifier,
                            name: "_toFloatArray"
                        }
                    },
                    arguments: []
                };
                return node;
            }
        }
        }

    ns.transformUniformSetter = function (ast, variables) {
        return walk.replace(ast, { leave: function(node, parent) {
            return leaveVisitor(node, parent, variables, this);
        }});
    };


}(exports));

},{"../../utils":206,"estraverse":61}],136:[function(require,module,exports){
(function(ns){

    // Dependencies
    var traverse = require('estraverse'),
        common = require("./../../base/common.js"),
        codegen = require('escodegen'),
        setterGenerator = require('./uniformSetterTransformation.js');

    // Shortcuts
    var ANNO = common.ANNO,
        Syntax = traverse.Syntax;
    var counter = 1;
    function getCounter() {
        return counter++;
    }
    var UniformTransformer = function(opt){
        opt = opt || {};

        this.uniformExpressions = {};
        this.activeUniformVariables = {};
    };

    UniformTransformer.prototype = {
        transform: function(ast) {
            var that = this;
            return traverse.replace(ast, {
                enter: function(node) {
                    var anno = ANNO(node);
                    if(anno.isUniformExpression() && shouldGenerateUniformExpression(node, anno)) {
                        return that.generateUniformExpression(node);
                    }
                    if (node.type == Syntax.AssignmentExpression || (node.type == Syntax.VariableDeclarator && node.init)) {
                        var right = ANNO(node.right || node.init);
                        var leftNode = node.left || node.id;
                        if (right.isUniformExpression() && leftNode.type == Syntax.Identifier) {
                            that.activeUniformVariables[leftNode.name] = {
                                code: setterGenerator.transformUniformSetter(node.right || node.init, that.activeUniformVariables),
                                dependencies: right.getUniformDependencies()
                            }
                        }
                    }
                }
            });
        },
        getUniformExpression: function(uexp) {
            for(var name in this.uniformExpressions) {
                var other = this.uniformExpressions[name];
                if(uexp.code == other.code && equalDependencies(uexp.dependencies, other.dependencies))
                    return name;
            }
            return "";
        },
        generateUniformExpression: function(node) {
            var anno = ANNO(node);
            var uexp = {
                code: codegen.generate(setterGenerator.transformUniformSetter(node, this.activeUniformVariables)),
                dependencies: anno.getUniformDependencies()

            };

            var name = this.getUniformExpression(uexp);
            if(!name) {
                name = "u" + getCounter();
                this.uniformExpressions[name] = uexp;
            }
            var result = {
                type: Syntax.MemberExpression,
                object: {
                    type: Syntax.Identifier,
                    name: "uexp"
                },
                property: {
                    type: Syntax.Identifier,
                    name: name
                }
            }

            ANNO(result).copyFrom(anno);
            return result;
        }
    };

    function equalDependencies(a, b) {
        if(a.length != b.length)
            return false;
        a.forEach(function(elem) {
            if(b.indexOf(elem) == -1)
                return false;
        });
        return true;
    }

    function shouldGenerateUniformExpression(node, anno) {
        var costs = anno.getUniformCosts();
        return costs > 0;
    };

    var transform = ns.transform = function (ast, opt) {
        var transformer = new UniformTransformer(opt);
        var result = transformer.transform(ast);
        opt.uniformExpressions = transformer.uniformExpressions;
        return result;
    };

}(exports));

},{"./../../base/common.js":140,"./uniformSetterTransformation.js":135,"escodegen":54,"estraverse":61}],137:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var Set = require("analyses").Set;

function findVariableDefinitions(ast, ignoreUninitializedDeclarations) {
	var definitions = new Set();
	estraverse.traverse(ast, {
		leave: function(node) {
			switch (node.type) {
			case Syntax.AssignmentExpression:
				if (node.left.type === Syntax.Identifier)
					definitions.add(node.left.name);
				break;
			case Syntax.VariableDeclarator:
				if (node.id.type === Syntax.Identifier
					&& (!ignoreUninitializedDeclarations || node.init))
					definitions.add(node.id.name);
				break;
			case Syntax.UpdateExpression:
				if (node.argument.type === Syntax.Identifier)
					definitions.add(node.argument.name);
				break;
			}
		}
	});
	return definitions;
}

function findVariableReferences(ast) {
	var references = new Set();
	estraverse.traverse(ast, {
		leave: function(node, parent) {
			switch (node.type) {
			case Syntax.AssignmentExpression:
				references = Set.union(references, findVariableReferences(node.right));
				this.break();
				break;
			case Syntax.Identifier:
				if (isVariableReference(node, parent))
					references.add(node.name);
				break;
			case Syntax.MemberExpression:
				if (isMemberReference(node, parent)) {
					if (isVariableReference(node.object, node))
						references.add(node.name);
					references.add(node.object.name + "." + node.property.name);
				}
				break;
			case Syntax.CallExpression:
				if (node.callee.type === Syntax.MemberExpression && parent
					&& parent.type !== Syntax.MemberExpression) {
					var object = node.callee.object;
					if (object.type == Syntax.Identifier)
						references.add(object.name)
				}

				break;
			}
		}
	});
	return references;
}

function isVariableReference(node, parent) {
    return isVariableName(node, parent) && parent.type !== Syntax.VariableDeclarator;
}

function isVariableName(node, parent) {
	if (node.type !== Syntax.Identifier)
        return false;

    if (parent) {
        if (parent.type === Syntax.FunctionDeclaration)
            return false;
        if (parent.type === Syntax.MemberExpression && parent.property === node)
            return false;
        if (parent.type === Syntax.NewExpression && parent.callee === node)
            return false;
        if (parent.type === Syntax.CallExpression && parent.callee === node)
            return false;
    }

    return true;
}

function isMemberReference(node, parent) {
    if (node.type !== Syntax.MemberExpression)
        return false;
    if (node.object.type !== Syntax.Identifier)
        return false;
    if (node.property.type !== Syntax.Identifier)
        return false;
    if (!parent)
        return false;
    if (parent.type === Syntax.CallExpression && parent.callee === node)
        return false;
    
    return true;
}


exports.findVariableDefinitions = findVariableDefinitions;
exports.findVariableReferences = findVariableReferences;
exports.isVariableReference = isVariableReference;
exports.isVariableName = isVariableName;

},{"analyses":46,"estraverse":61}],138:[function(require,module,exports){
"use strict";

var worklist = require("analyses");
var Set = worklist.Set;

function computePostDominators(cfg) {
    return worklist(cfg, function (input) {
        if (this.type || !this.astNode)
            return input;

        return Set.union(input, new Set([this]));
    }, {direction: "backward", start: new Set(), merge:  worklist.merge(Set.intersect)});
}

exports.computePostDominators = computePostDominators;
},{"analyses":46}],139:[function(require,module,exports){
"use strict";

//var common = require("./../base/common.js");
var utils = require("../../utils");
var estraverse = require('estraverse');
var Syntax = estraverse.Syntax;
var TYPES = require("../../type-system/constants").TYPES;

exports = module.exports = function (ast) {
    return estraverse.traverse(ast, {
        leave: function(node, parent) {
            var annotation = utils.annotate(node), right;
            if(!annotation.isValid()) {
                var errorInfo = annotation.getError();
                var error = new Error(errorInfo.message);
                error.loc = errorInfo.loc;
                throw error;
            }

            if(node.type == Syntax.VariableDeclarator) {
                if(node.init) {
                    right = utils.annotate(node.init);
                    annotation.copyFrom(right);
                }

                if (annotation.isNullOrUndefined()) {
                    utils.throwError(node, "No type could be calculated for ")
                }
            }
            if(node.type == Syntax.AssignmentExpression) {
                right = utils.annotate(node.right);
                annotation.copyFrom(right);
                annotation.clearUniformDependencies();

                if (annotation.isNullOrUndefined()) {
                    utils.throwError(node, "No type could be calculated for ")
                }
            } else if(node.type == Syntax.ExpressionStatement) {
                var exp = utils.annotate(node.expression);
                annotation.copyFrom(exp);
            }
        }
    });
};

},{"../../type-system/constants":200,"../../utils":206,"estraverse":61}],140:[function(require,module,exports){
(function (ns) {

    var annotate = require("../utils").annotate,
        estraverse = require('estraverse'),
        ErrorHandler = require("../type-system/errors.js");


    var Syntax = estraverse.Syntax;

    /**
     *
     * @param {object|Array.<object>} node
     * @param scope
     * @returns {TypeInfo|Array.<TypeInfo>}
     */
    ns.createTypeInfo = function (node, scope) {
        if(Array.isArray(node)) {
            return node.map(function (arg) {
                return scope.createTypeInfo(arg);
            });
        }
        var result = annotate(node);
        if (node.type == Syntax.Identifier || node.type == Syntax.ThisExpression) {
            var name = node.type == Syntax.Identifier ? node.name : 'this';
            var binding = scope.getBindingByName(name);
            if (binding) {
                result.copyFrom(binding);
                return binding;
            }
        }
        return result;
    };

    /**
     *
     * @param {object|Array.<object>} node
     * @param scope
     * @param {Array?} constants Additional array of constants
     * @param {boolean} check
     * @returns {TypeInfo|Array.<TypeInfo>}
     */
    ns.getTypeInfo = function getTypeInfo(node, scope, constants, check) {
        if(!node)
            return null;

        check = check == undefined ? false : check;

        if(Array.isArray(node)) {
            return node.map(function (arg) {
                return getTypeInfo(arg, scope, constants, check);
            });
        }
        var binding;
        if (node.type == Syntax.Identifier) {
            var name = node.name;

            if(name == 'undefined')
                return annotate(node);

            binding = scope.get(name);
            if(binding == undefined && check) {
                annotate(node).setInvalid(ErrorHandler.generateErrorInformation(node, ErrorHandler.ERROR_TYPES.REFERENCE_ERROR, name, "is not defined"));
                return annotate(node);
            }
            if(binding) {
                var result = annotate(node);
                result.copyFrom(binding);
                // A variable is dynamic per default. Only if it's listed in constant
                // we can assume a static value
                result.setDynamicValue();
                binding.setDynamicValue();
                if (constants && !binding.isNullOrUndefined()) {
                    var propagatedConstant = constants.filter(function (constant) {
                        return constant.name == name;
                    });

                    if (propagatedConstant.length) {
                        binding.setConstantValue(propagatedConstant[0].constant);
                        result.setConstantValue(propagatedConstant[0].constant);
                    }
                }
                return binding;

            }
        } else if (node.type == Syntax.ThisExpression) {
            binding = scope.get("this");
        }
        return binding || annotate(node);
    };



    ns.Syntax = Syntax;
    ns.VisitorOption = estraverse.VisitorOption;

    ns.ANNO = annotate;
    ns.getObjectReferenceFromNode = ns.getTypeInfo;


}(exports));

},{"../type-system/errors.js":201,"../utils":206,"estraverse":61}],141:[function(require,module,exports){
var Context = function (root, opt) {

    this.options = opt || {};

    /**
     * The root of the program to analyze
     * @type {*}
     */
    this.root = root;

    /**
     * To identify the main method of the shader
     * @type {*|string}
     */
    this.mainFunction = opt.mainFunction || "shade";

    /**
     * @type {Array.<Scope>}
     */
    this.scopeStack = opt.scope ? [opt.scope] : [];

    /**
     * Reserved keywords
     * @type {Array.<string>}
     */
    this.blockedNames = opt.blockedNames || [];

    /**
     * Used names
     * @type {Array.<string>}
     */
    this.usedNames = [];


    this.declaration = false;
};

Context.prototype = {
    getScope: function () {
        return this.scopeStack[this.scopeStack.length - 1];
    },
    pushScope: function (scope) {
        return this.scopeStack.push(scope);
    },
    popScope: function () {
        return this.scopeStack.pop();
    },
    inMainFunction: function () {
        return this.getScope().toString() == "global." + this.mainFunction;
    },
    setInDeclaration: function (inDeclaration) {
        this.declaration = inDeclaration;
    },
    inDeclaration: function () {
        return this.declaration;
    },
    getSafeName: function (baseName) {
        var index = 0, searchName = baseName;
        while (this.blockedNames.indexOf(searchName) != -1) {
            searchName = baseName + index++;
        }
        return searchName;
    },
    getSafeUniqueName: function (baseName) {
        var index = 1, searchName = baseName;
        while (!(this.usedNames.indexOf(searchName) == -1 && this.blockedNames.indexOf(searchName) == -1)) {
            searchName = baseName + index++;
        }
        this.usedNames.push(searchName);
        return searchName;
    }

};


module.exports = Context;


},{}],142:[function(require,module,exports){
(function(ns){

    ns.extend = require("lodash.assign");



    ns.deepExtend = function(destination, source) {
        for (var property in source) {
            var srcValue = source[property];
            var dstValue = destination[property];
            var copy;
            if (Array.isArray(srcValue)) {
                copy = dstValue || [];
                ns.deepExtend(copy, srcValue);
            } else if (typeof srcValue === "object" && srcValue !== null) {
                copy = dstValue || {};
                ns.deepExtend(copy, srcValue);
            } else {
                copy = srcValue;
            }
            destination[property] = copy;
        }
        return destination;
    };

    ns.shallowExtend = function(destination, source) {
        for (var property in source) {
            destination[property] = source[property];
        }
        return destination;
    };

    /**
     *
     * @param {Object} ctor Constructor
     * @param {Object} parent Parent class
     * @param {Object=} methods Methods to add to the class
     * @return {Object!}
     */
    ns.createClass = function(ctor, parent, methods) {
        methods = methods || {};
        if (parent) {
            /** @constructor */
            var F = function() {
            };
            F.prototype = parent.prototype;
            ctor.prototype = new F();
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent.prototype;
        }
        for ( var m in methods) {
            ctor.prototype[m] = methods[m];
        }
        return ctor;
    };


}(exports))

},{"lodash.assign":81}],143:[function(require,module,exports){
(function(ns){

    ns.swizzleToIndex = function(swizzleKey){
        switch(swizzleKey){
            case 'x':case 'r' :case 's': return 0;
            case 'y':case 'g' :case 't': return 1;
            case 'z':case 'b' :case 'p': return 2;
            case 'w':case 'a' :case 'q': return 3;
        }
        throw new Error("Unknown swizzle key: '" + swizzleKey + "'");
    };
    ns.indexToSwizzle = function(index){
        switch(index){
            case 0: return 'x';
            case 1: return 'y';
            case 2: return 'z';
            case 3: return 'w';
        }
        throw new Error("Unknown swizzle index: '" + index + "'");
    };
    ns.swizzleSets = [
        ['x', 'y', 'z', 'w'],
        ['r', 'g', 'b', 'a'],
        ['s', 't', 'p', 'q']
    ];
    ns.swizzleOperators = {
        'Add' : '+',
        'Sub' : '-',
        'Mul' : '*',
        'Div' : '/'
    }


}(exports))

},{}],144:[function(require,module,exports){
(function(ns){

    var OneParameterNumberMethods = ["acos", "asin", "atan", "cos", "exp", "log", "round", "sin", "sqrt", "tan", "ceil", "floor"];

    function oneParameterFunction(name) {

        var func = Math[name];

        return function(vec) {
            var length = vec.length,
                result = new Float32Array(length);
            while(length--) {
                result[length] = func(vec[length]);
            }
            return result;
        }
    }

    var VecMath = {
        mix : function(x,y,a) {
            var length = x.length,
                result = new Float32Array(length),
                oneMinusA;

            if (Array.isArray(a) && a.length >= length) {
                while(length--) {
                    var a = a[length];
                    result[length] = x[length] * (1 - a) + y[length] * a;
                }
            } else {
                oneMinusA = 1 - a;
                while(length--) {
                    result[length] = x[length] * oneMinusA + y[length] * a;
                }
            }
            return result;

        },
        step : function(edge, x) {
            var length = edge.length,
                result = new Float32Array(length);

            while(length--) {
                var e = edge[length];
                var x0 = x[length];
                result[length] = (x0 <= e) ? 0 : 1;
            }
            return result;
        },
        smoothstep : function(edge0, edge1, x) {
            var length = edge0.length,
                result = new Float32Array(length);

            while(length--) {
                var e0 = edge0[length];
                var e1 = edge1[length];
                var x0 = x[length];
                var t = Math.clamp((x0 - e0) / (e1 - e0), 0.0, 1.0);
                result[length] = t * t * (3.0 - 2.0 * t);
            }
            return result;
        }
    };

    OneParameterNumberMethods.forEach(function(name) {
        VecMath[name] = oneParameterFunction(name);
    });

    ns.VecMath = VecMath;


}(exports));

},{}],145:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var common = require("../../base/common.js");
    var Shade = require("../../interfaces.js");

    // Shortcuts
    var Syntax = common.Syntax;

    function generateFloat(value) {
        if (isNaN(value))
            throw Error("Internal: Expression generated NaN!");
        var result = '' + value;
        if (result.indexOf(".") == -1 && result.indexOf("e") == -1) {
            result += ".0";
        }
        return result;
    }

    /**
     *
     * @param controller
     * @param {object?} options
     * @constructor
     */
    var ExpressionHandler = function (controller, options) {
        this.controller = controller;
        this.controller.generateFloat = this.controller.generateFloat || generateFloat;
        this.options = options || {};
    };

    ExpressionHandler.prototype = {
        binary: function (node) {
            var result = this.expression(node);
            //noinspection FallthroughInSwitchStatementJS
            switch (node.type) {
                case Syntax.BinaryExpression:
                case Syntax.LogicalExpression:
                case Syntax.AssignmentExpression:
                case Syntax.ConditionalExpression:
                    result = "( " + result + " )";
                    break;
            }
            return result;
        },
        arguments: function (container) {
            var result = "(";
            container.forEach(function (arg, index) {
                result += this.expression(arg);
                if (index < container.length - 1) {
                    result += ", ";
                }
            }, this);
            return result + ")";
        },
        literal: function (extra, alternative) {
            var extra = extra || {},
                value = extra.staticValue !== undefined ? extra.staticValue : alternative;

            if (extra.type == Shade.TYPES.NUMBER)
                return this.controller.generateFloat(value); else
                return value;
        },
        expression: function (node) {
            if (!node) return "";

            var result = "";

            //noinspection FallthroughInSwitchStatementJS
            switch (node.type) {
                case Syntax.NewExpression:
                    result = this.controller.type(node.extra, { constructor: true });
                    result += this.arguments(node.arguments);
                    break;

                case Syntax.Literal:
                    result = this.literal(node.extra, node.value);
                    break;

                case Syntax.Identifier:
                    result = node.name;
                    break;

                case Syntax.AssignmentExpression:
                case Syntax.BinaryExpression:
                case Syntax.LogicalExpression:
                    result += this.binary(node.left);
                    result += " " + node.operator + " ";
                    result += this.binary(node.right);
                    break;
                case Syntax.UnaryExpression:
                    result = node.operator;
                    result += this.binary(node.argument);
                    break;

                case Syntax.CallExpression:
                    result = this.expression(node.callee);
                    result += this.arguments(node.arguments);
                    break;

                case Syntax.MemberExpression:
                    result = this.binary(node.object);
                    result += node.computed ? "[" : ".";
                    result += this.expression(node.property);
                    node.computed && (result += "]");
                    break;

                case Syntax.ConditionalExpression:
                    result = this.expression(node.test);
                    result += " ? ";
                    result += this.expression(node.consequent);
                    result += " : ";
                    result += this.expression(node.alternate);
                    break;

                case Syntax.UpdateExpression:
                    result = "";
                    if (node.isPrefix) {
                        result += node.operator;
                    }
                    result += this.expression(node.argument);
                    if (!node.isPrefix) {
                        result += node.operator;
                    }
                    break;
                case Syntax.ExpressionStatement:
                    result = this.expression(node.expression);
                    break;
                default:
                    result = "<unhandled: " + node.type + ">"
            }
            return result;
        },
        statement: function (node) {
            var result = "unhandled statement";
            switch (node.type) {
                case Syntax.ReturnStatement:
                    var hasArguments = node.argument;
                    result = "return" + (hasArguments ? (" " + this.expression(node.argument)) : "") + ";";
                    break;
            }
            return result;
        }
    };

    // Exports
    ns.ExpressionHandler = ExpressionHandler;


}(exports));

},{"../../base/common.js":140,"../../interfaces.js":188}],146:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

function createDeclaration(name, init) {
    return {
        type: Syntax.VariableDeclaration,
        declarations: [
            {
                type: Syntax.VariableDeclarator,
                id: {
                    type: Syntax.Identifier,
                    name: name
                },
                init: init !== undefined ? createIdentifierLiteralOrStripExpression(init) : undefined
            }
        ],
        kind: "var"
    }
}

function createBinaryExpression(lhs, rhs, operator) {
    return {
        type: Syntax.ExpressionStatement,
        expression: {
            type: operator === "=" ? Syntax.AssignmentExpression : Syntax.BinaryExpression,
            operator: operator,
            left: createIdentifierLiteralOrStripExpression(lhs),
            right: createIdentifierLiteralOrStripExpression(rhs),
        }
    }
}

function createMemberExpression(object, property, info) {
    return annotate({
        type: Syntax.MemberExpression,
        object: createIdentifierLiteralOrStripExpression(object),
        property: createIdentifierLiteralOrStripExpression(property),
    }, info);
}

function createIdentifierLiteralOrStripExpression(node) {
    if (typeof node === "string")
        return {
            type: Syntax.Identifier,
            name: node
        };
    if (typeof node === "number")
        return {
            type: Syntax.Literal,
            value: node
        };

    if (node.type === Syntax.ExpressionStatement)
        return node.expression;

    return node;
}

function createLiteral(value) {
    if (value < 0)
        return {
            type: Syntax.UnaryExpression,
            operator: "-",
            argument: {
                type: Syntax.Literal,
                value: -value
            },
            prefix: true
        };

    return {
        type: Syntax.Literal,
        value: value
    }
}

function createIdentifier(name, info) {
    return annotate({
        type: Syntax.Identifier,
        name: name
    }, info);
}

function createFunctionCall(fn, args, info) {
    args = args === undefined ? [] : args;
    args = Array.isArray(args) ? args : [args];
    return annotate({
        type: Syntax.CallExpression,
        callee: createIdentifierLiteralOrStripExpression(fn),
        arguments: args.map(createIdentifierLiteralOrStripExpression)
    }, info);
}

function createArrayAccess(object, index, info) {
    return annotate({
        type: Syntax.MemberExpression,
        computed: true,
        object: createIdentifierLiteralOrStripExpression(object),
        property: createIdentifierLiteralOrStripExpression(index)
    }, info);
}

function createArrayExpression(args, info) {
    return annotate({
        type: Syntax.ArrayExpression,
        elements: args,
    }, info)
}

function createNewExpression(name, args) {
    return {
        type: Syntax.NewExpression,
        callee: {
            type: Syntax.Identifier,
            name: name
        },
        arguments: args,
        extra: {
            type: "object",
            kind: name
        }
    }
}

function annotate(node, info) {
    node.extra = info;
    return node;
}

exports.createDeclaration = createDeclaration;
exports.createBinaryExpression = createBinaryExpression;
exports.createIdentifier = createIdentifier;
exports.createMemberExpression = createMemberExpression;
exports.createLiteral = createLiteral;
exports.createFunctionCall = createFunctionCall;
exports.createArrayAccess = createArrayAccess;
exports.createArrayExpression = createArrayExpression;
exports.createNewExpression = createNewExpression;

},{"estraverse":61}],147:[function(require,module,exports){
"use strict";

var assert = require("assert");

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var constants = require("./constants");
var simdMarker = require("./simd_marker");
var vectorizer = require("./vectorizer");
var simplify = require("./simplify");
var propagateConstants = require("./optimizer/constant_propagation");
var inlineInternalFunctions = require("./optimizer/inline_internal_functions");
var utils = require("../../utils");
var astUtils = require("./ast_utils");
var math = require("./math");
Shade.math = math;
Shade.texture = require("./texture");

var supportedTypes = constants.supportedTypes;
var typeSizeMap = constants.typeSizeMap;
var swizzleToIndexMap = constants.swizzleToIndexMap;
var columnToSingleSwizzle = constants.columnToSingleSwizzle;
var vectorIndexToSwizzleMap = constants.vectorIndexToSwizzleMap;
var matrixIndexToSwizzleMap = constants.matrixIndexToSwizzleMap;
var indexToSwizzleMap = constants.indexToSwizzleMap;

function FastlaneCompiler(opt) {
	opt = Object.assign({useSIMD: false}, opt);

	this._useSIMD = opt.useSIMD;
	this._counter = 0;
	this._isSIMDType = new Set();
}

FastlaneCompiler.prototype.compile = function(aast, opt) {
	var normalizer = require("./normalizer");
	normalizer.normalize(aast);
	if (this._useSIMD) {
		vectorizer.vectorize(aast.body[0].body);
		simdMarker.mark(aast.body[0].body);
	}

	aast = this.traverse(aast);

	var DeclarationSimplifier = require("../../analyze/sanitizer/declaration_simplifier");
	var RedundantBlocksRemover
		= require("../../analyze/sanitizer/redundant_blocks_remover");

	var declarationSimplifier = new DeclarationSimplifier();
	declarationSimplifier.execute(aast);

	inlineInternalFunctions(aast);

	estraverse.replace(aast, {
		enter: function(node) {
			if (node.type === Syntax.ExpressionStatement) {
				if (node.expression.type === Syntax.BlockStatement)
					return node.expression;
				if (node.expression.type === Syntax.AssignmentExpression && node.expression.right.type === Syntax.BlockStatement)
					return node.expression.right;
			}
		}
	});

	var redundantBlocksRemover = new RedundantBlocksRemover();
	declarationSimplifier.execute(aast);
	redundantBlocksRemover.execute(aast);

	propagateConstants(aast);

	estraverse.replace(aast, {
		enter: function (node) {
			if (node.type === Syntax.ExpressionStatement && node.expression.type === Syntax.EmptyStatement)
				return this.remove();
			if (node.type === Syntax.EmptyStatement)
				return this.remove();
		}
	});

    opt = opt || {};

    if (opt.name)
		aast.body[0].id.name = opt.name;

	if (opt.benchmark) {
		insertBenchmarking(aast);
	}

	return utils.toJavaScript(aast);
};

function insertBenchmarking(aast) {
	var t0Name = "__benchmark_t0";
	aast.body[0].body.body.unshift(astUtils.createDeclaration(t0Name, astUtils.createFunctionCall("performance.now")));
	estraverse.traverse(aast.body[0].body, {
		enter: function (node) {
			if (node.type === Syntax.ReturnStatement) {
				node.argument.properties.push({
					type: Syntax.Property,
					key: {type: Syntax.Identifier, name: "__time"},
					value: astUtils.createBinaryExpression(astUtils.createFunctionCall("performance.now"), t0Name, "-").expression
				})
			}
		}
	});
}

FastlaneCompiler.prototype.traverse = function(block) {
	var self = this;

	var currentBlock = null;
	var oldBlock = null;
	var parent = -1;
	block = estraverse.replace(block, {
		enter: function(node) {
			if (node.type === Syntax.BlockStatement) {
				oldBlock = currentBlock;
				currentBlock = node;
			}
			if (node.type === Syntax.ExpressionStatement) {
				parent = node;
			}
		},
		leave: function(node) {
			if (node.type === Syntax.BlockStatement)
				currentBlock = oldBlock;
			if (node.type === Syntax.CallExpression)
				node.arguments = node.arguments.filter(function(arg) {
					return !utils.annotate(arg).isUndefined();
				});
			if (node.type === Syntax.NewExpression)
				return self.handleNewExpression(
					node, currentBlock, currentBlock.body.indexOf(parent));
			if (node.type === Syntax.MemberExpression)
				return self.handleMemberExpression(
					node, currentBlock, currentBlock.body.indexOf(parent));
			if (node.type === Syntax.CallExpression
				&& node.callee.type === Syntax.MemberExpression)
				return self.handleMemberCallExpression(
					node, currentBlock, currentBlock.body.indexOf(parent));
			if (node.type === Syntax.ReturnStatement)
				return self.handleReturnStatement(
					node, currentBlock, currentBlock.body.indexOf(parent));
			if (node.type === Syntax.AssignmentExpression) {
				return self.handleAssignmentExpression(
					node, currentBlock, currentBlock.body.indexOf(parent));
			}
		}
	});

	return block;
};

FastlaneCompiler.prototype.handleNewExpression = function(node, currentBlock,
														  index) {
	var annotation = utils.annotate(node);
	var kind = annotation.getKind();
	if (supportedTypes.has(kind)) {
		var args = node.arguments;
		var size = typeSizeMap[kind];
		var tmp = this.createTmpVariableName();
		var init = null;
		if (node.__simd) {
			if (args.length === 1) {
				init = astUtils.createFunctionCall(
					"SIMD.Float32x4.splat",
					node.arguments[0],
					node.extra);
			} else {
				init = astUtils.createFunctionCall(
					"SIMD.Float32x4",
					this.convertArguments(node.arguments),
					node.extra);
			}
			this._isSIMDType.add(tmp);
		} else {
			if (args.length === 1) {
				for (var i = 1; i < size; ++i)
					args[i] = args[0];
			}
			init = astUtils.createArrayExpression(
				this.convertArguments(node.arguments),
				node.extra);
		}

		currentBlock.body.splice(
			index, 0,
			astUtils.createDeclaration(createOffsetVariableName(tmp), 0),
			astUtils.createDeclaration(tmp, init)
		);

		return astUtils.createIdentifier(tmp, node.extra);
	}
	return node;
};

FastlaneCompiler.prototype.createTmpVariableName = function() {
	return "__tmp" + this._counter++;
};

function createOffsetVariableName(name) {
	return "__offset" + name;
}

function isTmpVariable(name) {
	return name ? name.indexOf("__") === 0 : false;
}

FastlaneCompiler.prototype.convertArguments = function(values) {
	var scalarList = [];
	var self = this;
	values.forEach(function(value) {
		var valueAnnotation = utils.annotate(value);
		if (valueAnnotation.canNumber()) {
			scalarList.push(value);
		} else if (valueAnnotation.isVector()) {
			var kind = valueAnnotation.getKind();
			var size = typeSizeMap[kind];
			for (var i = 0; i < size; ++i)
				scalarList.push(
					self.swizzleToExtract(astUtils.createMemberExpression(
						value, indexToSwizzleMap[kind][i], {type: "number"})))
		} else {
			scalarList.push(value)
		}
	});

	return scalarList;
};

FastlaneCompiler.prototype.createFromValuesCall = function(kind, args,
														   typeSize) {
	if (args.length === 1) {
		for (var i = 1; i < typeSize; ++i)
			args[i] = args[0];
	}

	return astUtils.createArrayExpression(args, {type: "object", kind: kind});
};

FastlaneCompiler.prototype.handleMemberExpression = function(node, currentBlock,
															 index) {
	var resultAnnotation = utils.annotate(node);
	var objectAnnotation = utils.annotate(node.object);

	if (resultAnnotation.getType() === "any")
		return;

	if (objectAnnotation.isTexture()) {
		if (node.property.name === "width")
			node.property.name = "shape[0]";
		if (node.property.name === "height")
			node.property.name = "shape[1]";
	}

	if (node.computed) {
		if (objectAnnotation.isArray()) {
			var elementSize = determineLogicalElementSize(node.object);
			var offset = astUtils.createBinaryExpression(node.property,
														 elementSize, "*")
							 .expression;
			if (isTmpVariable(node.object.name)) {
				offset = astUtils.createBinaryExpression(
									 offset,
									 createOffsetVariableName(node.object.name),
									 "+")
							 .expression;
			}

			if (resultAnnotation.canNumber()) {
				return astUtils.createArrayAccess(node.object, offset)
			} else {
				var tmp = this.createTmpVariableName();
				currentBlock.body.splice(
					index, 0, astUtils.createDeclaration(tmp, node.object),
					astUtils.createDeclaration(createOffsetVariableName(tmp),
											   offset));
				return astUtils.createIdentifier(tmp, resultAnnotation.info);
			}
		}
		if (objectAnnotation.isTexture()) {
			var elementSize = objectAnnotation.info.width * 4;
			var offset = astUtils.createBinaryExpression(node.property,
														 elementSize, "*")
							 .expression;
			if (node.object.name && node.object.name.indexOf("__") === 0) {
				offset = astUtils.createBinaryExpression(
									 offset,
									 createOffsetVariableName(node.object.name),
									 "+")
							 .expression;
			}
			var tmp = this.createTmpVariableName();
			currentBlock.body.splice(
				index, 0, astUtils.createDeclaration(tmp, node.object),
				astUtils.createDeclaration(createOffsetVariableName(tmp),
										   offset));
			return astUtils.createIdentifier(tmp, resultAnnotation.info);
		}
	}

	if (!node.computed && supportedTypes.has(objectAnnotation.getKind())
		&& node.property.type === Syntax.Identifier)
		return this.swizzleToExtract(node);
};

function determineLogicalElementSize(object) {
	var annotation = utils.annotate(object);
	var elementType = annotation.getArrayElementType();
	var size = 1;

	while (elementType.extra.type === "array") {
		size *= elementType.extra.staticSize;
		elementType = elementType.extra.elements;
	}

	return size * typeSizeMap[elementType.extra.kind || elementType.extra.type];
}

FastlaneCompiler.prototype.swizzleToExtract = function(node) {
	var resultAnnotation = utils.annotate(node);
	var objectAnnotation = utils.annotate(node.object);

	var self = this;
	function swizzleToAccess(swizzle) {
		var index = swizzleToIndexMap[objectAnnotation.getKind()][swizzle];
		if (node.object.type === Syntax.Identifier) {
			if (self._isSIMDType.has(node.object.name)) {
				return astUtils.createFunctionCall("SIMD.Float32x4.extractLane", [node.object, index], {type: "number"})
			} else {
				return astUtils.createArrayAccess(
					node.object,
					astUtils.createBinaryExpression(
						createOffsetVariableName(node.object.name), index, "+"),
					{type: "number"});
			}
		}
		else {
			return astUtils.createArrayAccess(node.object, index, {type: "number"});
		}
	}

	if (resultAnnotation.isNumber()) {
		return swizzleToAccess(node.property.name);
	}

	if (resultAnnotation.isVector()) {
		if (objectAnnotation.isVector()) {
			var elements
				= node.property.name.split("").map(swizzleToAccess);
		} else if (objectAnnotation.isMatrix()) {
			var elements
				= columnToSingleSwizzle[node.property.name]
					  .split(",")
					  .slice(0, typeSizeMap[resultAnnotation.getKind()])
					  .map(swizzleToAccess);
		}
		return this.createFromValuesCall(resultAnnotation.getKind(), elements,
										 elements.length);
	}
};

FastlaneCompiler.prototype.handleAssignmentExpression = function(
	node, currentBlock, index) {
	var lhs = node.left;
	var rhs = node.right;
	var rhsAnnotation = utils.annotate(rhs);

	if (lhs.type === Syntax.Identifier && rhs.__simd || this._isSIMDType.has(rhs.name))
		this._isSIMDType.add(lhs.name);

	if (lhs.type === Syntax.Identifier && isTmpVariable(lhs.name)
		&& rhs.type === Syntax.Identifier
		&& rhs.name.indexOf("_call") !== -1) {

		var fnNode = null;
		estraverse.replace(currentBlock, {
			enter: function (node) {
				if (node.type === Syntax.AssignmentExpression && node.left.type === Syntax.Identifier && node.left.name === rhs.name) {
					node.right.callee.name += "Store";
					node.right.arguments.unshift(astUtils.createIdentifier(createOffsetVariableName(lhs.name)));
					node.right.arguments.unshift(lhs);
					fnNode = node;
					return {type: Syntax.EmptyStatement};
				}
			}
		});

		return fnNode;
	}

	if (lhs.type == Syntax.Identifier && isTmpVariable(lhs.name)) {
		var rhsKind = rhsAnnotation.getKind();
		var object = lhs;
		var objectAnnotation = utils.annotate(object);
		var body = [];
		if (objectAnnotation.isVector() || objectAnnotation.isMatrix()) {
			var varName = rhs.name;
			if (rhs.type !== Syntax.Identifier) {
				var tmp = this.createTmpVariableName();
				body.push(astUtils.createDeclaration(tmp, rhs));
				if (rhs.type === Syntax.Identifier && isTmpVariable(rhs.name))
					body.push(astUtils.createDeclaration(
						createOffsetVariableName(tmp),
						astUtils.createIdentifier(
							createOffsetVariableName(rhs.name))));
				else
					body.push(astUtils.createDeclaration(
						createOffsetVariableName(tmp), astUtils.createLiteral(0)));
				varName = tmp;
			}

			for (var i = 0; i < typeSizeMap[rhsKind]; ++i) {
				body.push(astUtils.createBinaryExpression(
					astUtils.createArrayAccess(
						object,
						astUtils.createBinaryExpression(
							createOffsetVariableName(object.name), i, "+")),
					this.swizzleToExtract(astUtils.createMemberExpression(
						astUtils.createIdentifier(
							varName, {type: "object", kind: rhsKind}),
						rhsAnnotation.isMatrix()
							? matrixIndexToSwizzleMap[rhsKind][i]
							: vectorIndexToSwizzleMap[i],
						{type: "number"})),
					"="))
			}
			return {type: Syntax.BlockStatement, body: body};
		}
	}

	if (lhs.type === Syntax.Identifier) {
		if (rhsAnnotation.isArray() || rhs.type === Syntax.ArrayExpression || (rhs.type === Syntax.CallExpression && rhs.callee.type === Syntax.Identifier && rhs.callee.name.indexOf("Shade.") !== -1)) {
			var offset = astUtils.createLiteral(0);
			if (rhs.name && rhs.name.indexOf("__") === 0) {
				offset = astUtils.createIdentifier("__offset" + rhs.name);
			}
			var varName = lhs.name;
			currentBlock.body.splice(
				index, 0,
				astUtils.createDeclaration("__offset" + varName, offset));
			return node;
		} else if (rhsAnnotation.isMatrix() || rhsAnnotation.isVector()) {
			if (rhs.name && rhs.name.indexOf("__") === 0) {
				var offset = astUtils.createIdentifier("__offset" + rhs.name);
				var varName = lhs.name;
				currentBlock.body.splice(
					index, 0,
					astUtils.createDeclaration("__offset" + varName, offset));
				if (this._isSIMDType.has(rhs.name))
					this._isSIMDType.add(lhs.name);
				return node;
			}
		}
	}
};

FastlaneCompiler.prototype.handleMemberCallExpression = function(node) {
	var lhs = node.callee.object;
	var lhsAnnotation = utils.annotate(lhs);
	var resultAnnotation = utils.annotate(node);

	if (lhsAnnotation.isTexture()) {
		var fnName = "Shade.texture.sample";
		if (node.__simd) {
			fnName += "SIMD";
			if (lhs.extra.isByteTexture)
				fnName += "Byte";
		}
		var uv = node.arguments[0];
		if (uv.type === Syntax.Identifier && isTmpVariable(uv.name)) {
			var newNode = astUtils.createFunctionCall(
				fnName,
				[lhs, uv, createOffsetVariableName(uv.name)],
				resultAnnotation.info);
			newNode.__simd = node.__simd;
			return newNode;
		}

		var newNode = astUtils.createFunctionCall(fnName,
										   [lhs, uv, astUtils.createLiteral(0)],
										   resultAnnotation.info);
		newNode.__simd = node.__simd;
		return newNode;
	}

	if (!lhsAnnotation.isVector() && !lhsAnnotation.isMatrix())
		return node;

	var lhsType = lhsAnnotation.getKind();
	var fun = node.callee.property.name;

	if (fun === "mul" && lhsAnnotation.isMatrix()
		&& resultAnnotation.isVector())
		fun = "mulVec";

	var args = node.arguments;

	if (node.__simd && math[lhsAnnotation.getKind().toLowerCase()][fun + "SIMD"]) {
		if (args.length === 1 && utils.annotate(args[0]).canNumber()
			&& fun === "mul") {
			fun = "scale";
		}
		fun = fun + "SIMD";
		var loadFunctionName = "SIMD.Float32x4.load" + (typeSizeMap[lhsType] !== 4 ? typeSizeMap[lhsType] : "");
		var newArgs = [];
		if (this._isSIMDType.has(lhs.name)) {
			newArgs.push(lhs.name);
		}
		else {
			if (lhs.type === Syntax.Identifier) {
				if (lhsAnnotation.isVector()) {
					newArgs.push(astUtils.createFunctionCall(
						loadFunctionName,
						[lhs.name, createOffsetVariableName(lhs.name)]));
				}
				else {
					newArgs.push(lhs.name);
					newArgs.push(createOffsetVariableName(lhs.name));
				}
			} else {
				newArgs.push(lhs);
				newArgs.push(0);
			}
		}

		if (args.length > 0) {
			if (this._isSIMDType.has(args[0].name)) {
				newArgs.push(args[0].name);
			}
			else {
				if (args[0].type === Syntax.Identifier) {
					if (utils.annotate(args[0]).isVector()) {
						newArgs.push(astUtils.createFunctionCall(
							"SIMD.Float32x4.load" + (typeSizeMap[utils.annotate(args[0]).getKind()] !== 4 ? typeSizeMap[utils.annotate(args[0]).getKind()] : ""),
							[args[0], createOffsetVariableName(args[0].name)]));
					}
					else {
						newArgs.push(args[0].name);
						newArgs.push(createOffsetVariableName(args[0].name));
					}

				} else {
					newArgs.push(args[0]);
				}
			}
		}

		args = newArgs;
	} else {
		if (args.length !== 0) {
			if (args.length === 1 && utils.annotate(args[0]).canNumber()
				&& fun === "mul") {
				fun = "scale";
				var rhs = args[0];
				args.push(rhs);
			} else {
				var arg = this.convertFunctionArguments(
					args, lhsAnnotation.getKind());
				if (arg.type === Syntax.Identifier) {
					args = [arg, "__offset" + arg.name];
				} else {
					args = [arg, 0];
				}
			}
		}

		if (lhs.type === Syntax.Identifier) {
			args.unshift("__offset" + lhs.name);
			args.unshift(lhs.name);
		} else {
			args.unshift(0);
			args.unshift(lhs);
		}
	}

	var newNode = astUtils.createFunctionCall("Shade.math." + lhsType.toLowerCase()
										   + "." + fun,
									   args, resultAnnotation.info);
	newNode.__simd = node.__simd;
	return newNode;
};

FastlaneCompiler.prototype.convertFunctionArguments = function(args, vecType) {
	if (args.length === 0)
		return;

	if (args.length === 1) {
		if (utils.annotate(args[0]).canNumber()) {
			var scalar = args[0];
			var newArgs = [];
			for (var i = 0; i < typeSizeMap[vecType]; ++i)
				newArgs.push(scalar);
			return this.createFromValuesCall(vecType, newArgs,
											 typeSizeMap[vecType]);
		} else
			return args[0]
	}

	return this.createFromValuesCall(vecType, this.convertArguments(args),
									 typeSizeMap[vecType]);
};

FastlaneCompiler.prototype.handleReturnStatement = function(node) {
	// todo: handle array return
};

exports = module.exports = FastlaneCompiler;

},{"../../analyze/sanitizer/declaration_simplifier":109,"../../analyze/sanitizer/redundant_blocks_remover":110,"../../utils":206,"./ast_utils":146,"./constants":148,"./math":150,"./normalizer":151,"./optimizer/constant_propagation":152,"./optimizer/inline_internal_functions":153,"./simd_marker":161,"./simplify":162,"./texture":163,"./vectorizer":164,"assert":25,"estraverse":61}],148:[function(require,module,exports){
"use strict";

exports.supportedTypes = new Set(["Vec2", "Vec3", "Vec4", "Mat2", "Mat3", "Mat4"]);
exports.typeSizeMap = {
    "int": 1,
    "number": 1,
    "Vec2": 2,
    "Vec3": 3,
    "Vec4": 4,
    "Mat2": 4,
    "Mat3": 9,
    "Mat4": 16
};

var swizzleToIndexMap = {
    "Mat2": {
        "m11": 0,
        "m21": 1,
        "m12": 2,
        "m22": 3
    },
    "Mat3": {
        "m11": 0,
        "m21": 1,
        "m31": 2,
        "m12": 3,
        "m22": 4,
        "m32": 5,
        "m13": 6,
        "m23": 7,
        "m33": 8
    },
    "Mat4": {
        "m11": 0,
        "m21": 1,
        "m31": 2,
        "m41": 3,
        "m12": 4,
        "m22": 5,
        "m32": 6,
        "m42": 7,
        "m13": 8,
        "m23": 9,
        "m33": 10,
        "m43": 11,
        "m14": 12,
        "m24": 13,
        "m34": 14,
        "m44": 15
    }
};

swizzleToIndexMap.Vec2 = swizzleToIndexMap.Vec3 = swizzleToIndexMap.Vec4 = {
    "x": 0,
    "y": 1,
    "z": 2,
    "w": 3,
    "r": 0,
    "g": 1,
    "b": 2,
    "a": 3,
    "s": 0,
    "t": 1,
    "p": 2,
    "q": 3
};

exports.swizzleToIndexMap = swizzleToIndexMap;

exports.columnToSingleSwizzle = {
    c1: "m11,m21,m31,m41",
    c2: "m12,m22,m32,m42",
    c3: "m13,m23,m33,m43",
    c4: "m14,m24,m34,m44"
};

exports.vectorIndexToSwizzleMap = {0: "x", 1: "y", 2: "z", 3: "w"};

exports.matrixIndexToSwizzleMap = {
    "Mat2": {
        0: "m11",
        1: "m21",
        2: "m12",
        3: "m22"
    },
    "Mat3": {
        0: "m11",
        1: "m21",
        2: "m31",
        3: "m12",
        4: "m22",
        5: "m32",
        6: "m13",
        7: "m23",
        8: "m33"
    },
    "Mat4": {
        0: "m11",
        1: "m21",
        2: "m31",
        3: "m41",
        4: "m12",
        5: "m22",
        6: "m32",
        7: "m42",
        8: "m13",
        9: "m23",
        10: "m33",
        11: "m43",
        12: "m14",
        13: "m24",
        14: "m34",
        15: "m44"
    }
};

var indexToSwizzleMap = {
    "Mat2": {
        0: "m11",
        1: "m21",
        2: "m12",
        3: "m22"
    },
    "Mat3": {
        0: "m11",
        1: "m21",
        2: "m31",
        3: "m12",
        4: "m22",
        5: "m32",
        6: "m13",
        7: "m23",
        8: "m33"
    },
    "Mat4": {
        0: "m11",
        1: "m21",
        2: "m31",
        3: "m41",
        4: "m12",
        5: "m22",
        6: "m32",
        7: "m42",
        8: "m13",
        9: "m23",
        10: "m33",
        11: "m43",
        12: "m14",
        13: "m24",
        14: "m34",
        15: "m44"
    }
};
indexToSwizzleMap.Vec2 = indexToSwizzleMap.Vec3 = indexToSwizzleMap.Vec4 = {
    0: "x",
    1: "y",
    2: "z",
    3: "w"
};
exports.indexToSwizzleMap = indexToSwizzleMap;
},{}],149:[function(require,module,exports){
"use strict";

var annotate = require("../../utils/annotate");
var typeSizeMap = require("./constants").typeSizeMap;

exports = module.exports = function (node) {
    var annotation = annotate(node);
    var elementType = annotation.getArrayElementType();
    var size = 1;

    while (elementType.extra.type === "array") {
        size *= elementType.extra.staticSize;
        elementType = elementType.extra.elements;
    }

    return size * typeSizeMap[elementType.extra.kind || elementType.extra.type];
}

},{"../../utils/annotate":204,"./constants":148}],150:[function(require,module,exports){
"use strict";

var vec2 = {};
vec2.add = function add(vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset], y1 = vec[vecOffset + 1];
    var x2 = vec2[vecOffset2], y2 = vec2[vecOffset2 + 1];
    return [x1 + x2, y1 + y2];
};

vec2.addStore = function addStore(result, resultOffset, vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset], y1 = vec[vecOffset + 1];
    var x2 = vec2[vecOffset2], y2 = vec2[vecOffset2 + 1];``
    result[resultOffset] = x1 + x2;
    result[resultOffset + 1] = y1 + y2;
};

var vec3 = {};
vec3.add = function add(vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var x2 = vec2[vecOffset2 + 0], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2];
    return [x1 + x2, y1 + y2, z1 + z2];
};

// vec3.addSIMD = function add(vec, vec2) {
//     return SIMD.Float32x4.add(vec, vec2);
// };

vec3.addStore = function addStore(result, resultOffset, vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var x2 = vec2[vecOffset2 + 0], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2];
    result[resultOffset] = x1 + x2;
    result[resultOffset + 1] = y1 + y2;
    result[resultOffset + 2] = z1 + z2;
};

// vec3.addSIMDStore = function add(result, resultOffset, vec, vec2) {
//     SIMD.Float32x4.store3(result, resultOffset, SIMD.Float32x4.add(vec, vec2));
// };

vec3.sub = function sub(vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var x2 = vec2[vecOffset2 + 0], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2];
    return [x1 - x2, y1 - y2, z1 - z2];
};

vec3.subStore = function subStore(result, resultOffset, vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var x2 = vec2[vecOffset2 + 0], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2];
    result[resultOffset] = x1 - x2;
    result[resultOffset + 1] = y1 - y2;
    result[resultOffset + 2] = z1 - z2;
};

// vec3.subSIMD = function sub(vec, vec2) {
//     return SIMD.Float32x4.sub(vec, vec2);
// };

vec3.mul = function mul(vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var x2 = vec2[vecOffset2 + 0], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2];
    return [x1 * x2, y1 * y2, z1 * z2];
};

// vec3.mulSIMD = function mul(vec, vec2) {
//     return SIMD.Float32x4.mul(vec, vec2);
// };

vec3.normalize = function normalize(vec, vecOffset) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var norm = 1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1);
    return [x1 * norm, y1 * norm, z1 * norm];
};

vec3.normalizeStore = function normalizeStore(result, resultOffset, vec, vecOffset) {
    var x1 = vec[vecOffset + 0], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2];
    var norm = 1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1);
    result[resultOffset] = x1 * norm;
    result[resultOffset + 1] = y1 * norm;
    result[resultOffset + 2] = z1 * norm;
};

vec3.scale = function scale(vec, vecOffset, scalar) {
    return [vec[vecOffset] * scalar, vec[vecOffset + 1] * scalar, vec[vecOffset + 2] * scalar];
};

vec3.scaleStore = function scale(result, resultOffset, vec, vecOffset, scalar) {
    result[resultOffset] = vec[vecOffset] * scalar;
    result[resultOffset + 1] = vec[vecOffset + 1] * scalar;
    result[resultOffset + 2] = vec[vecOffset + 2] * scalar;
};

// vec3.scaleSIMD = function scale(vec, scalar) {
//     return SIMD.Float32x4.mul(vec, SIMD.Float32x4.splat(scalar));
// };

// vec3.scaleSIMDStore = function scale(result, offset, vec, scalar) {
//     SIMD.Float32x4.store3(result, offset, SIMD.Float32x4.mul(vec, SIMD.Float32x4.splat(scalar)));
// };

var vec4 = {};
vec4.add = function add(vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2], w1 = vec[vecOffset + 3];
    var x2 = vec2[vecOffset2], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2], w2 = vec2[vecOffset2 + 3];
    return [x1 + x2, y1 + y2, z1 + z2, w1 + w2];
};

vec4.addSIMD = function add(vec, vec2) {
    return SIMD.Float32x4.add(vec, vec2);
};

vec4.addStore = function addStore(result, resultOffset, vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2], w1 = vec[vecOffset + 3];
    var x2 = vec2[vecOffset2], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2], w2 = vec2[vecOffset2 + 3];
    result[resultOffset] = x1 + x2;
    result[resultOffset + 1] = y1 + y2;
    result[resultOffset + 2] = z1 + z2;
    result[resultOffset + 3] = w1 + w2;
};

vec4.sub = function sub(vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2], w1 = vec[vecOffset + 3];
    var x2 = vec2[vecOffset2], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2], w2 = vec2[vecOffset2 + 3];
    return [x1 - x2, y1 - y2, z1 - z2, w1 - w2];
};

vec4.subSIMD = function sub(vec, vec2) {
    return SIMD.Float32x4.sub(vec, vec2);
};

vec4.subStore = function subStore(result, resultOffset, vec, vecOffset, vec2, vecOffset2) {
    var x1 = vec[vecOffset], y1 = vec[vecOffset + 1], z1 = vec[vecOffset + 2], w1 = vec[vecOffset + 3];
    var x2 = vec2[vecOffset2], y2 = vec2[vecOffset2 + 1], z2 = vec2[vecOffset2 + 2], w2 = vec2[vecOffset2 + 3];
    result[resultOffset] = x1 - x2;
    result[resultOffset + 1] = y1 - y2;
    result[resultOffset + 2] = z1 - z2;
    result[resultOffset + 3] = w1 - w2;
};

vec4.mul = function mul(vec, vecOffset, vec2, vecOffset2) {
    return [vec[vecOffset + 0] * vec2[vecOffset2 + 0], vec[vecOffset + 1] * vec2[vecOffset2 + 1], vec[vecOffset + 2] * vec2[vecOffset2 + 2], vec[vecOffset + 3] * vec2[vecOffset2 + 3]];
};

vec4.mulSIMD = function mul(vec, vec2) {
    return SIMD.Float32x4.mul(vec, vec2);
};

vec4.div = function mul(vec, vecOffset, vec2, vecOffset2) {
    return [vec[vecOffset + 0] / vec2[vecOffset2 + 0], vec[vecOffset + 1] / vec2[vecOffset2 + 1], vec[vecOffset + 2] / vec2[vecOffset2 + 2], vec[vecOffset + 3] / vec2[vecOffset2 + 3]];
};

vec4.divSIMD = function mul(vec, vec2) {
    return SIMD.Float32x4.div(vec, vec2);
};

vec4.scale = function scale(vec, vecOffset, scalar) {
    return [vec[vecOffset] * scalar, vec[vecOffset + 1] * scalar, vec[vecOffset + 2] * scalar, vec[vecOffset + 3] * scalar];
};

vec4.scaleSIMD = function scale(vec, scalar) {
    return SIMD.Float32x4.mul(vec, SIMD.Float32x4.splat(scalar));
};

vec4.sqrtSIMD = function scale(vec) {
    return SIMD.Float32x4.sqrt(vec);
};

vec4.sinSIMD = function scale(vec) {
    var PI = SIMD.Float32x4.splat(3.1415926536);
    var PI2 = SIMD.Float32x4.splat(2 * 3.1415926536);
    vec = SIMD.Float32x4.add(vec, PI);
    var x = SIMD.Float32x4.sub(vec, SIMD.Float32x4.mul(SIMD.Float32x4.fromInt32x4(SIMD.Int32x4.fromFloat32x4(SIMD.Float32x4.div(vec, PI2))), PI2));
    var ltzero = SIMD.Float32x4.lessThan(x, SIMD.Float32x4.splat(0));
    var normed = SIMD.Float32x4.select(ltzero, SIMD.Float32x4.add(x, PI), SIMD.Float32x4.sub(x, PI));

    var square  = SIMD.Float32x4.mul(normed, normed);

    return SIMD.Float32x4.mul(normed, SIMD.Float32x4.add(SIMD.Float32x4.splat(0.99997937679290771484375), SIMD.Float32x4.mul(square, SIMD.Float32x4.add(SIMD.Float32x4.splat(-0.166624367237091064453125), SIMD.Float32x4.mul(square, SIMD.Float32x4.add(SIMD.Float32x4.splat(8.30897875130176544189453125e-3), SIMD.Float32x4.mul(square, SIMD.Float32x4.add(SIMD.Float32x4.splat(-1.92649182281456887722015380859375e-4), SIMD.Float32x4.mul(SIMD.Float32x4.splat(2.147840177713078446686267852783203125e-6), square)))))))));
};

vec4.cosSIMD = function scale(vec) {
    var PI = SIMD.Float32x4.splat(3.1415926536);
    var PI2 = SIMD.Float32x4.splat(2 * 3.1415926536);
    vec = SIMD.Float32x4.add(vec, PI);
    var x = SIMD.Float32x4.sub(vec, SIMD.Float32x4.mul(SIMD.Float32x4.fromInt32x4(SIMD.Int32x4.fromFloat32x4(SIMD.Float32x4.div(vec, PI2))), PI2));
    var ltzero = SIMD.Float32x4.lessThan(x, SIMD.Float32x4.splat(0));
    var normed = SIMD.Float32x4.select(ltzero, SIMD.Float32x4.add(x, PI), SIMD.Float32x4.sub(x, PI));
    var square  = SIMD.Float32x4.mul(normed, normed);

    return SIMD.Float32x4.add(SIMD.Float32x4.splat(0.999959766864776611328125), SIMD.Float32x4.mul(square, SIMD.Float32x4.add(SIMD.Float32x4.splat(-0.4997930824756622314453125), SIMD.Float32x4.mul(square, SIMD.Float32x4.add(SIMD.Float32x4.splat(4.1496001183986663818359375e-2), SIMD.Float32x4.mul(square, SIMD.Float32x4.add(SIMD.Float32x4.splat(-1.33926304988563060760498046875e-3), SIMD.Float32x4.mul(SIMD.Float32x4.splat(1.8791708498611114919185638427734375e-5), square))))))));
};

var mat3 = {};

var mat4 = {};
mat4.mulVec = function mulVec(mat, matOffset, vec, vecOffset) {
    var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2], w = vec[vecOffset + 3];
    return [
    mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z + mat[matOffset + 12] * w,
    mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z + mat[matOffset + 13] * w,
    mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z + mat[matOffset + 14] * w,
    mat[matOffset + 3] * x + mat[matOffset + 7] * y + mat[matOffset + 11] * z + mat[matOffset + 15] * w,
    ]
};

mat4.mulVecStore = function mulVec(result, resultOffset, mat, matOffset, vec, vecOffset) {
    var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2], w = vec[vecOffset + 3];
    result[resultOffset] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z + mat[matOffset + 12] * w;
    result[resultOffset + 1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z + mat[matOffset + 13] * w;
    result[resultOffset + 2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z + mat[matOffset + 14] * w;
    result[resultOffset + 3] = mat[matOffset + 3] * x + mat[matOffset + 7] * y + mat[matOffset + 11] * z + mat[matOffset + 15] * w;
};

mat4.mulVecSIMD = function mulVec(mat, offset, vec) {
    var a0 = SIMD.Float32x4.load(mat, offset);
    var a1 = SIMD.Float32x4.load(mat, offset + 4);
    var a2 = SIMD.Float32x4.load(mat, offset + 8);
    var a3 = SIMD.Float32x4.load(mat, offset + 12);
    return SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 3, 3, 3, 3), a3))));
};

mat4.mulVecSIMDStore = function mulVec(result, resultOffset, mat, offset, vec) {
    var a0 = SIMD.Float32x4.load(mat, offset);
    var a1 = SIMD.Float32x4.load(mat, offset + 4);
    var a2 = SIMD.Float32x4.load(mat, offset + 8);
    var a3 = SIMD.Float32x4.load(mat, offset + 12);
    SIMD.Float32x4.store(result, resultOffset, SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(vec, 3, 3, 3, 3), a3)))));
};

mat4.mul = function mul(mat, offset1, mat2, offset2) {
    var a11 = mat[offset1];
    var a21 = mat[offset1 + 1];
    var a31 = mat[offset1 + 2];
    var a41 = mat[offset1 + 3];
    var a12 = mat[offset1 + 4];
    var a22 = mat[offset1 + 5];
    var a32 = mat[offset1 + 6];
    var a42 = mat[offset1 + 7];
    var a13 = mat[offset1 + 8];
    var a23 = mat[offset1 + 9];
    var a33 = mat[offset1 + 10];
    var a43 = mat[offset1 + 11];
    var a14 = mat[offset1 + 12];
    var a24 = mat[offset1 + 13];
    var a34 = mat[offset1 + 14];
    var a44 = mat[offset1 + 15];

    var b11 = mat2[offset2];
    var b21 = mat2[offset2 + 1];
    var b31 = mat2[offset2 + 2];
    var b41 = mat2[offset2 + 3];
    var b12 = mat2[offset2 + 4];
    var b22 = mat2[offset2 + 5];
    var b32 = mat2[offset2 + 6];
    var b42 = mat2[offset2 + 7];
    var b13 = mat2[offset2 + 8];
    var b23 = mat2[offset2 + 9];
    var b33 = mat2[offset2 + 10];
    var b43 = mat2[offset2 + 11];
    var b14 = mat2[offset2 + 12];
    var b24 = mat2[offset2 + 13];
    var b34 = mat2[offset2 + 14];
    var b44 = mat2[offset2 + 15];

    var dest = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    dest[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    dest[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    dest[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    dest[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;

    dest[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    dest[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    dest[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    dest[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;

    dest[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    dest[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    dest[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    dest[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;

    dest[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    dest[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    dest[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    dest[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return dest;
};

mat4.mulStore = function mulStore(result, resultOffset, mat, offset, mat2, offset2) {
    var a11 = mat[offset];
    var a21 = mat[offset + 1];
    var a31 = mat[offset + 2];
    var a41 = mat[offset + 3];
    var a12 = mat[offset + 4];
    var a22 = mat[offset + 5];
    var a32 = mat[offset + 6];
    var a42 = mat[offset + 7];
    var a13 = mat[offset + 8];
    var a23 = mat[offset + 9];
    var a33 = mat[offset + 10];
    var a43 = mat[offset + 11];
    var a14 = mat[offset + 12];
    var a24 = mat[offset + 13];
    var a34 = mat[offset + 14];
    var a44 = mat[offset + 15];

    var b11 = mat2[offset2];
    var b21 = mat2[offset2 + 1];
    var b31 = mat2[offset2 + 2];
    var b41 = mat2[offset2 + 3];
    var b12 = mat2[offset2 + 4];
    var b22 = mat2[offset2 + 5];
    var b32 = mat2[offset2 + 6];
    var b42 = mat2[offset2 + 7];
    var b13 = mat2[offset2 + 8];
    var b23 = mat2[offset2 + 9];
    var b33 = mat2[offset2 + 10];
    var b43 = mat2[offset2 + 11];
    var b14 = mat2[offset2 + 12];
    var b24 = mat2[offset2 + 13];
    var b34 = mat2[offset2 + 14];
    var b44 = mat2[offset2 + 15];

    result[resultOffset] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    result[resultOffset + 1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    result[resultOffset + 2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    result[resultOffset + 3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;

    result[resultOffset + 4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    result[resultOffset + 5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    result[resultOffset + 6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    result[resultOffset + 7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;

    result[resultOffset + 8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    result[resultOffset + 9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    result[resultOffset + 10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    result[resultOffset + 11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;

    result[resultOffset + 12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    result[resultOffset + 13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    result[resultOffset + 14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    result[resultOffset + 15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
};

mat4.mulSIMD = function mulStoreSIMD(mat, offset, mat2, offset2) {
    var out = new Float32Array(16);
    var resultOffset = 0;
    var a0 = SIMD.Float32x4.load(mat, offset);
    var a1 = SIMD.Float32x4.load(mat, offset + 4);
    var a2 = SIMD.Float32x4.load(mat, offset + 8);
    var a3 = SIMD.Float32x4.load(mat, offset + 12);

    var b0 = SIMD.Float32x4.load(mat2, offset2);
    var out0 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, resultOffset, out0);

    var b1 = SIMD.Float32x4.load(mat2, offset2 + 4);
    var out1 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, resultOffset + 4, out1);

    var b2 = SIMD.Float32x4.load(mat2, offset2 + 8);
    var out2 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, resultOffset + 8, out2);

    var b3 = SIMD.Float32x4.load(mat2, offset2 + 12);
    var out3 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, resultOffset + 12, out3);

    return out;
};

mat4.mulSIMDStore = function mulStoreSIMD(result, resultOffset, mat, offset, mat2, offset2) {
    var out = result;
    var a0 = SIMD.Float32x4.load(mat, offset);
    var a1 = SIMD.Float32x4.load(mat, offset + 4);
    var a2 = SIMD.Float32x4.load(mat, offset + 8);
    var a3 = SIMD.Float32x4.load(mat, offset + 12);

    var b0 = SIMD.Float32x4.load(mat2, offset2);
    var b1 = SIMD.Float32x4.load(mat2, offset2 + 4);
    var b2 = SIMD.Float32x4.load(mat2, offset2 + 8);
    var b3 = SIMD.Float32x4.load(mat2, offset2 + 12);

    var out0 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));

    var out1 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));

    var out2 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));

    var out3 = SIMD.Float32x4.add(
        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
        SIMD.Float32x4.add(
            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
            SIMD.Float32x4.add(
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));

    SIMD.Float32x4.store(out, resultOffset, out0);
    SIMD.Float32x4.store(out, resultOffset + 4, out1);
    SIMD.Float32x4.store(out, resultOffset + 8, out2);
    SIMD.Float32x4.store(out, resultOffset + 12, out3);
};

exports.vec2 = vec2;
exports.vec3 = vec3;
exports.vec4 = vec4;
exports.mat3 = mat3;
exports.mat4 = mat4;
},{}],151:[function(require,module,exports){
exports.normalize = require("./sanitizer");

},{"./sanitizer":160}],152:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var esgraph = require("esgraph");
var worklist = require("./worklist");
var astUtils = require("../ast_utils");

function propagateConstants(aast) {
    var cfg = esgraph(aast.body[0].body);

    worklist(cfg, function (input) {
        if (this.type)
            return;

        this.input = input;
        var result = findValue(this.astNode);
        var rvalues = [...result];
        var dif = [...input].filter(function (i) {
            return !rvalues.some(function (rv) {
                return i.left.name === rv.left.name;
            })
        });
        return new Set([...dif, ...result]);
    });

    worklist(cfg, function (input) {
        if (this.type)
            return;

        if (this.input.size > 0)
            propagateValues(this.astNode, this.input);

        this.gen = this.gen || findVariableReferences(this.astNode);
        return new Set([...input, ...this.gen]);
    });

    cfg[2].forEach(function (node) {
        node.gen = node.kill = null;
    });

    var changed = true;
    while (changed) {
        changed = false;
        var result = worklist(cfg, function (input) {
            if (this.type)
                return input;

            var gen = this.gen = findVariableReferences(this.astNode);
            var kill = this.kill = findVariableDefinitions(this.astNode);
            return new Set([...gen, ...[...input].filter(x => !kill.has(x))]);
        }, {direction: "backward"});

        cfg[2].forEach(function (cfgNode) {
            if (cfgNode.type)
                return;

            var node = cfgNode.astNode;
            if (cfgNode.kill.size > 0) {
                cfgNode.kill.forEach(function (kill) {
                    if (cfgNode.next.some(function (cfgNode) {
                            return result.get(cfgNode).has(kill);
                        }))
                        return;
                    if (node.type === Syntax.AssignmentExpression && node.left.type === Syntax.Identifier && node.left.name === kill) {
                        node.type = Syntax.EmptyStatement;
                        changed = true;
                    }
                })
            }
        });
    }

    return aast;
}

exports = module.exports = propagateConstants;

function propagateValues(ast, input) {
    var multipleValues = [];
    var values = [...input].reduce(function (map, v) {
        var name = v.left.name;
        if (map.has(name))
            multipleValues.push(name);
        else
            map.set(name, v.right);
        return map;
    }, new Map());

    multipleValues.forEach(function (name) {
        values.delete(name);
    });

    function getValue(name, idx) {
        var v = values.get(name);
        if (!v)
            return;
        if (v.type === Syntax.Literal)
            return v;
        if (v.type === Syntax.ArrayExpression && idx !== undefined) {
            var value = v.elements[idx];
            // if (value.type !== Syntax.Literal)
            //     return;
            return value;
        }
        if (v.type === Syntax.Identifier) {
            var value = getValue(v.name);
            if (value)
                return value;
            return v;
        }
    }

    estraverse.replace(ast, {
        leave: function (node, parent) {
            if (node.type === Syntax.Identifier) {
                if (parent.type === Syntax.AssignmentExpression && parent.left === node)
                    return;
                if (parent.type === Syntax.UpdateExpression)
                    return;
                if (parent.type === Syntax.Property && parent.key === node)
                    return;
                if (parent.type === Syntax.MemberExpression && parent.property === node && !parent.computed)
                    return;

                return getValue(node.name);
            } else if (node.type === Syntax.BinaryExpression) {
                if (node.left.type === Syntax.Literal && node.right.type === Syntax.Literal)
                    return astUtils.createLiteral(eval(node.left.value + "" + node.operator + "" + node.right.value));
            } else if (node.type === Syntax.ExpressionStatement && node.expression.type === Syntax.Literal) {
                return node.expression;
            } else if (node.computed) {
                if (node.object.type !== Syntax.Identifier || node.property.type !== Syntax.Literal)
                    return;
                return getValue(node.object.name, node.property.value);
            }
        }
    });
}

function findVariableDefinitions(ast) {
    var definitions = new Set();
    estraverse.traverse(ast, {
        leave: function(node) {
            switch (node.type) {
                case Syntax.AssignmentExpression:
                    if (node.left.type === Syntax.Identifier)
                        definitions.add(node.left.name);
                    break;
                case Syntax.UpdateExpression:
                    if (node.argument.type === Syntax.Identifier)
                        definitions.add(node.argument.name);
                    break;
            }
        }
    });
    return definitions;
}

function findVariableReferences(ast) {
    var references = new Set();
    estraverse.traverse(ast, {
        enter: function(node, parent) {
            if (isVariableReference(node, parent))
                references.add(node.name);
        }
    });
    return references;
}

function isVariableReference(node, parent) {
    if (node.type !== Syntax.Identifier)
        return false;

    if (parent) {
        if (parent.type === Syntax.FunctionDeclaration)
            return false;
        if (parent.type === Syntax.NewExpression && parent.callee === node)
            return false;
        if (parent.type === Syntax.CallExpression && parent.callee === node)
            return false;
        if (parent.type === Syntax.Property && parent.key === node)
            return false;
        if (parent.type === Syntax.AssignmentExpression && parent.left === node)
            return false;
    }

    return true;
}


function isMemberReference(node, parent) {
    if (node.type !== Syntax.MemberExpression)
        return false;
    if (node.object.type !== Syntax.Identifier)
        return false;
    if (node.property.type !== Syntax.Identifier)
        return false;
    if (!parent)
        return false;
    if (parent.type === Syntax.CallExpression && parent.callee === node)
        return false;

    return true;
}

function findValue(ast) {
    var values = new Set();
    estraverse.traverse(ast, {
        enter: function (node) {
            switch(node.type) {
                case Syntax.AssignmentExpression:
                    if (node.left.type !== Syntax.Identifier)
                        return;
                    values.add(node);
                    this.skip();
                    break;
                case Syntax.UpdateExpression:
                    node.left = node.argument;
                    node.right = node;
                    values.add(node);
                    break;
            }
        }
    });

    return values;
}

},{"../ast_utils":146,"./worklist":154,"esgraph":58,"estraverse":61}],153:[function(require,module,exports){
"use strict";

var esprima = require("esprima");
var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var internalFunctions = require("../math");
internalFunctions.texture = require("../texture");
var astUtils = require("../ast_utils");

var inlineCounter = 0;

function inlineInternalFunctions(aast) {
    estraverse.replace(aast, {
        enter: function (node, parent) {
            if (node.type === Syntax.CallExpression && node.callee.type === Syntax.Identifier) {
                if (parent.type === Syntax.AssignmentExpression && parent.left.type !== Syntax.Identifier)
                    return;
                if (parent.type !== Syntax.AssignmentExpression && parent.type !== Syntax.ExpressionStatement)
                    return;
                var lhs = null;
                if (parent.type === Syntax.AssignmentExpression)
                    lhs = parent.left.name;

                var name = node.callee.name;
                var components = name.split(".");
                var fnName = components[components.length - 1];
                var typeName = components[components.length - 2];
                if (!internalFunctions[typeName] || !internalFunctions[typeName][fnName])
                    return;
                var fnAst = esprima.parse(internalFunctions[typeName][fnName].toString()).body[0];
                var fnParameterNames = fnAst.params.map(function (param) {
                    return param.name;
                });
                var resultName = "__inline_" + typeName + fnName + "result" + inlineCounter;
                var functionVariables = new Set();
                fnParameterNames.forEach(function (parameter, idx) {
                    functionVariables.add(parameter);
                    fnAst.body.body.unshift(astUtils.createDeclaration(parameter, node.arguments[idx]));
                });
                estraverse.replace(fnAst, {
                    enter: function (node) {
                        if (node.type === Syntax.VariableDeclaration) {
                            node.declarations.forEach(function (declaration) {
                                functionVariables.add(declaration.id.name);
                            });
                        }

                        if (node.type === Syntax.Identifier) {
                            if (functionVariables.has(node.name))
                                node.name = "__inline_" + typeName + fnName + node.name + inlineCounter;
                        }

                        if (node.type === Syntax.ReturnStatement) {
                            return astUtils.createBinaryExpression(resultName, node.argument, "=");
                        }
                    }
                });
                if (lhs)
                    fnAst.body.body.push(astUtils.createBinaryExpression(lhs, resultName, "="));
                fnAst.body.body.unshift(astUtils.createDeclaration(resultName));

                inlineCounter++;
                return fnAst.body;
            }
        },
        leave: function (node) {
            if (node.type === Syntax.ExpressionStatement && node.expression.type === Syntax.AssignmentExpression && node.expression.right.type === Syntax.BlockStatement)
                return node.expression.right;
        }
    })
}

exports = module.exports = inlineInternalFunctions;
},{"../ast_utils":146,"../math":150,"../texture":163,"esprima":60,"estraverse":61}],154:[function(require,module,exports){

var Queue = require('analyses/lib/queue');

var exports = module.exports = worklist;

// expose the utilities to have them tested separately
exports.Queue = Queue;

/**
 * Implementation of a general worklist algorithm
 * `cfg` is a control flow graph created by `esgraph`,
 * `transferFunction` gets called with (this = node, input, worklist)
 * it operates on the input `Set` and can return an output set, in which case
 * the worklist algorithm automatically enqueues all the successor nodes, or it
 * might return an {output: output, enqueue: false} object in which case it is
 * itself responsible to enqueue the successor nodes.
 * `options` defines the `direction`, a `merge` function and an `equals`
 * function which merge the inputs to a node and determine if a node has changed
 * its output respectively.
 * Returns a `Map` from node -> output
 */
function worklist(cfg, transferFunction, options) {
	options = options || {};
	var direction = options.direction || 'forward';
	var merge = options.merge || worklist.merge(Set.union);
	var equals = options.equals || Set.equals;
	var list = new Queue();
	if (direction === 'forward') {
		list.push(cfg[0]);
		var predecessors = worklist.predecessors;
		var successors = worklist.successors;
	} else {
		list.push(cfg[1]);
		var predecessors = worklist.successors;
		var successors = worklist.predecessors;
	}
	var start = options.start || new Set();

	var output = new Map();
	while (list.length) {
		var node = list.shift();
		var pre = predecessors(node)
			.map(function (n) {return output.get(n);})
		var input = pre.length ? merge(pre) : start;
		var oldOutput = output.get(node);
		var out = transferFunction.call(node, input, list, oldOutput);
		if (!out || out instanceof Set)
			out = {output: out, enqueue: true};
		output.set(node, out.output);
		if (out.enqueue && (!oldOutput || !equals(out.output, oldOutput)))
			successors(node).forEach(function (aSuccessor) {	list.push(aSuccessor);	});
	}
	return output;
};

worklist.predecessors = function (node) {
	return node.prev;
};

worklist.successors = function (node) {
	return node.next;
};

worklist.merge = function (fn) {
	return function (inputs) {
		if (inputs.length == 1)
			return new Set(inputs[0]);
		return inputs.reduce(fn);
	};
};

if (!Set.equals)
	Set.equals = function (a, b) {
		if (a.size != b.size)
			return false;
		return [...a].every(function (val) {
			return b.has(val);
		});
	};

if (!Set.union)
	Set.union = function (a, b) {
		if (!a)
			return b;
		if (!b)
			return a;
		return new Set([...a, ...b]);
	};

if (!Set.minus)
	Set.minus = function (a, b) {
		if (!b)
			return a;
		if (!a)
			return new Set();
		return new Set([...a].filter(x => !b.has(x)));
	};
},{"analyses/lib/queue":51}],155:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var utils = require("../../../utils");
var astUtils = require("../ast_utils");
var swizzleToIndexMap = require("../constants").swizzleToIndexMap;
var determineLogicalElementSize = require("../determine_logical_element_size");

exports.nodeTypes = [Syntax.MemberExpression];
exports.enter = function (node) {
    if (!node.object.computed || node.computed)
        return;

    var annotation = utils.annotate(node);
    if (!annotation.canNumber())
        return;

    var swizzleIndex = swizzleToIndexMap[utils.annotate(node.object).getKind()][node.property.name];
    var stride = astUtils.createBinaryExpression(node.object.property, determineLogicalElementSize(node.object.object), "*");
    node.object.property = astUtils.createBinaryExpression(stride, swizzleIndex, "+").expression;
    node.object.extra = {
        type: "number"
    };

    node.object.object.extra = {
        type: "array",
        elements: {
            extra: {
                type: "number"
            }
        }
    };

    return [node.object];
};


},{"../../../utils":206,"../ast_utils":146,"../constants":148,"../determine_logical_element_size":149,"estraverse":61}],156:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var utils = require("../../../utils");

var determineLogicalElementSize = require("../determine_logical_element_size");
var constants = require("../constants");
var astUtils = require("../ast_utils");

exports.nodeTypes = [Syntax.AssignmentExpression];
exports.enter = function (node) {
    if (node.left.type !== Syntax.MemberExpression || !node.left.computed || node.right.type !== Syntax.NewExpression)
        return;

    var destinationAnnotation = utils.annotate(node.left);
    var type = destinationAnnotation.getKind();
    var index = node.left.property;

    var assignments = [];

    for (var i = 0; i < constants.typeSizeMap[type]; ++i) {
        assignments.push(astUtils.createBinaryExpression(
            astUtils.createArrayAccess(
                node.left.object,
                astUtils.createBinaryExpression(astUtils.createBinaryExpression(index, determineLogicalElementSize(node.left.object), "*"), i, "+"), {type: "number"}),
            node.right.arguments[i],
            "=",
            {type: "number"}));
    }
    node.left.object.extra.elements = {
        extra: {
            type: "number"
        }
    };
    assignments[assignments.length - 1] = assignments[assignments.length - 1].expression;

    return assignments;
};

},{"../../../utils":206,"../ast_utils":146,"../constants":148,"../determine_logical_element_size":149,"estraverse":61}],157:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var astUtils = require("../ast_utils");

var validOperators = ["+", "-", "*", "/", "%"];
var counter = 0;

exports.nodeTypes = [Syntax.BinaryExpression];
exports.enter = function (node, parent) {
    if (parent.type === Syntax.MemberExpression) {
        node.__ignore_binary_expression = true;
        return;
    }

    node.__ignore_binary_expression = parent.__ignore_binary_expression;
};
exports.leave = function (node) {
    if (validOperators.indexOf(node.operator) === -1 || node.__ignore_binary_expression)
        return;

    var tmp = "_bop" + counter++;
    node.__tmp = tmp;
    return [astUtils.createDeclaration(tmp, astUtils.createBinaryExpression(getVarNameOrLiteral(node.left), getVarNameOrLiteral(node.right), node.operator).expression, node.extra), astUtils.createIdentifier(node.__tmp, node.extra)]
};

function getVarNameOrLiteral(node) {
    if (node.__tmp)
        return astUtils.createIdentifier(node.__tmp, node.extra);
    return node;
}

},{"../ast_utils":146,"estraverse":61}],158:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

exports.nodeTypes = [Syntax.IfStatement, Syntax.WhileStatement, Syntax.ForStatement];
exports.enter = function (node) {
    if (node.type === Syntax.IfStatement) {
        node.consequent = wrapInBlockStatement(node.consequent);
        node.alternate = wrapInBlockStatement(node.alternate);
    }
    if (node.type === Syntax.WhileStatement
        || node.type === Syntax.ForStatement) {
        node.body = wrapInBlockStatement(node.body);
    }
};

function wrapInBlockStatement(node) {
    if (node && node.type !== Syntax.BlockStatement)
        return {type: Syntax.BlockStatement, body: [node]};
    return node;
}
},{"estraverse":61}],159:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var astUtils = require("../ast_utils");

var counter = 0;

exports.nodeTypes = [Syntax.CallExpression];
exports.leave = function (node) {
    if (node.__tmp)
        return;
    var tmp = "_call" + counter++;
    node.arguments = node.arguments.map(getVarNameOrLiteral);
    node.__tmp = tmp;
    return [astUtils.createDeclaration(tmp, node, node.extra), astUtils.createIdentifier(node.__tmp, node.extra)];
};

function getVarNameOrLiteral(node) {
    if (node.__tmp)
        return astUtils.createIdentifier(node.__tmp, node.extra);
    return node;
}

},{"../ast_utils":146,"estraverse":61}],160:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;

var DeclarationSimplifier = require("../../../analyze/sanitizer/declaration_simplifier");
var RedundantBlocksRemover
    = require("../../../analyze/sanitizer/redundant_blocks_remover");

var transformers = [require("./block_wrapper"), require("./binary_expression"), require("./assignment_expression"), require("./array_access_swizzle"), require("./call_expression")];

function sanitize(ast) {
    transformers.forEach(function (transformer) {
        var currentBlock = null;
        var lastBlock = null;
        var currentExpression = null;
        estraverse.replace(ast, {
            enter: function (node, parent) {
                if (node.type === Syntax.BlockStatement) {
                    lastBlock = currentBlock;
                    currentBlock = node;
                }

                if (node.type === Syntax.ExpressionStatement || node.type === Syntax.VariableDeclaration || node.type == Syntax.IfStatement || node.type === Syntax.WhileStatement || node.type === Syntax.ForStatement || node.type === Syntax.ReturnStatement) {
                    currentExpression = node;
                }

                if (!currentBlock)
                    return;

                var currentIndex = currentBlock.body.indexOf(currentExpression);
                if (currentIndex === -1)
                    return;

                if (transformer.nodeTypes.indexOf(node.type) === -1 || !transformer.enter)
                    return;

                var result = transformer.enter(node, parent);

                if (!result)
                    return;

                var replacementNode = result.pop();
                insertNewNodes(result, currentBlock, currentIndex);
                return replacementNode;
            },
            leave: function (node, parent) {
                if (node.type === Syntax.BlockStatement) {
                    currentBlock = lastBlock;
                }
                if (!currentBlock)
                    return;

                var currentIndex = currentBlock.body.indexOf(currentExpression);
                if (currentIndex === -1)
                    return;

                if (transformer.nodeTypes.indexOf(node.type) === -1 || !transformer.leave)
                    return;

                var result = transformer.leave(node, parent);
                if (!result)
                    return;

                var replacementNode = result.pop();
                insertNewNodes(result, currentBlock, currentIndex);
                return replacementNode;
            }
        });
    });

    var declarationSimplifier = new DeclarationSimplifier();
    declarationSimplifier.execute(ast);
    var redundantBlocksRemover = new RedundantBlocksRemover();
    redundantBlocksRemover.execute(ast);

    return ast;
}

exports = module.exports = sanitize;

function insertNewNodes(nodes, block, expressionIdx) {
    if (!nodes || nodes.length === 0)
        return false;

    nodes.forEach(function (replacementNode, idx) {
         block.body.splice(expressionIdx + idx, 0 , replacementNode);
    });

    return true;
}

},{"../../../analyze/sanitizer/declaration_simplifier":109,"../../../analyze/sanitizer/redundant_blocks_remover":110,"./array_access_swizzle":155,"./assignment_expression":156,"./binary_expression":157,"./block_wrapper":158,"./call_expression":159,"estraverse":61}],161:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var esgraph = require("esgraph");
var analyses = require("analyses");
var utils = require("../../utils");
var math = require("./math");

exports.mark = function(ast) {
    var cfg = esgraph(ast, {omitExceptions: true});

    var variablesVisited = new Set();
    var shouldSIMD = analyses(cfg, function (input) {
        if (this.type)
            return input;

        var shouldSIMD = new analyses.Set();
        var shouldNotSIMD = new analyses.Set();

        var node = this.astNode;
        if (node.type === Syntax.AssignmentExpression) {
            if (node.left.type === Syntax.Identifier) {
                var name = node.left.name;
                if (variablesVisited.has(name) && !input.has(name)) {
                    return input;
                }
                if (node.right.type === Syntax.Identifier) {
                    if (input.has(node.left.name))
                        shouldSIMD.add(node.right.name)
                }
            }
            if (node.right.type === Syntax.CallExpression && node.right.callee.type === Syntax.MemberExpression) {
                var lhsAnnotation = utils.annotate(node.right.callee.object);
                if (!lhsAnnotation.isVector() && !lhsAnnotation.isMatrix())
                    return input;

                var fnName = node.right.callee.property.name;

                if (fnName === "mul" && lhsAnnotation.isMatrix() && utils.annotate(node.right.arguments[0]).isVector())
                    fnName += "Vec";

                if (fnName === "mul" && lhsAnnotation.isVector() && utils.annotate(node.right.arguments[0]).canNumber())
                    fnName = "scale";

                if (math[lhsAnnotation.getKind().toLowerCase()][fnName + "SIMD"]) {
                    if (node.left.type === Syntax.Identifier) {
                        shouldSIMD.add(node.left.name);
                        variablesVisited.add(node.left.name);
                    } else {
                        shouldSIMD.add(node.right);
                    }

                    if (node.right.callee.object.type === Syntax.Identifier) {
                        shouldSIMD.add(node.right.callee.object.name);
                        variablesVisited.add(node.right.callee.object.name);
                    }

                    node.right.arguments.forEach(function (arg) {
                        if (arg.type === Syntax.Identifier) {
                            shouldSIMD.add(arg.name);
                            variablesVisited.add(arg.name);
                        }
                    });
                } else {
                    if (node.left.type === Syntax.Identifier && !shouldSIMD.has(node.left.name)) {
                        shouldNotSIMD.add(node.left.name);
                        variablesVisited.add(node.left.name);
                    }
                    if (node.right.callee.object.type === Syntax.Identifier) {
                        shouldNotSIMD.add(node.right.callee.object.name);
                    }

                    node.right.arguments.forEach(function (arg) {
                        if (arg.type === Syntax.Identifier) {
                            shouldNotSIMD.add(arg.name);
                            variablesVisited.add(arg.name);
                        }
                    });
                }
            }
        }
        return new analyses.Set.union(shouldSIMD, analyses.Set.minus(input, shouldNotSIMD));
    }, {direction: "backward"}).get(cfg[0]);

    // do {
    //     var lastShouldSIMD = new analyses.Set(shouldSIMD)
    //     analyses(cfg, function (input) {
    //         if (this.type)
    //             return input;
    //
    //         var shouldNotSIMD = new analyses.Set();
    //         if (this.astNode.type === Syntax.AssignmentExpression) {
    //             var name = null;
    //             if (this.astNode.left.type === Syntax.Identifier)
    //                 name = this.astNode.left.name;
    //             estraverse.traverse(this.astNode.right, {
    //                 enter: function (node, parent) {
    //                     if (node.type === Syntax.NewExpression)
    //                         this.break();
    //                     if (node.type === Syntax.CallExpression && node.callee.type === Syntax.MemberExpression && node.callee.object.name !== "Math") {
    //                         var allArgsSIMD = true;
    //                         node.arguments.forEach(function (arg) {
    //                             if (arg.name && arg.extra.type === "object" && !lastShouldSIMD.has(arg.name))
    //                                 allArgsSIMD = false;
    //                         });
    //                         if (!allArgsSIMD && node.callee.object.name)
    //                             shouldNotSIMD.add(node.callee.object.name)
    //                     }
    //                     if (node.type === Syntax.MemberExpression && node.computed)
    //                         this.skip();
    //                     if (node.type === Syntax.Identifier && !lastShouldSIMD.has(node.name)) {
    //                         if (parent && (parent.property === node || parent.object === node))
    //                             return;
    //                         if (name)
    //                             shouldNotSIMD.add(name)
    //                     }
    //                 }
    //             });
    //         }
    //
    //         shouldSIMD = analyses.Set.minus(shouldSIMD, shouldNotSIMD);
    //         return shouldNotSIMD;
    //     }, {direction: "backward"}).get(cfg[0]);
    // } while (shouldSIMD.size !== 0 && !analyses.Set.equals(lastShouldSIMD, shouldSIMD));

    var canSIMD = analyses(cfg, function (input) {
        if (this.type)
            return input;

        var canSIMD = input;
        estraverse.traverse(this.astNode, {
            enter: function (node) {
                if (node.type === Syntax.AssignmentExpression && node.left.type === Syntax.Identifier && canSIMD.has(node.left.name)) {
                    estraverse.traverse(node.right ? node.right : node, {
                        leave: function (node) {
                            if (node.type === Syntax.Identifier && shouldSIMD.has(node.name))
                                node.__simd = true;
                            if (node.type === Syntax.CallExpression && node.callee.type === Syntax.MemberExpression && node.callee.object.name !== "Math") {
                                node.__simd = true;
                            }
                            if (node.type === Syntax.MemberExpression && node.computed)
                                node.__simd = true;
                            if (node.type === Syntax.NewExpression)
                                node.__simd = true;
                        }
                    });
                }

                if (node.right && node.right.__simd && node.left.name)
                    canSIMD.add(node.left.name);
            }
        });

        return canSIMD;
    }, {direction: "forward", start: shouldSIMD}).get(cfg[1]);

    return canSIMD;
};

},{"../../utils":206,"./math":150,"analyses":46,"esgraph":58,"estraverse":61}],162:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var esgraph = require("esgraph");
var analyses = require("analyses");
var astUtils = require("./ast_utils");
var external = require("./math");
external.texture = require("./texture");
var esprima = require("esprima");

var RedundantBlocksRemover
    = require("../../analyze/sanitizer/redundant_blocks_remover");
var DeclarationSimplifier = require("../../analyze/sanitizer/declaration_simplifier");

function simplify(aast) {
    inlineFunctions(aast);

    estraverse.replace(aast, {
        enter: function(node) {
            if (node.type === Syntax.ExpressionStatement) {
                if (node.expression.type === Syntax.BlockStatement)
                    return node.expression;
                if (node.expression.type === Syntax.AssignmentExpression && node.expression.right.type === Syntax.BlockStatement)
                    return node.expression.right;
            }
        }
    });

    var declarationSimplifier = new DeclarationSimplifier();
    declarationSimplifier.execute(aast);

    var redundantBlocksRemover = new RedundantBlocksRemover();
    redundantBlocksRemover.execute(aast);

    propagateCopies(aast);
    propagateConstants(aast);
    deadCodeElimination(aast);
    removeEmptyStatements(aast);
}

exports = module.exports = simplify;

function inlineFunctions(aast) {
    var inlineCounter = 0;
    estraverse.replace(aast, {
        enter: function (node, parent) {
            if (parent.type === Syntax.AssignmentExpression && parent.left.type !== Syntax.Identifier)
                return;
            if (parent.type !== Syntax.AssignmentExpression && parent.type !== Syntax.ExpressionStatement)
                return;
            if (node.type === Syntax.CallExpression && node.callee.type === Syntax.Identifier) {
                var lhs = null;
                if (parent.type === Syntax.AssignmentExpression)
                    lhs = parent.left.name;

                var name = node.callee.name;
                var components = name.split(".");
                var fnName = components[components.length - 1];
                var typeName = components[components.length - 2];
                if (!external[typeName][fnName])
                    return;
                var fnAst = esprima.parse(external[typeName][fnName].toString()).body[0];
                var fnParameterNames = fnAst.params.map(function (param) {
                    return param.name;
                });
                var resultName = "__inline_" + typeName + fnName + "result" + inlineCounter;
                var functionVariables = new Set();
                fnParameterNames.forEach(function (parameter, idx) {
                    functionVariables.add(parameter);
                    fnAst.body.body.unshift(astUtils.createDeclaration(parameter, node.arguments[idx]));
                });
                estraverse.replace(fnAst, {
                    enter: function (node) {
                        if (node.type === Syntax.VariableDeclaration) {
                            node.declarations.forEach(function (declaration) {
                                functionVariables.add(declaration.id.name);
                            });
                        }

                        if (node.type === Syntax.Identifier) {
                            if (functionVariables.has(node.name))
                                node.name = "__inline_" + typeName + fnName + node.name + inlineCounter;
                        }

                        if (node.type === Syntax.ReturnStatement) {
                            return astUtils.createBinaryExpression(resultName, node.argument, "=");
                        }
                    }
                });
                if (lhs)
                    fnAst.body.body.push(astUtils.createBinaryExpression(lhs, resultName, "="));
                fnAst.body.body.unshift(astUtils.createDeclaration(resultName));

                inlineCounter++;
                return fnAst.body;
            }
        }
    })
}

function propagateCopies(aast) {
    var changed = true;
    while (changed) {
        changed = false;
        var cfg = esgraph(aast.body[0].body);
        var result =  reachingDefinitions(cfg, findAssignedVariablesAndCopyValues);
        cfg[2].forEach(function (cfgNode, idx) {
            if (cfgNode.type)
                return;

            var input = result.get(cfgNode);
            function findDefintion(name) {
                var defs = input.values().filter(function (value) {
                    return value.name === name;
                });

                if (defs.length === 1)
                    return defs[0];

                var first = defs[0];
                if (defs.every(function (def) {
                        if (def.name !== first.name)
                            return false;
                        return equalValue(def.value, first.value);
                    }))
                    return first;
            }

            estraverse.replace(cfgNode.astNode, {
                enter: function (node, parent) {
                    if (node.type === Syntax.Identifier) {
                        if (parent.type === Syntax.MemberExpression && !parent.computed && parent.property.type === Syntax.Identifier && parent.property.name === node.name)
                            return;
                        if (parent.type === Syntax.Property)
                            return;
                        var definition = findDefintion(node.name);

                        if (definition && definition.value.type === Syntax.Identifier) {
                            if (definition === parent)
                                return;
                            if (parent.type === Syntax.AssignmentExpression && parent.right === definition.value)
                                return;
                            if (parent.type === Syntax.AssignmentExpression && parent.left === node)
                                return;
                            changed = true;
                            return definition.value;
                        }
                    }
                }
            });
        });
    }
}


function propagateConstants(aast) {
    var changed = true;
    while (changed) {
        changed = false;
        var cfg = esgraph(aast.body[0].body);
        var result =  reachingDefinitions(cfg, findAssignedVariablesAndLiteralValues);
        cfg[2].forEach(function (cfgNode, idx) {
            if (cfgNode.type)
                return;

            var input = result.get(cfgNode);
            function findDefinition(name) {
                var defs = input.values().filter(function (value) {
                    return value.name === name;
                });

                if (defs.length === 1)
                    return defs[0];

                var first = defs[0];
                if (defs.every(function (def) {
                        if (def.name !== first.name)
                            return false;
                        return equalValue(def.value, first.value);
                    }))
                    return first;
            }

            estraverse.replace(cfgNode.astNode, {
                enter: function (node, parent) {
                    if (node.type === Syntax.Identifier) {
                        if (parent.type === Syntax.MemberExpression && !parent.computed && parent.property.type === Syntax.Identifier && parent.property.name === node.name)
                            return;
                        if (parent.type === Syntax.Property)
                            return;
                        var definition = findDefinition(node.name);

                        if (definition && definition.value && definition.value.type === Syntax.Literal) {
                            if (definition === parent)
                                return;
                            if (parent.type === Syntax.AssignmentExpression && parent.right === definition.value)
                                return;
                            if (parent.type === Syntax.AssignmentExpression && parent.left === node)
                                return;
                            changed = true;
                            return definition.value;
                        }
                    }
                }
            });

            estraverse.replace(cfgNode.astNode, {
                enter: function (node, parent) {
                    if (parent.type === Syntax.AssignmentExpression && parent.left === node)
                        return;
                    if (node.computed && node.type === Syntax.MemberExpression && node.object.type === Syntax.Identifier && node.property.type === Syntax.Literal) {
                        var name = node.object.name;
                        var idx = node.property.value;
                        var definition = findDefinition(name);

                        if (definition && definition.value && definition.value.type === Syntax.ArrayExpression) {
                            changed = true;
                            return definition.value.elements[idx];
                        }
                    }
                }
            });

            foldConstants(aast);
        });
    }
}

function reachingDefinitions(cfg, gatherVariableDefinitions) {
    return analyses(cfg, function (input) {
        if (this.type)
            return input;

        var gen = this.gen = this.gen || gatherVariableDefinitions(this);

        var result = input.values().filter(function (i) {
            return !gen.values().some(function (v) {
                return i.name === v.name;
            });
        });

        return analyses.Set.union(gen, new analyses.Set(result));
    }, {
        equals: function (a, b) {
            if (a.size !== b.size)
                return;

            return a.values().every(function (v) {
                var x = b.values().find(function (bv) {
                    return bv.name === v.name && bv.value === v.value;
                });
                return x !== undefined;
            });
        }
    });
}

function findAssignedVariablesAndCopyValues(cfgNode) {
    var result = new analyses.Set();
    if (cfgNode.parent.type !== Syntax.ForStatement &&
        cfgNode.parent.type !== Syntax.WhileStatement &&
        cfgNode.astNode.type === Syntax.AssignmentExpression &&
        cfgNode.astNode.left.type === Syntax.Identifier) {
        result.add({name: cfgNode.astNode.left.name, value: cfgNode.astNode.right});
    }

    if (cfgNode.astNode.type === Syntax.CallExpression && cfgNode.astNode.callee.type === Syntax.Identifier && cfgNode.astNode.callee.name.indexOf("Store") !== -1)
        result.add({name: cfgNode.astNode.arguments[0].name, value: cfgNode.astNode.callee.name});

    return result;
}


function findAssignedVariablesAndLiteralValues(cfgNode) {
    var result = new analyses.Set();
    if (cfgNode.parent.type !== Syntax.ForStatement &&
        cfgNode.parent.type !== Syntax.WhileStatement &&
        cfgNode.astNode.type === Syntax.AssignmentExpression &&
        cfgNode.astNode.left.type === Syntax.Identifier) {
        result.add({name: cfgNode.astNode.left.name, value: cfgNode.astNode.right});
    }
    if (cfgNode.astNode.type === Syntax.AssignmentExpression &&
        cfgNode.astNode.left.type === Syntax.MemberExpression &&
        cfgNode.astNode.left.object.type === Syntax.Identifier)
        result.add({name: cfgNode.astNode.left.object.name, value: null});

    if (cfgNode.astNode.type === Syntax.CallExpression && cfgNode.astNode.callee.type === Syntax.Identifier && cfgNode.astNode.callee.name.indexOf("Store") !== -1)
        result.add({name: cfgNode.astNode.arguments[0].name, value: cfgNode.astNode.callee.name});

    return result;}

function equalValue(node1, node2) {
    if (!node1 || !node2)
        return false;
    if (node1.type !== node2.type)
        return false;

    switch (node1.type) {
        case Syntax.Literal:
            return node1.value === node2.value;
        case Syntax.Identifier:
            return node1.name === node2.name;
        case Syntax.ArrayExpression:
            return node1.elements.every(function (element, idx) {
                return node2.elements[idx] === element;
            });
        default:
            return false;
    }
}

function foldConstants(node) {
    estraverse.replace(node, {
        enter: function (node, parent) {
            switch (node.type) {
                case Syntax.BinaryExpression:
                case Syntax.LogicalExpression:
                    if (node.left.type === Syntax.Literal
                        && node.right.type === Syntax.Literal) {
                        var lhs = node.left.value;
                        var rhs = node.right.value;
                        return astUtils.createLiteral(eval(lhs + "" + node.operator + "" + rhs))
                    }
                    break;
            }
        }
    });

    return estraverse.replace(node, {
        enter: function(node) {
            if (node.type === Syntax.ExpressionStatement) {
                if (node.expression.type === Syntax.Literal)
                    return node.expression;
            }
        }
    });
}

function deadCodeElimination(aast) {
    var changed = true;
    while (changed) {
        changed = false;
        var cfg = esgraph(aast.body[0].body);
        // var result = liveVariables(cfg);
        var result = analyses(cfg, function (input) {
            if (this.type)
                return input;

            var gen = this.gen = this.gen || findUsedVariables(this.astNode);
            var kill = this.kill = this.kill || findAssignedVariables(this.astNode);
            return new analyses.Set.union(gen, analyses.Set.minus(input, kill));
        }, {direction: "backward"});

        cfg[2].forEach(function (cfgNode) {
            if (cfgNode.type)
                return;

            var node = cfgNode.astNode;
            if (cfgNode.kill.size > 0) {
                cfgNode.kill.forEach(function (kill) {
                    if (cfgNode.next.some(function (cfgNode) {
                            return result.get(cfgNode).has(kill);
                        }))
                        return;
                    if (node.type === Syntax.AssignmentExpression && node.left.type === Syntax.Identifier && node.left.name === kill) {
                        node.type = Syntax.EmptyStatement;
                        changed = true;
                    }
                })
            }
        });
    }
}

function findUsedVariables(node) {
    var vars = new analyses.Set();
    estraverse.traverse(node, {
        enter: function (node, parent) {
            if (node.type === Syntax.Identifier) {
                if (parent) {
                    if (parent.type === Syntax.AssignmentExpression && parent.left === node && ["+=", "-=", "*=", "/=", "&=", "|="].indexOf(parent.operator) === -1)
                        return;
                    if (parent.type === Syntax.MemberExpression && parent.property === node)
                        return;
                }
                vars.add(node.name);
            }
        }
    });

    return vars;
}

function findAssignedVariables(node) {
    var vars = new analyses.Set();
    estraverse.traverse(node, {
        enter: function (node, parent) {
            if (node.type === Syntax.AssignmentExpression && node.left.type === Syntax.Identifier)
                vars.add(node.left.name);
        }
    });
    return vars;
}

function removeEmptyStatements(aast) {
    estraverse.replace(aast, {
        enter: function (node) {
            if (node.type === Syntax.ExpressionStatement && node.expression.type === Syntax.EmptyStatement)
                return this.remove();
            if (node.type === Syntax.EmptyStatement)
                return this.remove();
        }
    })
}

},{"../../analyze/sanitizer/declaration_simplifier":109,"../../analyze/sanitizer/redundant_blocks_remover":110,"./ast_utils":146,"./math":150,"./texture":163,"analyses":46,"esgraph":58,"esprima":60,"estraverse":61}],163:[function(require,module,exports){
"use strict";

exports.sample = function sampleTexture(array, uv, uvOffset) {
    var u = uv[uvOffset], v = uv[uvOffset + 1];
    var x = Math.floor(u * (array.shape[0] - 1)) % (array.shape[0] - 1);
    var y = Math.floor((1 - v) * (array.shape[1] - 1)) % (array.shape[1] - 1);

    var offset = (x + y * array.shape[0]) * 4;
    return [array[offset], array[offset + 1], array[offset + 2] , array[offset + 3]];
};
},{}],164:[function(require,module,exports){
"use strict";

var estraverse = require("estraverse");
var Syntax = estraverse.Syntax;
var esgraph = require("esgraph");
var analyses = require("analyses");

var utils = require("../../utils");
var math = require("./math");
var astUtils = require("./ast_utils");
var constants = require("./constants");

exports.vectorize = function (ast) {
    estraverse.replace(ast, {
        leave: function (node, parent) {
            if (node.type === Syntax.ForStatement) {
                if (canBeVectorized(node) && !node.__ignore) {
                    vectorize(node, parent);
                }

            }
        }
    });

    return ast;
};

function canBeVectorized(node) {
    var loopVar = node.init.left.name;

    var cannotBeVectorized = false;
    var unsupportedOperators = ["%"];
    estraverse.traverse(node, {
        enter: function (node) {
            if (node.type === Syntax.ExpressionStatement) {
                var annotation = utils.annotate(node.expression);
                if (annotation.isVector() || annotation.isMatrix()) {
                    cannotBeVectorized = true;
                    this.break();
                }
            }
            if (node.type === Syntax.BinaryExpression && unsupportedOperators.indexOf(node.operator) !== -1) {
                cannotBeVectorized = true;
                this.break()
            }
        }
    });

    if (cannotBeVectorized)
        return false;

    var containsAlreadyVectorizedLoop = false;
    var node = JSON.parse(JSON.stringify(node));
    estraverse.replace(node, {
        enter: function (n) {
            if (n !== node && n.type === Syntax.ForStatement) {
                if (n.__vectorized) {
                    containsAlreadyVectorizedLoop = true;
                    this.break();
                }
                this.remove();
            }
        }
    });
    if (containsAlreadyVectorizedLoop)
        return false;

    var cfg = esgraph(node, {omitExceptions: true});
    analyses(cfg, function (input) {
        if (this.type)
            return input;

        var gen = this.gen = this.gen || findUsedVariables(this.astNode);
        this.gen.delete(loopVar);
        var kill = this.kill = this.kill || findAssignedVariables(this.astNode);
        return new analyses.Set.union(gen, analyses.Set.minus(input, kill));
    }, {direction: "backward"});

    var loopDependency = false;
    for (var i = 0; i < cfg[2].length && !loopDependency; ++i) {
        var cfgNode = cfg[2][i];

        if (!cfgNode.gen)
            continue;

        var definedAfter = cfgNode.gen.filter(function (varName) {
            return isDefinedAfter(cfgNode, varName, cfg[1].prev[0]);
        });

        loopDependency = definedAfter.length > 0;
    }

    return !loopDependency;
}

function findUsedVariables(node) {
    var vars = new analyses.Set();
    estraverse.traverse(node, {
        enter: function (node, parent) {
            if (node.type === Syntax.Identifier) {
                if (parent) {
                    if (parent.type === Syntax.AssignmentExpression && parent.left === node && ["+=", "-=", "*=", "/=", "&=", "|="].indexOf(parent.operator) === -1)
                        return;
                    if (parent.type === Syntax.MemberExpression && parent.property === node)
                        return;
                }
                vars.add(node.name);
            }
        }
    });

    return vars;
}

function findAssignedVariables(node) {
    var vars = new analyses.Set();
    estraverse.traverse(node, {
        enter: function (node, parent) {
            if (node.type === Syntax.AssignmentExpression && node.left.type === Syntax.Identifier)
                vars.add(node.left.name);
        }
    });
    return vars;
}

function isDefinedAfter(cfgNode, varName, loopTail, alreadyVisited) {
    alreadyVisited = alreadyVisited || new Set();
    alreadyVisited.add(cfgNode);
    if (!cfgNode.kill)
        return false;

    return cfgNode.next.reduce(function (isDefined, nextNode) {
        if (!nextNode.kill)
            return isDefined;
        if (nextNode.parent.type === Syntax.ForStatement)
            return isDefined;
        if (alreadyVisited.has(nextNode))
            return isDefined;
        if (nextNode === loopTail)
            return isDefined;
        return isDefined || nextNode.kill.has(varName) || isDefinedAfter(nextNode, varName, loopTail, alreadyVisited);
    }, false);
}

function vectorize(ast, parent) {
    ast.__vectorized = true;
    var loopVariable = ast.init.left.name;

    // clean up
    parent.body.splice(parent.body.indexOf(ast) + 1, 0, {
        type: Syntax.ForStatement,
        test: ast.test,
        update: ast.update,
        body: {
            type: Syntax.BlockStatement,
            body: JSON.parse(JSON.stringify(ast.body.body))
        }
    });
    ast.update = astUtils.createBinaryExpression(loopVariable, astUtils.createBinaryExpression(loopVariable, 4, "+"), "=").expression;
    ast.test = astUtils.createBinaryExpression(loopVariable, astUtils.createBinaryExpression(ast.test.right, astUtils.createBinaryExpression(ast.test.right, 4, "%"), "-"), ast.test.operator).expression;

    var vectorizedVariables = new Set();
    estraverse.replace(ast.body, {
        enter: function (node, parent) {
            if (node.type !== Syntax.BlockStatement && parent.type === Syntax.ForStatement) {
                this.skip();
            }
            if (node.type === Syntax.MemberExpression)
                this.skip();
        },
        leave: function (node, parent) {
            if (parent.type === Syntax.ForStatement)
                return;
            if (node.type === Syntax.AssignmentExpression) {
                if (node.left.type === Syntax.Identifier) {
                    var annotation = utils.annotate(node.right);
                    if (annotation.isVector())
                        return;
                    node.right = vectorizeNode(node.right, vectorizedVariables, loopVariable);
                    vectorizedVariables.add(node.left.name);
                    node.left.extra = node.left.extra || {};
                    node.left.extra.type = "object";
                    node.left.extra.kind = "Vec4";
                } else if (node.left.type === Syntax.MemberExpression) {
                    var containsLoopVariable = false;
                    estraverse.traverse(node.left, {
                        enter: function (n) {
                            if (n.type === Syntax.Identifier && n.name === loopVariable)
                                containsLoopVariable = true;
                        }
                    });

                    if (containsLoopVariable) {
                        var assignments = [];
                        for (var i = 0; i < 4; ++i) {
                            var newNode = estraverse.replace(JSON.parse(JSON.stringify(node)), {
                                enter: function (n, parent) {
                                    if (n.type === Syntax.Identifier && n.name === loopVariable) {
                                        this.skip();
                                        return astUtils.createBinaryExpression(n, i, "+").expression;
                                    }
                                }
                            });
                            newNode.right = extractComp(newNode.right, i, loopVariable);

                            newNode.__ignore = true;
                            assignments.push(newNode);
                        }
                        var expressionIdx = ast.body.body.indexOf(parent);
                        assignments.forEach(function (assignment, idx) {
                            ast.body.body.splice(expressionIdx + idx, 0, {type: Syntax.ExpressionStatement, expression: assignment})
                        });
                        return {
                            type: Syntax.EmptyStatement
                        }
                    }
                }
            }

            if (node.type === Syntax.BinaryExpression) {
                var operator = node.operator;
                var method = "";
                switch (operator) {
                    case "+":
                        method = "add";
                        break;
                    case "-":
                        method = "sub";
                        break;
                    case "*":
                        method = "mul";
                        break;
                    case "/":
                        method = "div";
                        break;
                }

                node.left = vectorizeNode(node.left, vectorizedVariables, loopVariable);
                node.right = vectorizeNode(node.right, vectorizedVariables, loopVariable);
                node.left.extra = node.left.extra || {};
                node.left.extra.type = "object";
                node.left.extra.kind = "Vec4";

                return astUtils.createFunctionCall(astUtils.createMemberExpression(node.left, method), [node.right], {type: "object", kind: "Vec4"});
            }
        }
    });
}

function vectorizeNode(node, vectorizedVariables, loopVariable) {
    if (node.type === Syntax.Identifier) {
        if ((vectorizedVariables.has(node.name) || node.name.indexOf("_bop") === 0)) {
            node.extra = node.extra || {};
            node.extra.type = "object";
            node.extra.kind = "Vec4";
            return node;
        } else {
            if (node.name === loopVariable)
                return astUtils.createNewExpression("Vec4", [
                    astUtils.createBinaryExpression(node, 0, "+").expression,
                    astUtils.createBinaryExpression(node, 1, "+").expression,
                    astUtils.createBinaryExpression(node, 2, "+").expression,
                    astUtils.createBinaryExpression(node, 3, "+").expression,
                ]);
            else
                return astUtils.createNewExpression("Vec4", [node]);
        }
    } else {
        var containsLoopVariable = false;
        estraverse.replace(node, {
            enter: function (n) {
                if (n.type === Syntax.Identifier && n.name === loopVariable) {
                    containsLoopVariable = true;
                }
            }
        });

        if (containsLoopVariable) {
            var args = [];
            for (var i = 0; i < 4; ++i) {
                var newNode = estraverse.replace(JSON.parse(JSON.stringify(node)), {
                    enter: function (n, parent) {
                        if (n.type === Syntax.Identifier && n.name === loopVariable) {
                            this.skip();
                            return astUtils.createBinaryExpression(n, i, "+").expression;
                        }
                    }
                });
                newNode.__ignore = true;
                args.push(newNode);
            }
            return astUtils.createNewExpression("Vec4", args);
        }


        if (node.type === Syntax.CallExpression && node.callee.type === Syntax.MemberExpression && node.callee.object.name === "Math" && math.vec4[node.callee.property.name + "SIMD"])
            return astUtils.createFunctionCall(astUtils.createMemberExpression(astUtils.createIdentifier(node.arguments[0].name, {type: "object", kind: "Vec4"}), node.callee.property.name));

        return astUtils.createNewExpression("Vec4", [extractComp(node, 0), extractComp(node, 1), extractComp(node, 2), extractComp(node, 3)]);
    }
}

function extractComp(node, idx, loopVariable) {
    var node = JSON.parse(JSON.stringify(node));
    return estraverse.replace(node, {
        enter: function (node, parent) {
            if (node.type === Syntax.Identifier && parent.type !== Syntax.MemberExpression && node.name !== loopVariable) {
                node.extra = node.extra || {};
                node.extra.type = "object";
                node.extra.kind = "Vec4";
                return astUtils.createMemberExpression(node, constants.vectorIndexToSwizzleMap[idx], {type: "number"});
            }
        }
    });
}

},{"../../utils":206,"./ast_utils":146,"./constants":148,"./math":150,"analyses":46,"esgraph":58,"estraverse":61}],165:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js");

    var Transformer = require("./transform.js");
    var generate = require("./glsl-generate.js").generate;


    var GLSLCompiler = function () {

    };

    Base.extend(GLSLCompiler.prototype, {

        compileFragmentShader: function (aast, opt) {
            opt = opt || {};

            var transformer = new Transformer(aast, "shade", false, opt);

            //console.log(require("escodegen").generate(aast));
            //console.log(JSON.stringify(aast, 0, " "));

            var transformed = transformer.transform(aast);

            //console.log(JSON.stringify(aast, 0, " "));

            opt.headers = transformed.headers;
            var code = generate(transformed.program, false, opt);

            return {source: code, uniformSetter: transformed.uniformSetter};
        },
        compileVertexShader: function (aast, opt) {
            opt = opt || {};

            var transformer = new Transformer(aast, "global.main", true, opt);

            //console.log(JSON.stringify(aast, 0, " "));

            var transformed = transformer.transform(aast);

            //console.log(JSON.stringify(aast, 0, " "));

            opt.headers = transformed.headers;
            var code = generate(transformed.program, true, opt);

            return {source: code, uniformSetter: transformed.uniformSetter};
        }

    });


    ns.GLSLCompiler = GLSLCompiler;

}(exports));

},{"../../base/index.js":142,"./glsl-generate.js":166,"./transform.js":178}],166:[function(require,module,exports){
// Dependencies
var Shade = require("./../../interfaces.js");
var walk = require('estraverse');
var ExpressionHandler = require('../base/expression-handler.js').ExpressionHandler,
    Syntax = walk.Syntax,
    VisitorOption = walk.VisitorOption,
    annotate = require("../../utils").annotate;


// Shortcuts
var Types = Shade.TYPES,
    Kinds = Shade.OBJECT_KINDS,
    Sources = Shade.SOURCES;

var InternalFunctions = {
    "MatCol": function (name, details) {
        var matType = details.matType,
            colType = details.colType;
        return [matType + " " + name + "(" + matType + " mat, int idx, " + colType + " value){",
            "  " + matType + " result = " + matType + "(mat);",
            "  result[idx] = value;",
            "  return result;",
            "}"];
    }
}

var GLSL = {
    Storage: {
        CONST: "const",
        UNIFORM: "uniform",
        VARYING: "varying",
        ATTRIBUTE: "attribute"
    }
}

var handler = new ExpressionHandler({
    type: toGLSLType
});


/**
 * @param {object} opt
 */
var getHeader = function (opt) {
    if (opt.omitHeader == true)
        return [];
    var header = [
        "// Generated by shade.js"
    ];
    if (opt.headers)
        header = header.concat(opt.headers)
    var floatPrecision = opt.floatPrecision || "highp";
    header.push("precision " + floatPrecision + " float;");
    header.push("");
    return header;
}

function toGLSLType(info, options) {
    if (!info) return "?";
    options = options || {};

    //console.log(info);

    switch (info.type) {
        case Types.OBJECT:
            switch (info.kind) {
                case "Vec4":
                    return "vec4";
                case "Vec3":
                    return "vec3";
                case "Vec2":
                    return "vec2";
                case "Texture":
                    return "sampler2D";
                case "Mat3":
                    return "mat3";
                case Kinds.MATRIX4:
                    return "mat4";
                case Kinds.COLOR_CLOSURE:
                    return "vec4";
                default:
                    throw new Error("Missing GLSL support for:" + info.kind);
            }
        case Types.ARRAY:
            return toGLSLType(info.elements, options);

        case Types.UNDEFINED:
            if (options.allowUndefined)
                return "void";
            throw new Error("Could not determine type");
        case Types.NUMBER:
            return "float";
        case Types.BOOLEAN:
            return "bool";
        case Types.INT:
            return "int";
        default:
            //throw new Error("toGLSLType: Unhandled type: " + info.type);
            return info.type;

    }
}

var toGLSLStorage = function (info, vertexShader) {
    if (!info.source)
        return null;
    if (info.source == Sources.VERTEX) {
        if (vertexShader && !info.output)
            return GLSL.Storage.ATTRIBUTE;
        else
            return GLSL.Storage.VARYING;
    }
    if (info.source == Sources.UNIFORM)
        return GLSL.Storage.UNIFORM;
    if (info.source == Sources.CONSTANT)
        return GLSL.Storage.CONST;
    throw new Error("toGLSLSource: Unhandled type: " + info.source);
}

function filterUndefined(arr) {
    return arr.filter(function (n) {
        return n.extra.type != Types.UNDEFINED;
    });
}

function createLineStack() {
    var arr = [];
    arr.push.apply(arr, arguments);
    var indent = "";
    arr.appendLine = function (line) {
        line ? this.push(indent + line) : this.push("");
    };
    arr.changeIndention = function (add) {
        while (add > 0) {
            indent += "    ";
            add--;
        }
        if (add < 0) {
            indent = indent.substr(0, indent.length + add * 4);
        }
    };
    arr.append = function (str) {
        this[this.length - 1] = this[this.length - 1] + str;
    };
    return arr;
};


/*Base.extend(LineStack.prototype, {

 });*/

var generate = function (ast, vertexshader, opt) {

    opt = opt || {};

    var lines = createLineStack();

    traverse(ast, lines, vertexshader, opt);

    return lines.join("\n");
}

function appendInternalFunctions(lines, internalFunctions) {
    if (!internalFunctions) return;
    for (var key in internalFunctions) {
        var entry = internalFunctions[key];
        if (InternalFunctions[entry.type]) {
            var linesToAdd = InternalFunctions[entry.type](entry.name, entry.details);
            lines.push.apply(lines, linesToAdd);
        }
        else {
            throw Error("Internal: InlineFunction of type '" + entry.type + "' not available!");
        }
    }
}

function traverse(ast, lines, vertexShader, opt) {
    var insideMain = false;


    walk.traverse(ast, {
            enter: function (node) {
                try {
                    var type = node.type;
                    switch (type) {

                        case Syntax.Program:
                            getHeader(opt).forEach(function (e) {
                                lines.push(e)
                            });
                            appendInternalFunctions(lines, annotate(ast).getUserData().internalFunctions);
                            addForwardDeclarations(lines, node);
                            break;


                        case Syntax.FunctionDeclaration:
                            opt.newLines && lines.appendLine();
                            if (node.id.name == "main")
                                insideMain = true;

                            lines.appendLine(generateFunctionSignature(node) + " {");
                            lines.changeIndention(1);
                            return;


                        case Syntax.ReturnStatement:
                            lines.appendLine(handler.statement(node));
                            return;

                        case Syntax.VariableDeclarator :
                            // console.log("Meep!");
                            var decl = handleVariableDeclaration(node, insideMain, vertexShader, opt);
                            lines.appendLine(decl);
                            return;

                        case Syntax.AssignmentExpression:
                        case Syntax.ExpressionStatement:
                            lines.appendLine(handler.expression(node) + ";")
                            return VisitorOption.Skip;

                        case Syntax.IfStatement:
                            lines.appendLine("if(" + handler.expression(node.test, opt) + ") {");

                            lines.changeIndention(1);
                            traverse(node.consequent, lines, opt);
                            lines.changeIndention(-1);

                            if (node.alternate) {
                                lines.appendLine("} else {");
                                lines.changeIndention(1);
                                traverse(node.alternate, lines, opt);
                                lines.changeIndention(-1);
                            }
                            lines.appendLine("}");
                            return VisitorOption.Skip;

                        case Syntax.ForStatement:
                            lines.appendLine("for (" + handleInlineDeclaration(node.init, opt) + "; " + handler.expression(node.test, opt) + "; " + handler.expression(node.update, opt) + ") {");
                            lines.changeIndention(1);
                            traverse(node.body, lines, opt);
                            lines.changeIndention(-1);
                            lines.appendLine("}");
                            return VisitorOption.Skip;

                        case Syntax.NewStatement:


                        case Syntax.ContinueStatement:
                            lines.appendLine("continue;");
                            return;
                        case Syntax.BreakStatement:
                            lines.appendLine("break;");
                            return;


                        default:
                        //console.log("Unhandled: " + type);

                    }
                } catch (e) {
                    throw e;//console.error(e);
                    //Shade.throwError(node, e.message);
                }
            },
            leave: function (node) {
                var type = node.type;
                switch (type) {
                    case Syntax.Program:
                        break;
                    case Syntax.FunctionDeclaration:
                        lines.changeIndention(-1);
                        lines.appendLine("}");
                        break;
                }
            }
        }
    );
}

function addForwardDeclarations(lines, node) {
    var first = true;
    walk.traverse(node, {
        enter: function (node) {
            if (node.type == Syntax.FunctionDeclaration) {
                if (node.id.name == "main") {
                    return;
                }
                if (first) {
                    first = false;
                    lines.appendLine("// Forward declarations");
                }
                lines.appendLine(generateFunctionSignature(node) + ";");
            }
        }
    });
    if (!first) {
        lines.appendLine("");
    }
}

function generateFunctionSignature(node) {
    var func = annotate(node);
    var methodStart = [toGLSLType(func.getReturnInfo(), {allowUndefined: true})];
    methodStart.push(node.id.name, '(');
    if (!(node.params && node.params.length)) {
        methodStart.push("void");
    } else {
        var methodArgs = [];
        node.params.forEach(function (param) {
            methodArgs.push(toGLSLType(param.extra) + " " + param.name);
        })
        methodStart.push(methodArgs.join(", "));
    }
    methodStart.push(")");
    return methodStart.join(" ");
}

function getStaticValue(extra) {
    if (!extra || extra.staticValue === undefined) return "";
    return extra.staticValue;
};

function handleVariableDeclaration(node, writeStorageQualifier, vertexShader, opt) {
    var storageQualifier = !writeStorageQualifier ? toGLSLStorage(node.extra, vertexShader) : null;
    var result = storageQualifier ? storageQualifier + " " : "";
    result += toGLSLType(node.extra) + " " + node.id.name;
    if (node.extra.elements) {
        result += "[" + (node.extra.staticSize ? node.extra.staticSize : "0") + "]";
    }
    if (node.init) result += " = " + handler.expression(node.init);
    if (!node.init && storageQualifier == GLSL.Storage.CONST) {
        result += " = " + getStaticValue(node.extra);
    }
    return result + ";";
}


function handleInlineDeclaration(node, opt) {
    if (!node)
        return "";
    if (node.type == Syntax.VariableDeclaration) {
        var result = node.declarations.reduce(function (declString, declaration) {
            var decl = toGLSLType(declaration.extra) + " " + declaration.id.name;
            if (declaration.init) {
                decl += " = " + handler.expression(declaration.init);
            }
            return declString + decl;
        }, "");
        return result;
    }

    // GLSL allows only declaration in init, but since this is a new scope, it should be fine
    if (node.type == Syntax.AssignmentExpression) {
        return toGLSLType(node.extra) + " " + handler.expression(node.left) + " = " + handler.expression(node.right);
    }
    Shade.throwError(node, "Internal error in GLSL::handleInlineDeclaration, found " + node.type);
}


exports.generate = generate;



},{"../../utils":206,"../base/expression-handler.js":145,"./../../interfaces.js":188,"estraverse":61}],167:[function(require,module,exports){
var GLObjects = new Map();

GLObjects.set("Math", require("./math.js"));
GLObjects.set("Vec2", require("./vec2.js"));
GLObjects.set("Vec3", require("./vec3.js"));
GLObjects.set("Vec4", require("./vec4.js"));
GLObjects.set("System", require("./system.js"));

var TypeSystem = require("../../../type-system/type-system.js");

    var Scope = require("../../../utils/").Scope,
        Context = require("../../../base/context.js"),
        Base = require("../../../base/index.js"),
        common = require("../../../base/common.js");


    var objects = {
        Shade : require("./shade.js"),
        Space : require("./space.js"),
        Math : require("./math.js"),
        System : require("./system.js"),
        Vec2 : require("./vec2.js"),
        Vec3 : require("./vec3.js"),
        Color: require("./vec3.js"),
        Vec4 : require("./vec4.js"),
        Mat3 : require("./mat3.js"),
        Mat4 : require("./mat4.js"),
        Texture : require("./texture.js")
    };

    var Registry = {
        name: "GLSLTransformRegistry",
        getByName: function(name) {
            var result = objects[name];
            return result || null;
        },
        getInstanceForKind: function(kind) {
            for(var obj in objects) {
                //noinspection JSUnfilteredForInLoop
                if (objects[obj].kind == kind) {
                    //noinspection JSUnfilteredForInLoop
                    return objects[obj].instance;
                }
            }
            return null;
        }
    };


    /**
     * @param root
     * @param {string} entry
     * @param opt
     * @extends {Context}
     * @constructor
     */
    var GLTransformContext = function(root, entry, vertexShader, opt) {
        opt.mainFunction = entry;
        Context.call(this, root, opt);
        this.usedParameters = {
            environment: {},
            system: {},
            uexp: {}
        };

        this.outputs = opt.outputs || ["color"];
        this.uniformExpressions = opt.uniformExpressions || {};

        this.vertexShader = vertexShader;
        this.systemParameters = {};
        this.blockedNames = [];
        this.topDeclarations = [];
        this.internalFunctions = {};
        this.idNameMap = {};
        this.headers = []; // Collection of header lines to define

        this.globalParameters = root.globalParameters && root.globalParameters[entry] && root.globalParameters[entry][0] ? root.globalParameters[entry][0].extra.info : {};


    };

    Base.createClass(GLTransformContext, Context, {
        createScope: function(node, parent, name) {
            return new GLTransformScope(node, parent, {name: name});
        },
        getTypeInfo: function(node) {
            return common.getTypeInfo(node, this.getScope());
        },
        addHeader: function(headerStr) {
            if (this.headers.indexOf(headerStr) == -1) {
                this.headers.push(headerStr);
            }
        }
    });

    /**
     * @constructor
     * @extends {Scope}
     */
    var GLTransformScope = function(node, parentScope, opt) {
        Scope.call(this, node, parentScope, opt);
    };

    Base.createClass(GLTransformScope, Scope, {

        registerGlobals: function() {

            this.declarePredefined("Math", TypeSystem.getPredefinedObject("Math"));
		    this.declarePredefined("Vec2", TypeSystem.getPredefinedObject("Vec2"));
		    this.declarePredefined("Vec3", TypeSystem.getPredefinedObject("Vec3"));
		    this.declarePredefined("Vec4", TypeSystem.getPredefinedObject("Vec4"));

            //console.log(TypeSystem.getPredefinedObject("Vec3"));
            //this.declarePredefined("Vec3", TypeSystem.getPredefinedObject("Vec3"));

            /*this.registerObject("Math", objects.Math);
            this.registerObject("Color",  objects.Color);
            this.registerObject("Vec2", objects.Vec2);
            this.registerObject("Vec3", objects.Vec3);
            this.registerObject("Vec4", objects.Vec4);
            this.registerObject("Texture", objects.Texture);
            this.registerObject("Shade", objects.Shade);
            this.registerObject("Mat3", objects.Mat3);
            this.registerObject("Mat4", objects.Mat4);
            this.registerObject("Space", objects.Space);

            this.declare("gl_FragCoord", false);
            this.updateTypeInfo("gl_FragCoord", new TypeInfo({
                extra: {
                    type: Types.OBJECT,
                    kind: "Vec3"
                }
            }));*/
        }
    });



    module.exports = {
        GLTransformScope : GLTransformScope,
        GLTransformContext : GLTransformContext,
        GLObjects: GLObjects
    };


},{"../../../base/common.js":140,"../../../base/context.js":141,"../../../base/index.js":142,"../../../type-system/type-system.js":202,"../../../utils/":206,"./mat3.js":168,"./mat4.js":169,"./math.js":170,"./shade.js":171,"./space.js":172,"./system.js":173,"./texture.js":174,"./vec2.js":175,"./vec3.js":176,"./vec4.js":177}],168:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Mat3Instance = {
        col: {
            callExp: Tools.Mat.generateColCall.bind(null, "Mat3")
        }
    }
    Tools.Mat.attachOperators(Mat3Instance, "Mat3", {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/'
    });
    Tools.Vec.attachOperators(Mat3Instance, 3, {
        mulVec: '*'
    });


    Tools.extend(ns, {
        id: "Mat3",
        kind: KINDS.MATRIX3,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Mat3Instance
    });

}(exports));

},{"../../../interfaces.js":188,"../../tools.js":182,"estraverse":61}],169:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Mat4Instance = {
        col: {
            callExp: Tools.Mat.generateColCall.bind(null, "Mat4")
        }
    }
    Tools.Mat.attachOperators(Mat4Instance, "Mat4", {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/'
    });
    Tools.Vec.attachOperators(Mat4Instance, 4, {
        mulVec: '*'
    });


    Tools.extend(ns, {
        id: "Mat4",
        kind: KINDS.MATRIX4,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Mat4Instance
    });

}(exports));

},{"../../../interfaces.js":188,"../../tools.js":182,"estraverse":61}],170:[function(require,module,exports){
var Tools = require("../../tools.js");
var TypeInfo = require("../../../type-system/typeinfo.js");

var MathConstants = ["E", "PI", "LN2", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2"];

// TODO: Implement saturate
// TODO: Rename atan
// TODO: Handle ceil?

var MathCall = function (node, name) {
    // Remove Math.
    node.callee = Tools.removeMemberFromExpression(node.callee);

    // Cast all arguments of the math function to float, as they are
    // not defined for other types (int, bool)
    // Don't replace the arguments array, it's already cached by the traversal
    node.arguments.forEach(function (arg, i) {
        var t = new TypeInfo(arg.extra);
        if (t.isInt()) {
            node.arguments[i] = Tools.castToFloat(node.arguments[i]);
        }
    });
    return node;
};

var MathProperty = function (node, name) {
    if(MathConstants.indexOf(name) != -1) {
        return {type: 'Literal', value: Math[name], extra: {type: "number"}};
    }
};

module.exports = {
    call: MathCall,
    property: MathProperty
};


},{"../../../type-system/typeinfo.js":203,"../../tools.js":182}],171:[function(require,module,exports){
(function (ns) {

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");

    var ShadeInstance = {
        mix: { callExp: function(node, args) {
            node.callee = Tools.removeMemberFromExpression(node.callee);
            return node;
        }}
    }

    Tools.extend(ns, {
        id: "Shade",
        kind: Shade.OBJECT_KINDS.COLOR_CLOSURE,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: ShadeInstance
        },
        instance: ShadeInstance
    });

}(exports));

},{"../../../interfaces.js":188,"../../tools.js":182,"estraverse":61}],172:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");


    function getSpaceTransform(spaceArg, normal){
        if( spaceArg.type != Syntax.MemberExpression ||
            spaceArg.object.type != Syntax.Identifier ||
            spaceArg.object.name != "Space" ||
            spaceArg.property.type != Syntax.Identifier)
            Shade.throwError(spaceArg, "We only support Space enums for the first argument of transformDirection and transformPoint");

        switch(spaceArg.property.name){
            case "VIEW": return normal ? "modelViewMatrixN" : "modelViewMatrix";
            case "WORLD": return normal ? "modelMatrixN" : "modelMatrix";
            default: Shade.throwError(spaceArg, "Unknown Space Type: '" + spaceArg.property.name + "'");
        }
    }

    var annotate = require("../../../utils").annotate;
    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;
    var SpaceEntry  = {
        transformDirection: { callExp: function(callExpression, parent, context, state){
            var transform = getSpaceTransform(callExpression.arguments[0], true);
            var result = {  type: Syntax.BinaryExpression, operator: "*",
                            left: { type: Syntax.Identifier, name: transform},
                            right: callExpression.arguments[1]
            };

            annotate(result).setType(TYPES.OBJECT, KINDS.FLOAT3);
            annotate(result.left).setType(TYPES.OBJECT, KINDS.MATRIX3);
            annotate(result.right).setType(TYPES.OBJECT, KINDS.FLOAT3);

            var systemName = Tools.getNameForSystem(transform);
            state.usedParameters.system[systemName] = state.systemParameters[transform];

            return result;
        } },
        transformPoint: { callExp: function(callExpression, parent, context, state){
            var transform = getSpaceTransform(callExpression.arguments[0], false);
            var result = {  type: Syntax.MemberExpression,
                            object: {  type: Syntax.BinaryExpression, operator: "*",
                                left: { type: Syntax.Identifier, name: transform},
                                right: {type: Syntax.CallExpression,
                                   callee: {type: Syntax.Identifier, name: "vec4"},
                                   arguments: [
                                        callExpression.arguments[1],
                                        { type: Syntax.Literal, value: 1, raw: 1}
                                   ]
                                }
                            },
                            property: { type: Syntax.Identifier, name: "xyz" }
                          };
            annotate(result).setType(TYPES.OBJECT, KINDS.FLOAT3);
            annotate(result.object).setType(TYPES.OBJECT, KINDS.FLOAT4);
            annotate(result.object.left).setType(TYPES.OBJECT, KINDS.MATRIX4);
            annotate(result.object.right).setType(TYPES.OBJECT, KINDS.FLOAT4);
            annotate(result.object.right.arguments[1]).setType(TYPES.NUMBER);


            var systemName = Tools.getNameForSystem(transform);
            state.usedParameters.system[systemName] = state.systemParameters[transform];

            return result;
        } },
        VIEW: {
            property: function (memberExpression) {
                return memberExpression;
            }},
        WORLD: {
            property: function (memberExpression) {
                return  memberExpression;
            }}
    };

    Tools.extend(ns, {
        id: "Space",
        object: {
            constructor: null,
            static: SpaceEntry
        },
        instance: SpaceEntry
    });

}(exports));

},{"../../../interfaces.js":188,"../../../utils":206,"../../tools.js":182,"estraverse":61}],173:[function(require,module,exports){
// Dependencies
var Shade = require("../../../interfaces.js");
var Tools = require("../../tools.js");
var Syntax = require('estraverse').Syntax;

// Shortcuts
var TYPES = Shade.TYPES,
    KINDS = Shade.OBJECT_KINDS;


var SystemDefines = {};
SystemDefines.CANVAS_DIMENSIONS = "coords";
SystemDefines.DERIVATE_EXTENSION = "#extension GL_OES_standard_derivatives : enable";

var CoordsType = {
    type: Shade.TYPES.OBJECT,
    kind: Shade.OBJECT_KINDS.FLOAT3,
    source: Shade.SOURCES.UNIFORM
};


var SystemProperties = {
    coords: function (node) {
            node.property.name = "gl_FragCoord";
            return node.property;
    },
    normalizedCoords:  function () {
            return {
                type: Syntax.NewExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: "Vec3"
                },
                arguments: [
                    {
                        type: Syntax.BinaryExpression,
                        left: {
                            type: Syntax.MemberExpression,
                            object: {
                                type: Syntax.Identifier,
                                name: "gl_FragCoord"
                            },
                            property: {
                                type: Syntax.Identifier,
                                name: "xyz"
                            }
                        },
                        right: {
                            type: Syntax.Identifier,
                            name: SystemDefines.CANVAS_DIMENSIONS
                        },
                        operator: "/",
                        extra: {
                            type: Shade.TYPES.OBJECT,
                            kind: "Vec3"
                        }
                    }
                ],
                extra: {
                    type: Shade.TYPES.OBJECT,
                    kind: "Vec3"
                }
            }
    },
    height:  function (node) {
            var parameterName = Tools.getNameForSystem(SystemDefines.CANVAS_DIMENSIONS);
            state.usedParameters.system[parameterName] = state.systemParameters[SystemDefines.CANVAS_DIMENSIONS];

            node.property.name = parameterName + ".y";
            return node.property;
    },
    width:  function (node) {
            var parameterName = Tools.getNameForSystem(SystemDefines.CANVAS_DIMENSIONS);
            state.usedParameters.system[parameterName] = state.systemParameters[SystemDefines.CANVAS_DIMENSIONS];

            node.property.name = parameterName + ".x";
            return node.property;
    },
    fwidth: function (node, context) {
            context.addHeader(SystemDefines.DERIVATE_EXTENSION);
            return Tools.removeMemberFromExpression(node);
    },
    dx: function (node, context) {
            context.addHeader(SystemDefines.DERIVATE_EXTENSION);
            var result = Tools.removeMemberFromExpression(node);
            result.name = "dFdx";
            return result;
    },
    dy:  function (node, context) {
            context.addHeader(SystemDefines.DERIVATE_EXTENSION);
            var s = Tools.removeMemberFromExpression(node);
            var result = Tools.removeMemberFromExpression(node);
            result.name = "dFdy";
            return result;
    }

};

module.exports = {
    call: function (node, name) {},
    property: function (node, name, context) {
        if(SystemProperties.hasOwnProperty(name)) {
            return SystemProperties[name](node, context);
        }

    }
};

},{"../../../interfaces.js":188,"../../tools.js":182,"estraverse":61}],174:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var TextureInstance = {
        sample2D: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'texture2D', 2)
        },
        width: {
            property: function (node, parent, context, state) {
                var parameterName = node.object.name;
                node.property.name = parameterName + "_width";
                state.usedParameters.shader[parameterName + "_width"] = {
                    type: Shade.TYPES.INT,
                    kind: Shade.OBJECT_KINDS.INT,
                    source: Shade.SOURCES.UNIFORM
                };
                return node.property;
            }
        },
        height: {
            property: function (node, parent, context, state) {
                var parameterName = node.object.name;
                node.property.name = parameterName + "_height";
                state.usedParameters.shader[parameterName + "_height"] = {
                    type: Shade.TYPES.INT,
                    kind: Shade.OBJECT_KINDS.INT,
                    source: Shade.SOURCES.UNIFORM
                };
                return node.property;
            }
        }
    }

    Tools.extend(ns, {
        id: "Texture",
        kind: KINDS.TEXTURE,
        object: {
            constructor: null,
            static: {}
        },
        instance: TextureInstance
    });

}(exports));

},{"../../../interfaces.js":188,"../../tools.js":182,"estraverse":61}],175:[function(require,module,exports){
var Shade = require("../../../interfaces.js");
var Syntax = require('estraverse').Syntax;
var Tools = require("../../tools.js");

var TYPES = Shade.TYPES,
    KINDS = Shade.OBJECT_KINDS;

var Vec2Instance = {
    normalize: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'normalize', 0)
    },
    flip: {
        callExp: Tools.Vec.createFunctionCall.bind(null, '-', 0)
    },
    dot: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'dot', 2)
    },
    reflect: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'reflect', 2)
    },
    length: {
        callExp: Tools.Vec.generateLengthCall
    }
};

Tools.Vec.attachSwizzles(Vec2Instance, 2, Tools.Vec.createSwizzle, Tools.Vec.createSwizzleOperator);

Tools.Vec.attachOperators(Vec2Instance, 2, {
    add: '+',
    sub: '-',
    mul: '*',
    div: '/',
    mod: '%'
});


module.exports = {
    call: function (node, name) {
        if (Vec2Instance.hasOwnProperty(name)) {
            return Vec2Instance[name].callExp(node)
        }
    },
    property: function () {
    }
};

},{"../../../interfaces.js":188,"../../tools.js":182,"estraverse":61}],176:[function(require,module,exports){
var Tools = require("../../tools.js");
var TypeInfo = require("../../../type-system/typeinfo.js");


var Vec3Instance = {
    normalize: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'normalize', 0)
    },
    flip: {
        callExp: Tools.Vec.createFunctionCall.bind(null, '-', 0)
    },
    dot: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'dot', 3)
    },
    reflect: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'reflect', 3)
    },
    refract: {
        callExp: function (node, args, parent) {
            var eta = node.arguments.pop();
            var result = Tools.Vec.createFunctionCall("refract", 3, node);
            new TypeInfo(eta.extra).setType("number");
            result.arguments.push(eta);
            return result;
        }
    },
    length: {
        callExp: Tools.Vec.generateLengthCall
    },
    cross: {
        callExp: Tools.Vec.createFunctionCall.bind(null, "cross", 3)
    }
};

Tools.Vec.attachSwizzles(Vec3Instance, 3, Tools.Vec.createSwizzle, Tools.Vec.createSwizzleOperator);
Tools.Vec.attachOperators(Vec3Instance, 3, {
    add: '+',
    sub: '-',
    mul: '*',
    div: '/',
    mod: '%'
});


function Vec3Call(node, name) {
    if (Vec3Instance.hasOwnProperty(name)) {
        return Vec3Instance[name].callExp(node)
    }
}

module.exports = {
    call: Vec3Call,
    property: function () {
    }
};

},{"../../../type-system/typeinfo.js":203,"../../tools.js":182}],177:[function(require,module,exports){
var Tools = require("../../tools.js");

var Vec4Instance = {
    normalize: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'normalize', 0)
    },
    flip: {
        callExp: Tools.Vec.createFunctionCall.bind(null, '-', 0)
    },
    dot: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'dot', 4)
    },
    reflect: {
        callExp: Tools.Vec.createFunctionCall.bind(null, 'reflect', 4)
    },
    length: {
        callExp: Tools.Vec.generateLengthCall
    }
}
Tools.Vec.attachSwizzles(Vec4Instance, 4, Tools.Vec.createSwizzle, Tools.Vec.createSwizzleOperator);
Tools.Vec.attachOperators(Vec4Instance, 4, {
    add: '+',
    sub: '-',
    mul: '*',
    div: '/',
    mod: '%'
})


module.exports = {
    call: function (node, name) {
        if (Vec4Instance.hasOwnProperty(name)) {
            return Vec4Instance[name].callExp(node)
        }
    },
    property: function () {
    }
};

},{"../../tools.js":182}],178:[function(require,module,exports){
var Base = require("../../base/index.js"),
    common = require("../../base/common.js"),
    Shade = require("./../../interfaces.js"),
    Types = Shade.TYPES,
    analyses = require('analyses'),
    Tools = require('../tools.js'),
    System = require('./registry/system.js'),
    assert = require('assert'),
    TypeInfo = require("../../type-system/typeinfo.js");


var Context = require("./registry/").GLTransformContext;
var GLObjects = require("./registry/").GLObjects;


var walk = require('estraverse');
var Syntax = walk.Syntax;
var ANNO = common.ANNO;
var Set = analyses.Set;


/**
 * Transforms the JS AST to an AST representation convenient
 * for code generation
 * @constructor
 */
var GLASTTransformer = function (root, mainId, vertexShader, opt) {
    this.context = new Context(root, mainId, vertexShader, opt);
};

function createUniformDependencyMap(uniformExpressions) {
    var name, uexpSet, dependencies, dependency, dl, dependencyMap = new Map();
    for (name in uniformExpressions) {
        dependencies = uniformExpressions[name].getUniformDependencies();
        dl = dependencies.length;
        while (dl--) {
            dependency = dependencies[dl];
            if (dependencyMap.has(dependency)) {
                uexpSet = dependencyMap.get(dependency);
            } else {
                uexpSet = new Set();
                dependencyMap.set(dependency, uexpSet);
            }
            uexpSet.add(name);
        }
    }
    return dependencyMap;
}

Base.extend(GLASTTransformer.prototype, {
    /**
     *
     * @param {GLTransformScope} scope
     */
    registerThisObject: function (scope) {
        /*var thisObject = scope.getBindingByName("this");
         if (thisObject && thisObject.isObject()) {
         var properties = thisObject.getNodeInfo();
         for (var name in properties) {
         var prop = ANNO({}, properties[name]);
         if (!prop.isDerived())
         this.context.blockedNames.push(Tools.getNameForSystem(name));
         }
         for (var property in System.derivedParameters) {
         if(properties.hasOwnProperty(property)) {
         Base.deepExtend(properties[property], System.derivedParameters[property]);
         }
         }
         Base.extend(this.context.systemParameters, properties);
         } */
    },


    createUniformSetterFunction: function (parameters) {
        // Reverse uniform expression dependencies
        var c_dependencyMap = createUniformDependencyMap(parameters.uexp);

        return function (envNames, sysNames, inputCollection, cb) {
            var i, base, override, srcName, destName, ul, uniformList;
            if (envNames && inputCollection.envBase) {
                i = envNames.length;
                base = inputCollection.envBase;
                override = inputCollection.envOverride;
                while (i--) {
                    srcName = envNames[i];
                    if (c_dependencyMap.has(srcName)) {
                        uniformList = c_dependencyMap.get(srcName).values();
                        ul = uniformList.length;
                        while (ul--) {
                            var expName = uniformList[ul];
                            var expression = parameters.uexp[expName];
                            var value = expression.setter.call(Shade, inputCollection.envBase);
                            cb(expName, value);
                        }
                    }
                    destName = Tools.getNameForGlobal(envNames[i]);
                    if (!parameters.shader[destName])
                        continue;
                    cb(destName, override && override[srcName] !== undefined ? override[srcName] : base[srcName]);
                    if (parameters.shader[destName].kind === Shade.OBJECT_KINDS.TEXTURE) {
                        cb(destName + "_width", override && override[srcName] !== undefined ? override[srcName].width : base[srcName] && base[srcName][0].width || 0);
                        cb(destName + "_height", override && override[srcName] !== undefined ? override[srcName].height : base[srcName] && base[srcName][0].height || 0)
                    }
                }
            }
            if (sysNames && inputCollection.sysBase) {
                i = sysNames.length;
                base = inputCollection.sysBase;
                while (i--) {
                    srcName = sysNames[i];
                    destName = Tools.getNameForSystem(sysNames[i]);
                    cb(destName, base[srcName]);
                }
            }
        }

    },

    transform: function () {
        var context = this.context,
            program = context.root,
            scope = context.createScope(program, null, "global"),
            name, declaration;

        scope.registerGlobals();
        context.pushScope(scope);

        // TODO: We should also block systemParameters here. We can block all system names, even if not used.
        for (name in context.globalParameters) {
            context.blockedNames.push(Tools.getNameForGlobal(name));
        }

        this.replace(program);

        var usedParameters = context.usedParameters;
        for (var container in usedParameters) {
            for (name in usedParameters[container]) {
                var typeInfo = usedParameters[container][name];
                assert(typeInfo instanceof TypeInfo);
                declaration = createTopDeclaration(name, typeInfo);
                declaration && program.body.unshift(declaration);
            }
        }

        var uniformSetter = this.createUniformSetterFunction(usedParameters);

        var userData = ANNO(program).getUserData();
        userData.internalFunctions = context.internalFunctions;

        return {program: program, uniformSetter: uniformSetter, headers: context.headers};
    },
    /**
     *
     * @param {Object!} ast
     * @returns {*}
     */
    replace: function (ast) {
        var controller = new walk.Controller(),
            context = this.context,
            that = this;

        ast = controller.replace(ast, {

            enter: function (node, parent) {

                switch (node.type) {
                    case Syntax.Identifier:
                        return enterIdentifier(node, parent, context);
                    case Syntax.IfStatement:
                        return enterIfStatement(node);
                    case Syntax.FunctionDeclaration:
                        return enterFunctionDeclaration(node, context);
                }
            },

            leave: function (node, parent) {
                switch (node.type) {
                    case Syntax.MemberExpression:
                        return leaveMemberExpression(node, parent, context);
                    case Syntax.NewExpression:
                        return leaveNewExpression(node, context);
                    case Syntax.LogicalExpression:
                        return leaveLogicalExpression(node);
                    case Syntax.CallExpression:
                        return leaveCallExpression(node, parent, context);
                    case Syntax.UnaryExpression:
                        return leaveUnaryExpression(node);
                    case Syntax.FunctionDeclaration:
                        return leaveFunctionDeclaration(node, context);
                    case Syntax.ReturnStatement:
                        return leaveReturnStatement(node, context);
                    case Syntax.BinaryExpression:
                        return handleBinaryExpression(node, parent, context);

                }
            }
        });
        return ast;
    }
});

/**
 * @param {string} name
 * @param {object} typeInfo
 * @returns {*}
 */
var createTopDeclaration = function (name, typeInfo) {
    var propertyLiteral = {type: Syntax.Identifier, name: name};
    var propertyAnnotation = ANNO(propertyLiteral);
    propertyAnnotation.copyFrom(typeInfo);

    if (propertyAnnotation.isNullOrUndefined() || propertyAnnotation.isDerived() || propertyAnnotation.isFunction())
        return;

    if (propertyAnnotation.isOfType(Types.ARRAY) && typeInfo.staticSize == 0)
        return;

    var decl = {
        type: Syntax.VariableDeclaration,
        declarations: [
            {
                type: Syntax.VariableDeclarator,
                id: propertyLiteral,
                init: null
            }
        ],
        kind: "var"
    };
    var declAnnotation = ANNO(decl.declarations[0]);
    declAnnotation.copyFrom(propertyAnnotation);
    return decl;
};

var enterIdentifier = function (node, parent, state) {
    var blockedNames = state.blockedNames;
    var idNameMap = state.idNameMap;

    if (parent.type == Syntax.MemberExpression)
        return node;
    var name = node.name;
    if (idNameMap[name]) {
        node.name = idNameMap[name];
        return node;
    }
    var newName = Tools.generateFreeName(name, blockedNames);
    idNameMap[name] = newName;
    node.name = newName;
    return node;
};


/**
 * Transform a !number expression into an binary expression, number == 0
 * @param node
 * @returns {*}
 */
var leaveUnaryExpression = function (node) {
    if (node.operator == "!") {
        var argument = ANNO(node.argument);
        //noinspection FallthroughInSwitchStatementJS
        switch (argument.getType()) {
            case Types.INT:
            case Types.NUMBER:
                return {
                    type: Syntax.BinaryExpression,
                    operator: "==",
                    left: node.argument,
                    right: {
                        type: Syntax.Literal,
                        value: 0,
                        extra: {
                            type: argument.getType()
                        }
                    }
                };
                break;
        }
    }
};

/**
 * A return in the main functions sets gl_FragColor or discard if the
 * main method returns without argument
 * @param node
 * @param {GLTransformContext} context
 * @returns {*}
 */
var leaveReturnStatement = function (node, context) {
        var scope = context.getScope(), fragColors;

        if (!context.inMainFunction()) {
            return;
        }

        if (node.argument) {
            var argument = ANNO(node.argument);
            if (argument.isArray()) {
                context.addHeader("#extension GL_EXT_draw_buffers : require");
                fragColors = {type: Syntax.BlockStatement, body: []};
                node.argument.elements.forEach(function (element, index) {
                    fragColors.body.push(createGLFragColor(Tools.castToVec4(element, scope), index, context));
                });
            } else if (!argument.getKind()) {
                assert(node.argument.type == Syntax.ObjectExpression, "GLSL currently support object expressions as output only.");

                var outputs = node.argument.properties.filter(function (p) {
                    return p.key.type == Syntax.Identifier && context.outputs.indexOf(p.key.name) != -1;
                });

                fragColors = {type: Syntax.BlockStatement };
                fragColors.body = outputs.map(function (p) {
                    return createGLFragColor(Tools.castToVec4(p.value, scope), context.outputs.indexOf(p.key.name) , context);
                })


            } else {
                fragColors = createGLFragColor(Tools.castToVec4(node.argument, scope), undefined, context);
            }
            return {
                type: Syntax.BlockStatement,
                body: [fragColors, {type: Syntax.ReturnStatement}]
            };

        }
        else {
            return {
                type: Syntax.ExpressionStatement,
                expression: {
                    type: Syntax.Identifier,
                    name: "discard"
                }
            }
        }
    }
    ;

/**
 * Transform the main function into a GLSL conform main function
 * with signature 'void main(void)'
 * @param node
 */
var leaveMainFunction = function (node) {
    var anno = new TypeInfo(node.extra);
    anno.setReturnInfo({type: Types.UNDEFINED});

    // Main has no parameters
    node.params = [];
    // Rename to 'main'
    node.id.name = "main";
    //console.log(node);
};

function createGLFragColor(result, index, context) {
    var name;
    if (context.vertexShader) {
        name = "gl_Position";
    }
    else if (index !== undefined) {
        name = "gl_FragData[" + index + "]";
    }
    else {
        name = "gl_FragColor";
    }

    return {
        type: Syntax.AssignmentExpression,
        operator: "=",
        left: {
            type: Syntax.Identifier,
            name: name
        },
        right: result
    };
}

function getNameOfNode(node) {
    switch (node.type) {
        case Syntax.Identifier:
            return node.name;
        case Syntax.MemberExpression:
            return getNameOfNode(node.object) + "." + getNameOfNode(node.property);
        case Syntax.NewExpression:
            return getNameOfNode(node.callee);
        default:
            return "unknown(" + node.type + ")";
    }
}

/**
 *
 * @param {object} node
 * @param {object} parent
 * @param {GLTransformContext} context
 * @returns {*}
 */
var leaveCallExpression = function (node, parent, context) {
    var scope = context.getScope();

    /** Filter out undefined arguments, we do the same for the declaration */
    node.arguments = node.arguments.filter(validParameters);

    // Is this a call on an object?
    if (node.callee.type == Syntax.MemberExpression) {
        var calleeReference = common.getTypeInfo(node.callee, scope);
        assert(calleeReference && calleeReference.isFunction(), "Expected function but found: " + calleeReference);

        var object = node.callee.object,
            propertyName = node.callee.property.name;

        var objectReference = common.getTypeInfo(object, scope);
        assert(objectReference && objectReference.isObject(), "Expected object to call but found: " + objectReference);
        assert(objectReference.hasProperty(propertyName), "Expected object to have a property: " + propertyName);
        return handleMethodCall(node, objectReference, propertyName);
    }
};

var leaveNewExpression = function (newExpression, context) {
    var scope = context.getScope();
    if (!newExpression.arguments.length) {
        return Tools.Vec.generateConstructor(newExpression);
    }
};


/**
 *
 * @param {object} node
 * @param {object} parent
 * @param {GLTransformContext} context
 * @returns {*}
 */
var leaveMemberExpression = function (node, parent, context) {
    var propertyName = node.property.name,
        scope = context.getScope();

    if (node.computed) {
        return handleComputedMemberExpression(node, parent, context);
    }

    if (ANNO(node).isUniformExpression()) {
        var uexp = handleUniformExpression(node, context);
        if (uexp)
            return uexp;
    }

    var objectReference = common.getTypeInfo(node.object, scope);
    assert(objectReference && objectReference.isObject(), "Object of Member expression is not an object.");
    assert(objectReference.hasProperty(propertyName), "Object of Member expression has no property '" + propertyName + "'");
    return handleStaticMemberExpression(node, objectReference, propertyName, context);

    // There is a specual handling defined for the object
    /*if (objectInfo.hasOwnProperty(propertyName)) {
     var propertyHandler = objectInfo[propertyName];
     if (typeof propertyHandler.property == "function") {
     return propertyHandler.property(node, parent, scope, context);
     }
     }


     if (node.object.type == Syntax.ThisExpression) {
     parameterName = Tools.getNameForSystem(propertyName);
     if (!usedParameters.system.hasOwnProperty(parameterName)) {
     usedParameters.system[parameterName] = context.systemParameters[propertyName];
     }

     propertyLiteral = {type: Syntax.Identifier, name: parameterName};
     ANNO(propertyLiteral).copy(ANNO(node));
     return propertyLiteral;
     } */

};

var handleStaticMemberExpression = function (node, object, propertyName, context) {
    if (object.isPredefinedObject()) {
        if (GLObjects.has(object.getKind())) {
            var objectHandler = GLObjects.get(object.getKind());
            return objectHandler.property(node, propertyName, context);
        }
        console.log("Unhandled property", object.getKind(), propertyName);
    }
    if (object.isGlobal()) {
        var usedParameters = context.usedParameters;
        var parameterName = Tools.getNameForGlobal(propertyName);

        if (!usedParameters.environment.hasOwnProperty(parameterName)) {
            usedParameters.environment[parameterName] = ANNO(node);
        }

        var propertyLiteral = {type: Syntax.Identifier, name: parameterName};
        ANNO(propertyLiteral).copyFrom(ANNO(node));
        return propertyLiteral;
    }
    return node;
};

var handleMethodCall = function (node, object, methodName) {
    if (object.isPredefinedObject()) {
        if (GLObjects.has(object.getKind())) {
            var objectHandler = GLObjects.get(object.getKind());
            return objectHandler.call(node, methodName);
        }
        console.log("Unhandled call", object.getKind(), methodName);
    }
    return node;
};

/**
 * @param {object} node
 * @param {object} parent
 * @param {GLASTTransformer} context
 */
var handleComputedMemberExpression = function (node, parent, context) {
    var objectReference = context.getTypeInfo(node.object);
    if (!objectReference.isArray()) {
        Shade.throwError(node, "In shade.js, [] access is only allowed on arrays.");
    }
    var propertyType = context.getTypeInfo(node.property);
    if (!propertyType.canInt()) {
        node.property = {
            type: Syntax.CallExpression,
            callee: {type: "Identifier", name: "int"},
            arguments: [node.property]
        }
        ANNO(node.property).setType(Types.INT);
    }
    return node;
};


/**
 * @param {object} node
 * @param {object} parent
 * @param {GLASTTransformer} context
 */
var handleBinaryExpression = function (node, parent, context) {
    // In GL, we can't mix up floats, ints and bool for binary expressions
    var left = context.getTypeInfo(node.left),
        right = context.getTypeInfo(node.right);

    if (left.isNumber() && right.isInt()) {
        node.right = Tools.castToFloat(node.right);
    }
    else if (right.isNumber() && left.isInt()) {
        node.left = Tools.castToFloat(node.left);
    }

    if (node.operator == "%") {
        return Tools.binaryExpression2FunctionCall(node, "mod");
    }
    return node;
};

/*function castToInt(ast, force) {
 var exp = ANNO(ast);

 if (!exp.isInt() || force) {   // Cast
 return {
 type: Syntax.CallExpression,
 callee: {
 type: Syntax.Identifier,
 name: "int"
 },
 arguments: [ast]
 };
 }
 return ast;
 };*/

/**
 * @param {Object} node
 * @param {GLTransformContext} context
 * @returns {*}
 */
var enterFunctionDeclaration = function (node, context) {
    var scope = context.createScope(node, context.getScope(), node.id.name);
    context.pushScope(scope);

    // Remove global parameters and parameters of type undefined (these are not used anyway)
    node.params = node.params.filter(validParameters);
    return node;
};

/**
 * @param {Object} node
 * @param {GLTransformContext} context
 * @returns {*}
 */
var leaveFunctionDeclaration = function (node, context) {
    var wasMain = context.inMainFunction();
    context.popScope();
    if (wasMain)
        return leaveMainFunction(node);
};


var enterIfStatement = function (node) {
    var test = ANNO(node.test);

    assert(!test.hasConstantValue(), "Static value in IfStatement test");
    assert(!test.isObject(), "Object in IfStatement test");

    //noinspection FallthroughInSwitchStatementJS
    switch (test.getType()) {
        // Transform 'if(number)' into 'if(number != 0)'
        case Types.INT:
        case Types.NUMBER:
            node.test = {
                type: Syntax.BinaryExpression,
                operator: "!=",
                left: node.test,
                right: {
                    type: Syntax.Literal,
                    value: 0,
                    extra: {
                        type: test.getType()
                    }
                }
            };
            break;
    }
};

/**
 * Need to transform truth expressions in real boolean expression, because something like if(0) is
 * not allowed in GLSL
 *
 * @param node
 * @returns {*}
 */
var leaveLogicalExpression = function (node) {
    var left = ANNO(node.left);
    var right = ANNO(node.right);

    if (left.isBool() && right.isBool()) {
        // Everything is okay, no need to modify anything
        return;
    }

    // Now we have to implement the JS boolean semantic for GLSL
    if (left.canNumber()) {
        var test = node.left;
        return {
            type: Syntax.ConditionalExpression,
            test: {
                type: Syntax.BinaryExpression,
                operator: "==",
                left: test,
                right: {
                    type: Syntax.Literal,
                    value: left.isNumber() ? 0.0 : left.isInt() ? 0 : "false",
                    extra: {
                        type: left.getType(),
                        staticValue: left.isNumber() ? 0.0 : left.isInt() ? 0 : "false"
                    }
                },
                extra: {type: Types.BOOLEAN}
            },
            consequent: node.right,
            alternate: test
        };
    }
};


function handleUniformExpression(node, context) {
    var exp = ANNO(node);

    assert.equal(node.type, Syntax.MemberExpression);

    if (exp.isUniformExpression() && !(exp.getSource() == Shade.SOURCES.UNIFORM)) {
        var uniformName = node.property.name;
        var result = {
            type: Syntax.Identifier,
            name: uniformName
        };

        if (context.usedParameters.uexp.hasOwnProperty(uniformName)) { // Reuse
            var typeInfo = context.usedParameters.uexp[uniformName];
            ANNO(result).copyFrom(typeInfo);
            return result;
        }

        // Generate new uniform expression
        assert(context.uniformExpressions.hasOwnProperty(uniformName), "Internal: No information about uniform expression available: " + Shade.toJavaScript(node));
        // Use typeinfo from node as basis
        var typeInfo = ANNO(result);
        typeInfo.copyFrom(exp);

        typeInfo.setter = generateUniformSetter(exp, context.uniformExpressions[uniformName]);

        //console.log(uniformName, extra.setter);

        typeInfo.setSource(Shade.SOURCES.UNIFORM);
        typeInfo.setUniformDependencies(exp.getUniformDependencies());

        context.usedParameters.uexp[uniformName] = typeInfo;

        return result;
    }
}

function generateUniformSetter(uniformAnno, expressionInfo) {
    var code = expressionInfo.code;
    if (uniformAnno.isObject())
        code = "(" + expressionInfo.code + ")._toFloatArray()";
    var source = "return " + code + ";";
    return new Function("env", source);
}

function addDeclaration(name, typeInfo, target) {
    var targetContainer, declaration;
    switch (target.type) {
        case Syntax.BlockStatement:
            targetContainer = target.body;
            break;
        default:
            throw new Error("Internal: addDeclaration to " + target.type);
    }
    if (targetContainer.length && targetContainer[0].type == Syntax.VariableDeclaration) {
        declaration = targetContainer[0];
        //console.log(declaration.declarations.push(declaration.declarations[0]));
    } else {
        declaration = {
            type: Syntax.VariableDeclaration,
            kind: "var",
            declarations: []
        }
        targetContainer.unshift(declaration);
    }
    var declarator = {
        type: Syntax.VariableDeclarator,
        id: {
            type: Syntax.Identifier,
            name: name
        },
        init: null
    };
    ANNO(declarator).copy(typeInfo);
    declaration.declarations.push(declarator);
}

function validParameters(p) {
    var ap = ANNO(p);
    return !(ap.isUndefined() || ap.isGlobal());
}

// Exports
module.exports = GLASTTransformer;



},{"../../base/common.js":140,"../../base/index.js":142,"../../type-system/typeinfo.js":203,"../tools.js":182,"./../../interfaces.js":188,"./registry/":167,"./registry/system.js":173,"analyses":46,"assert":25,"estraverse":61}],179:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        assert = require("assert"),
        Base = require("../../base/index.js"),
        common = require("./../../base/common.js");

    var SnippetList = function(){
        this.entries = [];
    }

    Base.extend(SnippetList.prototype, {
        addEntry: function(entry){
            this.entries.push(entry);
        }
    });

    var SnippetEntry = function(ast){
        this.inputInfo = [];
        this.outputInfo = [];
        this.ast = ast || null;
    }
 
    
    Base.extend(SnippetEntry.prototype, {
        setAst: function(ast){
            this.ast = ast;
        },
        addVertexInput: function(type, directInputIndex){
            var input = new SnippetInput(type, true, false);
            input.setDirectInput(directInputIndex);
            this.inputInfo.push(input);
        },
        addUniformInput: function(type, directInputIndex){
            var input = new SnippetInput(type, false, false);
            input.setDirectInput(directInputIndex);
            this.inputInfo.push(input);
        },
        addUniformArray: function(type, directInputIndex, arraySize){
            var input = new SnippetInput(type, false, true);
            input.setDirectInput(directInputIndex, arraySize);
            this.inputInfo.push(input);
        },
        addTransferInput: function(type, transferOperatorIndex, transferOutputIndex){
            var input = new SnippetInput(type, true, false);
            input.setTransferInput(transferOperatorIndex, transferOutputIndex);
            this.inputInfo.push(input);
        },
        addLostOutput: function(type, name){
            var output = new SnippetOutput(type, name);
            this.outputInfo.push(output);
        },
        addFinalOutput: function(type, name, index){
            var output = new SnippetOutput(type, name);
            output.setFinalOutputIndex(index);
            this.outputInfo.push(output);
        }
    });


    var SnippetInput = function(type, iterate, arrayAccess){
        this.type = type;
        this.iterate = iterate;
        this.arrayAccess = arrayAccess;
        this.transferOperatorIndex = undefined;
        this.transferOutputIndex = undefined;
        this.directInputIndex = undefined;
        this.arraySize = undefined;
    }

    Base.extend(SnippetInput.prototype, {
        setDirectInput: function(directInputIndex, arraySize){
            this.transferOperatorIndex = this.transferOutputIndex = undefined;
            this.directInputIndex = directInputIndex;
            this.arraySize = arraySize;
        },
        setTransferInput: function(transferOperatorIndex, transferOutputIndex){
            this.transferOperatorIndex = transferOperatorIndex;
            this.transferOutputIndex = transferOutputIndex;
            this.directInputIndex = undefined;
        },
        isTransferInput: function(){
            return this.transferOperatorIndex !== undefined;
        },
        getTransferInputKey: function(){
            return this.transferOperatorIndex + "_" + this.transferOutputIndex;
        }
    });

    var SnippetOutput = function(type, name) {
        this.type = type;
        this.name = name;
        this.finalOutputIndex = undefined;
    }

    Base.extend(SnippetOutput.prototype, {
        setFinalOutputIndex: function(index){
            this.finalOutputIndex = index;
        },
        isFinal: function(){
            return this.finalOutputIndex !== undefined;
        }
    });

    ns.SnippetList = SnippetList;
    ns.SnippetEntry = SnippetEntry;

}(exports));

},{"../../base/index.js":142,"./../../base/common.js":140,"assert":25,"estraverse":61}],180:[function(require,module,exports){
(function (ns) {

    var common = require("../../base/common.js"),
        Shade = require("./../../interfaces.js"),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        SpaceType = Shade.SpaceType,
        VectorType = Shade.VectorType;
    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = common.ANNO;


    ns.getSpaceTransformCall = function(ast, space){
        var callExpression = {
            type: Syntax.CallExpression,
            callee: this.getSpaceConvertFunction(space),
            arguments: [ this.getSpaceConvertArg(space), ast ]
        };
        return callExpression;
    };

    ns.getSpaceConvertFunction = function(space){
        var vectorType = Shade.getVectorFromSpaceVector(space);
        var functionName;
        switch(vectorType){
            case VectorType.POINT: functionName = "transformPoint"; break;
            case VectorType.NORMAL: functionName = "transformDirection"; break;
        }
        var result = {
            type: Syntax.MemberExpression,
            object: {type: Syntax.Identifier, name: "Space"},
            property: { type: Syntax.Identifier, name: functionName }
        };
        ANNO(result).setType(Types.FUNCTION);
        ANNO(result.object).setType(Types.OBJECT, Kinds.ANY);
        return result;
    }

    ns.getSpaceConvertArg = function(space){
        var spaceType = Shade.getSpaceFromSpaceVector(space);
        var spaceName;
        switch(spaceType){
            case SpaceType.VIEW: spaceName = "VIEW"; break;
            case SpaceType.WORLD: spaceName = "WORLD"; break;
        }
        return {
            type: Syntax.MemberExpression,
            object: { type: Syntax.Identifier, name: "Space"  },
            property: { type: Syntax.Identifier, name: spaceName }
        };
    };


}(exports));

},{"../../base/common.js":140,"./../../interfaces.js":188,"estraverse":61}],181:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        common = require("../../base/common.js"),
        TypeInfo = require("../../type-system/typeinfo.js"),
        Shade = require("./../../interfaces.js"),
        esgraph = require('esgraph'),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;
    var spaceAnalyzer = require("../../analyze/space_analyzer.js"),
        SpaceVectorType = Shade.SpaceVectorType,
        SpaceType = Shade.SpaceType,
        VectorType = Shade.VectorType;
    var SpaceTransformTools = require("./space-transform-tools.js");



    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = common.ANNO;


    /**
     * Transforms the JS AST to an AST representation convenient
     * for code generation
     * @constructor
     */
    var SpaceTransformer = function (mainId) {
        this.mainId = mainId;
    };

    function spaceInfo(ast){
        return ast.spaceInfo || {};
    }

    Base.extend(SpaceTransformer.prototype, {
        transformAast: function (aast, opt) {
            opt = opt || {};
            this.root = aast;
            this.functionSpaceInfo = {};
            this.functionTranfserInfo = {};
            this.globalIdentifiers = this.getGlobalIdentifiers(aast);
            this.envSpaces = {};

            this.transformFunctions(aast);
            this.updateGlobalObject(aast, this.envSpaces);
            return this.envSpaces;
        },
        /**
         *
         * @param {Object!} ast
         * @param {Object!} state
         * @returns {*}
         */
        transformFunctions: function(aast) {
            var self = this;
            aast = walk.replace(aast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    switch (node.type) {
                        case Syntax.FunctionDeclaration:
                            self.replaceFunctionInvocations(node.body);
                            self.extractSpaceTransforms(node);
                            this.skip();
                            break;
                    }
                }
            });
            return aast;
        },
        replaceFunctionInvocations: function(functionBodyAast){
            var self = this;
            walk.replace(functionBodyAast, {
                enter: function (node, parent) {
                    if(node.type == Syntax.CallExpression){
                        if(node.callee.type == Syntax.Identifier && self.functionSpaceInfo[node.callee.name]){
                            var paramTransitions = self.functionSpaceInfo[node.callee.name];
                            var oldArgs = node.arguments, newArgs = [];
                            for(var i = 0; i < paramTransitions.length; ++i){
                                var paramT = paramTransitions[i];
                                if(!paramT.space)
                                    oldArgs[paramT.idx] !== undefined && newArgs.push(oldArgs[paramT.idx]);
                                else{
                                    newArgs.push(SpaceTransformTools.getSpaceTransformCall(oldArgs[paramT.idx], paramT.space));
                                }
                            }
                            node.arguments = newArgs;
                        }
                    }
                }
            });
        },

        extractSpaceTransforms: function(functionAast){
            var self = this;
            this.usedIdentifiers = this.getUsedIdentifiers(functionAast);

            var analyzeResult = spaceAnalyzer.analyze(functionAast, this.functionTranfserInfo);
            var nameMap = {}, addDeclarations = [];
            this.extractEnvSpaces(analyzeResult, nameMap);
            this.initFunctionHeader(functionAast, analyzeResult, nameMap, addDeclarations);

            functionAast.body = walk.replace(functionAast.body, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.type == Syntax.ExpressionStatement){
                        var newStatement = self.duplicateSpaceStatement(node, nameMap, addDeclarations);
                        if(newStatement){
                            this.skip();
                            return newStatement;
                        }
                    }
                    else if(spaceInfo(node).hasSpaceOverrides){
                        self.resolveSpaceUsage(node, SpaceVectorType.OBJECT, nameMap);
                        this.skip();
                    }
                }
            });
            this.addDeclarations(functionAast, addDeclarations);
            this.cleanUpDeclarations(functionAast);
        },

        extractEnvSpaces: function(analyzeResult, nameMap){
            for(var name in analyzeResult){
                if(name.indexOf("env.") == 0){
                    var property = name.substr(4);
                    var j = analyzeResult[name].length;
                    while(j--){
                        var space = analyzeResult[name][j];
                        var spaceName = this.getSpaceName(name, space);
                        if(!this.envSpaces[property]) this.envSpaces[property] = [];
                        if( !this.envSpaces[property].some(function(e){return e.space == space}))
                            this.envSpaces[property].push({ name: spaceName.split(".")[1], space: space } );
                        if(!nameMap[name]) nameMap[name] = {};
                        nameMap[name][space] = this.getSpaceName(name, space);
                    }
                }
            }
        },

        initFunctionHeader: function(functionAast, analyzeResult, nameMap, addDeclarations){
            var newParams = [];
            var paramTransitions = [];
            for(var i = 0; i < functionAast.params.length; ++i){
                var param = functionAast.params[i], paramName = param.name;
                if(analyzeResult[paramName]){
                    var j = analyzeResult[paramName].length, hasObjectSpace = false;
                    while(j--){
                        var space = analyzeResult[paramName][j];
                        if(space != SpaceVectorType.OBJECT){
                            if(!nameMap[paramName]) nameMap[paramName] = {};
                            nameMap[paramName][space] = this.getSpaceName(paramName, space);
                            var newParam = {
                                type: Syntax.Identifier,
                                name: nameMap[paramName][space]
                            };
                            ANNO(newParam).copyFrom(ANNO(param));
                            newParams.push(newParam);
                            paramTransitions.push({idx: i, space: space});
                        }
                        else{
                            hasObjectSpace = true;
                            newParams.push(param);
                            paramTransitions.push({idx: i});
                        }
                    }
                    if(!hasObjectSpace){
                        addDeclarations.push(paramName);
                    }
                }
                else{
                    newParams.push(param);
                    paramTransitions.push({idx: i});
                }
            }
            functionAast.params = newParams;
            this.functionSpaceInfo[functionAast.id.name] = paramTransitions;
        },

        duplicateSpaceStatement: function(statementAast, nameMap, addedDeclarations){
            var duplicatedStatements = [];
            var child = statementAast.expression;
            var sInfo = spaceInfo(child);

            var newSpaceNameEntries = {};
            if(!sInfo.finalSpaces){
                nameMap[sInfo.def] = newSpaceNameEntries;
                return;
            }

            sInfo.finalSpaces.forEach(function(space){
                var expressionCopy = JSON.parse(JSON.stringify(child));
                if(space != SpaceVectorType.OBJECT && !this.isSpacePropagrationPossible(sInfo, space)){
                    this.resolveSpaceUsage(expressionCopy, SpaceVectorType.OBJECT, nameMap);
                    expressionCopy.right = SpaceTransformTools.getSpaceTransformCall(expressionCopy.right, space);
                }
                else{
                    this.resolveSpaceUsage(expressionCopy, space, nameMap);
                }
                duplicatedStatements.push({ type: Syntax.ExpressionStatement, expression: expressionCopy });
                if(space != SpaceVectorType.OBJECT){
                    var spaceName = this.getSpaceName(sInfo.def, space);
                    if(addedDeclarations.indexOf(spaceName) == -1)
                        addedDeclarations.push(spaceName);
                    newSpaceNameEntries[space] = spaceName;
                    expressionCopy.left.name = spaceName;
                }

            }.bind(this));
            nameMap[sInfo.def] = newSpaceNameEntries;

            if(duplicatedStatements.length == 0)
                return;
            if(duplicatedStatements.length == 1)
                return duplicatedStatements[0];

            var blockStatement = {
                type: Syntax.BlockStatement,
                body: duplicatedStatements
            };
            return blockStatement

        },

        addDeclarations: function(functionAast, addDeclarations){
            var i = functionAast.params.length;
            while(i--) {
                var idx = addDeclarations.indexOf(functionAast.params[i].name);
                if(idx != -1)
                    addDeclarations.splice(idx, 1);
            }
            if(addDeclarations.length > 0){
                var declarations = { type: Syntax.VariableDeclaration, kind: "var", declarations: []};
                var i = addDeclarations.length;
                while(i--){
                    var name = addDeclarations[i];
                    var decl = {type: Syntax.VariableDeclarator, id: {type: Syntax.Identifier, name: name}, init: null};
                    ANNO(decl).setType(Types.OBJECT, "Vec3");
                    declarations.declarations.push(decl);
                }
                functionAast.body.body.unshift(declarations);
            }
        },

        isSpacePropagrationPossible: function(sInfo, targetSpace){
            if(sInfo.propagateSet.length == 0) // We need to have at least one dependency. Otherwise we can't propagate the space
                return false;
            var vectorType = Shade.getVectorFromSpaceVector(targetSpace)
            if(vectorType == VectorType.NORMAL && sInfo.normalSpaceViolation)
                return false;
            if(vectorType == VectorType.POINT && sInfo.pointSpaceViolation)
                return false;

            return true;
        },

        resolveSpaceUsage: function(aast, targetSpace, nameMap){
            var self = this;
            aast = walk.replace(aast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    switch (node.type) {
                        case Syntax.Identifier:
                            if(targetSpace != SpaceVectorType.OBJECT && spaceInfo(node).propagate){
                                node.name = nameMap[node.name][targetSpace];
                            }
                            break;
                        case Syntax.MemberExpression:
                            if(targetSpace != SpaceVectorType.OBJECT && spaceInfo(node).propagate){
                                var nameKey = "env." + node.property.name;
                                var name = nameMap[nameKey][targetSpace],
                                    token = name.split(".");
                                node.property.name = token[1];
                            }
                            break;
                        case Syntax.CallExpression:
                            var sInfo = spaceInfo(node);
                            if(sInfo.spaceOverride &&
                                self.isSpacePropagrationPossible(sInfo, sInfo.spaceOverride))
                            {
                                var result = self.resolveSpaceUsage(node.arguments[1], sInfo.spaceOverride, nameMap);
                                this.skip();
                                return result;
                            }
                    }
                }
            });
            return aast;
        },

        getSpaceName: function(name, space){
            if(space == SpaceVectorType.OBJECT)
                return name;

            var checkGlobal = false;
            if(name.indexOf("env.") == 0){
                checkGlobal = true;
                name = name.substr(4);
            }
            switch(space){
                case SpaceVectorType.VIEW_POINT : name += "_vps"; break;
                case SpaceVectorType.WORLD_POINT : name += "_wps"; break;
                case SpaceVectorType.VIEW_NORMAL : name += "_vns"; break;
                case SpaceVectorType.WORLD_NORMAL : name += "_wns"; break;
            }
            var result = name;
            var i = 2;
            while( (checkGlobal ? this.globalIdentifiers : this.usedIdentifiers ).indexOf(result) != -1){
                result = name + i++;
            }
            if(checkGlobal)
                result = "env." + result;
            return result;
        },

        getUsedIdentifiers : function(functionAast){
            var result = [];
            walk.traverse(functionAast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.type == Syntax.Identifier){
                        if( parent.type == Syntax.MemberExpression && parent.property == node)
                            return;
                        if(result.indexOf(node.name) == -1)
                            result.push(node.name);
                    }
                }
            });
            return result;
        },
        getGlobalIdentifiers : function(programAast){
            var result = [];
            walk.traverse(programAast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.type == Syntax.MemberExpression && node.object.extra.global){
                        if(result.indexOf(node.property.name) == -1)
                            result.push(node.property.name);
                    }
                }
            });
            return result;
        },
        cleanUpDeclarations: function(functionAast){
            var declarators = [];
            var body = functionAast.body.body;
            var i = body.length;
            while(i--){
                if(body[i].type == Syntax.VariableDeclaration){
                    declarators.push.apply(declarators, body[i].declarations);
                    body.splice(i,1);
                }
            }
            var usedIdentifiers = this.getUsedIdentifiers(functionAast.body);
            var declaration = { type: Syntax.VariableDeclaration, kind: "var", declarations: []};
            i = declarators.length;
            while(i--){
                if(usedIdentifiers.indexOf(declarators[i].id.name) != -1){
                    declaration.declarations.push(declarators[i]);
                }
            }
            if(declaration.declarations.length > 0)
                body.unshift(declaration);
        },

        updateGlobalObject: function(aast, envSpaces){
            if(!aast.globalParameters)
                return;
            var globalObject;
            for(var funcName in aast.globalParameters){
                var args = aast.globalParameters[funcName];
                var i = args.length;
                while(i--){
                    if(args[i].extra.global)
                        globalObject = args[i].extra;
                }
            }
            if(!globalObject)
                return;
            var newInfo = {};
            for(var propName in globalObject.info){
                var data = globalObject.info[propName];
                if(!envSpaces[propName]){
                    newInfo[propName] = data;
                    continue;
                }
                var entryList = envSpaces[propName];
                for(var i = 0; i < entryList.length; ++i){
                    var copyData = Base.deepExtend({}, data);
                    newInfo[entryList[i].name]= copyData;
                }
            }
            globalObject.info = newInfo;
            walk.traverse(aast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.extra && node.extra.global){
                        node.extra.info = newInfo;
                    }
                    if(node.scope && node.scope.bindings){
                        for(var name in node.scope.bindings){
                            if(node.scope.bindings[name].extra.global){
                                node.scope.bindings[name].extra.info = newInfo;
                            }
                        }
                    }
                }
            });
        }


    });

    // Exports
    ns.SpaceTransformer = new SpaceTransformer();


}(exports));

},{"../../analyze/space_analyzer.js":115,"../../base/common.js":140,"../../base/index.js":142,"../../type-system/typeinfo.js":203,"./../../interfaces.js":188,"./space-transform-tools.js":180,"esgraph":58,"estraverse":61}],182:[function(require,module,exports){
var Syntax = require('estraverse').Syntax;
var Base = require("../base/index.js");
var annotate = require("../utils/").annotate;
var TypeInfo = require("../type-system/typeinfo.js");
var Shade = require("../interfaces.js");
var VecBase = require("../base/vec.js");
var assert = require("assert");

var TYPES = Shade.TYPES,
    KINDS = Shade.OBJECT_KINDS;

var ns = {};

ns.removeMemberFromExpression = function (node) {
    return {
        type: Syntax.Identifier,
        name: node.property.name
    }
}

ns.generateFreeName = function (name, blockedNames) {
    var newName = name.replace(/_+/g, "_"), i = 1;
    while (blockedNames.indexOf(newName) != -1) {
        newName = (name + "_" + (++i)).replace(/_+/g, "_");
    }
    blockedNames.push(newName);
    return newName;
}

ns.getInternalFunctionName = function (state, key, type, details) {
    if (!state.internalFunctions[key]) {
        var name = ns.generateFreeName(key, state.blockedNames);
        state.internalFunctions[key] = {
            name: name,
            type: type,
            details: details
        };
    }
    return state.internalFunctions[key].name;
};


ns.binaryExpression2FunctionCall = function (node, name) {
    node.right = ns.castToFloat(node.right);
    node.left = ns.castToFloat(node.left);
    return {
        type: Syntax.CallExpression,
        callee: {
            type: Syntax.Identifier,
            name: name
        },
        arguments: [
            node.left,
            node.right
        ],
        extra: {
            type: TYPES.NUMBER
        }
    }
};

var Vec = {
    getVecArgs: function (args) {
        if (args.length == 0) {
            var result = [
                {
                    type: "Literal",
                    value: "0"
                }
            ];
            annotate(result[0]).setType(TYPES.NUMBER);
            return result;
        }
        else {
            return args;
        }
    },

    generateVecFromArgs: function (vecCount, args) {
        if (vecCount == 1)
            return args[0];
        if (args.length == 0) {
            args = Vec.getVecArgs(args);
        }

        if (args.length == 1 && annotate(args[0]).isOfKind("Vec" + vecCount))
            return args[0];
        var result = {
            type: Syntax.NewExpression,
            callee: {
                type: Syntax.Identifier,
                name: "Vec" + vecCount
            },
            arguments: args
        };
        annotate(result).setType(TYPES.OBJECT, "Vec" + vecCount);
        annotate(result.callee).setType(TYPES.FUNCTION);
        return result;
    },

    createSwizzle: function (vecCount, swizzle, node) {
        if (node.arguments.length == 0) {
            node.callee.extra = node.extra;
            return node.callee;
        }
        var singular = swizzle.length == 1;
        var argObject = singular ? node.arguments[0] : Vec.generateVecFromArgs(swizzle.length, node.arguments);
        var replace = {
            type: Syntax.NewExpression,
            callee: {
                type: Syntax.Identifier,
                name: "Vec" + vecCount
            },
            arguments: []
        };
        var indices = [];
        for (var i = 0; i < swizzle.length; ++i) {
            var idx = VecBase.swizzleToIndex(swizzle.charAt(i));
            indices[idx] = i;
        }

        for (var i = 0; i < vecCount; ++i) {
            if (indices[i] !== undefined) {
                replace.arguments[i] = singular ? argObject : {
                    type: Syntax.MemberExpression,
                    object: argObject,
                    property: {
                        type: Syntax.Identifier,
                        name: VecBase.indexToSwizzle(indices[i])
                    }
                };
            }
            else {
                replace.arguments[i] = {
                    type: Syntax.MemberExpression,
                    object: node.callee.object,
                    property: {
                        type: Syntax.Identifier,
                        name: VecBase.indexToSwizzle(i)
                    }
                };
            }
        }
        annotate(replace).copyFrom(annotate(node));
        return replace;
    },
    createSwizzleOperator: function (vecCount, swizzle, operator, node, args, parent) {
        var singular = swizzle.length == 1;
        var argObject = singular ? node.arguments[0] : Vec.generateVecFromArgs(swizzle.length, node.arguments);
        var replace = {
            type: Syntax.NewExpression,
            callee: {
                type: Syntax.Identifier,
                name: "Vec" + vecCount
            },
            arguments: []
        };
        var indices = [];
        for (var i = 0; i < swizzle.length; ++i) {
            var idx = VecBase.swizzleToIndex(swizzle.charAt(i));
            indices[idx] = i;
        }
        for (var i = 0; i < vecCount; ++i) {
            var thisValue = {
                type: Syntax.MemberExpression,
                object: node.callee.object,
                property: {
                    type: Syntax.Identifier,
                    name: VecBase.indexToSwizzle(i)
                }
            };
            if (indices[i] !== undefined) {
                replace.arguments[i] = {
                    type: Syntax.BinaryExpression,
                    operator: operator,
                    left: thisValue,
                    right: singular ? argObject : {
                        type: Syntax.MemberExpression,
                        object: argObject,
                        property: {
                            type: Syntax.Identifier,
                            name: VecBase.indexToSwizzle(indices[i])
                        }
                    }
                }
            }
            else {
                replace.arguments[i] = thisValue
            }
        }
        annotate(replace).copy(annotate(node));
        return replace;
    },

    attachSwizzles: function (instance, vecCount, callExp, callOperatorExp) {
        for (var s = 0; s < VecBase.swizzleSets.length; ++s) {
            for (var count = 1; count <= 4; ++count) {
                var max = Math.pow(vecCount, count);
                for (var i = 0; i < max; ++i) {
                    var val = i;
                    var key = "";
                    var indices = [], withSetter = (count <= vecCount);
                    for (var j = 0; j < count; ++j) {
                        var idx = val % vecCount;
                        val = Math.floor(val / vecCount);
                        key += VecBase.swizzleSets[s][idx];
                        if (indices[idx])
                            withSetter = false;
                        else
                            indices[idx] = true;
                    }
                    instance[key] = {
                        callExp: callExp.bind(null, vecCount, key)
                    };
                    if (withSetter && callOperatorExp) {
                        for (var operator in VecBase.swizzleOperators) {
                            var opSymbol = VecBase.swizzleOperators[operator];
                            instance[key + operator] = {
                                callExp: callOperatorExp.bind(null, vecCount, key, opSymbol)
                            };
                        }
                    }
                }
            }
        }
    },

    createOperator: function (vecCount, operator, node, args, parent) {
        var other = Vec.generateVecFromArgs(vecCount, node.arguments);
        var replace = {
            type: Syntax.BinaryExpression,
            operator: operator,
            left: node.callee.object,
            right: other
        };
        annotate(replace).copyFrom(annotate(node));
        return replace;
    },

    attachOperators: function (instance, vecCount, operators) {
        for (var name in operators) {
            var operator = operators[name];
            instance[name] = {
                callExp: Vec.createOperator.bind(null, vecCount, operator)
            }
        }
    },

    createFunctionCall: function (functionName, secondVecSize, node) {
        assert(arguments.length == 3);
        var replace = {
            type: Syntax.CallExpression,
            callee: {
                type: Syntax.Identifier,
                name: functionName
            },
            arguments: [
                node.callee.object
            ]
        };
        if (secondVecSize) {
            var other = Vec.generateVecFromArgs(secondVecSize, node.arguments);
            replace.arguments.push(other);
        }
        annotate(replace).copyFrom(annotate(node));
        return replace;
    },

    generateLengthCall: function (node) {
        if (node.arguments.length == 0) {
            return Vec.createFunctionCall('length', 0, node);
        }
        else {
            var replace = {
                type: Syntax.BinaryExpression,
                operator: '*',
                left: node.callee.object,
                right: {
                    type: Syntax.BinaryExpression,
                    operator: '/',
                    left: node.arguments[0],
                    right: Vec.createFunctionCall('length', 0, node)
                }
            };
            annotate(replace.right).setType(TYPES.NUMBER);
            annotate(replace).copyFrom(annotate(node));
            return replace;
        }
    },

    generateConstructor: function (node) {
        node.arguments = Vec.getVecArgs(node.arguments);
    }
};

var Mat = {
    TYPES: {
        "Mat3": {kind: KINDS.MATRIX3, colKind: KINDS.FLOAT3, colCount: 3, glslType: "mat3"},
        "Mat4": {kind: KINDS.MATRIX4, colKind: KINDS.FLOAT4, colCount: 4, glslType: "mat3"}
    },

    generateMatFromArgs: function (matName, args) {
        if (args.length == 0) {
            args = Vec.getVecArgs(args);
        }

        if (args.length == 1 && annotate(args[0]).isOfKind(Mat.TYPES[matName].kind))
            return args[0];
        var result = {
            type: Syntax.NewExpression,
            callee: {
                type: Syntax.Identifier,
                name: matName
            },
            arguments: args
        };
        annotate(result).setType(TYPES.OBJECT, Mat.TYPES[matName].kind);
        annotate(result.callee).setType(TYPES.FUNCTION);
        return result;
    },

    createOperator: function (matName, operator, node, args, parent) {
        var other = Mat.generateMatFromArgs(matName, node.arguments);
        var replace = {
            type: Syntax.BinaryExpression,
            operator: operator,
            left: node.callee.object,
            right: other
        };
        annotate(replace).copy(annotate(node));
        return replace;
    },

    attachOperators: function (instance, matName, operators) {
        for (var name in operators) {
            var operator = operators[name];
            instance[name] = {
                callExp: Mat.createOperator.bind(null, matName, operator)
            }
        }
    },

    generateColCall: function (matName, node, args, parent, state) {
        var memberAccess = {
            type: Syntax.MemberExpression,
            object: node.callee.object,
            property: node.arguments[0],
            computed: true
        };
        annotate(memberAccess).setType(TYPES.OBJECT, Mat.TYPES[matName].colKind);

        if (args.length == 1) {
            return memberAccess;
        }
        else {
            var methodKey = "_" + matName + "_col";
            var methodName = ns.getInternalFunctionName(state, methodKey,
                "MatCol", {colType: "vec" + Mat.TYPES[matName].colCount, matType: Mat.TYPES[matName].glslType});

            var replace = {
                type: Syntax.CallExpression,
                callee: {type: Syntax.Identifier, name: methodName},
                arguments: [
                    node.callee.object,
                    node.arguments[0],
                    node.arguments[1]
                ]
            };
            annotate(replace).copy(annotate(node));
            return replace;
        }
    }

}


ns.Vec = Vec;
ns.Mat = Mat;

ns.castToFloat = function (ast) {
    var exp = annotate(ast);

    if (!exp.isNumber()) {   // Cast
        return {
            type: Syntax.CallExpression,
            callee: {
                type: Syntax.Identifier,
                name: "float"
            },
            arguments: [ast]
        }
    }
    return ast;
}

ns.getNameForSystem = function (baseName) {
    return baseName;
}

ns.getNameForGlobal = function (baseName) {
    var name = "_env_" + baseName;
    return name.replace(/_+/g, "_");
}

/**
 * @param {Object} node
 * @param  {GLTransformContext} context
 * @returns {*}
 */
ns.castToVec4 = function (node, context) {
    var exp = TypeInfo.createForContext(node, context);

    if (exp.isOfKind("Vec4") || exp.isOfKind("Closure"))
        return node;

    if (exp.isOfKind("Vec3")) {
        return {
            type: Syntax.CallExpression,
            callee: {
                type: Syntax.Identifier,
                name: "vec4"
            },
            arguments: [node, {type: Syntax.Literal, value: 1.0, extra: {type: TYPES.NUMBER}}]
        }
    }
    Shade.throwError(node, "Can't cast from '" + exp.getTypeString() + "' to vec4");
}

ns.extend = Base.extend;
ns.createClass = Base.createClass;

module.exports = ns;

},{"../base/index.js":142,"../base/vec.js":143,"../interfaces.js":188,"../type-system/typeinfo.js":203,"../utils/":206,"assert":25,"estraverse":61}],183:[function(require,module,exports){
"use strict";

var parser = require("esprima");
var codegen = require("escodegen");
var extractParameters = require("./analyze/extract_parameters");
var interfaces = require("./interfaces.js");
var sanitizer = require("./analyze/sanitizer/sanitizer.js");
var Base = require("./base/index.js");
var GLSLCompiler = require("./generate/glsl/compiler.js").GLSLCompiler;
var resolver = require("./resolve/resolve.js");
var validator = require("./analyze/validation");
var analyzer = require("./analyze");
var SpaceVectorType = interfaces.SpaceVectorType;
var SnippetList = require("./generate/snippets/snippet-list.js").SnippetList;
var SnippetEntry = require("./generate/snippets/snippet-list.js").SnippetEntry;
var TypeSystem = require("./type-system/type-system.js");
var PluginRegistry = require("./plugin_registry");
function WorkingSet() {
	this.ast = null;
	this.aast = null;
	this.result = null;
	this.processingData = {};
	this.inject = null;
}

WorkingSet.prototype.setAst = function(ast) {
	this.ast = ast;
};

WorkingSet.prototype.parse = function(code, opt) {
	opt = opt || {};
	this.ast = parse(code, opt);
};

WorkingSet.prototype.analyze = function(inject, implementation, opt) {
	opt = opt || {};
	opt.entry = opt.entry || "shade";
	opt.validate = opt.validate !== undefined ? opt.validate : true;
	opt.throwOnError = opt.throwOnError !== undefined ? opt.throwOnError : true;
	opt.implementation = implementation;
	this.inject = opt.inject = inject;
	this.aast = analyzer.analyze(this.ast, this.processingData, opt);
	return this.aast;
};

WorkingSet.prototype.injectMemory = function (mem) {
	this.aast = analyzer.injectMemory(this.aast, mem, {
		inject: this.inject,
		entry: "evaluate"
	});
};

WorkingSet.prototype.getProcessingData = function(key) {
	return this.processingData[key];
};

WorkingSet.prototype.compileFragmentShader = function(opt) {
	this.result = compileFragmentShader(this.aast, opt);
	return this.result;
};

WorkingSet.prototype.compileToFastlane = function (opt) {
	var compiler = new (require("./generate/fastlane/compiler"))(opt);

	return compiler.compile(this.aast, opt);
};

function extractParams(ast, opt) {
	opt = opt || {};
	opt.entry = opt.entry || "shade";
	return extractParameters(ast, opt);
}

function determineUsedParameters(code, opt) {
	opt = opt || {};
	opt.entry = opt.entry || "shade";
	var ast = parse(code, opt);
	var aast = analyze(ast, opt);
	return extractParameters(aast, opt);
}

function determineReturnType(code, opt) {
	opt = opt || {};
	opt.entry = opt.entry || "shade";
	var ast = parse(code, opt);
	var aast = analyze(ast, opt);
	for (var i = 0; i < aast.body.length; ++i)
		if (aast.body[i].id.name === opt.entry)
			return aast.body[i].extra.returnInfo;
}

function parse(ast, opt) {
	opt = opt || {};
	if (typeof ast == "function")
		ast = ast.toString();

	if (typeof ast == "string")
		return parser.parse(ast, {raw: true, loc: opt.loc || false});

	return ast;
}

function analyze(ast, opt) {
	opt = opt || {};
	opt.entry = opt.entry || "shade";
	opt.validate = opt.validate !== undefined ? opt.validate : true;
	opt.throwOnError = opt.throwOnError !== undefined ? opt.throwOnError : true;
	return analyzer.analyze(parse(ast), {}, opt);
}

function getSanitizedAst(str, opt) {
	var ast = parse(str, opt);
	return sanitizer.sanitize(ast, opt);
}

function parseAndInferenceExpression(ast, opt) {
	ast = parse(ast, opt);
	return analyze(ast, opt);
}

function resolveClosures(ast, implementation, processData, opt) {
	opt = opt || {};
	processData = processData || {};
	return resolver.resolveClosuresPreTypeInference(ast, implementation,
													processData, opt);
}

function compileFragmentShader(aast, opt) {
	return new GLSLCompiler().compileFragmentShader(aast, opt);
}

function toJavaScript(aast, opt) {
	return codegen.generate(aast, opt);
}

function getSystem() {
	return TypeSystem.getPredefinedObject("System");
}

// var fs = require("fs");
// PluginRegistry.registerModule("shade", fs.readFileSync(__dirname + "/modules/shade.js"));

exports.parse = parse;
exports.extractParameters = extractParams;
exports.determineUsedParameters = determineUsedParameters;
exports.determineReturnType = determineReturnType;
exports.parseAndInferenceExpression = parseAndInferenceExpression;
exports.analyze = analyze;
exports.getSystem = getSystem;
exports.resolveClosures = resolveClosures;
exports.toJavaScript = toJavaScript;
exports.getSanitizedAst = getSanitizedAst;

exports.TYPES = interfaces.TYPES;
exports.OBJECT_KINDS = interfaces.OBJECT_KINDS;
exports.SOURCES = interfaces.SOURCES;
exports.SPACE_VECTOR_TYPES = SpaceVectorType;
exports.Vec2 = interfaces.Vec2;
exports.Vec3 = interfaces.Vec3;
exports.Vec4 = interfaces.Vec4;
exports.Texture = interfaces.Texture;
exports.Color = interfaces.Color;
exports.Mat3 = interfaces.Mat3;
exports.Mat4 = interfaces.Mat4;
exports.WorkingSet = WorkingSet;
exports.SnippetList = SnippetList;
exports.SnippetEntry = SnippetEntry;

exports.version = "0.0.0";

},{"./analyze":106,"./analyze/extract_parameters":105,"./analyze/sanitizer/sanitizer.js":111,"./analyze/validation":139,"./base/index.js":142,"./generate/fastlane/compiler":147,"./generate/glsl/compiler.js":165,"./generate/snippets/snippet-list.js":179,"./interfaces.js":188,"./plugin_registry":189,"./resolve/resolve.js":193,"./type-system/type-system.js":202,"escodegen":54,"esprima":60}],184:[function(require,module,exports){
"use strict";

Math.clamp = function(x, minVal, maxVal) {
    return Math.min(Math.max(x, minVal), maxVal);
};

Math.smoothstep = function(edge1, edge2, x) {
    var t = Math.clamp((x - edge1) / (edge2 - edge1), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
};

Math.step = function(edge, x) {
    return x < edge ? 0 : 1;
};

Math.fract = function(x) {
    return x - Math.floor(x);
};

Math.mix = function(x, y, a) {
    var simple = typeof x == "number";
    var asimple = typeof a == "number";
    if(simple && asimple)
        return x * (1 - a) + y * a;
    if (asimple)
        return x.mul(1 - a).add(y.mul(a));
    return x.mul(a.mul(-1).add(1)).add(y.mul(a));
};

Math.saturate = function (x) {
    return Math.clamp(x, 0.0, 1.0);
};




},{}],185:[function(require,module,exports){
"use strict";

var glMatrix = require("gl-matrix");

var utils = require("./utils");
var vector = require("./vector");
var Vec2 = vector.Vec2;
var Vec3 = vector.Vec3;
var Vec4 = vector.Vec4;

function Mat2() {
	constructMatrix(this, Mat2, 2, arguments);
}

function Mat3() {
	constructMatrix(this, Mat3, 3, arguments);
}

function Mat4() {
	constructMatrix(this, Mat4, 4, arguments);
}

function constructMatrix(that, type, columnSize, args) {
	if (!(that instanceof type))
		that = Object.create(type.prototype);

	if (args[0] instanceof type)
		throw new TypeError(
			"Copy construction of an immutable type is meaningless!");

	var flatSize = columnSize * columnSize;
	if (args.length === 1 && args[0].BYTES_PER_ELEMENT) {
		var array = args[0];
		if (array.length !== flatSize)
			throw new TypeError("Typed array for construction of Mat"
								+ columnSize
								+ " has to have the correct size!");
		that.data = array;
	} else {
		that.data = new Float32Array(flatSize);
		fillMatrix(that, columnSize, args);
	}

	return that;
}

function fillMatrix(dest, columnSize, args) {
	var diagonalEntry = 1;
	if (args.length === 1)
		diagonalEntry = args[0];

	if (args.length === 0 || args.length === 1) {
		for (var i = 0; i < columnSize; ++i)
			dest.data[i * columnSize + i] = diagonalEntry;
		return dest;
	}

	var size = columnSize * columnSize;
	var componentIdx = 0;
	for (var argIdx = 0; argIdx < args.length; ++argIdx) {
		var arg = args[argIdx];
		var argComponentCount = arg.data ? arg.data.length : 1;

		if (argComponentCount > columnSize)
			throw new TypeError(
				"Vector of size " + argComponentCount
				+ " too large to initialize a matrix of column size "
				+ columnSize + "!");

		if (argComponentCount + componentIdx % columnSize > columnSize)
			throw new TypeError(
				"Too many arguments for column construction of Mat" + columnSize
				+ "!");

		if (argComponentCount + componentIdx > size)
			throw new TypeError("Too many arguments for Mat" + columnSize
								+ " construction !");

		if (argComponentCount === 1)
			dest.data[componentIdx++] = arg;
		else
			for (var i = 0; i < argComponentCount; ++i)
				dest.data[componentIdx++] = arg.data[i];
	}

	if (componentIdx < size)
		throw new TypeError("Not enough arguments for Mat " + columnSize + "!");

	return dest;
}

var methods = {
	unaryScalarResult: ["determinant"],
	unary: ["invert", "transpose"]
};

utils.forwardPrototypeMethodsToGLMatrix(Mat2, glMatrix.mat2, methods);
utils.forwardPrototypeMethodsToGLMatrix(Mat3, glMatrix.mat3, methods);
utils.forwardPrototypeMethodsToGLMatrix(Mat4, glMatrix.mat4, methods);

// we handle mul special because we overload it for vector and matrices
// we could also handle scalar multiplication here if needed
Mat2.prototype.mul = createMulFunction(Mat2, 4, Vec2, glMatrix.mat2.mul,
									   glMatrix.vec2.transformMat2);
Mat3.prototype.mul = createMulFunction(Mat3, 9, Vec3, glMatrix.mat3.mul,
									   glMatrix.vec3.transformMat3);
Mat4.prototype.mul = createMulFunction(Mat4, 16, Vec4, glMatrix.mat4.mul,
									   glMatrix.vec4.transformMat4);

function createMulFunction(matType, componentSize, vecType, glMatrixMatMul,
						   glMatrixVecTrans) {
	return function(matrix) {
		if (matrix.data.length === componentSize) {
			var result = new matType();
			glMatrixMatMul(result.data, this.data, matrix.data);
			return result;
		}
		// its not a matrix so we try to build a vector from all arguments that
		// fits the row size (because we only handle square matrices its equal
		// to the column size)
		var rhs = utils.toType(vecType, arguments);
		var result = new vecType();
		glMatrixVecTrans(result.data, rhs.data, this.data);
		return result;
	}
}

generateRowColumnAccessors(Mat2, 2);
generateRowColumnAccessors(Mat3, 3);
generateRowColumnAccessors(Mat4, 4);

function generateRowColumnAccessors(type, columnSize) {
	for (var rowIdx = 1; rowIdx <= columnSize; ++rowIdx)
		for (var columnIdx = 1; columnIdx <= columnSize; ++columnIdx)
			Object.defineProperty(
				type.prototype, "m" + rowIdx + "" + columnIdx, {
					get: (function(rowIdx, columnIdx) {
						return function() {
							return this.data[rowIdx + columnIdx * columnSize];
						}
					})(rowIdx - 1, columnIdx - 1),
					set: (function(rowIdx, columnIdx) {
						return function(newValue) {
							return this.data[rowIdx + columnIdx * columnSize]
								   = newValue;
						}
					})(rowIdx - 1, columnIdx - 1)
				});
}

generateColumnAccessors(Mat2, 2, Vec2);
generateColumnAccessors(Mat3, 3, Vec3);
generateColumnAccessors(Mat4, 4, Vec4);

function generateColumnAccessors(type, columnSize, vecType) {
	for (var columnIdx = 1; columnIdx <= columnSize; ++columnIdx) {
		Object.defineProperty(type.prototype, "c" + columnIdx, {
			get: (function(columnIdx) {
				return function() {
					return vecType(new this.data.constructor(this.data.subarray(
						columnIdx * columnSize,
						columnIdx * columnSize + columnSize)));
				}
			})(columnIdx - 1),
			set: (function(columnIdx) {
				return function(newColumn) {
					if (!(newColumn instanceof vecType))
						throw TypeError("Columns of a Mat" + columnSize
										+ " can only be set with a "
										+ vecType.name);
					var length = newColumn.data.length;
					for (var idx = 0; idx < length; ++idx)
						this.data[columnIdx * columnSize + idx]
							= newColumn.data[idx];
				}
			})(columnIdx - 1)
		});
	}
}

exports.Mat2 = Mat2;
exports.Mat3 = Mat3;
exports.Mat4 = Mat4;

},{"./utils":186,"./vector":187,"gl-matrix":67}],186:[function(require,module,exports){
"use strict";

function forwardPrototypeMethodsToGLMatrix(type, glMatrixType, functionList) {
    functionList.unaryScalarResult = functionList.unaryScalarResult || [];
    functionList.unaryScalarResult.forEach(function (functionName) {
        type.prototype[functionName] = function () {
            return glMatrixType[functionName](this.data);
        };
    });

    functionList.binaryScalarResult = functionList.binaryScalarResult || [];
    functionList.binaryScalarResult.forEach(function (functionName) {
        type.prototype[functionName] = function () {
            return glMatrixType[functionName](this.data, toType.call(null, type, arguments).data);
        };
    });

    functionList.unary = functionList.unary || [];
    functionList.unary.forEach(function (functionName) {
        type.prototype[functionName] = function () {
            var result = new type();
            glMatrixType[functionName](result.data, this.data);
            return result;
        };
    });

    functionList.binary = functionList.binary || [];
    functionList.binary.forEach(function (functionName) {
        type.prototype[functionName] = function () {
            var rhs = toType.call(null, type, arguments);
            var result = new type();
            glMatrixType[functionName](result.data, this.data, rhs.data);
            return result;
        };
    });
}

function toType(type, args) {
    if (args[0] instanceof type)
        return args[0];

    return type.apply(null, args);
}

var vectorComponentNameCategories
    = [["x", "y", "z", "w"], ["r", "g", "b", "a"], ["s", "t", "p", "q"]];

function attachSwizzles(vecLength, evaluator) {
    addSingleProperties(vecLength, evaluator);
    vectorComponentNameCategories.forEach(function(componentNames) {
        var allowedComponentNames = componentNames.slice(0, vecLength);
        [2, 3, 4].forEach(function(maskLength) {
            generateSwizzleCombinations(allowedComponentNames, maskLength)
                .forEach(evaluator);
        });
    });
}

function addSingleProperties(vecLength, evaluator) {
    vectorComponentNameCategories.forEach(function(componentNames) {
        componentNames.slice(0, vecLength).forEach(function (swizzle, idx) {
            evaluator([swizzle], idx)
        });
    });
}

function generateSwizzleCombinations(availableComponents, combinationSize) {
    var sets = [];
    for (var i = 0; i < combinationSize; ++i)
        sets[i] = availableComponents;

    return sets.reduce(function(currentCombinations, currentSet) {
        return currentCombinations.map(function(combination) {
                return currentSet.map(function(component) {
                    return combination.concat([component]);
                });
            })
            .reduce(function(a, b) {
                return a.concat(b);
            });
    }, [[]]);
}

exports.forwardPrototypeMethodsToGLMatrix = forwardPrototypeMethodsToGLMatrix;
exports.toType = toType;
exports.attachSwizzles = attachSwizzles;
},{}],187:[function(require,module,exports){
"use strict";

var glMatrix = require("gl-matrix");
var utils = require("./utils");

function Vec2(x, y) {
	return constructVector(this, Vec2, 2, arguments);
}

function Vec3(x, y, z) {
	return constructVector(this, Vec3, 3, arguments);
}

function Vec4(x, y, z, w) {
	return constructVector(this, Vec4, 4, arguments);
}

function constructVector(that, type, size, args) {
	if (!(that instanceof type))
		that = Object.create(type.prototype);

	if (args.length === 1 && Array.isArray(args[0]))
		args = args[0];

	if (args.length === 1 && args[0].data === 1 && args[0].data.length >= size)
		throw new TypeError(
			"Copy construction of an immutable type or construction from a vector of greater size is not allowed!");

	if (args.length === 1 && args[0].BYTES_PER_ELEMENT) {
		var array = args[0];
		if (array.length !== size)
			throw new TypeError("Typed array for construction of Vec" + size
								+ " has to have the correct size!");
		that.data = array;
	} else {
		that.data = new Float32Array(size);
		fillVecX(that, size, args);
	}

	return Object.seal(that);
}

function fillVecX(dest, size, args) {
	if (args.length === 0)
		return dest;

	if (args.length === 1) {
		for (var idx = 0; idx < size; ++idx)
			dest.data[idx] = args[0];
		return dest;
	}

	var componentIdx = 0;
	for (var argIdx = 0; argIdx < args.length; ++argIdx) {
		var arg = args[argIdx];
		var argComponentCount = arg.data ? arg.data.length : 1;
		if (argComponentCount + componentIdx > size)
			throw new TypeError("Too many arguments for Vec" + size
								+ " construction!");

		if (argComponentCount === 1)
			dest.data[componentIdx++] = arg;
		else
			for (var i = 0; i < argComponentCount; ++i)
				dest.data[componentIdx++] = arg.data[i];
	}

	if (componentIdx < size)
		throw new TypeError("Not enough arguments for Vec" + size
							+ " construction!");

	return dest;
}

var methods = {
	unaryScalarResult: ["length"],
	binaryScalarResult: ["dot"],
	unary: ["normalize", "negate"],
	binary: ["add", "sub", "mul", "div"]
};

var vectorComponentNameCategories
	= [["x", "y", "z", "w"], ["r", "g", "b", "a"], ["s", "t", "p", "q"]];

var sizeTypeMapping = {
	2: Vec2,
	3: Vec3,
	4: Vec4
};

utils.forwardPrototypeMethodsToGLMatrix(Vec2, glMatrix.vec2, methods);
utils.attachSwizzles(2, addSwizzleGetter.bind(undefined, Vec2.prototype));

utils.forwardPrototypeMethodsToGLMatrix(Vec4, glMatrix.vec4, methods);
utils.attachSwizzles(3, addSwizzleGetter.bind(undefined, Vec3.prototype));

// add cross product for vec3 only
methods.binary.push("cross");
utils.forwardPrototypeMethodsToGLMatrix(Vec3, glMatrix.vec3, methods);
utils.attachSwizzles(4, addSwizzleGetter.bind(undefined, Vec4.prototype));


function addSwizzleGetter(type, swizzle, idx) {
	if (swizzle.length > 1) {
		var resultType = sizeTypeMapping[swizzle.length];
		Object.defineProperty(type, swizzle.join(""), {
			get: (function (swizzle, resultType) {
				return function () {
					var args = new this.data.constructor(swizzle.length);
					for (var i = 0; i < swizzle.length; ++i)
						args[i] = this[swizzle[i]];

					return resultType(args);
				}
			})(swizzle, resultType)
		});
	} else {
		Object.defineProperty(type, swizzle.join(""), {
			get: (function (idx) {
				return function () {
					return this.data[idx];
				}
			})(idx)
		});
	}
}

exports.Vec2 = Vec2;
exports.Vec3 = Vec3;
exports.Vec4 = Vec4;

},{"./utils":186,"gl-matrix":67}],188:[function(require,module,exports){
(function (ns) {
    var Base = require("./base/index.js");
    var CodeGen = require("escodegen");
    var VecMath = require("./base/vecmath.js").VecMath;


    /**
     * @enum {string}
     */
    var Types = ns.TYPES = {
        ANY: "any",
        INT: "int",
        NUMBER: "number",
        BOOLEAN: "boolean",
        OBJECT: "object",
        ARRAY: "array",
        NULL: "null",
        UNDEFINED: "undefined",
        FUNCTION: "function",
        STRING: "string",
        INVALID: "invalid"
    }

    var Kinds = ns.OBJECT_KINDS = {
        ANY: "any",
        VEC2: "Vec2", // virtual kinds
        VEC3: "Vec3", // virtual kinds
        VEC4: "Vec4", // virtual kinds
        MATRIX3: "Mat3",
        MATRIX4: "Mat4",
        TEXTURE: "Texture",
        COLOR_CLOSURE: "color_closure"
    }

    var Semantics = ns.SEMANTICS = {
        COLOR: 'color',
        NORMAL: 'normal',
        SCALAR_0_TO_1: 'scalar0To1',
        UNKNOWN: 'unknown'
    }

    /**
     * Possible Spaces
     * @enum
     */
    var SpaceType = ns.SpaceType = {
        OBJECT: 0,
        VIEW: 1,
        WORLD: 2,
        RESULT: 5
    };
    var VectorType = ns.VectorType = {
        NONE: 0,
        POINT: 1,
        NORMAL: 2
    };
    ns.SpaceVectorType = {
        OBJECT: SpaceType.OBJECT,
        VIEW_POINT : SpaceType.VIEW + (VectorType.POINT << 3),
        WORLD_POINT : SpaceType.WORLD + (VectorType.POINT << 3),
        VIEW_NORMAL : SpaceType.VIEW + (VectorType.NORMAL << 3),
        WORLD_NORMAL : SpaceType.WORLD + (VectorType.NORMAL << 3),
        RESULT_POINT : SpaceType.RESULT + (VectorType.POINT << 3),
        RESULT_NORMAL : SpaceType.RESULT + (VectorType.NORMAL << 3)
    };
    ns.getVectorFromSpaceVector = function(spaceType){
        return spaceType >> 3;
    }
    ns.getSpaceFromSpaceVector = function(spaceType){
        return spaceType % 8;
    }

    ns.SOURCES = {
        UNIFORM: "uniform",
        VERTEX: "vertex",
        CONSTANT: "constant"
    }

    ns.ColorClosures = {
        "emissive" : {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.COLOR}
            ]
        },
        "diffuse" : {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0 }
            ]
        },
        "phong" : {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0}
            ]
        },
        cookTorrance: {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0}
            ]
        },
        ward: {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0}
            ]
        },
        scatter: {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0}
            ]
        },
        "reflect" : {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 1 },
            ]
        },
        "refract" : {
            input: [
                { type: Types.OBJECT, kind: "Vec3", semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 1 },
                { type: Types.NUMBER, semantic: Semantics.UNKNOWN, defaultValue: 1 },
            ]
        },
        "transparent" : {
            input: [
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0 }
            ]
        }
    }

    ns.toJavaScript = function(node) {
        return CodeGen.generate(node);
    };

    ns.VecMath = VecMath;
    require("./interface/math")
    ns.Vec2 = require("./interface/vector").Vec2;
    ns.Vec3 = require("./interface/vector").Vec3;
    ns.Vec4 = require("./interface/vector").Vec4;
    ns.Mat2 = require("./interface/matrix").Mat2;
    ns.Mat3 = require("./interface/matrix").Mat3;
    ns.Mat4 = require("./interface/matrix").Mat4;

}(exports));

},{"./base/index.js":142,"./base/vecmath.js":144,"./interface/math":184,"./interface/matrix":185,"./interface/vector":187,"escodegen":54}],189:[function(require,module,exports){
"use strict";

function PluginRegistry() {
    this._registeredPlugins = {

    }
}

PluginRegistry.prototype._get = function (subsystem, name) {
    if (!this._has(subsystem, name))
        throw new Error(subsystem + ": " + name + " not found!")

    return this._registeredPlugins[subsystem].get(name);
};

PluginRegistry.prototype._has = function (subsystem, name) {
    return this._registeredPlugins[subsystem] && this._registeredPlugins[subsystem].has(name);
};

PluginRegistry.prototype._register = function (subsystem, name, plugin) {
    if (!this._registeredPlugins[subsystem])
        this._registeredPlugins[subsystem] = new Map();
    this._registeredPlugins[subsystem].set(name, plugin)
};

function establishSubsystem(subsystemName) {
    subsystemName = subsystemName.charAt(0).toUpperCase() + subsystemName.substring(1);
    PluginRegistry.prototype["has" + subsystemName] = function (name) {
        return this._has(subsystemName, name);
    };
    PluginRegistry.prototype["get" + subsystemName] = function (name) {
        return this._get(subsystemName, name);
    };
    PluginRegistry.prototype["register" + subsystemName] = function (name, plugin) {
        return this._register(subsystemName, name, plugin);
    };
}

establishSubsystem("module");

exports = module.exports = new PluginRegistry();
},{}],190:[function(require,module,exports){
(function (ns) {

    var Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima'),
        Shade = require("../interfaces.js"),
        annotate = require("../utils").annotate;

    function handleCallExpression(node) {
        var callee = annotate(node.callee);
        // console.log("Call", node.callee.property, callee.getTypeString(), node.callee.object)
        if(callee.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
            annotate(node).copyFrom(callee);
        }
    }

    function handleMemberExpression(node) {
        var object = annotate(node.object);
        var result = annotate(node);
        if (node.object.name == "Shade" || object.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
            var closureName = node.property.name;
            if (!Shade.ColorClosures.hasOwnProperty(closureName)) {
                return;
            };
            result.setType(Shade.TYPES.OBJECT, Shade.OBJECT_KINDS.COLOR_CLOSURE);
        }
    }

    ns.markColorClosures = function(programAast){
        Traversal.traverse(programAast, {
            leave: function(node, parent){
                 switch (node.type) {
                    case Syntax.CallExpression:
                        return handleCallExpression(node);
                    case Syntax.MemberExpression:
                        return handleMemberExpression(node);
                }
            }
        });
    }

}(exports));

},{"../interfaces.js":188,"../utils":206,"esprima":60,"estraverse":61}],191:[function(require,module,exports){
/**
 * Simple replacer that collects all closure calls of a color closure expression and passes them to the
 * provided callback
 * @type {exports}
 */

var Traversal = require('estraverse');
var annotate = require("../utils").annotate;
var Shade = require("../interfaces.js");

var Syntax = Traversal.Syntax;

function isColorClosure(node) {
    if (node.type !== Syntax.CallExpression) {
        return false;
    }
    return annotate(node).isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE);
}

function handleCallExpression(node, colorClosureList) {
    var callee = annotate(node.callee);
    // console.log("Call", node.callee.property, callee.getTypeString(), node.callee.object)
    if (callee.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
        colorClosureList.push({name: node.callee.property.name, args: node.arguments});
    }
}

function getClosureList(closureExpression) {
    // console.log(JSON.stringify(closureExpression, null, " "))
    var colorClosureList = [];
    Traversal.traverse(closureExpression, {
        leave: function (node) {
            if (node.type == Syntax.CallExpression) {
                return handleCallExpression(node, colorClosureList);
            }
        }
    });
    colorClosureList.sort(function (a, b) {
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0
    });
    return colorClosureList;
}

function handleColorClosure(closureExpression, replacer) {
    var list = getClosureList(closureExpression);
    return replacer(list);
}

var replace = function (ast, replacer) {
    return Traversal.replace(ast, {
        enter: function (node) {
            if (isColorClosure(node)) {
                this.skip();
                return handleColorClosure(node, replacer)
            }
        }
    });
};


module.exports = replace;

},{"../interfaces.js":188,"../utils":206,"estraverse":61}],192:[function(require,module,exports){
(function (ns) {

    var Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima');

    var Shade = require("../interfaces.js"),
    SpaceVectorType = Shade.SpaceVectorType,
    Types = Shade.TYPES,
    Kinds = Shade.OBJECT_KINDS;

    ns.getDefaultValue = function(ccInputDefinition){
        if(ccInputDefinition.defaultValue == undefined)
            throw new Error("ColorClosure input has not default value!");

        if(ccInputDefinition.type == Types.NUMBER || ccInputDefinition.type == Types.INT){
            var result = {
                type: Syntax.Literal,
                value: ccInputDefinition.defaultValue
            }
            return result;
        }
        else{
            throw new Error("Currentlty don't support default values of type " + ccInputDefinition.type + " and kind " + ccInputDefinition.kind);
        }
    }

}(exports));

},{"../interfaces.js":188,"esprima":60,"estraverse":61}],193:[function(require,module,exports){
var assert = require("assert");
var ColorClosureMarker = require("./colorclosure-marker.js");

var c_implementations = {};

var registerLightingImplementation = function (name, obj) {
    c_implementations[name] = obj;
};

var resolveClosuresPreTypeInference = function (aast, implementationName, processingData, opt) {
    if (!implementationName) {
        return aast;
    }
    try {
        var resolverImpl = c_implementations[implementationName];
        assert(resolverImpl, "Implementation not found: " + implementationName);
        if (resolverImpl.resolvePreTypeInference) {
            ColorClosureMarker.markColorClosures(aast);
            return resolverImpl.resolvePreTypeInference(aast, processingData, opt);
        } else
            return aast;
    } catch (e) {
        console.error(e);
    }
    return aast;
};

var resolveClosuresPostTypeInference = function (aast, implementationName, processingData, opt) {
    if (!implementationName) {
        return aast;
    }
    try {
        var resolverImpl = c_implementations[implementationName];
        if (resolverImpl.resolvePostTypeInference)
            return resolverImpl.resolvePostTypeInference(aast, processingData, opt); else
            return aast;
    } catch (e) {
        console.error(e);
    }
    return aast;
};

registerLightingImplementation("xml3d-glsl-forward", require("./xml3d-glsl-forward"));
registerLightingImplementation("xml3d-glsl-deferred", require("./xml3d-glsl-deferred"));

module.exports = {
  registerLightingImplementation: registerLightingImplementation,
  resolveClosuresPreTypeInference: resolveClosuresPreTypeInference,
  resolveClosuresPostTypeInference: resolveClosuresPostTypeInference
};

},{"./colorclosure-marker.js":190,"./xml3d-glsl-deferred":195,"./xml3d-glsl-forward":197,"assert":25}],194:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        annotate = require("./../../utils").annotate,
        DeferredInfo = require("./xml3d-deferred.js");

    var Shade = require("../../interfaces.js"),
        SpaceVectorType = Shade.SpaceVectorType,
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;

    var SpaceTransformTools = require("../../generate/space/space-transform-tools.js"),
        ColorClosureTools = require("../colorclosure-tools.js");

    var ADD_POSITION_TO_ARGS = true;

    var ArgStorageType = ns.ArgStorageType = {
        FLOAT : 'float',
        FLOAT_BYTE: 'floatByte',
        FLOAT_UBYTE: 'floatUByte',
        FLOAT2: 'float2',
        FLOAT3: 'float3',
        FLOAT3_NORMAL: 'float3Normal',
        FLOAT4: 'float4'
    }

    var AMBIENT_DEFINITION = {type: Types.NUMBER, semantic: Shade.SEMANTICS.SCALAR_0_TO_1, defaultValue: 0 };


    ns.ColorClosureSignature = function(){
        this.id = 0;
        this.textureCount = 0;
        this.args = [];
        this.colorClosures = [];
    };
    Base.extend(ns.ColorClosureSignature.prototype, {
        construct: function(returnAast, scope){
            var closureInfo = collectClosureInfo(returnAast);
            var argAast = gatherClosureArgs(this, closureInfo, scope);
            var textures = allocateArgumentsToTextures(this);
            this.id = getSignatureId(this);
            argAast[0].value = this.id; // Set ID for shader id assignment
            return generateAast(textures, argAast);
        }
    });

    // Basic ColorClosureSignature Createion

    function addColorClosure(ccSig, colorClosureName, argIndices, envIndices){
        ccSig.colorClosures.push({
            name: colorClosureName,
            argIndices: argIndices,
            envIndices: envIndices
        });
    }

    function addArgument(ccSig, type, kind, storeType){
        var id = ccSig.args.length;
        ccSig.args.push({
            id: id,
            type: type,
            kind: kind,
            storeType: storeType,
            texIdx: undefined,
            componentIdx: undefined,
            bitIdx: undefined
        });
        return id;
    }

    // Argument Collection

    function collectClosureInfo(returnAast){
        var result = [];
        Traversal.traverse(returnAast, {
                leave: function(node, parent){
                    switch (node.type) {
                        case Syntax.CallExpression:
                            if(node.callee.type == Syntax.MemberExpression
                               && annotate(node.callee.object).isOfKind(Kinds.COLOR_CLOSURE))
                            {
                                result.push({
                                    name: node.callee.property.name,
                                    args: node.arguments
                                });
                            }
                    }
                }
            });
        result.sort(function(a,b){return a.name < b.name ? -1 : a.name > b.name ? 1 : 0});
        return result;
    }

    function gatherClosureArgs(ccSig, closureInfo, scope){
        var argCache = {}, argAast = [];

        // Add argument for signature id;
        getCachedArgument(ccSig, {type: Types.INT}, {type: "Literal", value: "ID_UNSPECIFIED"}, argCache, argAast);
        if(ADD_POSITION_TO_ARGS)
            addPositionArgument(ccSig, argCache, argAast);
        var ambientValue = { type: Syntax.LogicalExpression, operator : "||",
                        left: getEnvAccess("ambientIntensity", AMBIENT_DEFINITION),
                        right: ColorClosureTools.getDefaultValue(AMBIENT_DEFINITION) };

        getCachedArgument(ccSig, AMBIENT_DEFINITION, ambientValue, argCache, argAast);

        for(var i = 0; i < closureInfo.length; ++i){
            var cInfo = closureInfo[i];
            var closureDefinition = Shade.ColorClosures[cInfo.name];
            if(!closureDefinition)
                throw new Error("Unknown Color closure '" + cInfo.name + "'");
            var argIndices = [], value;
            for(var j = 0; j < closureDefinition.input.length; ++j){
                var inputDefinition = closureDefinition.input[j];
                if(j < cInfo.args.length)
                    value = cInfo.args[j];
                else
                    value = ColorClosureTools.getDefaultValue(inputDefinition);
                var space = DeferredInfo[cInfo.name] && DeferredInfo[cInfo.name].inputSpaces[j];
                argIndices.push(getCachedArgument(ccSig, inputDefinition, value, argCache, argAast, space));
            }
            var envIndices = {};
            for(var property in closureDefinition.env){
                var envDefinition = closureDefinition.env[property];
                // TODO: Determine if env property is undefined and use defaultValue in this case;
                value = { type: Syntax.LogicalExpression, operator : "||",
                        left: getEnvAccess(property, envDefinition),
                        right: ColorClosureTools.getDefaultValue(envDefinition) };
                envIndices[property] = getCachedArgument(ccSig, envDefinition, value, argCache, argAast);
            }
            addColorClosure(ccSig, cInfo.name, argIndices, envIndices);
       }
       return argAast;
    }

    function addPositionArgument(ccSig, argCache, argAast){
        var positionLookup = { type: Syntax.MemberExpression,
            object: { type: Syntax.Identifier, name: "_env"},
            property: { type: Syntax.Identifier, name: "position"}
        }
        // ANNO(positionLookup).setType(Types.OBJECT, "Vec3");
        // ANNO(positionLookup.object).setType(Types.OBJECT, Kinds.ANY);
        // ANNO(positionLookup.object).setGlobal(true);
        getCachedArgument(ccSig, {type: Types.OBJECT, kind: "Vec3"}, positionLookup, argCache, argAast,
            SpaceVectorType.VIEW_POINT);
    }

    function getCachedArgument(ccSig, inputDefinition, inputAast, argCache, argAast, space){
        space = space || SpaceVectorType.OBJECT;
        inputAast = space ? SpaceTransformTools.getSpaceTransformCall(inputAast, space) : inputAast;
        var keyAast = Base.deepExtend({}, inputAast);
        cleanAast(keyAast);
        var storageType = getStorageType(inputDefinition);
        var key = storageType + ";" + JSON.stringify(keyAast);
        if(argCache[key] === undefined){
            var argId = addArgument(ccSig, inputDefinition.type, inputDefinition.kind, storageType);
            argCache[key] = argId;
            argAast.push(inputAast);
        }
        return argCache[key];
    }
    /* Remove all range properties from the aast */
    function cleanAast(aast){
        for(var i in aast){
            if(i == "range" || i == "loc"){
                delete aast[i];
            }
            else if(typeof aast[i] == "object"){
                cleanAast(aast[i]);
            }
        }
    }

    function getStorageType(closureInputType){
        if(closureInputType.type == Types.NUMBER || closureInputType.type == Types.INT){
            return ArgStorageType.FLOAT;
        }
        else if(closureInputType.type == Types.OBJECT){
            switch(closureInputType.kind){
                case "Vec2": return ArgStorageType.FLOAT2;
                case "Vec3": return ArgStorageType.FLOAT3;
                case "Vec4": return ArgStorageType.FLOAT4;
                default:
                    throw new Error("Deferred input of this kind not supported: " + closureInputType.kind);
            };
        }
        else{
            throw new Error("Deferred input of this type not supported: " + closureInputType.type);
        }
    }

    function getEnvAccess(property, definition){
        var result = {
            type: Syntax.MemberExpression,
            object: {type: Syntax.Identifier, name: "_env" },
            property: {type: Syntax.Identifier, name: property }
        }
        // ANNO(result).setType(definition.type, definition.kind);
        // var objAnno = ANNO(result.object);
        // objAnno.setType(Types.OBJECT, Kinds.ANY);
        // objAnno.setGlobal(true);
        return result;
    }


    // Argument Allocation


    function allocateArgumentsToTextures(ccSig){
        var argCopy = ccSig.args.slice( ADD_POSITION_TO_ARGS ? 3 : 2);
        argCopy.sort(function(a, b){
            return getStorageSize(a.storeType) - getStorageSize(b.storeType);
        });
        argCopy.push(ccSig.args[ADD_POSITION_TO_ARGS ? 2 : 1]); // Ambient comes third.
        if(ADD_POSITION_TO_ARGS)
            argCopy.push(ccSig.args[1]); // POSITION comes second.
        argCopy.push(ccSig.args[0]); // ID argument always comes first (and thus: last in this array)
        var textures = [];
        var i = argCopy.length;
        while(i--){
            var arg = argCopy[i];
            assignTextureSlot(arg, textures);
        }
        ccSig.textureCount = textures.length;
        return textures;
    }
    function assignTextureSlot(arg, textures){
        var size = getStorageSize(arg.storeType);
        for(var i = 0; i < textures.length; i++){
            var tex = textures[i];
            if(size < 32){
                throw new Error("We currently don't support storing of values smaller than 32 bit");
            }
            else if(tex.usedComponents + size / 32 <= 4){
                arg.texIdx = i;
                arg.componentIdx = tex.usedComponents;
                arg.bitIdx = 0;
                tex.usedComponents += size / 32;
                tex.usedBits = 0;
                tex.storedArgs.push(arg);
                return;
            }
        }
        arg.texIdx = textures.length;
        arg.componentIdx = 0;
        arg.bitIdx = 0;
        if(size < 32){
            throw new Error("We currently don't support storing of values smaller than 32 bit");
        }
        else{
            textures.push({
                usedComponents: size / 32,
                usedBits: 0,
                storedArgs: [arg]
            });
        }
    }

    function getStorageSize(storeType){
        switch(storeType){
            case ArgStorageType.FLOAT: return 32;
            case ArgStorageType.FLOAT_BYTE: return 8;
            case ArgStorageType.FLOAT_UBYTE: return 8;
            case ArgStorageType.FLOAT2: return 64;
            case ArgStorageType.FLOAT3: return 96;
            case ArgStorageType.FLOAT3_NORMAL: return 24;
            case ArgStorageType.FLOAT4: return 128;
        }
    }

    // Get ColorClosureSignature ID

    var c_SignatureNextId = 0;
    var c_SignatureIDCache = {};

    ns.ColorClosureSignature.clearIdCache = function(){
        c_SignatureNextId = 0;
        c_SignatureIDCache = {};
    }

    function getSignatureId(ccSig){
        var key = "";
        for(var i = 0; i < ccSig.args.length; ++i){
            var arg = ccSig.args[i];
            key += getArgumentKey(arg) + ";"
        }
        for(i = 0; i < ccSig.colorClosures.length; ++i){
            var closure = ccSig.colorClosures[i];
            key += closure.name + "," + closure.argIndices.join(",");
            for(var prop in closure.envIndices){
                key += "," + prop + ">" + closure.envIndices[i];
            }
        }
        if(c_SignatureIDCache[key] === undefined){
            c_SignatureIDCache[key] = c_SignatureNextId;
            c_SignatureNextId++;
        }
        return c_SignatureIDCache[key];
    }

    function getArgumentKey(arg){
        return arg.type + "," + arg.kind + "," + arg.storeType + "," + arg.texIdx + ","
            + arg.componentIdx + "," + arg.bitIdx;
    }

    // Aast generation

    function generateAast(textures, argAast){
        var arrayExpression = { type: Syntax.ArrayExpression, elements: []};
        for(var i = 0; i < textures.length; ++i){
            var vectorExpression = generateVectorAast(textures[i], argAast);
            arrayExpression.elements.push(vectorExpression);
        }
        // ANNO(arrayExpression).setType(Types.ARRAY);

        var returnStatement = {type: Syntax.ReturnStatement, argument: arrayExpression};
        return returnStatement;
    }

    function generateVectorAast(texture, argAast){
        var vecArgs = [];
        for(var i = 0; i < texture.storedArgs.length; ++i){
            var arg = texture.storedArgs[i];
            var size = getStorageSize(arg.storeType);
            if(size < 32){
                throw new Error("We currently don't support storing of values smaller than 32 bit");
            }
            else{
                vecArgs.push(argAast[arg.id]);
            }
        }
        for(i = texture.usedComponents; i < 4; ++i){
            var zeroLiteral = { type: Syntax.Literal, value: "0" };
            // ANNO(zeroLiteral).setType(Types.INT);
            vecArgs.push(zeroLiteral);
        }
        var result = { type: Syntax.NewExpression, callee: { type: Syntax.Identifier, name: "Vec4"}, arguments: vecArgs};
        // ANNO(result).setType(Types.OBJECT, "Vec4");
        return result;
    }


}(exports));

},{"../../base/index.js":142,"../../generate/space/space-transform-tools.js":180,"../../interfaces.js":188,"../colorclosure-tools.js":192,"./../../utils":206,"./xml3d-deferred.js":196,"estraverse":61}],195:[function(require,module,exports){
(function (ns) {

    var Closures = require("./xml3d-deferred.js"),
        Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima'),
        Shade = require("../../interfaces.js"),

        sanitizer = require("./../../analyze/sanitizer/sanitizer.js"),
        ColorClosureSignature = require("./color-closure-signature.js").ColorClosureSignature;


    ns.resolvePreTypeInference = function (aast, processData, opt) {
        var state = {
            colorClosureSignatures: [],
            inMain: false
        };
        var globalScrope = aast.scope;
        aast = Traversal.replace(aast, {
            enter: function(node, parent){
                switch(node.type){
                    case Syntax.FunctionDeclaration:
                        // TODO: Properly determine if we are in main function
                        if(node.id.name == "shade")
                            state.inMain = true;
                        else
                            this.skip();
                        break;
                }
            },
            leave: function(node, parent){
                switch(node.type){
                    case Syntax.FunctionDeclaration:
                        // TODO: Properly determine if we are in main function
                        if(node.id.name == "shade")
                            state.inMain = false;
                        break;
                    case Syntax.ReturnStatement:
                        if(state.inMain){
                            var signature = new ColorClosureSignature();
                            var replacement = signature.construct(node, globalScrope);
                            state.colorClosureSignatures.push(signature);
                            return replacement;
                        }
                }
            }
        })

        processData['colorClosureSignatures'] = state.colorClosureSignatures;

        return aast;
    }

}(exports));

},{"../../interfaces.js":188,"./../../analyze/sanitizer/sanitizer.js":111,"./color-closure-signature.js":194,"./xml3d-deferred.js":196,"esprima":60,"estraverse":61}],196:[function(require,module,exports){
(function (ns) {

        var Shade = require("../../interfaces.js"),
            SpaceVectorType = Shade.SpaceVectorType;

        ns.emissive = {
            inputSpaces: [
                SpaceVectorType.OBJECT
            ]
        }

        ns.diffuse = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.phong = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.cookTorrance = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT,
                SpaceVectorType.OBJECT
            ]
        }

        ns.ward = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT,
                SpaceVectorType.OBJECT
            ]
        }

        ns.scatter = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.reflect = {
            inputSpaces: [
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.refract = {
            inputSpaces: [
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT,
                SpaceVectorType.OBJECT
            ]
        }

}(exports));

},{"../../interfaces.js":188}],197:[function(require,module,exports){
(function (ns) {

    var assert = require("assert");
    var ClosuresImpl = require("./xml3d-forward.js"),
        LightLoop = require("./light-loop.js").LightLoop,
        Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima'),
        Shade = require("../../interfaces.js"),
        sanitizer = require("./../../analyze/sanitizer/sanitizer.js");
    var replacer = require("../colorclosure-replacer.js");

    var SpaceTransformTools = require("../../generate/space/space-transform-tools.js"),
        ColorClosureTools = require("../colorclosure-tools.js");



    function containsClosure(arr, name) {
        return arr.some(function (func) {
            return func.id.name == name;
        });
    }

    function getInjectAddition(destName, functionName, inputPre, ccName, colorClosureIndex ){
        var args = [];
        for(var i = 0; i < inputPre.length; ++i){
            args.push({ type: Syntax.Identifier, name: inputPre[i]});
        }
        var inputsCnt = Shade.ColorClosures[ccName].input.length;
        for(var i = 0; i < inputsCnt; ++i){
            args.push({ type: Syntax.Identifier, name: getColorClosureInputArg(colorClosureIndex, i)});
        }
        return {
            type: Syntax.ExpressionStatement,
            expression: { type: Syntax.AssignmentExpression,
                operator: "=",
                left: { type: Syntax.Identifier, name: destName},
                right: { type: Syntax.CallExpression,
                    callee: { type: Syntax.MemberExpression,
                        object: {type: Syntax.Identifier, name: destName},
                        property: {type: Syntax.Identifier, name: "add"}
                    },
                    arguments: [{ type: Syntax.CallExpression,
                        callee: {type: Syntax.Identifier, name: functionName},
                        arguments: args
                    }]
              }}
        };
    }

    function getColorClosureInject(ccName, functionMember, state){
        if(!ClosuresImpl[ccName])
            console.error("No implementation available for ColorClosure '" + ccName + "'" );
        if(!ClosuresImpl[ccName][functionMember])
            return null;
        var functionName = ccName + "_" + functionMember;
        if (!containsClosure(state.newFunctions, functionName)){
            var closureImplementation = ClosuresImpl[ccName][functionMember];
            try {
                var closureAST = parser.parse(closureImplementation.toString(), { raw: true });
                closureAST = sanitizer.sanitize(closureAST);
                closureAST.body[0].id.name = functionName;
                state.newFunctions.push(closureAST.body[0]);
            } catch (e) {
                console.error("Error in analysis of closure '", ccName + ">" + functionMember, "'", e);
                return;
            }
        }
        return functionName;
    }


    function injectBrdfEntry(ccNames, state){
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getDiffuse", state)){
                result.body.push(getInjectAddition("kd", fName, ["L", "V"], ccName, i));
            }
            if(fName = getColorClosureInject(ccName, "getSpecular", state)){
                result.body.push(getInjectAddition("ks", fName, ["L", "V"], ccName, i));
            }
        }
        return result;
    }

    function injectAmbientEntry(ccNames, state){
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getAmbient", state)){
                result.body.push(getInjectAddition("ambientColor", fName, ["ambientIntensity"], ccName, i));
            }
        }
        return result;
    }

    function injectEmissiveEntry(ccNames, state) {
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getEmissive", state)){
                result.body.push(getInjectAddition("emissiveColor", fName, [], ccName, i));
            }
        }
        return result;
    }

    function injectRefractReflectEntry(ccNames, state){
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getRefract", state)){
                result.body.push(getInjectAddition("refractColor", fName, ["position"], ccName, i));
            }
            if(fName = getColorClosureInject(ccName, "getReflect", state)){
                result.body.push(getInjectAddition("reflectColor", fName, ["position"], ccName, i));
            }
        }
        return result;
    }

    function injectTransparency(ccNames, state) {
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        state.isTransparent = true;
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getTransparency", state)) {
                result.body.push(getInjectAddition("transparency", fName, ["position"], ccName, i));
            }
        }
        // if no transparency closure force opaque
        if (result.body.length === 0) {
            result.body.push({
                type: Syntax.ExpressionStatement,
                expression: {
                    type: Syntax.AssignmentExpression,
                    operator: "=",
                    left: {type: Syntax.Identifier, name: "transparency"},
                    right: {type: Syntax.Identifier, name: "opaque"}
                }
            });
            state.isTransparent = false;
        }

        return result;
    }

    function injectColorClosureCalls(lightLoopFunction, ccNames, state){
        var result = Traversal.replace(lightLoopFunction.body, {
            enter: function(node, parent){
                if(node.type == Syntax.ExpressionStatement && node.expression.type == Syntax.Literal){
                    switch(node.expression.value){
                        case "BRDF_ENTRY": return injectBrdfEntry(ccNames, state);
                        case "AMBIENT_ENTRY": return injectAmbientEntry(ccNames, state);
                        case "EMISSIVE_ENTRY": return injectEmissiveEntry(ccNames, state);
                        case "REFRACT_REFLECT_ENTRY": return injectRefractReflectEntry(ccNames, state);
                        case "TRANSPARENCY": return injectTransparency(ccNames, state);
                    };

                }
            }
        });
        return result;
    }

    function getColorClosureInputArg(ccIndex, inputIndex){
        return "_cc" + ccIndex + "Input" + inputIndex;
    }

    function createLightLoopFunction(lightLoopFunctionName, ccNames, state){
        try {
            var lightLoopAst = parser.parse(LightLoop.toString(), { raw: true });
        } catch (e) {
            console.error("Error in analysis of the lightLoop", e);
            return;
        }
        var functionAast = lightLoopAst.body[0];
        functionAast.id.name = lightLoopFunctionName;

        for(var i = 0; i < ccNames.length; ++i){
            var ccName = ccNames[i];
            var ccInput = Shade.ColorClosures[ccName].input;
            for(var j = 0; j < ccInput.length; ++j){
                functionAast.params.push({
                    type: Syntax.Identifier,
                    name: getColorClosureInputArg(i,j)
                });
            }
        }
        injectColorClosureCalls(functionAast, ccNames, state);

        lightLoopAst = sanitizer.sanitize(lightLoopAst);
        return lightLoopAst.body[0];
    }

    function getLightLoopFunction(colorClosureList, state){
        var ccNames = [];
        for(var i = 0; i < colorClosureList.length; ++i)
            ccNames.push(colorClosureList[i].name);
        var lightLoopFunctionName = "lightLoop_" + ccNames.join("_");
        if (!containsClosure(state.newFunctions, lightLoopFunctionName)){
            state.newFunctions.push(createLightLoopFunction(lightLoopFunctionName, ccNames, state));
        }
        return lightLoopFunctionName;
    }



    function generateLightLoopCall(lightLoopFunction, colorClosureList, state){
        var args = [];

        var posArg = state.positionArg;
        if(!state.noSpaceTransform)
            posArg = SpaceTransformTools.getSpaceTransformCall(posArg, Shade.SpaceVectorType.VIEW_POINT);
        args.push(posArg)
        args.push(state.ambientArg);
        for(var i = 0; i < colorClosureList.length; ++i){
            var ccEntry = colorClosureList[i];
            var ccInput = Shade.ColorClosures[ccEntry.name].input;
            for(var j = 0; j < ccInput.length; ++j){
                var arg = ccEntry.args[j];
                if(!arg)
                    arg = ColorClosureTools.getDefaultValue(ccInput[j]);
                if(ccInput[j].semantic == Shade.SEMANTICS.NORMAL && !state.noSpaceTransform)
                    arg = SpaceTransformTools.getSpaceTransformCall(arg, Shade.SpaceVectorType.VIEW_NORMAL);
                args.push(arg);
            }
        }
        return {
            type: Syntax.CallExpression,
            callee: {type: Syntax.Identifier, name: lightLoopFunction},
            arguments: args
        };
    }

    function handleReturnStatement(returnAast, state){
        var list = getClosureList(returnAast, state);
        if(list.length == 0)
            return;

        returnAast.argument = lighLoopCall;
    }


    function getEnvParameter(property){
        return { type: Syntax.MemberExpression,
                object: { type: Syntax.Identifier, name: "_env" },
                property: { type: Syntax.Identifier, name: property}};
    }

    ns.resolvePreTypeInference = function (ast, processData, opt) {
        var state = {
            positionArg: opt && opt.lightLoopPositionArg || null,
            ambientArg: opt && opt.lightLoopAmbientArg || null,
            noSpaceTransform: opt && opt.lightLoopNoSpaceTransform || false,
            program: ast,
            newFunctions: []
        }
        if(!state.positionArg)
            state.positionArg = getEnvParameter("position");
        if(!state.ambientArg)
            state.ambientArg = { type: Syntax.LogicalExpression, operator: "||",
                                 left: getEnvParameter("ambientIntensity"),
                                 right: {type: Syntax.Literal, value: 0} };

        ast = replacer(ast, function(closures) {
            assert(closures.length);
            var lightLoopFunction = getLightLoopFunction(closures, state);
            var lighLoopCall = generateLightLoopCall(lightLoopFunction, closures, state);
            //console.log("here", arguments);
            return lighLoopCall;
        });

        state.newFunctions.forEach(function(newFunction) {
            state.program.body.unshift(newFunction);
        })

        processData["isTransparent"] = !!state.isTransparent;

        return ast;
    }

}(exports));

},{"../../generate/space/space-transform-tools.js":180,"../../interfaces.js":188,"../colorclosure-replacer.js":191,"../colorclosure-tools.js":192,"./../../analyze/sanitizer/sanitizer.js":111,"./light-loop.js":198,"./xml3d-forward.js":199,"assert":25,"esprima":60,"estraverse":61}],198:[function(require,module,exports){
/**
 * Created with JetBrains WebStorm.
 * User: lachsen
 * Date: 12/17/13
 * Time: 1:21 PM
 * To change this template use File | Settings | File Templates.
 */
(function (ns) {

ns.LightLoop = function LightLoop(position, ambientIntensity){
    var V = position.flip().normalize(), dist, atten;
    var kdComplete = new Vec3(0,0,0), ksComplete = new Vec3(0,0,0);
    if (this.MAX_POINTLIGHTS)
    for (var i = 0; i < this.MAX_POINTLIGHTS; i++) {
        if (!this.pointLightOn[i])
            continue;

        var L = this.viewMatrix.mulVec(this.pointLightPosition[i], 1.0).xyz();
        L = L.sub(position);
        dist = L.length();
        L = L.normalize();

        var kd = new Vec3(0,0,0), ks = new Vec3(0,0,0);
        "BRDF_ENTRY";

        atten = 1.0 / (this.pointLightAttenuation[i].x() + this.pointLightAttenuation[i].y() * dist + this.pointLightAttenuation[i].z() * dist * dist);
        kd = kd.mul(this.pointLightIntensity[i]).mul(atten);
        ks = ks.mul(this.pointLightIntensity[i]).mul(atten);
        kdComplete = kdComplete.add(kd);
        ksComplete = ksComplete.add(ks);
    }
    if (this.MAX_DIRECTIONALLIGHTS)
    for (i = 0; i < this.MAX_DIRECTIONALLIGHTS; i++) {
        if (!this.directionalLightOn[i])
            continue;

        L = this.viewMatrix.mulVec(this.directionalLightDirection[i], 0).xyz();
        L = L.flip().normalize();

        var kd = new Vec3(0,0,0), ks = new Vec3(0,0,0);
        "BRDF_ENTRY";

        kd = kd.mul(this.directionalLightIntensity[i]);
        ks = ks.mul(this.directionalLightIntensity[i]);
        kdComplete = kdComplete.add(kd);
        ksComplete = ksComplete.add(ks);
    }
    if (this.MAX_SPOTLIGHTS)
    for (i = 0; i < this.MAX_SPOTLIGHTS; i++) {
        if (this.spotLightOn[i]) {
            L = this.viewMatrix.mulVec(this.spotLightPosition[i], 1.0).xyz();
            L = L.sub(position);
            dist = L.length();
            L = L.normalize();

            var lDirection = this.viewMatrix.mulVec(this.spotLightDirection[i].flip(), 0).xyz().normalize();
            var angle = L.dot(lDirection);
            if(angle > this.spotLightCosCutoffAngle[i]) {
                var kd = new Vec3(0,0,0), ks = new Vec3(0,0,0);
                "BRDF_ENTRY";

                var c = 1.0;
                if (this.spotLightShadowMap && this.spotLightCastShadow[i]) {
                    var wpos = this.viewInverseMatrix.mulVec(position, 1.0).xyz();

                    var lsPos = this.spotLightMatrix[i].mulVec(new Vec4(wpos, 1));
                    var perspectiveDivPos = lsPos.xyz().div(lsPos.w()).mul(0.5).add(0.5);
                    var lsDepth = perspectiveDivPos.z() - this.spotLightShadowBias[i];

                    var lightuv = perspectiveDivPos.xy();
                    var bitShift = new Vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );

                    var depth = this.spotLightShadowMap[i].sample2D(lightuv).dot(bitShift);
                    if(lsDepth >= depth) {
                        c = 0.0;
                    }
                    /*var texSize = Math.max(this.width, this.height) * 2;
                    var texelSize = 1 / texSize;
                    var f = Math.fract(lightuv.mul(texSize).add(0.5));
                    var centroidUV = Math.floor(lightuv.mul(texSize).add(0.5));
                    centroidUV = centroidUV.div(texSize);

                    var lb = this.spotLightShadowMap[i].sample2D(centroidUV).dot(bitShift);
                    if (lb >= lsDepth)
                        lb = 1.0;
                    else
                        lb = 0.0;

                    var lt = this.spotLightShadowMap[i].sample2D(centroidUV.add(new Vec2(0.0, 1.0).mul(texelSize))).dot(bitShift);
                    if (lt >= lsDepth)
                        lt = 1.0;
                    else
                        lt = 0.0;

                    var rb = this.spotLightShadowMap[i].sample2D(centroidUV.add(new Vec2(1.0, 0.0).mul(texelSize))).dot(bitShift);
                    if (rb >= lsDepth)
                        rb = 1.0;
                    else
                        rb = 0.0;

                    var rt = this.spotLightShadowMap[i].sample2D(centroidUV.add(new Vec2(1.0, 1.0).mul(texelSize))).dot(bitShift);
                    if (rt >= lsDepth)
                        rt = 1.0;
                    else
                        rt = 0.0;

                    var a = Math.mix(lb, lt, f.y());
                    var b = Math.mix(rb, rt, f.y());
                    c = Math.mix(a, b, f.x());*/
                }

                var softness = 1.0;
                if(angle < this.spotLightCosSoftCutoffAngle[i])
                    softness = (angle - this.spotLightCosCutoffAngle[i]) /
                        (this.spotLightCosSoftCutoffAngle[i] -  this.spotLightCosCutoffAngle[i]);

                atten = 1.0 / (this.spotLightAttenuation[i].x() + this.spotLightAttenuation[i].y() * dist + this.spotLightAttenuation[i].z() * dist * dist);
                kd = kd.mul(this.spotLightIntensity[i]).mul(atten * softness * c);
                ks = ks.mul(this.spotLightIntensity[i]).mul(atten * softness * c);
                kdComplete = kdComplete.add(kd);
                ksComplete = ksComplete.add(ks);
            }
        }
    }
    var ambientColor = new Vec3(0,0,0);
    "AMBIENT_ENTRY";
    kdComplete = kdComplete.add(ambientColor);
    var emissiveColor = new Vec3(0, 0, 0);
    "EMISSIVE_ENTRY"
    /*if (this.ssaoMap) {
        kdComplete = kdComplete.mul(1 - this.ssaoMap.sample2D(this.normalizedCoords).r());
    } */
    var refractColor = new Vec3(0, 0, 0);
    var reflectColor = new Vec3(0, 0, 0);
    "REFRACT_REFLECT_ENTRY"
    var opaque = new Vec3(1, 1, 1);
    var transparency = new Vec3(0, 0, 0);
    "TRANSPARENCY"
    return new Vec4(Math.pow(new Vec3(emissiveColor.add(kdComplete.add(ksComplete)).add(refractColor).add(reflectColor)), new Vec3(1/2.2)), transparency.x());
}

}(exports));

},{}],199:[function(require,module,exports){
(function (ns) {

        ns.emissive = {
            getEmissive: function getEmissive(color){
                return color;
            }
        };

        ns.diffuse = {
            getDiffuse: function getDiffuse(L, V, color, N, roughness){
                // If a roughness is defined we use Oren Nayar brdf.
                var a, b, NdotV, thetaOut, phiOut, thetaIn;
                var cosPhiDiff, alpha, beta;
                var NdotL = Math.saturate(N.dot(L));

                // Lambertian reflection is constant over the hemisphere.
                var brdf = 1.0;

                if (roughness > 0) {
                    a = 1.0 - (roughness * roughness) / (2 * (roughness * roughness + 0.33));
                    b = 0.45 * (roughness * roughness) / (roughness * roughness + 0.09);
                    NdotV = N.dot(V);
                    thetaOut = Math.acos(NdotV);
                    phiOut = V.sub(N.mul(NdotV)).normalize();
                    thetaIn = Math.acos(NdotL);
                    cosPhiDiff = phiOut.dot(L.sub(N.mul(NdotL)).normalize());
                    alpha = Math.max(thetaOut, thetaIn);
                    beta = Math.min(thetaOut, thetaIn);
                    brdf = (a + b * Math.saturate(cosPhiDiff) * Math.sin(alpha) * Math.tan(beta));
                }
                brdf *= NdotL;
                return color.mul(brdf);
            },

            getAmbient: function getAmbient(ambientIntensity, color, N, roughness){
                return color.mul(ambientIntensity);
            }
        };

        ns.phong = {
            getSpecular: function getSpecular(L, V, color, N, shininess){
                var R = L.reflect(N).normalize();
                var eyeVector = V.flip();
                return color.mul(Math.pow(Math.max(R.dot(eyeVector),0.0), shininess*128.0));
            }
        };

        ns.cookTorrance = {
            getSpecular: function getSpecular(L, V, color, N, ior, roughness){
                var R0 = Math.pow((1 - ior) / (1 + ior), 2);
                var H = V.add(L).normalize(),
                    NdotH = N.dot(H),
                    NdotL = Math.saturate(N.dot(L)),
                    HdotN = H.dot(N),
                    HdotL = H.dot(L),
                    HdotV = H.dot(V),
                    NdotV = N.dot(V);

                // Beckmann distribution
                var alpha = Math.acos(NdotH),
                    numerator = Math.exp(-Math.pow(Math.tan(alpha) / roughness, 2)),
                    denominator = Math.pow(roughness, 2) * Math.pow(NdotH, 4),
                    d =  Math.max(0, numerator / denominator);

                // Geometric attenuation
                var G1 = 2 * HdotN * NdotV / HdotV,
                    G2 = 2 * HdotN * NdotL / HdotV,
                    g =  Math.min(1, Math.max(0, Math.min(G1, G2))),
                    f = Math.max(0, R0 + (1 - R0) * Math.pow(1 - NdotH, 5));

                var brdf = d * g * f / (Math.PI * NdotV);
                return color.mul(brdf);
            }
        };

        ns.ward = {
            getSpecular: function getSpecular(L, V, color, N, T, ax, ay){
                var H = L.add(V).normalize();
                var B = N.cross(T).normalize();
                var NdotV = Math.saturate(N.dot(V));
                var NdotL = Math.saturate(N.dot(L)) + 0.001;
                var NdotH = N.dot(H) + 0.001;
                var HdotT = H.dot(T);
                var HdotB = H.dot(B);

                var first = 1 / (4 * Math.PI * ax * ay * Math.sqrt(NdotL * NdotV));
                var beta = -(Math.pow(HdotT / ax, 2) + Math.pow(HdotB / ay, 2)) / (NdotH * NdotH);
                var second = Math.exp(beta);
                var brdf = Math.max(0, first * second) * NdotL;

                return color.mul(brdf);
            }
        };

        ns.scatter = {
            getSpecular: function getSpecular(L, V, color, N, wrap, scatterWidth){
                var NdotL = Math.saturate(N.dot(L));

                var NdotLWrap = (NdotL + wrap) / (1 + wrap);
                var scatter = Math.smoothstep(0.0, scatterWidth, NdotLWrap) * Math.smoothstep(scatterWidth * 2.0, scatterWidth, NdotLWrap);

                return color.mul(scatter);
            }
        };

        ns.reflect = {
            getReflect: function getReflect(position, N, factor) {
                N = this.viewInverseMatrix.mulVec(N, 0).xyz();
                var I = this.viewInverseMatrix.mulVec(position, 1.0).xyz().sub(this.cameraPosition).normalize();
                var reflection3D = I.reflect(N).normalize();
                var reflection2D = new Vec2((Math.atan2(-reflection3D.z(), reflection3D.x()) + Math.PI) / (2 * Math.PI), (Math.asin(reflection3D.y()) + Math.PI / 2.0) / Math.PI);
                return Math.pow(this.environment.sample2D(reflection2D).rgb(), new Vec3(2.2)).mul(factor);
            }
        };

        ns.refract = {
            getRefract: function getRefract(position, N, eta, factor) {
                N = this.viewInverseMatrix.mulVec(N, 0).xyz();
                var I = this.viewInverseMatrix.mulVec(position, 1.0).xyz().sub(this.cameraPosition).normalize();
                var refraction3D = I.refract(N, eta).normalize();
                var refraction2D = new Vec2((Math.atan2(-refraction3D.z(), refraction3D.x()) + Math.PI) / (2 * Math.PI), (Math.asin(refraction3D.y()) + Math.PI / 2.0) / Math.PI);
                return Math.pow(this.environment.sample2D(refraction2D).rgb(), new Vec3(2.2)).mul(factor);
            }
        };

        ns.transparent = {
            getTransparency: function getTransparency(position, alpha) {
                return new Vec3(alpha);
            }
        };

}(exports));

},{}],200:[function(require,module,exports){
/**
 * @enum {string}
 */
module.exports.TYPES = {
    ANY: "any",
    INT: "int",
    NUMBER: "number",
    BOOLEAN: "boolean",
    OBJECT: "object",
    ARRAY: "array",
    NULL: "null",
    UNDEFINED: "undefined",
    FUNCTION: "function",
    STRING: "string",
    INVALID: "invalid",
    REFERENCE: "reference"
};

},{}],201:[function(require,module,exports){
// Dependencies
var codegen = require('escodegen');

var ErrorHandler = {};

/**
 * @param node
 * @param {string} type
 * @param {...*} message
 * @returns {{message: string, loc: *}}
 */
ErrorHandler.generateErrorInformation = function (node, type, message) {
    var args = Array.prototype.slice.call(arguments).splice(2),
        loc = node.loc,
        codeInfo = "";

    codeInfo += codegen.generate(node);
    if (loc && loc.start.line) {
        codeInfo += " (Line " + loc.start.line + ")";
    }
    message = args.length ? args.join(" ") + ": " : "";
    return {message: type + ": " + message + codeInfo, loc: loc};
};

ErrorHandler.throwError = function(node, msg) {
    var loc = node && node.loc;
    if (loc && loc.start.line) {
        msg = "Line " + loc.start.line + ": " + msg;
    }
    msg += ": " + codegen.generate(node);

    var error = new Error(msg);
    error.loc = loc;
    throw error;
};

ErrorHandler.ERROR_TYPES = {
    TYPE_ERROR: "TypeError",
    REFERENCE_ERROR: "ReferenceError",
    NAN_ERROR: "NotANumberError",
    SHADEJS_ERROR: "ShadeJSError"
};

module.exports = ErrorHandler;


},{"escodegen":54}],202:[function(require,module,exports){
var assert = require("assert");

var TypeSystem = (function () {
    var registry = new Map();
    var result = {
        registerPredefinedObject: function (definition) {
			assert(definition.name, "Can't register object without name");
            registry.set(definition.name, definition);
        },

        getPredefinedObject: function (name) {
            var obj = registry.get(name);
            assert(obj, "Can't find object '" + name + "' in TypeSystem.");
            return obj;
        }
    };
    result.registerPredefinedObject(require("../analyze/typeinference/registry/math.js"));
	result.registerPredefinedObject(require("../analyze/typeinference/registry/vec2.js"));
	result.registerPredefinedObject(require("../analyze/typeinference/registry/vec3.js"));
	result.registerPredefinedObject(require("../analyze/typeinference/registry/vec4.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/mat3.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/mat4.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/system.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/space.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/object.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/shade.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/array.js"));
    result.registerPredefinedObject(require("../analyze/typeinference/registry/texture.js"));
    return result;
}());

module.exports = TypeSystem;

},{"../analyze/typeinference/registry/array.js":117,"../analyze/typeinference/registry/mat3.js":119,"../analyze/typeinference/registry/mat4.js":120,"../analyze/typeinference/registry/math.js":121,"../analyze/typeinference/registry/object.js":122,"../analyze/typeinference/registry/shade.js":123,"../analyze/typeinference/registry/space.js":124,"../analyze/typeinference/registry/system.js":125,"../analyze/typeinference/registry/texture.js":126,"../analyze/typeinference/registry/vec2.js":128,"../analyze/typeinference/registry/vec3.js":129,"../analyze/typeinference/registry/vec4.js":130,"assert":25}],203:[function(require,module,exports){
// External dependencies
var Syntax = require('estraverse').Syntax;
var Set = require('analyses').Set;
var extend = require("lodash.assign");
var clone = require("lodash.clone");
var assert = require('assert');
var TypeSystem = require('./type-system.js');

// Internal dependencies
var Shade = require("../interfaces.js"); // TODO(ksons): Eliminate this dependency
var TYPES = require("./constants.js").TYPES;

// TODO(ksons): New mechanism for predefined types
var KINDS = Shade.OBJECT_KINDS;

/**
 * @param {*} info Carrier object for the type info, only node.extra gets polluted
 * @constructor
 */
var TypeInfo = function (info) {
    this.info = info;
    var self = this;
    
    assert(info.type);

    Object.defineProperties(this, {
        type: {get: function() { return info.type }, set: function(e) { info.type = e; }},
        error: {get: function() { return info.error }, set: function(e) { info.error = e; }},
        ctor: {get: function() {
            if(!self.isFunction() || !self.getKind()) {
                throw new Error("Has no constructor:" + self);
            }
			var predefinedType = TypeSystem.getPredefinedObject(this.getKind());
			return predefinedType;
            }
        }
    });
};

TypeInfo.createForContext = function (node, ctx) {
    var result = new TypeInfo(node.extra);
    if (result.getType() !== TYPES.ANY) {
        return result;
    }

    if (node.type == Syntax.Identifier) {
        var name = node.name;
        var variable = ctx.getBindingByName(name);
        if (variable) {
            result.copy(variable);
        }
    }
    return result;
};

/**
 * @param {TypeInfo} typeInfo
 * @param {Object?} value
 */
TypeInfo.copyStaticValue = function (typeInfo, value) {
    value = value || typeInfo.getConstantValue();
    // We don't have to copy primitive types
    //if (!typeInfo.isObject())
        return value;
    //switch (typeInfo.getKind()) {
    //    case "Vec2":
    //        return new Shade.Vec2(value);
    //    case "Vec3":
    //        return new Shade.Vec3(value);
    //    case "Vec4":
    //        return new Shade.Vec4(value);
    //    case "Mat3":
    //        return new Shade.Mat3(value);
    //    case "Mat4":
    //        return new Shade.Mat4(value);
    //    default:
    //        throw new Error("Can't copy static value of kind: " + typeInfo.getKind());
    //}
};

TypeInfo.prototype = {
    getType: function () {
        return this.type;
    },

    setKind: function (kind) {
        this.info.kind = kind;
    },

    getKind: function () {
        if (this.isArray())
            return "Array";
        if (!(this.isObject() || this.isFunction()))
            return null;
        return this.info.kind || null;
    },

    getUserData: function () {
        var extra = this.info;
        if (!extra.userData) extra.userData = {};
        return extra.userData;
    },

    getArrayElementType: function () {
        if (!this.isArray())
            throw new Error("Called getArrayElementType on " + this.getType());
        return this.info.elements;
    },

    setArraySize: function (size) {
        if (!this.isArray())
            throw new Error("Called setArraySize on " + this.getType());
        assert(size >= 0);
        this.info.staticSize = size;
    },

    getArraySize: function () {
        if (!this.isArray())
            throw new Error("Called getArraySize on " + this.getType());
        return this.info.staticSize;
    },

    isOfKind: function (kind) {
        if (!this.isObject()) {
            return false;
        }
        return this.getKind() == kind;
    },

    /**
     * @param {string} type
     * @param {string?} kind
     */
    setType: function (type, kind) {
        var extra = this.info;
        extra.type = type;
        if (kind)
            this.setKind(kind);
        if (this.isValid())
            this.clearError();
    },
    setFunctionName: function (name) {
        this.info.functionName = name;
    },
    getFunctionName: function () {
        return this.info.functionName;
    },
    setInvalid: function (message) {
        this.setType(TYPES.INVALID);
        if (message)
            this.setError(message);
    },

    isOfType: function (type) {
        return this.getType() == type;
    },

    equals: function (other) {
        return this.getType() == other.getType() && this.getKind() == other.getKind();
    },

    isInt: function () {
        return this.isOfType(TYPES.INT);
    },
    isNumber: function () {
        return this.isOfType(TYPES.NUMBER);
    },
    isValid: function () {
        return !this.isOfType(TYPES.INVALID);
    },
    isNullOrUndefined: function () {
        return this.isNull() || this.isUndefined();
    },
    isNull: function () {
        return this.isOfType(TYPES.NULL);
    },
    isUndefined: function () {
        return this.isOfType(TYPES.UNDEFINED);
    },
    isBool: function () {
        return this.isOfType(TYPES.BOOLEAN);
    },
    isString: function () {
        return this.isOfType(TYPES.STRING);
    },
    isArray: function () {
        return this.isOfType(TYPES.ARRAY);
    },
    isFunction: function () {
        return this.isOfType(TYPES.FUNCTION);
    },
    isObject: function () {
        return this.isOfType(TYPES.OBJECT) || this.isOfType(TYPES.ARRAY);
    },
    isVector: function () {
        return this.isObject() && this.isOfKind("Vec2") || this.isOfKind("Vec3") || this.isOfKind("Vec4");
    },
    isTexture: function () {
        return this.isObject() && this.isOfKind("Texture")
    },
    isMatrix: function () {
        return this.isObject() && this.isOfKind("Mat2") || this.isOfKind("Mat3") || this.isOfKind("Mat4");
    },
    isGlobal: function () {
        return !!this.info.global;
    },
    setGlobal: function (global) {
        var extra = this.info;
        extra.global = global;
    },
    isOutput: function () {
        return !!this.info.output;
    },
    setOutput: function (output) {
        var extra = this.info;
        extra.output = output;
    },
    canNumber: function () {
        return this.isNumber() || this.isInt() || this.isBool();
    },
    canInt: function () {
        return this.isInt() || this.isBool();
    },
    canObject: function () {
        return this.isObject() || this.isArray() || this.isFunction();
    },
    setCommonType: function (a, b) {
        if (a.equals(b)) {
            this.copyFrom(a);
            return true;
        }
        if (a.canNumber() && b.canNumber()) {
            this.setType(TYPES.NUMBER);
            return true;
        }
        return false;
    },
    hasConstantValue: function () {
        var extra = this.info;
        if (this.isNullOrUndefined())
            return true;
        return extra.hasOwnProperty("constantValue");
    },
	getConstantValue: function () {
        if (!this.hasConstantValue()) {
            throw new Error("Node has no static value: " + this.node);
        }
        if (this.isNull())
            return null;
        if (this.isUndefined())
            return undefined;
        return this.info.constantValue;
    },
    setConstantValue: function (v) {
        var extra = this.info;
        if (this.isNullOrUndefined())
            throw new Error("Null and undefined have predefined values.");
        extra.constantValue = v;
    },
    canUniformExpression: function () {
        return this.hasConstantValue() || this.isUniformExpression();
    },

    isUniformExpression: function () {
        var extra = this.info;
        return extra.hasOwnProperty("uniformDependencies")
    },
    setUniformDependencies: function () {
        var extra = this.info;
        var dependencies = new Set();
        var args = Array.prototype.slice.call(arguments);
        args.forEach(function (arg) {
            if (Array.isArray(arg))
                dependencies = Set.union(dependencies, arg);
            else
                dependencies.add(arg);
        });
        extra.uniformDependencies = dependencies.values();
    },
    getUniformDependencies: function () {
        var extra = this.info;
        return extra.uniformDependencies || [];
    },
    getUniformCosts: function () {
        var extra = this.info;
        return extra.uniformCosts | 0;
    },
    setUniformCosts: function (costs) {
        var extra = this.info;
        extra.uniformCosts = costs;
    },
    clearUniformDependencies: function () {
        var extra = this.info;
        delete extra.uniformDependencies;
    },

    setDynamicValue: function () {
        delete this.info.constantValue;
    },
    setCall: function (call) {
        var extra = this.info;
        extra.evaluate = call;
    },
    getCall: function () {
        return this.info.evaluate;
    },
    clearCall: function () {
        var extra = this.info;
        delete extra.evaluate;
    },
    copyFrom: function (other) {
		assert(other instanceof TypeInfo);
        extend(this.info, other.info);
    },
    str: function () {
        var extra = this.info;
        return JSON.stringify(extra, null, 1);
    },
    canNormal: function () {
        return this.isObject() && (this.isOfKind(KINDS.NORMAL) || this.isOfKind(KINDS.VEC3));
    },
    canColor: function () {
        return this.isObject() && (this.isOfKind(KINDS.VEC4) || this.isOfKind(KINDS.VEC3));
    },
    hasError: function () {
        return this.getError() != null;
    },
    getError: function () {
        var extra = this.info;
        return extra.error;
    },
    setError: function (err) {
        var extra = this.info;
        extra.error = err;
    },
    clearError: function () {
        var extra = this.info;
        extra.error = null;
    },
    setFromExtra: function (extra) {
        extend(this.info, extra);
        // Set static object extra: This might be an object
        if (extra.constantValue != undefined) {
            this.setConstantValue(TypeInfo.copyStaticValue(this, extra.constantValue));
        }
    },

	hasProperty: function (name) {
        if (this.isObject() || this.isFunction()) {
             var obj;
             if(this.getKind()) {
                 obj = TypeSystem.getPredefinedObject(this.getKind());
             } else {
                obj = this.info;
             }
            return (obj.properties && obj.properties.hasOwnProperty(name)) || (obj.prototype && obj.prototype.hasOwnProperty(name));
        }
        return false;
    },


    isPredefinedObject: function() {
        return this.isObject() && this.getKind();
    },

    getPropertyInfo: function (name) {
        assert(this.hasProperty(name));
        if (this.isPredefinedObject()) { // Predefined object
            var predefinedType = TypeSystem.getPredefinedObject(this.getKind());
            var property = predefinedType.properties ? predefinedType.properties[name] : (predefinedType.prototype ? predefinedType.prototype[name] : null);
            if (property) {
                if (typeof property == "function") {
                    return new TypeInfo({type: "function", evaluate: property});
                }
                return new TypeInfo(property);
            }
        } else {
            return new TypeInfo(this.info.properties[name]);
        }
        return null;

    },
    setProperties: function(p) {
        assert(this.isObject());
        this.info.properties = p;
    },

    setProperty: function(name, p) {
        assert(this.isObject());
        this.info.properties[name] = p;
    },

    canEvaluate: function () {
        return this.isFunction() && typeof this.info.evaluate == "function";
    },

    evaluate: function (node, args, scope, objectReference) {
        assert(this.canEvaluate());
        return this.info.evaluate(node, args, scope, objectReference);
    },

    canComputeStaticValue: function () {
        return typeof this.info.computeStaticValue == "function";
    },

    computeStaticValue: function (typeInfo, args, scope, objectReference) {
        assert(this.canComputeStaticValue());
        return this.info.computeStaticValue(typeInfo, args, scope, objectReference);
    },

    getNodeInfo: function () {
        if (this.isObject())
            return this.info.info;
    },
    setNodeInfo: function (info) {
        if (!this.isObject())
            throw new Error("Only objects may have a node info");
        this.info.info = info;
    },
    getTypeString: function () {
        if (this.isObject()) {
            return this.isOfKind(KINDS.ANY) ? "Object" : ("Object #<" + this.getKind() + ">");
        }
        return this.getType();
    },
    /**
     * Get the internal type as JavaScript type
     * @returns {string}
     */
    getJavaScriptTypeString: function () {
        //noinspection FallthroughInSwitchStatementJS
        switch (this.getType()) {
            case TYPES.INT:
            case TYPES.FLOAT:
            case TYPES.NUMBER:
                return "number";
            case TYPES.OBJECT:
            case TYPES.ARRAY:
                return "object";
            case TYPES.STRING:
                return "string";
            case TYPES.UNDEFINED:
                return "undefined";
            case TYPES.FUNCTION:
                return "function";
            default:
                // TODO: For debug we use this now, should throw an exception
                return "?" + this.getType();
        }
    },
    setSource: function (source) {
        var extra = this.info;
        extra.source = source;
    },
    getSource: function () {
        return this.info.source;
    },

	isDerived: function () {
        return this.info.derived == true;
    },
    getStaticTruthValue: function () {
        // !!undefined == false;
        if (this.isNullOrUndefined())
            return false;
        // !!{} == true
        if (this.canObject())
            return true;
        // In all other cases, it depends on the value,
        // thus we can only evaluate this for static objects
        if (this.hasConstantValue()) {
            return !!this.getConstantValue();
        }
        return undefined;
    },
    setSemantic: function (sem) {
        this.info.semantic = sem;
    },
    getSemantic: function () {
        return this.info.semantic;
    },
	getReturnInfo: function () {
        return this.info.returnInfo;
    },
    setReturnInfo: function (info) {
        this.info.returnInfo = info;
    }

};


exports = module.exports = TypeInfo;

},{"../interfaces.js":188,"./constants.js":200,"./type-system.js":202,"analyses":46,"assert":25,"estraverse":61,"lodash.assign":81,"lodash.clone":82}],204:[function(require,module,exports){
"use strict";

var TypeInfo = require("../type-system/typeinfo.js");
var TYPES = require("../type-system/constants.js").TYPES;

exports = module.exports = function (node) {
    node.extra = node.extra || {type: TYPES.ANY};
    return new TypeInfo(node.extra);
};


},{"../type-system/constants.js":200,"../type-system/typeinfo.js":203}],205:[function(require,module,exports){
"use strict";

function Context(options) {
    options = options || {};

    this._scopeStack = [];
    this._reservedNames = options.reservedNames || [];
    this._usedNames = new Set();
}

Object.defineProperty(Context.prototype, "currentScope", {
    get: function () {
        return this._scopeStack[this._scopeStack.length - 1];
    }
});

Context.prototype.pushScope = function (scope) {
    this._scopeStack.push(scope);
};

Context.prototype.popScope = function () {
    return this._scopeStack.pop();
};

exports = module.exports = Context;

},{}],206:[function(require,module,exports){
"use strict";

exports.annotate = require("./annotate");
exports.Scope = require("./scope");
exports.throwError = require("./throw_error");
exports.toJavaScript = require("./to_javascript");
exports.Context = require("./context");
},{"./annotate":204,"./context":205,"./scope":207,"./throw_error":208,"./to_javascript":209}],207:[function(require,module,exports){
"use strict";

var assert = require("assert");
var Syntax = require("estraverse").Syntax;

// Internal dependencies
var ErrorHandler = require("./../type-system/errors.js");
var TypeInfo = require("./../type-system/typeinfo.js");
var TYPES = require("./../type-system/constants.js").TYPES;
var annotate = require("./annotate");


function Scope(node, parent, options) {
    options = options || {};
    options.name = options.name || node.id.name || "|anonymous|";

    if (parent)
        assert(parent instanceof Scope);

    this.parent = parent || null;
    this.scope = node.scope = node.scope || {};
    this.scope.capturedVariables = [];
    this.scope.name = options.name;
    this.scope.bindings = node.scope.bindings || {};
}

Object.defineProperties(Scope.prototype, {
    bindings: {
        get: function () {
            return this.scope.bindings;
        }
    },
    name: {
        get: function () {
            return this.scope.name;
        }
    },
    rootScope: {
        get: function () {
            if (this.parent)
                return parent.rootScope;
        }
    },
    returnInfo: {
        get: function () {
            return this.scope.returnInfo || {type: TYPES.UNDEFINED};
        },
        set: function (annotation) {
            this.scope.returnInfo = annotation.info;
        }
    }
});

Scope.prototype.declare = function(name, toremove, position) {
    this.bindings[name] =  {
        initialized: false,
        initPosition: position,
        extra: {
            type: TYPES.UNDEFINED
        }
    };
};

Scope.prototype.declarePredefined = function (name, descriptor) {
    assert(descriptor && descriptor.name);
    this.declare(name);
    this.updateTypeInfo(name, new TypeInfo({type: typeof descriptor, kind: descriptor.name }));
};

Scope.prototype.declareParameters = function (params) {
    var self = this;
    params.forEach(function (parameter) {
        self.declare(parameter.name);
        self.updateTypeInfo(parameter.name, new TypeInfo(parameter.extra));
    });
};

Scope.prototype.declares = function(name) {
    return this.bindings.hasOwnProperty(name);
};

Scope.prototype.get = function(name) {
    if(this.declares(name))
        return new TypeInfo(this.bindings[name].extra);

    if (this.parent) {
        var info = this.parent.get(name);
        if (info && !info.isFunction() && this.scope.capturedVariables.indexOf(name) === -1)
            this.scope.capturedVariables.push(name);
        return info;
    }

    return null;
};

Scope.prototype.type = function (node) {
    if (node.type === Syntax.Identifier && node.name !== "undefined") {
        assert(node.name);
        var definition = this.get(node.name);
        if(!definition) {
            ErrorHandler.throwError(node, ErrorHandler.ERROR_TYPES.REFERENCE_ERROR + ": " + node.name + " is not defined")
        }
        assert(definition instanceof TypeInfo);
        return definition;
    }

    if (node.type == Syntax.ThisExpression) {
        var definition = this.get("this");
        assert(definition instanceof TypeInfo);
        return definition;
    }

    return annotate(node);
};

Scope.prototype.updateTypeInfo = function (name, newTypeInfo, node) {
    if (!this.declares(name)) {
        if (node) {
            newTypeInfo.setInvalid(ErrorHandler.generateErrorInformation(node, ErrorHandler.ERROR_TYPES.REFERENCE_ERROR, name, "is not defined"));
            return;
        }
        throw new Error("Reference error: " + name + " is not defined.")
    }
    var v = this.bindings[name];
    var type = new TypeInfo(v.extra);

    if (v.initialized && type.getType() !== newTypeInfo.getType()) {
        if (node) {
            newTypeInfo.setInvalid(ErrorHandler.generateErrorInformation(node, ErrorHandler.ERROR_TYPES.SHADEJS_ERROR, name, "may not change it's type"));
            return;
        }
        throw new Error("Variable may not change it's type: " + name);
    }
    if (!v.initialized && v.initPosition) {
        // Annotate the declaration, if one is given
        annotate(v.initPosition).copyFrom(newTypeInfo);
        annotate(v.initPosition).setDynamicValue();
    }

    type.copyFrom(newTypeInfo);
    type.setDynamicValue();
    v.initialized = !type.isUndefined();
};

Scope.prototype.getScopeForName = function (name) {
    if (this.declares(name))
        return this;
    if (this.parent)
        return this.parent.getScopeForName(name);
    return null;
};

Scope.prototype.getIdentifier = function (name) {
    var scope = this.getScopeForName(name);
    if (!scope)
        return null;
    return scope.toString() + "." + name;
};

Scope.prototype.toString = function () {
    var ctx = this;
    var names = [];
    while (ctx) {
        names.unshift(ctx.name);
        ctx = ctx.parent;
    }
    return names.join(".");
};

exports = module.exports = Scope;

},{"./../type-system/constants.js":200,"./../type-system/errors.js":201,"./../type-system/typeinfo.js":203,"./annotate":204,"assert":25,"estraverse":61}],208:[function(require,module,exports){
"use strict";

var toJavaScript = require("./to_javascript");

exports = module.exports = function(node, msg) {
    var loc = node && node.loc;
    if (loc && loc.start.line)
        msg = "Line " + loc.start.line + ": " + msg;

    msg += ": " + toJavaScript(node);

    var error = new Error(msg);
    error.loc = loc;
    throw error;
};

},{"./to_javascript":209}],209:[function(require,module,exports){
"use strict";

var CodeGenerator = require("escodegen");

exports = module.exports = function (node) {
    return CodeGenerator.generate(node);
};
},{"escodegen":54}]},{},[43])(43)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvYW5hbHlzaXMvY2ZnX3V0aWxzLmpzIiwibGliL2FuYWx5c2lzL2NvbXB1dGVfZ3JhcGguanMiLCJsaWIvYW5hbHlzaXMvY29tcHV0ZV9ub2RlLmpzIiwibGliL2FuYWx5c2lzL2RldGVybWluZV9jb21wdXRlX2dyYXBoLmpzIiwibGliL2FuYWx5c2lzL2RldGVybWluZV9ub2RlX2lucHV0cy5qcyIsImxpYi9hbmFseXNpcy93b3JrbGlzdC5qcyIsImxpYi9jb21waWxlci9pbmRleC5qcyIsImxpYi9leGVjdXRpb24vY29tcHV0ZV9yZXF1ZXN0LmpzIiwibGliL2V4ZWN1dGlvbi9wcm9ncmFtLmpzIiwibGliL2V4ZWN1dGlvbi9ydW5uZXIuanMiLCJsaWIvZmllbGQvYnVmZmVyX2FjY2Vzc29yLmpzIiwibGliL2ZpZWxkL3R5cGVzLmpzIiwibGliL2dyYXBoL25vZGUuanMiLCJsaWIvZ3JhcGgvbm9kZV9jb2xsZWN0aW9uLmpzIiwibGliL29wZXJhdG9yL2ZpbHRlci5qcyIsImxpYi9vcGVyYXRvci9vcGVyYXRvci5qcyIsImxpYi9vcGVyYXRvci9yZW5hbWUuanMiLCJsaWIvcGxhdGZvcm0vY3B1LmpzIiwibGliL3BsYXRmb3JtL2RlYnVnLmpzIiwibGliL3V0aWwvYnVpbGRfc2hhZGVfb3B0aW9ucy5qcyIsImxpYi91dGlsL2Rpc3Bvc2VfaWZfbm9fbGlzdGVuZXIuanMiLCJsaWIvdXRpbC90b19maWVsZF9kZXNjcmlwdG9yLmpzIiwibGliL3V0aWwvdG9fc2hhZGVfdHlwZS5qcyIsImxpYi91dGlsL3RvX3NoYWRlX3ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIuLi8uLi9zaGFkZWpzL2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9hbmFseXNlcy9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2FuYWx5c2VzL2xpYi9leGFtcGxlcy9hdmFpbGFibGVleHByZXNzaW9ucy5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2FuYWx5c2VzL2xpYi9leGFtcGxlcy9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2FuYWx5c2VzL2xpYi9leGFtcGxlcy9saXZldmFyaWFibGVzLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvYW5hbHlzZXMvbGliL2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvYW5hbHlzZXMvbGliL3F1ZXVlLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvYW5hbHlzZXMvbGliL3NldC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2RlZXAtZXh0ZW5kL2xpYi9kZWVwLWV4dGVuZC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9lc2NvZGVnZW4uanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL2VzdHJhdmVyc2UvZXN0cmF2ZXJzZS5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9wYWNrYWdlLmpzb24iLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2dyYXBoL2xpYi9kb3QuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2dyYXBoL2xpYi9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzZ3JhcGgvbm9kZV9tb2R1bGVzL3dhbGtlcy9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzcHJpbWEvZXNwcmltYS5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzdHJhdmVyc2UvZXN0cmF2ZXJzZS5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzdHJhdmVyc2UvcGFja2FnZS5qc29uIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIvYXN0LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIvY29kZS5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2tleXdvcmQuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi91dGlscy5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0Mi5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvbG9kYXNoLl9hcnJheWVhY2gvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2Vmb3IvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9sb2Rhc2guX21hcGNhY2hlL2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvbG9kYXNoLl9zdGFjay9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xvbmUvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL2xvZGFzaC5yZXN0L2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYXJyYXktc2V0LmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQtdmxxLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2JpbmFyeS1zZWFyY2guanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL21hcHBpbmctbGlzdC5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIi4uLy4uL3NoYWRlanMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCIuLi8uLi9zaGFkZWpzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC91dGlsLmpzIiwiLi4vLi4vc2hhZGVqcy9ub2RlX21vZHVsZXMvd2Fsa2VzL2xpYi9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvYW5hbHl6ZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL2NvbnN0YW50cy9ldmFsdWF0b3IuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL2NvbnN0YW50cy9zdGF0aWNUcmFuc2Zvcm1lci5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvY29udGV4dC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvY3JlYXRlX2dsb2JhbF9zY29wZS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvZGV0ZXJtaW5lX3JldHVybl90eXBlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9leHRyYWN0X2FsbG9jYXRpb25zLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9leHRyYWN0X2Z1bmN0aW9uX3RlbXBsYXRlcy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvZXh0cmFjdF9wYXJhbWV0ZXJzLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvaW5zZXJ0X2J1ZmZlcl9hY2Nlc3NvcnMuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3JlcXVpcmUvcmVzb2x2ZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3Nhbml0aXplci9kZWNsYXJhdGlvbl9zaW1wbGlmaWVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9zYW5pdGl6ZXIvcmVkdW5kYW50X2Jsb2Nrc19yZW1vdmVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9zYW5pdGl6ZXIvc2FuaXRpemVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9zYW5pdGl6ZXIvc3RhdGVtZW50X3NpbXBsaWZpZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3Nhbml0aXplci9zdGF0ZW1lbnRfc3BsaXRfdHJhdmVyc2VyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS9zbGljZXIvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3NwYWNlX2FuYWx5emVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL2luZmVyX2V4cHJlc3Npb24uanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvYXJyYXkuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvbWF0My5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9tYXQ0LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L21hdGguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvb2JqZWN0LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3NoYWRlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3NwYWNlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3N5c3RlbS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS90ZXh0dXJlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3Rvb2xzLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3ZlYzIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvdmVjMy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS92ZWM0LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3ZlY190b29scy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS90eXBlaW5mZXJlbmNlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvZXZhbHVhdG9yLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvdW5pZm9ybUFuYWx5c2lzLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvdW5pZm9ybVNldHRlclRyYW5zZm9ybWF0aW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvdW5pZm9ybVRyYW5zZm9ybWVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYW5hbHl6ZS91dGlscy9hc3QuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9hbmFseXplL3V0aWxzL2RvbWluYW5jZS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2FuYWx5emUvdmFsaWRhdGlvbi9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2Jhc2UvY29tbW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYmFzZS9jb250ZXh0LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYmFzZS9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2Jhc2UvdmVjLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvYmFzZS92ZWNtYXRoLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvYmFzZS9leHByZXNzaW9uLWhhbmRsZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9hc3RfdXRpbHMuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9jb21waWxlci5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2Zhc3RsYW5lL2NvbnN0YW50cy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2Zhc3RsYW5lL2RldGVybWluZV9sb2dpY2FsX2VsZW1lbnRfc2l6ZS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2Zhc3RsYW5lL21hdGguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9ub3JtYWxpemVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZmFzdGxhbmUvb3B0aW1pemVyL2NvbnN0YW50X3Byb3BhZ2F0aW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZmFzdGxhbmUvb3B0aW1pemVyL2lubGluZV9pbnRlcm5hbF9mdW5jdGlvbnMuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9vcHRpbWl6ZXIvd29ya2xpc3QuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9zYW5pdGl6ZXIvYXJyYXlfYWNjZXNzX3N3aXp6bGUuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9zYW5pdGl6ZXIvYXNzaWdubWVudF9leHByZXNzaW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZmFzdGxhbmUvc2FuaXRpemVyL2JpbmFyeV9leHByZXNzaW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZmFzdGxhbmUvc2FuaXRpemVyL2Jsb2NrX3dyYXBwZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9zYW5pdGl6ZXIvY2FsbF9leHByZXNzaW9uLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZmFzdGxhbmUvc2FuaXRpemVyL2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZmFzdGxhbmUvc2ltZF9tYXJrZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS9zaW1wbGlmeS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2Zhc3RsYW5lL3RleHR1cmUuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9mYXN0bGFuZS92ZWN0b3JpemVyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9jb21waWxlci5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsc2wvZ2xzbC1nZW5lcmF0ZS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsc2wvcmVnaXN0cnkvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L21hdDMuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L21hdDQuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L21hdGguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L3NoYWRlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS9zcGFjZS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsc2wvcmVnaXN0cnkvc3lzdGVtLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS90ZXh0dXJlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS92ZWMyLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS92ZWMzLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS92ZWM0LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC90cmFuc2Zvcm0uanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9zbmlwcGV0cy9zbmlwcGV0LWxpc3QuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9zcGFjZS9zcGFjZS10cmFuc2Zvcm0tdG9vbHMuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9zcGFjZS90cmFuc2Zvcm0uanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9nZW5lcmF0ZS90b29scy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvaW50ZXJmYWNlL21hdGguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9pbnRlcmZhY2UvbWF0cml4LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvaW50ZXJmYWNlL3V0aWxzLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvaW50ZXJmYWNlL3ZlY3Rvci5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL2ludGVyZmFjZXMuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9wbHVnaW5fcmVnaXN0cnkuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9yZXNvbHZlL2NvbG9yY2xvc3VyZS1tYXJrZXIuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9yZXNvbHZlL2NvbG9yY2xvc3VyZS1yZXBsYWNlci5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL3Jlc29sdmUvY29sb3JjbG9zdXJlLXRvb2xzLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvcmVzb2x2ZS9yZXNvbHZlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWRlZmVycmVkL2NvbG9yLWNsb3N1cmUtc2lnbmF0dXJlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWRlZmVycmVkL2luZGV4LmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWRlZmVycmVkL3htbDNkLWRlZmVycmVkLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWZvcndhcmQvaW5kZXguanMiLCIuLi8uLi9zaGFkZWpzL3NyYy9yZXNvbHZlL3htbDNkLWdsc2wtZm9yd2FyZC9saWdodC1sb29wLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWZvcndhcmQveG1sM2QtZm9yd2FyZC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL3R5cGUtc3lzdGVtL2NvbnN0YW50cy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL3R5cGUtc3lzdGVtL2Vycm9ycy5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL3R5cGUtc3lzdGVtL3R5cGUtc3lzdGVtLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvdHlwZS1zeXN0ZW0vdHlwZWluZm8uanMiLCIuLi8uLi9zaGFkZWpzL3NyYy91dGlscy9hbm5vdGF0ZS5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL3V0aWxzL2NvbnRleHQuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy91dGlscy9pbmRleC5qcyIsIi4uLy4uL3NoYWRlanMvc3JjL3V0aWxzL3Njb3BlLmpzIiwiLi4vLi4vc2hhZGVqcy9zcmMvdXRpbHMvdGhyb3dfZXJyb3IuanMiLCIuLi8uLi9zaGFkZWpzL3NyYy91dGlscy90b19qYXZhc2NyaXB0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaDdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxa0JBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3U0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOS9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzMwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ253Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ptQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Y0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcblxuY2xhc3MgQ0ZHTm9kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IFtdO1xuICAgICAgICB0aGlzLnByZXYgPSBbXTtcbiAgICB9XG59XG5jbGFzcyBFbnRyeU5vZGUgZXh0ZW5kcyBDRkdOb2RlIHt9XG5jbGFzcyBFeGl0Tm9kZSBleHRlbmRzIENGR05vZGUge31cblxuZnVuY3Rpb24gd3JhcChub2RlKSB7XG4gICAgY29uc3QgZXhpc3RpbmdFeGl0Tm9kZSA9IGZpbmRFeGl0Tm9kZShub2RlKTtcbiAgICBjb25zdCBleGl0aW5nRW50cnlOb2RlID0gZmluZEVudHJ5Tm9kZShub2RlKTtcbiAgICBpZiAoZXhpc3RpbmdFeGl0Tm9kZSkge1xuICAgICAgICBpZiAoIWV4aXRpbmdFbnRyeU5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBleGl0IG5vZGUgYnV0IG5vIGVudHJ5IG5vZGUhXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50cnlOb2RlOiBleGl0aW5nRW50cnlOb2RlLFxuICAgICAgICAgICAgZXhpdE5vZGU6IGV4aXN0aW5nRXhpdE5vZGUsXG4gICAgICAgICAgICB3YXNBbHJlYWR5V3JhcHBlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBleGl0Tm9kZSA9IG5ldyBFeGl0Tm9kZSgpO1xuICAgIG5vZGUubmV4dC5wdXNoKGV4aXROb2RlKTtcbiAgICBleGl0Tm9kZS5wcmV2LnB1c2gobm9kZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRyeU5vZGU6IGFkZEVudHJ5Tm9kZShleGl0Tm9kZSksXG4gICAgICAgIGV4aXROb2RlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwKHtlbnRyeU5vZGUsIGV4aXROb2RlLCB3YXNBbHJlYWR5V3JhcHBlZH0pIHtcbiAgICBpZiAod2FzQWxyZWFkeVdyYXBwZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBlbnRyeU5vZGUubmV4dC5mb3JFYWNoKG5leHQgPT4gbmV4dC5wcmV2LnBvcCgpKTtcbiAgICBleGl0Tm9kZS5wcmV2LmZvckVhY2gocHJldiA9PiBwcmV2Lm5leHQucG9wKCkpO1xufVxuXG5leHBvcnRzLndyYXAgPSB3cmFwO1xuZXhwb3J0cy51bndyYXAgPSB1bndyYXA7XG5leHBvcnRzLkVudHJ5Tm9kZSA9IEVudHJ5Tm9kZTtcbmV4cG9ydHMuRXhpdE5vZGUgPSBFeGl0Tm9kZTtcblxuZnVuY3Rpb24gYWRkRW50cnlOb2RlKG5vZGUsIGVudHJ5Tm9kZSA9IG5ldyBFbnRyeU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVZpc2l0ZWQgPSBuZXcgU2V0KCkpIHtcbiAgICBpZiAoYWxyZWFkeVZpc2l0ZWQuaGFzKG5vZGUpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBhbHJlYWR5VmlzaXRlZC5hZGQobm9kZSk7XG4gICAgY29uc3QgcHJldiA9IG5vZGUucHJldi5maWx0ZXIocHJldiA9PiAhYWxyZWFkeVZpc2l0ZWQuaGFzKHByZXYpKTtcblxuICAgIGlmIChwcmV2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbnRyeU5vZGUubmV4dC5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlLnByZXYucHVzaChlbnRyeU5vZGUpO1xuICAgIH1cblxuICAgIHByZXYuZm9yRWFjaChwcmV2ID0+IGFkZEVudHJ5Tm9kZShwcmV2LCBlbnRyeU5vZGUsIGFscmVhZHlWaXNpdGVkKSk7XG4gICAgcmV0dXJuIGVudHJ5Tm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZEVudHJ5Tm9kZShub2RlKSB7XG4gICAgY29uc3QgYWxyZWFkeVZpc2l0ZWQgPSBuZXcgU2V0KCk7XG5cbiAgICBjb25zdCBxdWV1ZSA9IFtub2RlXTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVudHJ5Tm9kZSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBhbHJlYWR5VmlzaXRlZC5hZGQobm9kZSk7XG4gICAgICAgIHF1ZXVlLnB1c2goLi4ubm9kZS5wcmV2LmZpbHRlcihwcmV2ID0+ICFhbHJlYWR5VmlzaXRlZC5oYXMocHJldikpKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZmluZEV4aXROb2RlKG5vZGUpIHtcbiAgICBjb25zdCBhbHJlYWR5VmlzaXRlZCA9IG5ldyBTZXQoKTtcblxuICAgIGNvbnN0IHF1ZXVlID0gW25vZGVdO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRXhpdE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgYWxyZWFkeVZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICBxdWV1ZS5wdXNoKC4uLm5vZGUubmV4dC5maWx0ZXIobmV4dCA9PiAhYWxyZWFkeVZpc2l0ZWQuaGFzKG5leHQpKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyO1xuXG5jb25zdCBDb21wdXRlTm9kZSA9IHJlcXVpcmUoXCIuL2NvbXB1dGVfbm9kZVwiKTtcblxuY2xhc3MgQ29tcHV0ZUdyYXBoIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyeU5vZGUsIGV4aXROb2RlLCBub2RlTWFwKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5fZW50cnlOb2RlID0gZW50cnlOb2RlO1xuICAgICAgICB0aGlzLl9leGl0Tm9kZSA9IGV4aXROb2RlO1xuICAgICAgICB0aGlzLl9jb21wdXRlTm9kZU1hcCA9IG5vZGVNYXA7XG5cbiAgICAgICAgdGhpcy5fYnVmZmVyTm9kZURlcGVuZGVuY2llcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyRmVlZGJhY2tJbml0aWFsSW5wdXREZXBlbmRlbmNpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FsbG9jYXRpb25EZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgY2hhbmdlZEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fb25WYWx1ZUNoYW5nZSA9IGJ1ZmZlciA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlVGltZXJzLmhhcyhidWZmZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVycy5zZXQoYnVmZmVyLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVCdWZmZXJWYWx1ZUNoYW5nZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVycy5kZWxldGUoYnVmZmVyKTtcbiAgICAgICAgICAgIH0sIDApKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kZXRlcm1pbmVCdWZmZXJOb2RlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgIHRoaXMuX2RldGVybWluZUJ1ZmZlckluaXRpYWxGZWVkYmFja0lucHV0RGVwZW5kZW5jaWVzKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaFZhbHVlQ2hhbmdlZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9kZXRlcm1pbmVBbGxvY2F0aW9uUmVsZXZhbnRCdWZmZXJzKCk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fZGV0YWNoVmFsdWVDaGFuZ2VkTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuYWxsTm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUucGxhdGZvcm0uZGlzcG9zZU5vZGUgPyBub2RlLnBsYXRmb3JtLmRpc3Bvc2VOb2RlKG5vZGUpIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBnZXQgZW50cnlOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW50cnlOb2RlO1xuICAgIH1cblxuICAgIGdldCBleGl0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4aXROb2RlO1xuICAgIH1cblxuICAgIGdldCBhbGxOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoWy4uLnRoaXMuX2NvbXB1dGVOb2RlTWFwLnZhbHVlcygpXSk7XG4gICAgfVxuXG4gICAgZ2V0Q29tcHV0ZU5vZGVGb3JOb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXB1dGVOb2RlTWFwLmdldChub2RlKTtcbiAgICB9XG5cbiAgICBfZGV0ZXJtaW5lQnVmZmVyTm9kZURlcGVuZGVuY2llcyhub2RlID0gdGhpcy5fZW50cnlOb2RlLCBwYXJlbnREZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCkpIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBub2RlLmlucHV0cy5mb3JFYWNoKGlucHV0UXVldWUgPT4ge1xuICAgICAgICAgICAgaWYgKGlucHV0UXVldWUuaW5pdGlhbC5jb21wdXRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZEJ1ZmZlck5vZGVEZXBlbmRlbmN5KG5vZGUsIGlucHV0UXVldWUuaW5pdGlhbCk7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGlucHV0UXVldWUuaW5pdGlhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnREZXBlbmRlbmNpZXMuZm9yRWFjaChpbnB1dERlZmluaXRpb24gPT4gdGhpcy5fYWRkQnVmZmVyTm9kZURlcGVuZGVuY3kobm9kZSwgaW5wdXREZWZpbml0aW9uKSk7XG4gICAgICAgIG5vZGUubmV4dC5mb3JFYWNoKG5leHQgPT4gdGhpcy5fZGV0ZXJtaW5lQnVmZmVyTm9kZURlcGVuZGVuY2llcyhuZXh0LCBuZXcgU2V0KFsuLi5kZXBlbmRlbmNpZXMsIC4uLnBhcmVudERlcGVuZGVuY2llc10pKSk7XG4gICAgfVxuXG4gICAgX2FkZEJ1ZmZlck5vZGVEZXBlbmRlbmN5KG5vZGUsIGlucHV0RGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBpbnB1dERlZmluaXRpb24uYnVmZmVyO1xuICAgICAgICBpZiAoIXRoaXMuX2J1ZmZlck5vZGVEZXBlbmRlbmNpZXMuaGFzKGJ1ZmZlcikpXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJOb2RlRGVwZW5kZW5jaWVzLnNldChidWZmZXIsIG5ldyBTZXQoKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlck5vZGVEZXBlbmRlbmNpZXMuZ2V0KGJ1ZmZlcikuYWRkKG5vZGUpO1xuICAgIH1cblxuICAgIF9kZXRlcm1pbmVCdWZmZXJJbml0aWFsRmVlZGJhY2tJbnB1dERlcGVuZGVuY2llcyhub2RlID0gdGhpcy5fZW50cnlOb2RlKSB7XG4gICAgICAgIG5vZGUuaW5wdXRzLmZvckVhY2goaW5wdXRRdWV1ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0UXVldWUuaGFzRmVlZGJhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW5wdXQgPSBpbnB1dFF1ZXVlLmluaXRpYWw7XG4gICAgICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSAgaW5pdGlhbElucHV0LmNvbXB1dGVkID8gdGhpcy5fZGV0ZXJtaW5lQnVmZmVyRGVwZW5kZW5jaWVzKGluaXRpYWxJbnB1dC5zb3VyY2UpIDogbmV3IFNldChbaW5pdGlhbElucHV0LmJ1ZmZlcl0pO1xuXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaChidWZmZXIgID0+IHRoaXMuX2FkZEJ1ZmZlckluaXRpYWxGZWVkYmFja0lucHV0RGVwZW5kZW5jaWVzKGlucHV0UXVldWUsIGJ1ZmZlcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5uZXh0LmZvckVhY2gobmV4dCA9PiB0aGlzLl9kZXRlcm1pbmVCdWZmZXJJbml0aWFsRmVlZGJhY2tJbnB1dERlcGVuZGVuY2llcyhuZXh0KSk7XG4gICAgfVxuXG4gICAgX2RldGVybWluZUJ1ZmZlckRlcGVuZGVuY2llcyhjb21wdXRlTm9kZSkge1xuICAgICAgICBjb25zdCBidWZmZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9idWZmZXJOb2RlRGVwZW5kZW5jaWVzLmZvckVhY2goKG5vZGVzLCBidWZmZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5oYXMoY29tcHV0ZU5vZGUpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuYWRkKGJ1ZmZlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVmZmVycztcbiAgICB9XG5cbiAgICBfYWRkQnVmZmVySW5pdGlhbEZlZWRiYWNrSW5wdXREZXBlbmRlbmNpZXMoaW5wdXRRdWV1ZSwgYnVmZmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYnVmZmVyRmVlZGJhY2tJbml0aWFsSW5wdXREZXBlbmRlbmNpZXMuaGFzKGJ1ZmZlcikpXG4gICAgICAgICAgICB0aGlzLl9idWZmZXJGZWVkYmFja0luaXRpYWxJbnB1dERlcGVuZGVuY2llcy5zZXQoYnVmZmVyLCBuZXcgU2V0KCkpO1xuICAgICAgICB0aGlzLl9idWZmZXJGZWVkYmFja0luaXRpYWxJbnB1dERlcGVuZGVuY2llcy5nZXQoYnVmZmVyKS5hZGQoaW5wdXRRdWV1ZSk7XG4gICAgfVxuXG4gICAgX2RldGVybWluZUFsbG9jYXRpb25SZWxldmFudEJ1ZmZlcnMobm9kZSA9IHRoaXMuX2VudHJ5Tm9kZSkge1xuICAgICAgICBub2RlLmFsbG9jYXRpb25EZXBlbmRlbmNpZXMuZm9yRWFjaChhbGxvY2F0aW9uRGVwZW5kZW5jeSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hbGxvY2F0aW9uRGVwZW5kZW5jaWVzLmFkZChhbGxvY2F0aW9uRGVwZW5kZW5jeSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLm5leHQuZm9yRWFjaChuZXh0ID0+IHRoaXMuX2RldGVybWluZUFsbG9jYXRpb25SZWxldmFudEJ1ZmZlcnMobmV4dCkpO1xuICAgIH1cblxuICAgIF9hdHRhY2hWYWx1ZUNoYW5nZWRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlck5vZGVEZXBlbmRlbmNpZXMuZm9yRWFjaCgoXywgYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBidWZmZXIub24oXCJjaGFuZ2VcIiwgdGhpcy5fb25WYWx1ZUNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9oYW5kbGVCdWZmZXJWYWx1ZUNoYW5nZShidWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FsbG9jYXRpb25EZXBlbmRlbmNpZXMuaGFzKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInR5cGUtY2hhbmdlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLl9idWZmZXJOb2RlRGVwZW5kZW5jaWVzLmdldChidWZmZXIpO1xuICAgICAgICBpZiAobm9kZXMpXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS5kaXJ0eSA9IHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGlucHV0UXVldWVzID0gdGhpcy5fYnVmZmVyRmVlZGJhY2tJbml0aWFsSW5wdXREZXBlbmRlbmNpZXMuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmIChpbnB1dFF1ZXVlcylcbiAgICAgICAgICAgIGlucHV0UXVldWVzLmZvckVhY2gocXVldWUgPT4gcXVldWUucmVzZXQoKSk7XG5cbiAgICAgICAgY29uc3QgY2hhbmdlZE91dHB1dHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2V4aXROb2RlLmlucHV0cy5mb3JFYWNoKChvdXRwdXQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghb3V0cHV0LmNvbXB1dGVkKVxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuY3VycmVudC5idWZmZXIgPT09IGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZE91dHB1dHMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVzLmhhcyhvdXRwdXQuY3VycmVudC5zb3VyY2UpKVxuICAgICAgICAgICAgICAgIGNoYW5nZWRPdXRwdXRzLmFkZChuYW1lKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVtaXQoXCJ2YWx1ZS1jaGFuZ2VcIiwgY2hhbmdlZE91dHB1dHMpO1xuICAgIH1cblxuICAgIF9kZXRhY2hWYWx1ZUNoYW5nZWRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlck5vZGVEZXBlbmRlbmNpZXMuZm9yRWFjaCgoXywgYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBidWZmZXIucmVtb3ZlTGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5fb25WYWx1ZUNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29tcHV0ZUdyYXBoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNsYXNzIENvbXB1dGVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcGVyYXRvcikge1xuICAgICAgICB0aGlzLnByZXYgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG5cbiAgICAgICAgdGhpcy5pbnB1dHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmFsbG9jYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFsbG9jYXRpb25EZXBlbmRlbmNpZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLm1lbW9yeSA9IHt9O1xuICAgICAgICB0aGlzLmVudiA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmV2YWx1YXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29tcHV0ZU5vZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuY29uc3QgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbmNvbnN0IHdvcmtsaXN0ID0gcmVxdWlyZShcIi4vd29ya2xpc3RcIik7XG5jb25zdCBjZmdVdGlscyA9IHJlcXVpcmUoXCIuL2NmZ191dGlsc1wiKTtcbmNvbnN0IENvbXB1dGVHcmFwaCA9IHJlcXVpcmUoXCIuL2NvbXB1dGVfZ3JhcGhcIik7XG5jb25zdCBDb21wdXRlTm9kZSA9IHJlcXVpcmUoXCIuL2NvbXB1dGVfbm9kZVwiKTtcbmNvbnN0IHRvU2hhZGVWYWx1ZSA9IHJlcXVpcmUoXCIuLi91dGlsL3RvX3NoYWRlX3ZhbHVlXCIpO1xuY29uc3QgdG9GaWVsZERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vdXRpbC90b19maWVsZF9kZXNjcmlwdG9yXCIpO1xuXG5jbGFzcyBFbnRyeU5vZGUgZXh0ZW5kcyBDb21wdXRlTm9kZSB7fVxuY2xhc3MgRXhpdE5vZGUgZXh0ZW5kcyBDb21wdXRlTm9kZSB7fVxuXG5jbGFzcyBJbnB1dFF1ZXVlIHtcblx0Y29uc3RydWN0b3IoZGVmaW5pdGlvbikge1xuXHRcdHRoaXMuX2luaXRpYWwgPSBkZWZpbml0aW9uO1xuXHRcdHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9pbml0aWFsO1xuXHR9XG5cblx0Z2V0IGhhc0ZlZWRiYWNrKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2luaXRpYWwuZmVlZGJhY2s7XG5cdH1cblxuXHRnZXQgaW5pdGlhbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbDtcblx0fVxuXG5cdGdldCBjdXJyZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50O1xuXHR9XG5cblx0bmV4dCgpIHtcblx0XHRjb25zdCBuZXh0ID0gdGhpcy5fY3VycmVudDtcblx0XHRpZiAodGhpcy5fY3VycmVudC5mZWVkYmFjaylcblx0XHRcdHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50LmZlZWRiYWNrO1xuXG5cdFx0cmV0dXJuIG5leHQ7XG5cdH1cblxuXHRyZXNldCgpIHtcblx0XHR0aGlzLl9jdXJyZW50ID0gdGhpcy5faW5pdGlhbDtcblx0fVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVDb21wdXRlR3JhcGgocmVxdWVzdGVkRmllbGROYW1lcywgbm9kZSkge1xuXHRjb25zdCBub2RlT3V0cHV0cyA9IG5vZGUuZGV0ZXJtaW5lT3V0cHV0cygpO1xuXHRjb25zdCBleGlzdGluZ1JlcXVlc3RlZEZpZWxkcyA9IHJlcXVlc3RlZEZpZWxkTmFtZXNbMF0gIT09IFwiKlwiID8gbmV3IE1hcChyZXF1ZXN0ZWRGaWVsZE5hbWVzLmZpbHRlcihuYW1lID0+IG5vZGVPdXRwdXRzLmhhcyhuYW1lKSkubWFwKG5hbWUgPT4gW25hbWUsIG5vZGVPdXRwdXRzLmdldChuYW1lKV0pKSA6IG5vZGVPdXRwdXRzO1xuXHRyZXR1cm4gYnVpbGRDb21wdXRlR3JhcGgoZXhpc3RpbmdSZXF1ZXN0ZWRGaWVsZHMpO1xufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmVDb21wdXRlR3JhcGg7XG5cblxuZnVuY3Rpb24gYnVpbGRDb21wdXRlR3JhcGgocmVxdWVzdGVkRmllbGRzKSB7XG5cdGNvbnN0IGVudHJ5Tm9kZSA9IG5ldyBFbnRyeU5vZGUoKTtcblx0Y29uc3QgZXhpdE5vZGUgPSBuZXcgRXhpdE5vZGUoKTtcblxuXHRjb25zdCBjb21wdXRlTm9kZU1hcCA9IG5ldyBNYXAoKTtcblx0ZnVuY3Rpb24gYnVpbGRDb21wdXRlTm9kZShub2RlKSB7XG5cdFx0aWYgKGNvbXB1dGVOb2RlTWFwLmhhcyhub2RlKSlcblx0XHRcdHJldHVybiBjb21wdXRlTm9kZU1hcC5nZXQobm9kZSk7XG5cblx0XHRjb25zdCBjb21wdXRlTm9kZSA9IG5ldyBDb21wdXRlTm9kZShub2RlLm9wZXJhdG9yKTtcblx0XHRjb21wdXRlTm9kZS5uYW1lID0gbm9kZS5vcGVyYXRvci5uYW1lO1xuXHRcdGNvbXB1dGVOb2RlTWFwLnNldChub2RlLCBjb21wdXRlTm9kZSk7XG5cblx0XHRub2RlLnByZXYuZm9yRWFjaChwcmV2ID0+IHtcblx0XHRcdGJ1aWxkQ29tcHV0ZU5vZGUocHJldik7XG5cdFx0fSk7XG5cblx0XHRjb25zdCB1c2VkSW5wdXRzID0gbm9kZS5kZXRlcm1pbmVVc2VkSW5wdXRzKCk7XG5cdFx0dXNlZElucHV0cy5mb3JFYWNoKChmaWVsZCwgbmFtZSk9PiB7XG5cdFx0XHRpZiAoZmllbGQuY29tcHV0ZWQpIHtcblx0XHRcdFx0Y29uc3QgZGVwZW5kZW5jeSA9IGNvbXB1dGVOb2RlTWFwLmdldChmaWVsZC5zb3VyY2UpO1xuXHRcdFx0XHRkZXBlbmRlbmN5Lm5leHQgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLmRlcGVuZGVuY3kubmV4dCwgY29tcHV0ZU5vZGVdKSk7XG5cdFx0XHRcdGNvbXB1dGVOb2RlLnByZXYgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLmNvbXB1dGVOb2RlLnByZXYsIGRlcGVuZGVuY3ldKSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKGZpZWxkLmZlZWRiYWNrICYmIGZpZWxkLmZlZWRiYWNrLmNvbXB1dGVkICYmIGZpZWxkLmZlZWRiYWNrLnNvdXJjZSAhPT0gbm9kZSkge1xuXHRcdFx0XHRcdGNvbnN0IGZlZWRiYWNrUHJvdmlkZXIgPSBjb21wdXRlTm9kZU1hcC5nZXQoZmllbGQuZmVlZGJhY2suc291cmNlKTtcblx0XHRcdFx0XHRmZWVkYmFja1Byb3ZpZGVyLnByZXYgPSBbLi4ubmV3IFNldChbLi4uZmVlZGJhY2tQcm92aWRlci5wcmV2LCBjb21wdXRlTm9kZV0pXTtcblx0XHRcdFx0XHRjb21wdXRlTm9kZS5uZXh0ID0gWy4uLm5ldyBTZXQoWy4uLmNvbXB1dGVOb2RlLm5leHQsIGZlZWRiYWNrUHJvdmlkZXJdKV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbnN0IHF1ZXVlID0gY3JlYXRlSW5wdXRRdWV1ZShmaWVsZCwgY29tcHV0ZU5vZGVNYXApO1xuXHRcdFx0Y29tcHV0ZU5vZGUuaW5wdXRzLnNldChuYW1lLCBxdWV1ZSk7XG5cdFx0XHRjb21wdXRlTm9kZS5lbnYuc2V0KG5hbWUsIGZpZWxkKTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IGFsbG9jYXRpb25zID0gbm9kZS5vcGVyYXRvci5kZXRlcm1pbmVBbGxvY2F0aW9ucyh1c2VkSW5wdXRzKTtcblx0XHRhbGxvY2F0aW9ucy5mb3JFYWNoKGFsbG9jYXRpb24gPT4ge1xuXHRcdFx0Y29uc3Qgc2l6ZUlucHV0ID0ge307XG5cdFx0XHRhbGxvY2F0aW9uLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcGVuZGVuY3kgPT4ge1xuXHRcdFx0XHRjb25zdCBpbnB1dCA9IHVzZWRJbnB1dHMuZ2V0KGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRpZiAoaW5wdXQuY29tcHV0ZWQgfHwgaW5wdXQuZmVlZGJhY2spXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcHV0ZWQgb3IgZmVlZGJhY2sgaW5wdXQgZm9yIGFsbG9jYXRpb24gcmVsZXZhbnQgaW5wdXRzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkISBJbnB1dCBuYW1lOiBcIiwgZGVwZW5kZW5jeSk7XG5cdFx0XHRcdGNvbXB1dGVOb2RlLmFsbG9jYXRpb25EZXBlbmRlbmNpZXMuc2V0KGlucHV0Lm5hbWUsIGNvbXB1dGVOb2RlLmlucHV0cy5nZXQoZGVwZW5kZW5jeSkuaW5pdGlhbC5idWZmZXIpO1xuXHRcdFx0XHRzaXplSW5wdXRbZGVwZW5kZW5jeV0gPSB0b1NoYWRlVmFsdWUoY29tcHV0ZU5vZGUuaW5wdXRzLmdldChkZXBlbmRlbmN5KS5pbml0aWFsLmJ1ZmZlcilcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoYWxsb2NhdGlvbi5pc1RleHR1cmUpIHtcblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGFsbG9jYXRpb24uc2l6ZShzaXplSW5wdXQpO1xuXHRcdFx0XHRhbGxvY2F0aW9uLndpZHRoID0gc2l6ZVswXTtcblx0XHRcdFx0YWxsb2NhdGlvbi5oZWlnaHQgPSBzaXplWzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudFR5cGUgPSB0b0ZpZWxkRGVzY3JpcHRvcihhbGxvY2F0aW9uLmVsZW1lbnRzLmV4dHJhKTtcblx0XHRcdFx0aWYgKGVsZW1lbnRUeXBlLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcInVuZGVmaW5lZCBlbGVtZW50IHR5cGUgZm9yIGJ1ZmZlciBcIiArIGFsbG9jYXRpb24ucHJvcGVydHlOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhbGxvY2F0aW9uLmVsZW1lbnRzLnN0YXRpY1NpemUgPSBhbGxvY2F0aW9uLnNpemUoc2l6ZUlucHV0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRjb21wdXRlTm9kZS5hbGxvY2F0aW9ucyA9IGFsbG9jYXRpb25zO1xuXHRcdGNvbXB1dGVOb2RlLm91dHB1dHMgPSBub2RlLmRldGVybWluZU91dHB1dHMoKTtcblx0XHRyZXR1cm4gY29tcHV0ZU5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVGaWVsZChmaWVsZCkge1xuXHRcdGlmIChmaWVsZC5jb21wdXRlZClcblx0XHRcdGJ1aWxkQ29tcHV0ZU5vZGUoZmllbGQuc291cmNlKTtcblx0XHRpZiAoZmllbGQuZmVlZGJhY2spXG5cdFx0XHRoYW5kbGVGaWVsZChmaWVsZC5mZWVkYmFjayk7XG5cdH1cblxuXHRyZXF1ZXN0ZWRGaWVsZHMuZm9yRWFjaChoYW5kbGVGaWVsZCk7XG5cblx0Y29tcHV0ZU5vZGVNYXAuZm9yRWFjaCgoY29tcHV0ZU5vZGUsIG5vZGUpID0+IHtcblx0XHRpZiAoIW5vZGUub3BlcmF0b3IuZXZhbHVhdGUpXG5cdFx0XHRjb21wdXRlTm9kZU1hcC5kZWxldGUobm9kZSk7XG5cblx0XHRpZiAoY29tcHV0ZU5vZGUucHJldi5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbXB1dGVOb2RlLnByZXYucHVzaChlbnRyeU5vZGUpO1xuXHRcdFx0ZW50cnlOb2RlLm5leHQucHVzaChjb21wdXRlTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbXB1dGVOb2RlLm5leHQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRjb21wdXRlTm9kZS5uZXh0LnB1c2goZXhpdE5vZGUpO1xuXHRcdFx0ZXhpdE5vZGUucHJldi5wdXNoKGNvbXB1dGVOb2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChleGl0Tm9kZS5wcmV2Lmxlbmd0aCA9PT0gMCkge1xuXHRcdGV4aXROb2RlLnByZXYucHVzaChlbnRyeU5vZGUpO1xuXHRcdGVudHJ5Tm9kZS5uZXh0LnB1c2goZXhpdE5vZGUpO1xuXHR9XG5cblx0cmVxdWVzdGVkRmllbGRzLmZvckVhY2goKG91dHB1dCwgbmFtZSkgPT4ge1xuXHRcdGV4aXROb2RlLmlucHV0cy5zZXQobmFtZSwgY3JlYXRlSW5wdXRRdWV1ZShvdXRwdXQsIGNvbXB1dGVOb2RlTWFwKSk7XG5cdH0pO1xuXG5cdGlmICghaXNBY3ljbGljKGV4aXROb2RlKSlcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBkZXRlY3RlZCFcIik7XG5cblx0cmV0dXJuIG5ldyBDb21wdXRlR3JhcGgoZW50cnlOb2RlLCBleGl0Tm9kZSwgY29tcHV0ZU5vZGVNYXApO1xufVxuXG5mdW5jdGlvbiBpc0FjeWNsaWMobm9kZSwgY3VycmVudCA9IG5ldyBTZXQoKSwgdmlzaXRlZCA9IG5ldyBTZXQoKSkge1xuXHRpZiAoY3VycmVudC5oYXMobm9kZSkpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdGlmICh2aXNpdGVkLmhhcyhub2RlKSlcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRjdXJyZW50LmFkZChub2RlKTtcblx0Y29uc3QgYWN5Y2xpYyA9IG5vZGUucHJldi5ldmVyeShwcmV2ID0+IGlzQWN5Y2xpYyhwcmV2LCBjdXJyZW50LCB2aXNpdGVkKSk7XG5cdGN1cnJlbnQuZGVsZXRlKG5vZGUpO1xuXHR2aXNpdGVkLmFkZChub2RlKTtcblx0cmV0dXJuIGFjeWNsaWM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UXVldWUoaW5wdXREZWZpbml0aW9uLCBjb21wdXRlTm9kZU1hcCkge1xuXHRyZXR1cm4gbmV3IElucHV0UXVldWUocmV3cml0ZUlucHV0RGVmaW5pdGlvbihpbnB1dERlZmluaXRpb24sIGNvbXB1dGVOb2RlTWFwKSk7XG59XG5cbmZ1bmN0aW9uIHJld3JpdGVJbnB1dERlZmluaXRpb24oaW5wdXREZWZpbml0aW9uLCBjb21wdXRlTm9kZU1hcCwgdmlzaXRlZCA9IG5ldyBNYXAoKSkge1xuXHRpZiAodmlzaXRlZC5oYXMoaW5wdXREZWZpbml0aW9uKSlcblx0XHRyZXR1cm4gdmlzaXRlZC5nZXQoaW5wdXREZWZpbml0aW9uKTtcblxuXHRjb25zdCBuZXdJbnB1dERlZmluaXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBpbnB1dERlZmluaXRpb24pO1xuXHRpZiAoaW5wdXREZWZpbml0aW9uLmNvbXB1dGVkKSB7XG5cdFx0bmV3SW5wdXREZWZpbml0aW9uLnNvdXJjZSA9IGNvbXB1dGVOb2RlTWFwLmdldChpbnB1dERlZmluaXRpb24uc291cmNlKTtcblx0fSBlbHNlIHtcblx0XHRuZXdJbnB1dERlZmluaXRpb24uYnVmZmVyID0gaW5wdXREZWZpbml0aW9uLnNvdXJjZS5maWVsZHMuZ2V0KGlucHV0RGVmaW5pdGlvbi5uYW1lKTtcblx0fVxuXHR2aXNpdGVkLnNldChpbnB1dERlZmluaXRpb24sIG5ld0lucHV0RGVmaW5pdGlvbik7XG5cdGlmIChpbnB1dERlZmluaXRpb24uZmVlZGJhY2spXG5cdFx0bmV3SW5wdXREZWZpbml0aW9uLmZlZWRiYWNrID0gcmV3cml0ZUlucHV0RGVmaW5pdGlvbihpbnB1dERlZmluaXRpb24uZmVlZGJhY2ssIGNvbXB1dGVOb2RlTWFwKTtcblx0cmV0dXJuIG5ld0lucHV0RGVmaW5pdGlvbjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBkZWVwRXF1YWwgPSByZXF1aXJlKFwiZGVlcC1lcXVhbFwiKTtcblxuY29uc3Qgd29ya2xpc3QgPSByZXF1aXJlKFwiLi93b3JrbGlzdFwiKTtcbmNvbnN0IGNmZ1V0aWxzID0gcmVxdWlyZShcIi4vY2ZnX3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVOb2RlSW5wdXQobm9kZSkge1xuXHRjb25zdCBjZmcgPSBjZmdVdGlscy53cmFwKG5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0Y29uc3Qge2lucHV0c30gPSB3b3JrbGlzdChcblx0XHRcdGNmZywgZGV0ZXJtaW5lTm9kZU91dHB1dCxcblx0XHRcdHtzdGFydDogbmV3IE1hcCgpLCBlcXVhbHM6IGVxdWFsSW5wdXRzLCBtZXJnZTogbWVyZ2VOb2RlSW5wdXRzfSk7XG5cdFx0aW5wdXRzLmZvckVhY2goKGlucHV0cywgbm9kZSkgPT4ge1xuXHRcdFx0bm9kZS5fY2FjaGVkSW5wdXRzID0gaW5wdXRzO1xuXHRcdH0pO1xuXHRcdHJldHVybiBpbnB1dHMuZ2V0KG5vZGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0dGhyb3cgZTtcblx0fSBmaW5hbGx5IHtcblx0XHRjZmdVdGlscy51bndyYXAoY2ZnKTtcblx0fVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmVOb2RlSW5wdXQ7XG5cbmZ1bmN0aW9uIGRldGVybWluZU5vZGVPdXRwdXQobm9kZSwgaW5wdXQpIHtcblx0aWYgKG5vZGUgaW5zdGFuY2VvZiBjZmdVdGlscy5FbnRyeU5vZGVcblx0XHR8fCBub2RlIGluc3RhbmNlb2YgY2ZnVXRpbHMuRXhpdE5vZGUpXG5cdFx0cmV0dXJuIHtvdXRwdXQ6IGlucHV0LCBlbnF1ZXVlOiB0cnVlfTtcblxuXHR0cnkge1xuXHRcdGNvbnN0IG91dHB1dCA9IG5vZGUub3BlcmF0b3IuZGV0ZXJtaW5lRmluYWxPdXRwdXQoXG5cdFx0XHRuZXcgTWFwKFsuLi5pbnB1dF0pLCBub2RlKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0b3V0cHV0OiBvdXRwdXQsIGVucXVldWU6IHRydWVcblx0XHR9O1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG91dHB1dDogaW5wdXQsIGVucXVldWU6IHRydWVcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VOb2RlSW5wdXRzKG5vZGUsIGlucHV0VGFibGVzKSB7XG5cdGNvbnN0IGZpZWxkSW5wdXRUYWJsZSA9IG5ldyBNYXAoKTtcblx0aWYgKG5vZGUuZmllbGRzKSB7XG5cdFx0bm9kZS5maWVsZHMuZm9yRWFjaCgoYnVmZmVyLCBuYW1lKSA9PiB7XG5cdFx0XHRmaWVsZElucHV0VGFibGUuc2V0KG5hbWUsIHtcblx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0dHlwZTogYnVmZmVyLnR5cGUsXG5cdFx0XHRcdHNoYXBlOiBidWZmZXIuc2hhcGUsXG5cdFx0XHRcdGlzVGV4dHVyZTogYnVmZmVyLmlzVGV4dHVyZSxcblx0XHRcdFx0Y29tcHV0ZWQ6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdGlucHV0VGFibGVzID0gaW5wdXRUYWJsZXMubWFwKGlucHV0ID0+ICFpbnB1dCA/IG5ldyBNYXAoKSA6IGlucHV0KTtcblxuXHRjb25zdCBpc0ZlZWRiYWNrID0gaW5wdXRUYWJsZXMubWFwKChwb3NzaWJsZUZlZWRiYWNrSW5wdXRUYWJsZSwgaWR4KSA9PiB7XG5cdFx0aWYgKGlzRm9yd2FyZFJlYWNoYWJsZShub2RlLnByZXZbaWR4XSwgbm9kZSkpIHtcblx0XHRcdGNvbnN0IHByZWNlZGluZ0lucHV0VGFibGVcblx0XHRcdFx0PSBtZXJnZU1hcHMoLi4uaW5wdXRUYWJsZXMuc2xpY2UoMCwgaWR4KSwgZmllbGRJbnB1dFRhYmxlKTtcblx0XHRcdHJldHVybiBjb250YWluc0ZlZWRiYWNrRm9ySW5wdXRUYWJsZShwb3NzaWJsZUZlZWRiYWNrSW5wdXRUYWJsZSwgcHJlY2VkaW5nSW5wdXRUYWJsZSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkSW5wdXRUYWJsZSA9IG1lcmdlTWFwcyguLi5pbnB1dFRhYmxlcy5maWx0ZXIoKF8sIGlkeCkgPT4gIWlzRmVlZGJhY2tbaWR4XSksIGZpZWxkSW5wdXRUYWJsZSk7XG5cdGNvbnN0IG1lcmdlZEZlZWRiYWNrSW5wdXRUYWJsZSA9IG1lcmdlTWFwcyguLi5pbnB1dFRhYmxlcy5maWx0ZXIoKF8sIGlkeCkgPT4gaXNGZWVkYmFja1tpZHhdKSk7XG5cdG1lcmdlZEZlZWRiYWNrSW5wdXRUYWJsZS5mb3JFYWNoKHBvc3NpYmxlRmVlZGJhY2tJbnB1dCA9PiB7XG5cdFx0aWYgKGlzVmFsaWRGZWVkYmFja0ZvcklucHV0KHBvc3NpYmxlRmVlZGJhY2tJbnB1dCwgbWVyZ2VkSW5wdXRUYWJsZS5nZXQocG9zc2libGVGZWVkYmFja0lucHV0Lm5hbWUpKSkge1xuXHRcdFx0aGFuZGxlQ3ljbGljRmVlZGJhY2socG9zc2libGVGZWVkYmFja0lucHV0KTtcblx0XHRcdG1lcmdlZElucHV0VGFibGUuZ2V0KHBvc3NpYmxlRmVlZGJhY2tJbnB1dC5uYW1lKS5mZWVkYmFjayA9IHBvc3NpYmxlRmVlZGJhY2tJbnB1dDtcblx0XHR9XG5cdH0pO1xuXG5cdGZpZWxkSW5wdXRUYWJsZS5mb3JFYWNoKGlucHV0ID0+IGlucHV0LnNvdXJjZSA9IG5vZGUpO1xuXG5cdHJldHVybiBtZXJnZWRJbnB1dFRhYmxlO1xufVxuXG5mdW5jdGlvbiBpc0ZvcndhcmRSZWFjaGFibGUobm9kZVRvUmVhY2gsIHN0YXJ0Tm9kZSwgcmVtb3ZlZEVkZ2VzID0gW10sXG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWQgPSBuZXcgU2V0KCkpIHtcblx0dmlzaXRlZC5hZGQoc3RhcnROb2RlKTtcblx0cmV0dXJuIHN0YXJ0Tm9kZS5uZXh0LnNvbWUobmV4dE5vZGUgPT4ge1xuXHRcdGlmIChyZW1vdmVkRWRnZXMuZmluZChlZGdlID0+IGVkZ2VbMF0gPT09IHN0YXJ0Tm9kZVxuXHRcdFx0JiYgZWRnZVsxXSA9PT0gbmV4dE5vZGUpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChuZXh0Tm9kZSA9PT0gbm9kZVRvUmVhY2gpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAodmlzaXRlZC5oYXMobmV4dE5vZGUpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0dmlzaXRlZC5hZGQobmV4dE5vZGUpO1xuXHRcdHJldHVybiBpc0ZvcndhcmRSZWFjaGFibGUobm9kZVRvUmVhY2gsIG5leHROb2RlLCByZW1vdmVkRWRnZXMsIHZpc2l0ZWQpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBzKC4uLm1hcHMpIHtcblx0cmV0dXJuIG5ldyBNYXAoW10uY29uY2F0KC4uLm1hcHMubWFwKG0gPT4gQXJyYXkuZnJvbShtKSkpKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNGZWVkYmFja0ZvcklucHV0VGFibGUocG90ZW50aWFsRmVlZGJhY2tUYWJsZSwgaW5wdXRUYWJsZSkge1xuXHRyZXR1cm4gWy4uLnBvdGVudGlhbEZlZWRiYWNrVGFibGUudmFsdWVzKCldLnNvbWUocG90ZW50aWFsRmVlZGJhY2sgPT4ge1xuXHRcdHJldHVybiBpc1ZhbGlkRmVlZGJhY2tGb3JJbnB1dChwb3RlbnRpYWxGZWVkYmFjayxcblx0XHRcdGlucHV0VGFibGUuZ2V0KHBvdGVudGlhbEZlZWRiYWNrLm5hbWUpKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRGZWVkYmFja0ZvcklucHV0KHBvc3NpYmxlRmVlZGJhY2tJbnB1dCwgaW5wdXQpIHtcblx0cmV0dXJuIGlucHV0ICYmIGlucHV0LnNvdXJjZSAhPT0gcG9zc2libGVGZWVkYmFja0lucHV0LnNvdXJjZSAmJiBpbnB1dC50eXBlID09PSBwb3NzaWJsZUZlZWRiYWNrSW5wdXQudHlwZTtcbn1cblxuZnVuY3Rpb24gZXF1YWxJbnB1dHMoYSwgYikge1xuXHRpZiAoYS5zaXplICE9PSBiLnNpemUpXG5cdFx0cmV0dXJuO1xuXG5cdHJldHVybiBbLi4uYS52YWx1ZXMoKV0uZXZlcnkodiA9PiBiLmhhcyh2Lm5hbWUpICYmIGVxdWFsUHJvcGVydGllcyh2LCBiLmdldCh2Lm5hbWUpKSk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsUHJvcGVydGllcyhhLCBiKSB7XG5cdGZvciAobGV0IG5hbWUgaW4gYSkge1xuXHRcdGlmICghYVtuYW1lXSA9PT0gYltuYW1lXSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDeWNsaWNGZWVkYmFjayhpbnB1dCkge1xuXHRpZiAoIWlucHV0LmZlZWRiYWNrKVxuXHRcdHJldHVybjtcblxuXHRjb25zdCBwcmVjZWRpbmdGZWVkYmFjayA9IFtdO1xuXG5cdHdoaWxlIChpbnB1dC5mZWVkYmFjaykge1xuXHRcdGNvbnN0IGN5Y2xpY0ZlZWRiYWNrID0gcHJlY2VkaW5nRmVlZGJhY2suZmluZChmZWVkYmFjayA9PiB7XG5cdFx0XHRjb25zdCBvbGRGZWVkYmFjayA9IGZlZWRiYWNrLmZlZWRiYWNrO1xuXHRcdFx0ZGVsZXRlIGZlZWRiYWNrLmZlZWRiYWNrO1xuXHRcdFx0Y29uc3QgaXNFcXVhbCA9IGRlZXBFcXVhbChmZWVkYmFjaywgaW5wdXQuZmVlZGJhY2spO1xuXHRcdFx0ZmVlZGJhY2suZmVlZGJhY2sgPSBvbGRGZWVkYmFjaztcblx0XHRcdHJldHVybiBpc0VxdWFsO1xuXHRcdH0pO1xuXHRcdGlmIChjeWNsaWNGZWVkYmFjaykge1xuXHRcdFx0aW5wdXQuZmVlZGJhY2sgPSBjeWNsaWNGZWVkYmFjaztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJlY2VkaW5nRmVlZGJhY2sucHVzaChpbnB1dC5mZWVkYmFjayk7XG5cblx0XHRpbnB1dCA9IGlucHV0LmZlZWRiYWNrO1xuXHR9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gd29ya2xpc3QoXG5cdHtlbnRyeU5vZGUsIGV4aXROb2RlfSwgdHJhbnNmZXJGdW5jdGlvbixcblx0e2RpcmVjdGlvbiA9IFwiZm9yd2FyZFwiLCBzdGFydCA9IG5ldyBTZXQoKSwgbWVyZ2UgPSB1bmlvbiwgZXF1YWxzID0gZXF1YWxLZXlzfVxuXHQ9IHt9KSB7XG5cdHZhciBsaXN0ID0gbmV3IFF1ZXVlKCk7XG5cblx0bGV0IHByZWRlY2Vzc29ycyA9IGdldFByZWRlY2Vzc29ycztcblx0bGV0IHN1Y2Nlc3NvcnMgPSBnZXRTdWNjZXNzb3JzO1xuXG5cdGlmIChkaXJlY3Rpb24gPT09IFwiZm9yd2FyZFwiKSB7XG5cdFx0bGlzdC5wdXNoKGVudHJ5Tm9kZSk7XG5cdH0gZWxzZSB7XG5cdFx0bGlzdC5wdXNoKGV4aXROb2RlKTtcblx0XHRwcmVkZWNlc3NvcnMgPSBnZXRTdWNjZXNzb3JzO1xuXHRcdHN1Y2Nlc3NvcnMgPSBnZXRQcmVkZWNlc3NvcnM7XG5cdH1cblxuXHRjb25zdCBvdXRwdXRzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBpbnB1dHMgPSBuZXcgTWFwKCk7XG5cblx0d2hpbGUgKGxpc3QubGVuZ3RoKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IGxpc3Quc2hpZnQoKTtcblx0XHRjb25zdCBwcmUgPSBwcmVkZWNlc3NvcnMobm9kZSkubWFwKG4gPT4gb3V0cHV0cy5nZXQobikpO1xuXHRcdGNvbnN0IGlucHV0ID0gcHJlLmxlbmd0aCA/IG1lcmdlKG5vZGUsIHByZSkgOiBzdGFydDtcblx0XHRpbnB1dHMuc2V0KG5vZGUsIGlucHV0KTtcblx0XHRjb25zdCBvbGRPdXRwdXQgPSBvdXRwdXRzLmdldChub2RlKTtcblx0XHRsZXQgbmV3T3V0cHV0ID0gdHJhbnNmZXJGdW5jdGlvbihub2RlLCBpbnB1dCwgbGlzdCwgb2xkT3V0cHV0KTtcblx0XHRpZiAoIW5ld091dHB1dCB8fCBuZXdPdXRwdXQgaW5zdGFuY2VvZiBTZXQpXG5cdFx0XHRuZXdPdXRwdXQgPSB7b3V0cHV0OiBuZXdPdXRwdXQsIGVucXVldWU6IHRydWV9O1xuXHRcdG91dHB1dHMuc2V0KG5vZGUsIG5ld091dHB1dC5vdXRwdXQpO1xuXHRcdGlmIChuZXdPdXRwdXQuZW5xdWV1ZVxuXHRcdFx0JiYgKCFvbGRPdXRwdXQgfHwgIWVxdWFscyhuZXdPdXRwdXQub3V0cHV0LCBvbGRPdXRwdXQpKSlcblx0XHRcdHN1Y2Nlc3NvcnMobm9kZSkuZm9yRWFjaChhU3VjY2Vzc29yID0+IGxpc3QucHVzaChhU3VjY2Vzc29yKSk7XG5cdH1cblxuXHRyZXR1cm4ge291dHB1dHMsIGlucHV0c307XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdvcmtsaXN0O1xuXG5jbGFzcyBRdWV1ZSBleHRlbmRzIEFycmF5IHtcblx0cHVzaChlbGVtZW50KSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSlcblx0XHRcdHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRzdXBlci5wdXNoKGVsZW1lbnQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldFByZWRlY2Vzc29ycyhub2RlKSB7XG5cdHJldHVybiBub2RlLnByZXY7XG59XG5cbmZ1bmN0aW9uIGdldFN1Y2Nlc3NvcnMobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5uZXh0O1xufVxuXG5mdW5jdGlvbiB1bmlvbihfLCBwcmUpIHtcblx0cmV0dXJuIG5ldyBTZXQoW10uY29uY2F0KC4uLnByZS5tYXAodiA9PiAhdiA/IFtdIDogQXJyYXkuZnJvbSh2KSkpKVxufVxuXG5mdW5jdGlvbiBlcXVhbEtleXMoYSwgYikge1xuXHRyZXR1cm4gYS5zaXplID09PSBiLnNpemUgJiYgWy4uLmFdLmV2ZXJ5KHYgPT4gYi5oYXModikpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyO1xuXG5jb25zdCBkZXRlcm1pbmVDb21wdXRlR3JhcGggPSByZXF1aXJlKFwiLi4vYW5hbHlzaXMvZGV0ZXJtaW5lX2NvbXB1dGVfZ3JhcGhcIik7XG5cbmNvbnN0IGNwdVBsYXRmb3JtID0gcmVxdWlyZShcIi4uL3BsYXRmb3JtL2NwdVwiKTtcbmNvbnN0IGRlYnVnUGxhdGZvcm0gPSByZXF1aXJlKFwiLi4vcGxhdGZvcm0vZGVidWdcIik7XG5jb25zdCBQcm9ncmFtID0gcmVxdWlyZShcIi4uL2V4ZWN1dGlvbi9wcm9ncmFtXCIpO1xuY29uc3Qgbm93ID0gcmVxdWlyZShcInBlcmZvcm1hbmNlLW5vd1wiKTtcblxuY2xhc3MgSW52YWxpZFByb2dyYW0gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGVycm9yKSB7XG4gICAgICAgIHN1cGVyKFwidHlwZS1jaGFuZ2VcIik7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuX29uVHlwZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImludmFsaWRcIiwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX25vZGUub24oXCJ0eXBlLWNoYW5nZVwiLCB0aGlzLl9vblR5cGVDaGFuZ2UpO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVtb3ZlTGlzdGVuZXIoXCJ0eXBlLWNoYW5nZVwiLCB0aGlzLl9vblR5cGVDaGFuZ2UpO1xuICAgIH1cblxuICAgIHJ1bigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cblxuY29uc3QgcGxhdGZvcm1zID0ge1xuICAgIFwiY3B1XCI6IGNwdVBsYXRmb3JtLFxuICAgIFwiZGVidWdcIjogZGVidWdQbGF0Zm9ybVxufTtcblxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShub2RlLCBvdXRwdXRzLCBvcHRpb25zID0ge2ZvcmNlUGxhdGZvcm06IFwiY3B1XCIsIGJlbmNobWFyazogZmFsc2V9KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHBsYXRmb3Jtc1tvcHRpb25zLmZvcmNlUGxhdGZvcm1dO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gZGV0ZXJtaW5lQ29tcHV0ZUdyYXBoKG91dHB1dHMsIG5vZGUpO1xuICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFtuZXcgU2V0KFtncmFwaC5lbnRyeU5vZGVdKV07XG4gICAgICAgIGNvbnN0IGFsbE5vZGVzID0gZ3JhcGguYWxsTm9kZXM7XG4gICAgICAgIGxldCBsYXllcklkeCA9IDA7XG4gICAgICAgIHdoaWxlIChhbGxOb2Rlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgaWYgKCFzY2hlZHVsZVtsYXllcklkeF0pXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVbbGF5ZXJJZHhdID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgYWxsTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2LmV2ZXJ5KHByZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlLnNsaWNlKDAsIGxheWVySWR4KS5zb21lKGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuaGFzKHByZXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm0uY29tcGlsZShub2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVtsYXllcklkeF0uYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICArK2xheWVySWR4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKG5vZGUsIGdyYXBoLCBzY2hlZHVsZSwgbm93KCkgLSBzdGFydCwgb3B0aW9ucy5iZW5jaG1hcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52YWxpZFByb2dyYW0obm9kZSwgZXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0cy5jcmVhdGVQcm9ncmFtID0gY3JlYXRlUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IERpc3Bvc2VJZk5vTGlzdGVuZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9kaXNwb3NlX2lmX25vX2xpc3RlbmVyXCIpO1xuXG5jbGFzcyBDb21wdXRlUmVxdWVzdCBleHRlbmRzIERpc3Bvc2VJZk5vTGlzdGVuZXIoRXZlbnRFbWl0dGVyKSB7XG4gICAgY29uc3RydWN0b3IocHJvZ3JhbSkge1xuICAgICAgICBzdXBlcihcInZhbHVlXCIpO1xuICAgICAgICB0aGlzLnNldE1heExpc3RlbmVycygwKTtcblxuICAgICAgICB0aGlzLl9wcm9ncmFtID0gcHJvZ3JhbTtcblxuICAgICAgICB0aGlzLl9wcm9ncmFtLm9uKFwibmVlZHMtdXBkYXRlXCIsIHRoaXMuX29uUHJvZ3JhbU5lZWRzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wcm9ncmFtLm9uKFwiaW52YWxpZFwiLCB0aGlzLl9pbnZhbGlkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0uZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgdGhpcy5fcHJvZ3JhbS5lcnJvcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fb25Qcm9ncmFtTmVlZHNVcGRhdGUoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgX29uUHJvZ3JhbU5lZWRzVXBkYXRlKCkge1xuICAgICAgICBjb25zdCBwZW5kaW5nUmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5ydW4oKS50aGVuKHJlc29sdmUpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcInZhbHVlXCIsIHBlbmRpbmdSZXN1bHQpO1xuICAgIH1cblxuICAgIF9pbnZhbGlkYXRlKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJpbnZhbGlkXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29tcHV0ZVJlcXVlc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XG5cbmNvbnN0IERpc3Bvc2VJZk5vTGlzdGVuZXJzID0gcmVxdWlyZShcIi4uL3V0aWwvZGlzcG9zZV9pZl9ub19saXN0ZW5lclwiKTtcblxuY29uc3QgcnVubmVyID0gcmVxdWlyZShcIi4vcnVubmVyXCIpO1xuY29uc3QgQnVmZmVyID0gcmVxdWlyZShcIi4uL2ZpZWxkL2J1ZmZlcl9hY2Nlc3NvclwiKTtcblxuY2xhc3MgUHJvZ3JhbSBleHRlbmRzIERpc3Bvc2VJZk5vTGlzdGVuZXJzKEV2ZW50RW1pdHRlcikge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGNvbXB1dGVHcmFwaCwgc2NoZWR1bGUsIGNvbXBpbGVUaW1lLCBiZW5jaG1hcmsgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKFwibmVlZHMtdXBkYXRlXCIpO1xuICAgICAgICB0aGlzLnNldE1heExpc3RlbmVycygwKTtcblxuICAgICAgICB0aGlzLnRpbWUgPSBjb21waWxlVGltZTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZUdyYXBoID0gY29tcHV0ZUdyYXBoO1xuICAgICAgICB0aGlzLl9leGVjdXRpb25TY2hlZHVsZSA9IHNjaGVkdWxlO1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9iZW5jaG1hcmsgPSBiZW5jaG1hcms7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgICB0aGlzLl9vblZhbHVlQ2hhbmdlID0gKGNoYW5nZWRPdXRwdXRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkT3V0cHV0cyA9IGNoYW5nZWRPdXRwdXRzO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwibmVlZHMtdXBkYXRlXCIsIHRoaXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX29uVHlwZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImludmFsaWRcIiwgdGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fbm9kZS5vbihcInR5cGUtY2hhbmdlXCIsIHRoaXMuX29uVHlwZUNoYW5nZSk7XG4gICAgICAgIHRoaXMuX2NvbXB1dGVHcmFwaC5vbihcInZhbHVlLWNoYW5nZVwiLCB0aGlzLl9vblZhbHVlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZUdyYXBoLm9uKFwidHlwZS1jaGFuZ2VcIiwgdGhpcy5fb25UeXBlQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlbW92ZUxpc3RlbmVyKFwidHlwZS1jaGFuZ2VcIiwgdGhpcy5fb25UeXBlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZUdyYXBoLnJlbW92ZUxpc3RlbmVyKFwidmFsdWUtY2hhbmdlXCIsIHRoaXMuX29uVmFsdWVDaGFuZ2UpO1xuICAgICAgICB0aGlzLl9jb21wdXRlR3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJ0eXBlLWNoYW5nZVwiLCB0aGlzLl9vblR5cGVDaGFuZ2UpO1xuICAgICAgICB0aGlzLl9jb21wdXRlR3JhcGguZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHJ1bihmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmVlZHNVcGRhdGUgJiYgIWZvcmNlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9idWlsZFJlc3VsdCgpKTtcblxuICAgICAgICBjb25zdCBjaGFuZ2VkT3V0cHV0cyA9IHRoaXMuX2NoYW5nZWRPdXRwdXRzO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkT3V0cHV0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0aGlzLl9ydW5uaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bm5lci5ydW4odGhpcy5fZXhlY3V0aW9uU2NoZWR1bGUsIGZvcmNlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9idWlsZFJlc3VsdChjaGFuZ2VkT3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9iZW5jaG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG92ZXJhbGxUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVHcmFwaC5hbGxOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXMucHVzaCh7bmFtZTogbm9kZS5uYW1lLCB0aW1lOiBub2RlLnRpbWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJhbGxUaW1lICs9IG5vZGUudGltZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9fdGltZSA9IHRpbWVzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuX19vdmVyYWxsVGltZSA9IG92ZXJhbGxUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZztcbiAgICB9XG5cbiAgICBfYnVpbGRSZXN1bHQob3V0cHV0TmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIHRoaXMuX2NvbXB1dGVHcmFwaC5leGl0Tm9kZS5pbnB1dHMuZm9yRWFjaCgoaW5wdXQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChvdXRwdXROYW1lcyAmJiAhb3V0cHV0TmFtZXMuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGlucHV0LmNvbXB1dGVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IFByb2dyYW0uZnJvbVNoYWRlVmFsdWUoaW5wdXQudHlwZSwgaW5wdXQuc291cmNlLnJlc3VsdFtpbnB1dC5uYW1lXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gUHJvZ3JhbS5mcm9tU2hhZGVWYWx1ZShpbnB1dC50eXBlLCBpbnB1dC5idWZmZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVNoYWRlVmFsdWUodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZS5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih0eXBlLCB2YWx1ZSwgdmFsdWUuc2hhcGUuc2xpY2UoMCwgdmFsdWUuc2hhcGUubGVuZ3RoIC0xKSk7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcblxuICAgICAgICBjb25zdCBzaGFwZSA9IFt2YWx1ZS5sZW5ndGhdO1xuICAgICAgICBsZXQgZWxlbWVudHMgPSB2YWx1ZVswXTtcbiAgICAgICAgd2hpbGUgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICBzaGFwZS5wdXNoKGVsZW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBlbGVtZW50cyA9IHZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdHlwZS5hbGxvY2F0ZShzaGFwZSk7XG4gICAgICAgIFByb2dyYW0udG9CdWZmZXIoYnVmZmVyLCB2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgdG9CdWZmZXIoYnVmZmVyLCB2YWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVtpXSkpXG4gICAgICAgICAgICAgICAgUHJvZ3JhbS50b0J1ZmZlcihidWZmZXIucGljayhpKSwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoaSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtO1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcnVuKHNjaGVkdWxlLCBmb3JjZSkge1xuICAgIHNjaGVkdWxlID0gWy4uLnNjaGVkdWxlXTtcbiAgICBpZiAoc2NoZWR1bGUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHJ1bk5vZGVzKHNjaGVkdWxlLnNoaWZ0KCksIGZvcmNlKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHJ1bihzY2hlZHVsZSwgZm9yY2UpXG4gICAgfSk7XG59XG5cbmV4cG9ydHMucnVuID0gcnVuO1xuXG5mdW5jdGlvbiBydW5Ob2Rlcyhub2RlcywgZm9yY2UpIHtcbiAgICBsZXQgZGlydHlOb2RlcyA9IFsuLi5ub2Rlc10uZmlsdGVyKG5vZGUgPT4gbm9kZS5vcGVyYXRvciAmJiBub2RlLm9wZXJhdG9yLmV2YWx1YXRlKTtcbiAgICBkaXJ0eU5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnRpbWUgPSAwKTtcbiAgICBpZiAoIWZvcmNlKVxuICAgICAgICBkaXJ0eU5vZGVzID0gZGlydHlOb2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmRpcnR5KTtcblxuICAgIGlmIChkaXJ0eU5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gZGlydHlOb2Rlc1swXTtcbiAgICAgICAgcmV0dXJuIHJ1bkRpcmVjdChub2RlLCBwcmVwYXJlSW5wdXRzKG5vZGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVuV29ya2VyKGRpcnR5Tm9kZXMpO1xufVxuXG5mdW5jdGlvbiBydW5EaXJlY3Qobm9kZSwgaW5wdXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5vZGUuZXZhbHVhdGVEaXJlY3QoaW5wdXQsIG5vZGUubWVtb3J5KSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBub2RlLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgbm9kZS50aW1lID0gcmVzdWx0Ll9fdGltZTtcbiAgICAgICAgbm9kZS5kaXJ0eSA9IGZhbHNlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBydW5Xb3JrZXIobm9kZXMpIHtcbiAgICBjb25zdCBhbGwgPSBQcm9taXNlLmFsbChub2Rlcy5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9ySW5wdXQgPSBwcmVwYXJlSW5wdXRzKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLmV2YWx1YXRlV29ya2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ldmFsdWF0ZVdvcmtlcihvcGVyYXRvcklucHV0LCBub2RlLm1lbW9yeSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIG5vZGUudGltZSA9IHJlc3VsdC5fX3RpbWU7XG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnVuRGlyZWN0KG5vZGUsIG9wZXJhdG9ySW5wdXQpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBhbGw7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVJbnB1dHMobm9kZSkge1xuICAgIGNvbnN0IG9wZXJhdG9ySW5wdXQgPSB7fTtcblxuICAgIG5vZGUuaW5wdXRzLmZvckVhY2goKGlucHV0LCBuYW1lKT0+IHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5uZXh0KCk7XG4gICAgICAgIGlmIChpbnB1dC5jb21wdXRlZClcbiAgICAgICAgICAgIG9wZXJhdG9ySW5wdXRbbmFtZV0gPSBub2RlLnBsYXRmb3JtLnRvUGxhdGZvcm1WYWx1ZShpbnB1dC5zb3VyY2UucmVzdWx0W2lucHV0Lm5hbWVdKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3BlcmF0b3JJbnB1dFtuYW1lXSA9IG5vZGUucGxhdGZvcm0udG9QbGF0Zm9ybVZhbHVlKGlucHV0LmJ1ZmZlcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3BlcmF0b3JJbnB1dDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IG5kYXJyYXkgPSByZXF1aXJlKFwibmRhcnJheVwiKTtcblxuY2xhc3MgQnVmZmVyQWNjZXNzb3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIHNoYXBlLCBpc1RleHR1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGlmIChkYXRhLmJ1ZmZlcilcbiAgICAgICAgICAgIGRhdGEgPSB0eXBlLnRvU2hhcmVkQXJyYXlCdWZmZXIoZGF0YSk7XG5cbiAgICAgICAgaWYgKCFzaGFwZSB8fCBzaGFwZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBzaGFwZSA9IFtkYXRhLmxlbmd0aCAvIHR5cGUuc2l6ZV07XG4gICAgICAgIHRoaXMuX2FycmF5U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgaWYgKGRhdGEuZGF0YSlcbiAgICAgICAgICAgIHRoaXMuX25kYXJyYXkgPSBkYXRhO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9uZGFycmF5ID0gbmRhcnJheShkYXRhLCBbLi4uc2hhcGUsIC4uLnR5cGUuc2hhcGVdKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2lzVGV4dHVyZSA9IGlzVGV4dHVyZTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmRhcnJheS5zaGFwZTtcbiAgICB9XG5cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25kYXJyYXkuZGF0YTtcbiAgICB9XG5cbiAgICBzZXQgZGF0YShuZXdEYXRhKSB7XG4gICAgICAgIHRoaXMuX25kYXJyYXkuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmRhcnJheS5zaGFwZVswXTtcbiAgICB9XG5cbiAgICBnZXQgaXNUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNUZXh0dXJlO1xuICAgIH1cblxuICAgIGdldCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUudmFsdWVGcm9tQnVmZmVyKHRoaXMuX25kYXJyYXkucGljayguLi5hcmdzKSk7XG4gICAgfVxuXG4gICAgc2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzLnBvcCgpO1xuICAgICAgICB0aGlzLnR5cGUuc3RvcmVWYWx1ZUluQnVmZmVyKHRoaXMuX25kYXJyYXkucGljayguLi5hcmdzKSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcylcbiAgICB9XG5cbiAgICBwaWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9hcnJheVNoYXBlLnNsaWNlKCk7XG4gICAgICAgIHNoYXBlLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyQWNjZXNzb3IodGhpcy5fdHlwZSwgdGhpcy5fbmRhcnJheS5waWNrKC4uLmFyZ3MpLCBzaGFwZSk7XG4gICAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJBY2Nlc3NvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBTaGFkZSA9IHJlcXVpcmUoXCJzaGFkZS5qc1wiKTtcblxuY29uc3QgQnVmZmVyQWNjZXNzb3IgPSByZXF1aXJlKFwiLi9idWZmZXJfYWNjZXNzb3JcIik7XG5cbmlmICghZ2xvYmFsLlNoYXJlZEFycmF5QnVmZmVyICYmICFwcm9jZXNzLmJyb3dzZXIpXG5cdGdsb2JhbC5TaGFyZWRBcnJheUJ1ZmZlciA9IEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBjcmVhdGVUeXBlRGVzY3JpcHRvcihuYW1lLCB0eXBlZEFycmF5LCBiYXNlU2hhcGUsIHZhbHVlRnJvbUJ1ZmZlcixcblx0XHRcdFx0XHRcdFx0ICBzdG9yZVZhbHVlSW5CdWZmZXIsIGZyb21BcnJheSkge1xuXHRsZXQgYmFzZVNpemUgPSBiYXNlU2hhcGUucmVkdWNlKChwcmUsIGN1cikgPT4gcHJlICogY3VyLCAxKTtcblxuXHRjb25zdCBhbGxvY2F0ZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XG5cdFx0c2hhcGUgPSBBcnJheS5pc0FycmF5KHNoYXBlKSA/IHNoYXBlIDogW3NoYXBlXTtcblx0XHRjb25zdCBudW1FbGVtZW50cyA9IHNoYXBlLnJlZHVjZSgocHJlLCBjdXIpID0+IHByZSAqIGN1ciwgYmFzZVNpemUpO1xuXHRcdGNvbnN0IGRhdGEgPSBuZXcgdHlwZWRBcnJheShuZXcgU2hhcmVkQXJyYXlCdWZmZXIobnVtRWxlbWVudHMgKiAgdHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkpO1xuXG5cdFx0cmV0dXJuIG5ldyBCdWZmZXJBY2Nlc3Nvcih0aGlzLCBkYXRhLCBzaGFwZSk7XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRuYW1lOiBuYW1lLCBzaGFwZTogYmFzZVNoYXBlLCBzaXplOiBiYXNlU2l6ZSwgYWxsb2NhdGU6IGFsbG9jYXRlLFxuXHRcdHR5cGVkQXJyYXk6IHR5cGVkQXJyYXksXG5cdFx0dmFsdWVGcm9tQnVmZmVyOiB2YWx1ZUZyb21CdWZmZXIsXG5cdFx0c3RvcmVWYWx1ZUluQnVmZmVyOiBzdG9yZVZhbHVlSW5CdWZmZXIsXG5cdFx0ZnJvbUFycmF5OiBmcm9tQXJyYXksXG5cdFx0dG9TaGFyZWRBcnJheUJ1ZmZlcjogYXJyYXkgPT4ge1xuXHRcdFx0aWYgKGFycmF5LmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gU2hhcmVkQXJyYXlCdWZmZXIpXG5cdFx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdFx0dmFyIHNoYXJlZCA9IG5ldyB0eXBlZEFycmF5KG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihhcnJheS5sZW5ndGggKiAgdHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkpO1xuXHRcdFx0c2hhcmVkLnNldChhcnJheSk7XG5cdFx0XHRyZXR1cm4gc2hhcmVkO1xuXHRcdH1cblx0fTtcbn1cblxuZXhwb3J0cy5mbG9hdDMyID0gY3JlYXRlVHlwZURlc2NyaXB0b3IoXG5cdFwiZmxvYXQzMlwiLCBGbG9hdDMyQXJyYXksIFtdLCBidWZmZXIgPT4gYnVmZmVyLmdldCgwKSxcblx0KGJ1ZmZlciwgdmFsdWUpID0+IGJ1ZmZlci5zZXQodmFsdWUpLCB2ID0+IHZbMF0pO1xuZXhwb3J0cy5pbnQzMiA9IGNyZWF0ZVR5cGVEZXNjcmlwdG9yKFxuXHRcImludDMyXCIsIEludDMyQXJyYXksIFtdLCBidWZmZXIgPT4gYnVmZmVyLmdldCgwKSxcblx0KGJ1ZmZlciwgdmFsdWUpID0+IGJ1ZmZlci5zZXQodmFsdWUpLCB2ID0+IHZbMF0pO1xuZXhwb3J0cy51aW50OCA9IGNyZWF0ZVR5cGVEZXNjcmlwdG9yKFxuXHRcInVpbnQ4XCIsIFVpbnQ4QXJyYXksIFtdLCBidWZmZXIgPT4gYnVmZmVyLmdldCgwKSxcblx0KGJ1ZmZlciwgdmFsdWUpID0+IGJ1ZmZlci5zZXQodmFsdWUpLCB2ID0+IHZbMF0pO1xuXG5leHBvcnRzLnZlYzIgPSBjcmVhdGVUeXBlRGVzY3JpcHRvcihcblx0XCJ2ZWMyXCIsIEZsb2F0MzJBcnJheSwgWzJdLFxuXHRidWZmZXIgPT4gbmV3IFNoYWRlLlZlYzIoYnVmZmVyLmdldCgwKSwgYnVmZmVyLmdldCgxKSksIChidWZmZXIsIHZhbHVlKSA9PiB7XG5cdFx0YnVmZmVyLnNldCgwLCB2YWx1ZS54KTtcblx0XHRidWZmZXIuc2V0KDEsIHZhbHVlLnkpO1xuXHR9LCBTaGFkZS5WZWMyKTtcbmV4cG9ydHMudmVjMyA9IGNyZWF0ZVR5cGVEZXNjcmlwdG9yKFxuXHRcInZlYzNcIiwgRmxvYXQzMkFycmF5LCBbM10sXG5cdGJ1ZmZlciA9PiBuZXcgU2hhZGUuVmVjMyhuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5kYXRhLmJ1ZmZlciwgYnVmZmVyLm9mZnNldCAqIDQsIDMpKSxcblx0KGJ1ZmZlciwgdmFsdWUpID0+IHtcblx0XHRidWZmZXIuc2V0KDAsIHZhbHVlLngpO1xuXHRcdGJ1ZmZlci5zZXQoMSwgdmFsdWUueSk7XG5cdFx0YnVmZmVyLnNldCgyLCB2YWx1ZS56KTtcblx0fSwgU2hhZGUuVmVjMyk7XG5leHBvcnRzLnZlYzQgPSBjcmVhdGVUeXBlRGVzY3JpcHRvcihcblx0XCJ2ZWM0XCIsIEZsb2F0MzJBcnJheSwgWzRdLFxuXHRidWZmZXIgPT4gbmV3IFNoYWRlLlZlYzQoYnVmZmVyLmdldCgwKSwgYnVmZmVyLmdldCgxKSwgYnVmZmVyLmdldCgyKSxcblx0XHRcdFx0XHRcdFx0IGJ1ZmZlci5nZXQoMykpLFxuXHQoYnVmZmVyLCB2YWx1ZSkgPT4ge1xuXHRcdGJ1ZmZlci5zZXQoMCwgdmFsdWUueCk7XG5cdFx0YnVmZmVyLnNldCgxLCB2YWx1ZS55KTtcblx0XHRidWZmZXIuc2V0KDIsIHZhbHVlLnopO1xuXHRcdGJ1ZmZlci5zZXQoMywgdmFsdWUudyk7XG5cdH0sIFNoYWRlLlZlYzQpO1xuXG5leHBvcnRzLm1hdDIgPSBjcmVhdGVUeXBlRGVzY3JpcHRvcihcblx0XCJtYXQyXCIsIEZsb2F0MzJBcnJheSwgWzIsIDJdLFxuXHRidWZmZXIgPT4gbmV3IFNoYWRlLk1hdDIoYnVmZmVyLmdldCgwLCAwKSwgYnVmZmVyLmdldCgwLCAxKSxcblx0XHRcdFx0XHRcdFx0IGJ1ZmZlci5nZXQoMSwgMCksIGJ1ZmZlci5nZXQoMSwgMSkpLFxuXHQoYnVmZmVyLCB2YWx1ZSkgPT4ge1xuXHRcdGJ1ZmZlci5zZXQoMCwgMCwgdmFsdWUubTExKTtcblx0XHRidWZmZXIuc2V0KDAsIDEsIHZhbHVlLm0yMSk7XG5cdFx0YnVmZmVyLnNldCgxLCAwLCB2YWx1ZS5tMTIpO1xuXHRcdGJ1ZmZlci5zZXQoMSwgMSwgdmFsdWUubTIyKTtcblx0fSwgU2hhZGUuTWF0Mik7XG5cbmV4cG9ydHMubWF0MyA9IGNyZWF0ZVR5cGVEZXNjcmlwdG9yKFxuXHRcIm1hdDNcIiwgRmxvYXQzMkFycmF5LCBbMywgM10sXG5cdGJ1ZmZlciA9PiBuZXcgU2hhZGUuTWF0Myhcblx0XHRidWZmZXIuZ2V0KDAsIDApLCBidWZmZXIuZ2V0KDAsIDEpLCBidWZmZXIuZ2V0KDAsIDIpLCBidWZmZXIuZ2V0KDEsIDApLFxuXHRcdGJ1ZmZlci5nZXQoMSwgMSksIGJ1ZmZlci5nZXQoMSwgMiksIGJ1ZmZlci5nZXQoMiwgMCksIGJ1ZmZlci5nZXQoMiwgMSksXG5cdFx0YnVmZmVyLmdldCgyLCAyKSksXG5cdChidWZmZXIsIHZhbHVlKSA9PiB7XG5cdFx0YnVmZmVyLnNldCgwLCAwLCB2YWx1ZS5tMTEpO1xuXHRcdGJ1ZmZlci5zZXQoMCwgMSwgdmFsdWUubTIxKTtcblx0XHRidWZmZXIuc2V0KDAsIDIsIHZhbHVlLm0zMSk7XG5cdFx0YnVmZmVyLnNldCgxLCAwLCB2YWx1ZS5tMTIpO1xuXHRcdGJ1ZmZlci5zZXQoMSwgMSwgdmFsdWUubTIyKTtcblx0XHRidWZmZXIuc2V0KDEsIDIsIHZhbHVlLm0zMik7XG5cdFx0YnVmZmVyLnNldCgyLCAwLCB2YWx1ZS5tMTMpO1xuXHRcdGJ1ZmZlci5zZXQoMiwgMSwgdmFsdWUubTIzKTtcblx0XHRidWZmZXIuc2V0KDIsIDIsIHZhbHVlLm0zMyk7XG5cdH0sIFNoYWRlLk1hdDMpO1xuXG5leHBvcnRzLm1hdDQgPSBjcmVhdGVUeXBlRGVzY3JpcHRvcihcblx0XCJtYXQ0XCIsIEZsb2F0MzJBcnJheSwgWzQsIDRdLFxuXHRidWZmZXIgPT4gbmV3IFNoYWRlLk1hdDQoXG5cdFx0YnVmZmVyLmdldCgwLCAwKSwgYnVmZmVyLmdldCgwLCAxKSwgYnVmZmVyLmdldCgwLCAyKSwgYnVmZmVyLmdldCgwLCAzKSxcblx0XHRidWZmZXIuZ2V0KDEsIDApLCBidWZmZXIuZ2V0KDEsIDEpLCBidWZmZXIuZ2V0KDEsIDIpLCBidWZmZXIuZ2V0KDEsIDMpLFxuXHRcdGJ1ZmZlci5nZXQoMiwgMCksIGJ1ZmZlci5nZXQoMiwgMSksIGJ1ZmZlci5nZXQoMiwgMiksIGJ1ZmZlci5nZXQoMiwgMyksXG5cdFx0YnVmZmVyLmdldCgzLCAwKSwgYnVmZmVyLmdldCgzLCAxKSwgYnVmZmVyLmdldCgzLCAyKSwgYnVmZmVyLmdldCgzLCAzKSksXG5cdChidWZmZXIsIHZhbHVlKSA9PiB7XG5cdFx0YnVmZmVyLnNldCgwLCAwLCB2YWx1ZS5tMTEpO1xuXHRcdGJ1ZmZlci5zZXQoMCwgMSwgdmFsdWUubTIxKTtcblx0XHRidWZmZXIuc2V0KDAsIDIsIHZhbHVlLm0zMSk7XG5cdFx0YnVmZmVyLnNldCgwLCAzLCB2YWx1ZS5tNDEpO1xuXHRcdGJ1ZmZlci5zZXQoMSwgMCwgdmFsdWUubTEyKTtcblx0XHRidWZmZXIuc2V0KDEsIDEsIHZhbHVlLm0yMik7XG5cdFx0YnVmZmVyLnNldCgxLCAyLCB2YWx1ZS5tMzIpO1xuXHRcdGJ1ZmZlci5zZXQoMSwgMywgdmFsdWUubTQyKTtcblx0XHRidWZmZXIuc2V0KDIsIDAsIHZhbHVlLm0xMyk7XG5cdFx0YnVmZmVyLnNldCgyLCAxLCB2YWx1ZS5tMjMpO1xuXHRcdGJ1ZmZlci5zZXQoMiwgMiwgdmFsdWUubTMzKTtcblx0XHRidWZmZXIuc2V0KDIsIDMsIHZhbHVlLm00Myk7XG5cdFx0YnVmZmVyLnNldCgzLCAwLCB2YWx1ZS5tMTQpO1xuXHRcdGJ1ZmZlci5zZXQoMywgMSwgdmFsdWUubTI0KTtcblx0XHRidWZmZXIuc2V0KDMsIDIsIHZhbHVlLm0zNCk7XG5cdFx0YnVmZmVyLnNldCgzLCAzLCB2YWx1ZS5tNDQpO1xuXHR9LCBTaGFkZS5NYXQ0KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XG5cbmNvbnN0IE5vZGVDb2xsZWN0aW9uID0gcmVxdWlyZShcIi4vbm9kZV9jb2xsZWN0aW9uXCIpO1xuY29uc3QgT3BlcmF0b3IgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3JcIik7XG5jb25zdCBjb21waWxlciA9IHJlcXVpcmUoXCIuLi9jb21waWxlclwiKTtcblxuY29uc3QgZGV0ZXJtaW5lTm9kZUlucHV0cyA9IHJlcXVpcmUoXCIuLi9hbmFseXNpcy9kZXRlcm1pbmVfbm9kZV9pbnB1dHNcIik7XG5cbmxldCBjb3VudCA9IDE7XG5cbmNsYXNzIE5vZGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXHRjb25zdHJ1Y3Rvcih7bmFtZSA9IFwidW5uYW1lZCBub2RlIFwiICsgY291bnQrKywgb3BlcmF0b3IgPSBPcGVyYXRvci5kZWZhdWx0T3BlcmF0b3J9ID0ge30pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLm5leHQgPSBbXTtcblx0XHR0aGlzLnByZXYgPSBbXTtcblx0XHR0aGlzLmZpZWxkcyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLl9vcGVyYXRvciA9IG9wZXJhdG9yO1xuXHRcdHRoaXMuX2NhY2hlZElucHV0cyA9IG51bGw7XG5cdH1cblxuXHRnZXQgb3BlcmF0b3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29wZXJhdG9yO1xuXHR9XG5cblx0c2V0IG9wZXJhdG9yKG9wZXJhdG9yKSB7XG5cdFx0dGhpcy5fb3BlcmF0b3IgPSBvcGVyYXRvcjtcblx0XHR0aGlzLl90eXBlQ2hhbmdlZCgpO1xuXHR9XG5cblx0c2V0RmllbGQobmFtZSwgYnVmZmVyKSB7XG5cdFx0aWYgKHRoaXMuZmllbGRzLmhhcyhuYW1lKSlcblx0XHRcdHRoaXMuZmllbGRzLmRlbGV0ZShuYW1lKTtcblxuXHRcdHRoaXMuZmllbGRzLnNldChuYW1lLCBidWZmZXIpO1xuXHRcdHRoaXMuX3R5cGVDaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyZW1vdmVGaWVsZChuYW1lKSB7XG5cdFx0dGhpcy5maWVsZHMuZGVsZXRlKG5hbWUpO1xuXHRcdHRoaXMuX3R5cGVDaGFuZ2VkKCk7XG5cdH1cblxuXHRwaXBlKC4uLmRlc3RpbmF0aW9ucykge1xuXHRcdGRlc3RpbmF0aW9ucy5mb3JFYWNoKGRlc3RpbmF0aW9uID0+IHtcblx0XHRcdGFzc2VydChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIE5vZGUpO1xuXG5cdFx0XHRpZiAodGhpcy5uZXh0LmluZGV4T2YoZGVzdGluYXRpb24pID09PSAtMSkge1xuXHRcdFx0XHRhc3NlcnQoZGVzdGluYXRpb24ucHJldi5pbmRleE9mKHRoaXMpID09PSAtMSk7XG5cdFx0XHRcdHRoaXMubmV4dC5wdXNoKGRlc3RpbmF0aW9uKTtcblx0XHRcdFx0ZGVzdGluYXRpb24ucHJldi5wdXNoKHRoaXMpO1xuXHRcdFx0XHRkZXN0aW5hdGlvbi5fdHlwZUNoYW5nZWQoKTtcblx0XHRcdH1cblxuXHRcdFx0YXNzZXJ0KGRlc3RpbmF0aW9uLnByZXYuaW5kZXhPZih0aGlzKSAhPT0gLTEpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIG5ldyBOb2RlQ29sbGVjdGlvbihkZXN0aW5hdGlvbnMpO1xuXHR9XG5cblx0dW5waXBlKC4uLmRlc3RpbmF0aW9ucykge1xuXHRcdGlmIChkZXN0aW5hdGlvbnMubGVuZ3RoID09PSAwKVxuXHRcdFx0ZGVzdGluYXRpb25zID0gdGhpcy5uZXh0LnNsaWNlKCk7XG5cdFx0ZGVzdGluYXRpb25zLmZvckVhY2goZGVzdGluYXRpb24gPT4ge1xuXHRcdFx0YXNzZXJ0KGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgTm9kZSk7XG5cblx0XHRcdGNvbnN0IG5leHRJZHggPSB0aGlzLm5leHQuaW5kZXhPZihkZXN0aW5hdGlvbik7XG5cdFx0XHRpZiAobmV4dElkeCAhPT0gLTEpIHtcblx0XHRcdFx0Y29uc3QgcHJldklkeCA9IGRlc3RpbmF0aW9uLnByZXYuaW5kZXhPZih0aGlzKTtcblx0XHRcdFx0YXNzZXJ0KHByZXZJZHggIT09IC0xKTtcblx0XHRcdFx0dGhpcy5uZXh0LnNwbGljZShuZXh0SWR4LCAxKTtcblx0XHRcdFx0ZGVzdGluYXRpb24ucHJldi5zcGxpY2UocHJldklkeCwgMSk7XG5cdFx0XHRcdGRlc3RpbmF0aW9uLl90eXBlQ2hhbmdlZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRhc3NlcnQoZGVzdGluYXRpb24ucHJldi5pbmRleE9mKHRoaXMpID09PSAtMSk7XG5cdFx0fSk7XG5cdH1cblxuXHRkZXRlcm1pbmVBdmFpbGFibGVJbnB1dHMoKSB7XG5cdFx0aWYgKHRoaXMuX2NhY2hlZElucHV0cylcblx0XHRcdHJldHVybiB0aGlzLl9jYWNoZWRJbnB1dHM7XG5cdFx0cmV0dXJuIGRldGVybWluZU5vZGVJbnB1dHModGhpcyk7Ly8udGhlbihpbnB1dFRhYmxlID0+IHRoaXMuX2lucHV0VGFibGUgPSBpbnB1dFRhYmxlKTtcblx0fVxuXG5cdGRldGVybWluZVVzZWRJbnB1dHMoKSB7XG5cdFx0Y29uc3QgaW5wdXRzID0gdGhpcy5kZXRlcm1pbmVBdmFpbGFibGVJbnB1dHMoKTtcblx0XHRyZXR1cm4gdGhpcy5vcGVyYXRvci5kZXRlcm1pbmVVc2VkSW5wdXRzKG5ldyBNYXAoWy4uLmlucHV0c10pLCB0aGlzKTtcblx0fVxuXG5cdGRldGVybWluZU91dHB1dHMoKSB7XG5cdFx0Y29uc3QgaW5wdXRzID0gdGhpcy5kZXRlcm1pbmVBdmFpbGFibGVJbnB1dHMoKTtcblx0XHRyZXR1cm4gdGhpcy5vcGVyYXRvci5kZXRlcm1pbmVGaW5hbE91dHB1dChuZXcgTWFwKFsuLi5pbnB1dHNdKSwgdGhpcyk7XG5cdH1cblxuXHRjcmVhdGVQcm9ncmFtVG9Db21wdXRlKG91dHB1dHMsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gY29tcGlsZXIuY3JlYXRlUHJvZ3JhbSh0aGlzLCBvdXRwdXRzLCBvcHRpb25zKTtcblx0fVxuXG5cdF90eXBlQ2hhbmdlZChhbHJlYWR5SW5mb3JtZWROb2RlcyA9IG5ldyBTZXQoKSkge1xuXHRcdHRoaXMuX2NhY2hlZElucHV0cyA9IG51bGw7XG5cdFx0dGhpcy5lbWl0KFwidHlwZS1jaGFuZ2VcIik7XG5cdFx0dGhpcy5uZXh0LmZvckVhY2gobmV4dCA9PiB7XG5cdFx0XHRpZiAoYWxyZWFkeUluZm9ybWVkTm9kZXMuaGFzKG5leHQpKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRhbHJlYWR5SW5mb3JtZWROb2Rlcy5hZGQobmV4dCk7XG5cdFx0XHRuZXh0Ll90eXBlQ2hhbmdlZChhbHJlYWR5SW5mb3JtZWROb2Rlcylcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG5mdW5jdGlvbiBpc0JhY2t3YXJkc1JlYWNoYWJsZShub2RlVG9SZWFjaCwgc3RhcnROb2RlLFxuXHRcdFx0XHRcdFx0XHQgIHZpc2l0ZWQgPSBuZXcgU2V0KCkpIHtcblx0dmlzaXRlZC5hZGQoc3RhcnROb2RlKTtcblx0cmV0dXJuIHN0YXJ0Tm9kZS5wcmV2LnNvbWUocHJldk5vZGUgPT4ge1xuXHRcdGlmIChwcmV2Tm9kZSA9PT0gbm9kZVRvUmVhY2gpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAodmlzaXRlZC5oYXMocHJldk5vZGUpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0dmlzaXRlZC5hZGQocHJldk5vZGUpO1xuXHRcdHJldHVybiBpc0JhY2t3YXJkc1JlYWNoYWJsZShub2RlVG9SZWFjaCwgcHJldk5vZGUsIHZpc2l0ZWQpO1xuXHR9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jbGFzcyBOb2RlQ29sbGVjdGlvbiBleHRlbmRzIFNldCB7XG5cdGNvbnN0cnVjdG9yKG5vZGVzLCBiYXNlU2V0KSB7XG5cdFx0c3VwZXIobm9kZXMpO1xuXHRcdHRoaXMuX2Jhc2VTZXQgPSBiYXNlU2V0O1xuXHR9XG5cblx0cGlwZSguLi5kZXN0aW5hdGlvbnMpIHtcblx0XHR0aGlzLmZvckVhY2gobm9kZSA9PiBub2RlLnBpcGUoLi4uZGVzdGluYXRpb25zKSk7XG5cdFx0cmV0dXJuIG5ldyBOb2RlQ29sbGVjdGlvbihkZXN0aW5hdGlvbnMsIHRoaXMuX2Jhc2VTZXRDb21wbGVtZW50KCkpO1xuXHR9XG5cblx0c2VsZWN0KC4uLmZpbHRlcnMpIHtcblx0XHRsZXQgZmlsdGVyID0gbm9kZSA9PiB7XG5cdFx0XHRyZXR1cm4gZmlsdGVycy5pbmRleE9mKG5vZGUpICE9PSAtMVxuXHRcdH07XG5cdFx0aWYgKGZpbHRlcnMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaWx0ZXJzWzBdID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRmaWx0ZXIgPSBmaWx0ZXJzWzBdO1xuXG5cdFx0cmV0dXJuIG5ldyBOb2RlQ29sbGVjdGlvbihbLi4udGhpc10uZmlsdGVyKGZpbHRlciksIHRoaXMpO1xuXHR9XG5cblx0ZGVzZWxlY3QoKSB7XG5cdFx0aWYgKHRoaXMuX2Jhc2VTZXQpXG5cdFx0XHRyZXR1cm4gbmV3IE5vZGVDb2xsZWN0aW9uKFsuLi50aGlzLCAuLi50aGlzLl9iYXNlU2V0XSxcblx0XHRcdFx0XHRcdFx0XHRcdCAgdGhpcy5fYmFzZVNldC5fYmFzZVNldCk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfYmFzZVNldENvbXBsZW1lbnQoKSB7XG5cdFx0aWYgKHRoaXMuX2Jhc2VTZXQpXG5cdFx0XHRyZXR1cm4gbmV3IE5vZGVDb2xsZWN0aW9uKFsuLi50aGlzLl9iYXNlU2V0XS5maWx0ZXIobm9kZSA9PiB7XG5cdFx0XHRcdHJldHVybiAhdGhpcy5oYXMobm9kZSk7XG5cdFx0XHR9KSxcblx0XHRcdFx0XHRcdFx0XHRcdCAgdGhpcy5fYmFzZVNldC5fYmFzZVNldCk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTm9kZUNvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY2xhc3MgRmlsdGVyT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWVzID0gbmV3IFNldCgpLCB0eXBlID0gRmlsdGVyT3BlcmF0b3IudHlwZS5yZW1vdmUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKVxuICAgICAgICAgICAgdGhpcy5fbmFtZXMgPSBuZXcgU2V0KG5hbWVzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fbmFtZXMgPSBuYW1lcztcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgfVxuXG4gICAgZGV0ZXJtaW5lVXNlZElucHV0cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBkZXRlcm1pbmVGaW5hbE91dHB1dChpbnB1dHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaCgoZmllbGQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICgodGhpcy5fdHlwZSA9PT0gRmlsdGVyT3BlcmF0b3IudHlwZS5yZW1vdmUgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkgfHwgKHRoaXMuX3R5cGUgPT09IEZpbHRlck9wZXJhdG9yLnR5cGUua2VlcCAmJiB0aGlzLl9uYW1lcy5oYXMobmFtZSkpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQobmFtZSwgZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBkZXRlcm1pbmVBbGxvY2F0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICB9XG59XG5cbkZpbHRlck9wZXJhdG9yLnR5cGUgPSB7XG4gICAgcmVtb3ZlOiBcInJlbW92ZVwiLFxuICAgIGtlZXA6IFwia2VlcFwiXG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJPcGVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgU2hhZGUgPSByZXF1aXJlKFwic2hhZGUuanNcIik7XG5cbmNvbnN0IGJ1aWxkU2hhZGVPcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvYnVpbGRfc2hhZGVfb3B0aW9uc1wiKTtcbmNvbnN0IHRvRmllbGREZXNjcmlwdG9yID0gcmVxdWlyZShcIi4uL3V0aWwvdG9fZmllbGRfZGVzY3JpcHRvclwiKTtcblxubGV0IGNvdW50ID0gMTtcbmNvbnN0IHNoYWRlT3B0aW9ucyA9IHtcbiAgICBsb2M6IHRydWUsXG4gICAgdmFsaWRhdGU6IHRydWUsXG4gICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgIHNhbml0aXplOiB0cnVlLFxuICAgIGVudHJ5OiBcImV2YWx1YXRlXCJcbn07XG5cbmNsYXNzIE9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7bmFtZSA9IFwidW5uYW1lZCBvcGVyYXRvciBcIiArIGNvdW50KyssIGV2YWx1YXRlfSA9IHt9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXZhbHVhdGUgPSBldmFsdWF0ZTtcbiAgICB9XG5cbiAgICBkZXRlcm1pbmVVc2VkSW5wdXRzKGlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMuZXZhbHVhdGUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuXG4gICAgICAgIGNvbnN0IHVzZWRQYXJhbWV0ZXJzID0gU2hhZGUuZGV0ZXJtaW5lVXNlZFBhcmFtZXRlcnModGhpcy5ldmFsdWF0ZSwgIGJ1aWxkU2hhZGVPcHRpb25zKGlucHV0cywgc2hhZGVPcHRpb25zKSk7XG4gICAgICAgIGNvbnN0IHVzZWQgPSBbLi4uaW5wdXRzXS5maWx0ZXIoKFtuYW1lLCBmaWVsZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VkUGFyYW1ldGVycy5zaGFkZXJQYXJhbWV0ZXJzLmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAodXNlZCk7XG4gICAgfVxuXG4gICAgZGV0ZXJtaW5lRmluYWxPdXRwdXQoaW5wdXRzLCBub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmFsdWF0ZSlcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG5cbiAgICAgICAgY29uc3QgcmV0dXJuVHlwZUluZm8gPSBTaGFkZS5kZXRlcm1pbmVSZXR1cm5UeXBlKHRoaXMuZXZhbHVhdGUsIGJ1aWxkU2hhZGVPcHRpb25zKGlucHV0cywgc2hhZGVPcHRpb25zKSk7XG5cbiAgICAgICAgaWYgKHJldHVyblR5cGVJbmZvLnR5cGUgPT09IFNoYWRlLlRZUEVTLlVOREVGSU5FRClcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG5cbiAgICAgICAgaWYgKHJldHVyblR5cGVJbmZvLnR5cGUgPT09IFNoYWRlLlRZUEVTLk9CSkVDVClcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXR1cm5UeXBlSW5mby5wcm9wZXJ0aWVzKS5yZWR1Y2UoKG91dHB1dHMsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0b0ZpZWxkRGVzY3JpcHRvcihyZXR1cm5UeXBlSW5mby5wcm9wZXJ0aWVzW25hbWVdLCBuYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICBmaWVsZC5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy5zZXQobmFtZSwgZmllbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICAgICAgfSwgbmV3IE1hcChpbnB1dHMpKTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRvciByZXR1cm4gdHlwZSBoYXMgdG8gYmUgdW5kZWZpbmVkIG9yIG9iamVjdCFcIik7XG4gICAgfVxuXG4gICAgZGV0ZXJtaW5lQWxsb2NhdGlvbnMoaW5wdXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmFsdWF0ZSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KCk7XG5cbiAgICAgICAgY29uc3Qgd29ya1NldCA9IG5ldyBTaGFkZS5Xb3JraW5nU2V0KCk7XG4gICAgICAgIHdvcmtTZXQucGFyc2UodGhpcy5ldmFsdWF0ZSwgc2hhZGVPcHRpb25zKTtcbiAgICAgICAgd29ya1NldC5hbmFseXplKGJ1aWxkU2hhZGVPcHRpb25zKGlucHV0cykuaW5qZWN0LCB1bmRlZmluZWQsIE9iamVjdC5hc3NpZ24oe2V4dHJhY3RBbGxvY2F0aW9uczogdHJ1ZX0sIHNoYWRlT3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gd29ya1NldC5wcm9jZXNzaW5nRGF0YS5hbGxvY2F0aW9ucyB8fCBuZXcgU2V0KCk7XG4gICAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRvcjtcbmV4cG9ydHMuZGVmYXVsdE9wZXJhdG9yID0gbmV3IE9wZXJhdG9yKHtuYW1lOiBcImZhc3RsYW5lLWRlZmF1bHQtb3BlcmF0b3JcIn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNsYXNzIFJlbmFtZU9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5hbWVNYXApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZW5hbWUgT3BlcmF0b3JcIjtcbiAgICAgICAgdGhpcy5fcmVuYW1lTWFwID0gcmVuYW1lTWFwO1xuICAgIH1cblxuICAgIGRldGVybWluZVVzZWRJbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZGV0ZXJtaW5lRmluYWxPdXRwdXQoaW5wdXRzLCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goKGZpZWxkLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuYW1lTWFwLmhhcyhmaWVsZC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHRoaXMuX3JlbmFtZU1hcC5nZXQoZmllbGQubmFtZSksIGZpZWxkKTtcblxuICAgICAgICAgICAgcmVzdWx0LnNldChuYW1lLCBmaWVsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGRldGVybWluZUFsbG9jYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCgpO1xuICAgIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUmVuYW1lT3BlcmF0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgU2hhZGUgPSByZXF1aXJlKFwic2hhZGUuanNcIik7XG5cbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoXCIuLi9maWVsZC9idWZmZXJfYWNjZXNzb3JcIik7XG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoXCIuLi9maWVsZC90eXBlc1wiKTtcbmNvbnN0IGJ1aWxkU2hhZGVPcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWwvYnVpbGRfc2hhZGVfb3B0aW9uc1wiKTtcbmNvbnN0IHRvRmllbGREZXNjcmlwdG9yID0gcmVxdWlyZShcIi4uL3V0aWwvdG9fZmllbGRfZGVzY3JpcHRvclwiKTtcblxuY29uc3Qgc2hhZGVPcHRpb25zID0ge1xuICAgIGxvYzogdHJ1ZSxcbiAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgZW50cnk6IFwiZXZhbHVhdGVcIixcbiAgICBleHRyYWN0QWxsb2NhdGlvbnM6IHRydWVcbn07XG5cbmNvbnN0IHdvcmtlclNrZWxldG9uID0gYFxuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQuZGF0YS5pbnB1dDtcbiAgICAgICAgY29uc3QgaW5wdXRTaGFwZXMgPSBldmVudC5kYXRhLmlucHV0U2hhcGVzO1xuICAgICAgICBpbnB1dFNoYXBlcy5mb3JFYWNoKChzaGFwZSwgbmFtZSkgPT4gaW5wdXRbbmFtZV0uc2hhcGUgPSBzaGFwZSk7XG4gICAgICAgIGNvbnN0IG1lbW9yeSA9IGV2ZW50LmRhdGEubWVtb3J5O1xuICAgICAgICBjb25zdCBtZW1vcnlTaGFwZXMgPSBldmVudC5kYXRhLm1lbW9yeVNoYXBlcztcbiAgICAgICAgbWVtb3J5U2hhcGVzLmZvckVhY2goKHNoYXBlLCBuYW1lKSA9PiBtZW1vcnlbbmFtZV0uc2hhcGUgPSBzaGFwZSk7ICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoaW5wdXQsIG1lbW9yeSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2hhcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdFtuYW1lXS5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2gocmVzdWx0W25hbWVdLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgc2hhcGVzLnNldChuYW1lLCByZXN1bHRbbmFtZV0uc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5zaGFwZXMgPSBzaGFwZXM7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3Jlc3VsdCwgc2hhcGVzfSk7XG4gICAgfVxuICAgIGNvbnN0IGV2YWx1YXRlID0gYDtcblxuY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG5cbmNsYXNzIENQVVBsYXRmb3JtIHtcbiAgICBjb21waWxlKGNvbXB1dGVOb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29tcHV0ZU5vZGUub3BlcmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZW52ID0gYnVpbGRTaGFkZU9wdGlvbnMoY29tcHV0ZU5vZGUuZW52KS5pbmplY3Q7XG4gICAgICAgIGNvbnN0IGVudktleSA9IEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oe3VzZVNJTUQ6IG9wdGlvbnMudXNlU0lNRH0sIGVudikpO1xuICAgICAgICBjb25zdCBldmFsdWF0ZUZuID0gY29tcHV0ZU5vZGUub3BlcmF0b3IuZXZhbHVhdGUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGNhY2hlLmhhcyhldmFsdWF0ZUZuKSkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRTaWduYXR1cmVDYWNoZSA9IGNhY2hlLmdldChldmFsdWF0ZUZuKTtcbiAgICAgICAgICAgIGNvbnN0IGV2YWx1YXRlRnVuY3Rpb25zID0gaW5wdXRTaWduYXR1cmVDYWNoZS5nZXQoZW52S2V5KTtcbiAgICAgICAgICAgIGlmIChldmFsdWF0ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVOb2RlLmV2YWx1YXRlRGlyZWN0ID0gZXZhbHVhdGVGdW5jdGlvbnMuZGlyZWN0O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZVdlYldvcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXJJbmZvID0gdGhpcy5jcmVhdGVXZWJXb3JrZXIoZXZhbHVhdGVGdW5jdGlvbnMuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU5vZGUuZXZhbHVhdGVXb3JrZXIgPSB3b3JrZXJJbmZvLmZuO1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS53b3JrZXIgPSB3b3JrZXJJbmZvLndvcmtlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcHV0ZU5vZGUuYWxsb2NhdGlvbnMuZm9yRWFjaChhbGxvY2F0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG9jYXRpb24uaXNUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NvciA9IFR5cGVzLnZlYzQuYWxsb2NhdGUoW2FsbG9jYXRpb24ud2lkdGgsIGFsbG9jYXRpb24uaGVpZ2h0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdID0gYWNjZXNzb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVOb2RlLm1lbW9yeVthbGxvY2F0aW9uLnByb3BlcnR5TmFtZV0uc2hhcGUgPSBhY2Nlc3Nvci5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0b0ZpZWxkRGVzY3JpcHRvcihhbGxvY2F0aW9uLmVsZW1lbnRzLmV4dHJhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gZGVzY3JpcHRvci50eXBlLmFsbG9jYXRlKGFsbG9jYXRpb24uZWxlbWVudHMuc3RhdGljU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdID0gYWNjZXNzb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVOb2RlLm1lbW9yeVthbGxvY2F0aW9uLnByb3BlcnR5TmFtZV0uc2hhcGUgPSBhY2Nlc3Nvci5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcHV0ZU5vZGUuZXZhbHVhdGVEaXJlY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtzZXQgPSBuZXcgU2hhZGUuV29ya2luZ1NldCgpO1xuICAgICAgICAgICAgd29ya3NldC5wYXJzZShldmFsdWF0ZUZuLCBzaGFkZU9wdGlvbnMpO1xuXG4gICAgICAgICAgICB3b3Jrc2V0LmFuYWx5emUoZW52LCB1bmRlZmluZWQsIHNoYWRlT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtZW1JbmplY3QgPSB7fTtcbiAgICAgICAgICAgIGNvbXB1dGVOb2RlLmFsbG9jYXRpb25zLmZvckVhY2goYWxsb2NhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG9jYXRpb24uaXNUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gVHlwZXMudmVjNC5hbGxvY2F0ZShbYWxsb2NhdGlvbi53aWR0aCwgYWxsb2NhdGlvbi5oZWlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU5vZGUubWVtb3J5W2FsbG9jYXRpb24ucHJvcGVydHlOYW1lXSA9IGFjY2Vzc29yLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVOb2RlLm1lbW9yeVthbGxvY2F0aW9uLnByb3BlcnR5TmFtZV0uc2hhcGUgPSBhY2Nlc3Nvci5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgbWVtSW5qZWN0W2FsbG9jYXRpb24ucHJvcGVydHlOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5URVhUVVJFLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGFsbG9jYXRpb24ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGFsbG9jYXRpb24uaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRvRmllbGREZXNjcmlwdG9yKGFsbG9jYXRpb24uZWxlbWVudHMuZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NvciA9IGRlc2NyaXB0b3IudHlwZS5hbGxvY2F0ZShhbGxvY2F0aW9uLmVsZW1lbnRzLnN0YXRpY1NpemUpO1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdID0gYWNjZXNzb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU5vZGUubWVtb3J5W2FsbG9jYXRpb24ucHJvcGVydHlOYW1lXS5zaGFwZSA9IGFjY2Vzc29yLnNoYXBlO1xuICAgICAgICAgICAgICAgICAgICBtZW1JbmplY3RbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuQVJSQVksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTaXplOiBhbGxvY2F0aW9uLmVsZW1lbnRzLnN0YXRpY1NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogYWxsb2NhdGlvbi5lbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdvcmtzZXQuaW5qZWN0TWVtb3J5KHtcbiAgICAgICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG1lbUluamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjYWNoZS5oYXMoZXZhbHVhdGVGbikpXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KGV2YWx1YXRlRm4sIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFNpZ25hdHVyZUNhY2hlID0gY2FjaGUuZ2V0KGV2YWx1YXRlRm4pO1xuICAgICAgICAgICAgY29uc3QgZXZhbHVhdGVGdW5jdGlvbnMgPSB0aGlzLmNyZWF0ZUV2YWx1YXRlRnVuY3Rpb24oY29tcHV0ZU5vZGUsIHdvcmtzZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlV2ViV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2VySW5mbyA9IHRoaXMuY3JlYXRlV2ViV29ya2VyKGV2YWx1YXRlRnVuY3Rpb25zLnNyYyk7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVGdW5jdGlvbnMud29ya2VyID0gd29ya2VySW5mby5mbjtcbiAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS53b3JrZXIgPSB3b3JrZXJJbmZvLndvcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2lnbmF0dXJlQ2FjaGUuc2V0KGVudktleSwgZXZhbHVhdGVGdW5jdGlvbnMpO1xuXG4gICAgICAgICAgICBjb21wdXRlTm9kZS5ldmFsdWF0ZURpcmVjdCA9IGV2YWx1YXRlRnVuY3Rpb25zLmRpcmVjdDtcbiAgICAgICAgICAgIGNvbXB1dGVOb2RlLmV2YWx1YXRlV29ya2VyID0gZXZhbHVhdGVGdW5jdGlvbnMud29ya2VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlRXZhbHVhdGVGdW5jdGlvbihjb21wdXRlTm9kZSwgd29ya1NldCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgbmFtZSA9IGNvbXB1dGVOb2RlLm9wZXJhdG9yLm5hbWUucmVwbGFjZSgvIHwtL2csICdfJyk7XG4gICAgICAgIGxldCBzcmMgPSB3b3JrU2V0LmNvbXBpbGVUb0Zhc3RsYW5lKE9iamVjdC5hc3NpZ24ob3B0aW9ucywge25hbWU6IG5hbWV9KSk7XG4gICAgICAgIGxldCBldmFsdWF0ZUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIHNyYzogc3JjXG4gICAgICAgIH07XG4gICAgICAgIG5hbWUgPSBuYW1lICsgKG9wdGlvbnMudXNlU0lNRCA/IFwiX3NpbWRcIiA6IFwiXCIpO1xuICAgICAgICBsZXQgbmV3U3JjID0gYCgke3NyY30pLy8jIHNvdXJjZVVSTD0ke25hbWV9LmpzYDtcbiAgICAgICAgZXZhbHVhdGVGdW5jdGlvbnMuZGlyZWN0ID0gKDAsIGV2YWwpKG5ld1NyYyk7XG5cbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlRnVuY3Rpb25zO1xuICAgIH1cblxuICAgIGNyZWF0ZVdlYldvcmtlcihzcmMpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyU3JjID0gd29ya2VyU2tlbGV0b24gKyBzcmM7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbd29ya2VyU3JjXSwge3R5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJ9KTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3b3JrZXI6IHdvcmtlcixcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoaW5wdXQsIG1lbW9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7aW5wdXQsIG1lbW9yeX07XG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zZmVyID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRTaGFwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVtb3J5U2hhcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0W25hbWVdLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXIucHVzaChpbnB1dFtuYW1lXS5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRTaGFwZXMuc2V0KG5hbWUsIGlucHV0W25hbWVdLnNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIG1lbW9yeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtb3J5W25hbWVdLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXIucHVzaChtZW1vcnlbbmFtZV0uYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeVNoYXBlcy5zZXQobmFtZSwgbWVtb3J5W25hbWVdLnNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLmlucHV0U2hhcGVzID0gaW5wdXRTaGFwZXM7XG4gICAgICAgICAgICAgICAgZGF0YS5tZW1vcnlTaGFwZXMgPSBtZW1vcnlTaGFwZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBldmVudC5kYXRhLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlcyA9IGV2ZW50LmRhdGEuc2hhcGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzLmZvckVhY2goKHNoYXBlLCBuYW1lKSA9PiByZXN1bHRbbmFtZV0uc2hhcGUgPSBzaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b1BsYXRmb3JtVmFsdWUoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgICAgICBpZiAoYnVmZmVyLnNoYXBlICYmIGJ1ZmZlci5zaGFwZS5sZW5ndGggPT09IDEgJiYgYnVmZmVyLnNoYXBlWzBdID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5nZXQoMCk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5fbmRhcnJheS5kYXRhO1xuICAgICAgICAgICAgZGF0YS5zaGFwZSA9IGJ1ZmZlci5zaGFwZTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBkaXNwb3NlTm9kZShjb21wdXRlTm9kZSkge1xuICAgICAgICBpZiAoY29tcHV0ZU5vZGUud29ya2VyKVxuICAgICAgICAgICAgY29tcHV0ZU5vZGUud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IENQVVBsYXRmb3JtKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IFNoYWRlID0gcmVxdWlyZShcInNoYWRlLmpzXCIpO1xuXG5jb25zdCBidWlsZFNoYWRlT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi91dGlsL2J1aWxkX3NoYWRlX29wdGlvbnNcIik7XG5jb25zdCB0b0ZpZWxkRGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi91dGlsL3RvX2ZpZWxkX2Rlc2NyaXB0b3JcIik7XG5jb25zdCB0b1NoYWRlVmFsdWUgPSByZXF1aXJlKFwiLi4vdXRpbC90b19zaGFkZV92YWx1ZVwiKTtcblxuY29uc3Qgc2hhZGVPcHRpb25zID0ge1xuICAgIGVudHJ5OiBcImV2YWx1YXRlXCIsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgZXh0cmFjdEFsbG9jYXRpb25zOiB0cnVlXG59O1xuXG5nbG9iYWwuVmVjMiA9IFNoYWRlLlZlYzI7XG5nbG9iYWwuVmVjMyA9IFNoYWRlLlZlYzM7XG5nbG9iYWwuVmVjNCA9IFNoYWRlLlZlYzQ7XG5nbG9iYWwuTWF0MiA9IFNoYWRlLk1hdDI7XG5nbG9iYWwuTWF0MyA9IFNoYWRlLk1hdDM7XG5nbG9iYWwuTWF0NCA9IFNoYWRlLk1hdDQ7XG5cblxuY2xhc3MgRGVidWdQbGF0Zm9ybSB7XG4gICAgY29tcGlsZShjb21wdXRlTm9kZSkge1xuICAgICAgICBpZiAoIWNvbXB1dGVOb2RlLm9wZXJhdG9yKVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuXG4gICAgICAgIGNvbnN0IHdvcmtzZXQgPSBuZXcgU2hhZGUuV29ya2luZ1NldCgpO1xuICAgICAgICB3b3Jrc2V0LnBhcnNlKGNvbXB1dGVOb2RlLm9wZXJhdG9yLmV2YWx1YXRlLCBzaGFkZU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbnYgPSBidWlsZFNoYWRlT3B0aW9ucyhjb21wdXRlTm9kZS5lbnYpLmluamVjdDtcbiAgICAgICAgd29ya3NldC5hbmFseXplKGVudiwgdW5kZWZpbmVkLCBzaGFkZU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZW1JbmplY3QgPSB7fTtcbiAgICAgICAgY29tcHV0ZU5vZGUuYWxsb2NhdGlvbnMuZm9yRWFjaChhbGxvY2F0aW9uID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxvY2F0aW9uLmlzVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gVHlwZXMudmVjNC5hbGxvY2F0ZShbYWxsb2NhdGlvbi53aWR0aCwgYWxsb2NhdGlvbi5oZWlnaHRdKTtcbiAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdID0gdG9TaGFkZVZhbHVlKGFjY2Vzc29yKTtcbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdLnNoYXBlID0gYWNjZXNzb3Iuc2hhcGU7XG4gICAgICAgICAgICAgICAgbWVtSW5qZWN0W2FsbG9jYXRpb24ucHJvcGVydHlOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuT0JKRUNULFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuVEVYVFVSRSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGFsbG9jYXRpb24ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYWxsb2NhdGlvbi5oZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdG9GaWVsZERlc2NyaXB0b3IoYWxsb2NhdGlvbi5lbGVtZW50cy5leHRyYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzb3IgPSBkZXNjcmlwdG9yLnR5cGUuYWxsb2NhdGUoYWxsb2NhdGlvbi5lbGVtZW50cy5zdGF0aWNTaXplKTtcbiAgICAgICAgICAgICAgICBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdID0gdG9TaGFkZVZhbHVlKGFjY2Vzc29yKTtcbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlTm9kZS5tZW1vcnlbYWxsb2NhdGlvbi5wcm9wZXJ0eU5hbWVdLnNoYXBlID0gYWNjZXNzb3Iuc2hhcGU7XG4gICAgICAgICAgICAgICAgbWVtSW5qZWN0W2FsbG9jYXRpb24ucHJvcGVydHlOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuQVJSQVksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1NpemU6IGFsbG9jYXRpb24uZWxlbWVudHMuc3RhdGljU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGFsbG9jYXRpb24uZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtzZXQuaW5qZWN0TWVtb3J5KHtcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBnbG9iYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogbWVtSW5qZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNyYyA9IHdvcmtzZXQudG9KYXZhU2NyaXB0KCk7XG4gICAgICAgIGxldCBuYW1lID0gY29tcHV0ZU5vZGUub3BlcmF0b3IubmFtZS5yZXBsYWNlKC8gfC0vZywgJ18nKTtcbiAgICAgICAgbGV0IG5ld1NyYyA9IGAoJHtzcmN9KS8vIyBzb3VyY2VVUkw9JHtuYW1lfV9kZWJ1Zy5qc2A7XG4gICAgICAgIGNvbXB1dGVOb2RlLmV2YWx1YXRlRGlyZWN0ID0gKDAsIGV2YWwpKG5ld1NyYyk7XG4gICAgfVxuXG4gICAgdG9QbGF0Zm9ybVZhbHVlKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdG9TaGFkZVZhbHVlKGJ1ZmZlcik7XG4gICAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgRGVidWdQbGF0Zm9ybSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHRvU2hhZGVUeXBlID0gcmVxdWlyZShcIi4vdG9fc2hhZGVfdHlwZVwiKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gKGlucHV0cywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgZW52ID0gWy4uLmlucHV0c10ucmVkdWNlKChlbnYsIFtuYW1lLCBmaWVsZF0pID0+IHtcbiAgICAgICAgZW52W25hbWVdID0gdG9TaGFkZVR5cGUoZmllbGQpO1xuICAgICAgICByZXR1cm4gZW52O1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaW5qZWN0OiB7XG4gICAgICAgICAgICB0aGlzOiB7dHlwZTogXCJvYmplY3RcIiwga2luZDogXCJhbnlcIiwgaW5mbzoge319LFxuICAgICAgICAgICAgZXZhbHVhdGU6IFt7XG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBlbnZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IERpc3Bvc2VJZk5vTGlzdGVuZXIgPSBzdXBlcmNsYXNzID0+IGNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZXZlbnROYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgY29uc3QgY2FsbERpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwb3NlKVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub24oXCJyZW1vdmVMaXN0ZW5lclwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkgPT09IDApXG4gICAgICAgICAgICAgICAgY2FsbERpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkgPT09IDApXG4gICAgICAgICAgICAgICAgY2FsbERpc3Bvc2UoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGlzcG9zZUlmTm9MaXN0ZW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBTaGFkZSA9IHJlcXVpcmUoXCJzaGFkZS5qc1wiKTtcblxuY29uc3QgVHlwZXMgPSByZXF1aXJlKFwiLi4vZmllbGQvdHlwZXNcIik7XG5cbmNvbnN0IHR5cGVNYXAgPSBuZXcgTWFwKFtcbiAgICBbU2hhZGUuVFlQRVMuSU5ULCBUeXBlcy5pbnQzMl0sXG4gICAgW1NoYWRlLlRZUEVTLk5VTUJFUiwgVHlwZXMuZmxvYXQzMl0sXG4gICAgW1NoYWRlLk9CSkVDVF9LSU5EUy5WRUMyLCBUeXBlcy52ZWMyXSxcbiAgICBbU2hhZGUuT0JKRUNUX0tJTkRTLlZFQzMsIFR5cGVzLnZlYzNdLFxuICAgIFtTaGFkZS5PQkpFQ1RfS0lORFMuVkVDNCwgVHlwZXMudmVjNF0sXG4gICAgLy8gW1NoYWRlLk9CSkVDVF9LSU5EUy5NQVRSSVgyLCBUeXBlcy5tYXQyXSxcbiAgICBbU2hhZGUuT0JKRUNUX0tJTkRTLk1BVFJJWDMsIFR5cGVzLm1hdDNdLFxuICAgIFtTaGFkZS5PQkpFQ1RfS0lORFMuTUFUUklYNCwgVHlwZXMubWF0NF0sXG5dKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gKHR5cGVJbmZvLCBuYW1lLCBzb3VyY2UpID0+IHtcbiAgICBsZXQgdHlwZSA9IHR5cGVJbmZvLmtpbmQgfHwgdHlwZUluZm8udHlwZTtcbiAgICBjb25zdCBzaGFwZSA9IFtdO1xuICAgIGxldCBmbFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGUgPT09IFNoYWRlLk9CSkVDVF9LSU5EUy5URVhUVVJFKSB7XG4gICAgICAgIGZsVHlwZSA9IFR5cGVzLnZlYzQ7XG4gICAgICAgIHNoYXBlLnB1c2godHlwZUluZm8ud2lkdGgpO1xuICAgICAgICBzaGFwZS5wdXNoKHR5cGVJbmZvLmhlaWdodCk7XG4gICAgICAgIHNoYXBlLnB1c2goLi4uZmxUeXBlLnNoYXBlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IGZsVHlwZSxcbiAgICAgICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgaXNUZXh0dXJlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodHlwZSA9PT0gU2hhZGUuVFlQRVMuQVJSQVkpIHtcbiAgICAgICAgc2hhcGUucHVzaCh0eXBlSW5mby5zdGF0aWNTaXplKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFR5cGVJbmZvID0gdHlwZUluZm8uZWxlbWVudHMuZXh0cmE7XG4gICAgICAgIHR5cGUgPSBlbGVtZW50VHlwZUluZm8ua2luZCB8fCBlbGVtZW50VHlwZUluZm8udHlwZTtcbiAgICB9XG5cbiAgICBmbFR5cGUgPSB0eXBlTWFwLmdldCh0eXBlKTtcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKVxuICAgICAgICBzaGFwZS5wdXNoKDEpO1xuXG4gICAgc2hhcGUucHVzaCguLi5mbFR5cGUuc2hhcGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogZmxUeXBlLFxuICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgU2hhZGUgPSByZXF1aXJlKFwic2hhZGUuanNcIik7XG5cbmNvbnN0IFR5cGVzID0gcmVxdWlyZShcIi4uL2ZpZWxkL3R5cGVzXCIpO1xuXG5jb25zdCB0eXBlTWFwID0gbmV3IE1hcChbXG4gICAgW1R5cGVzLmludDMyLCB7XG4gICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLklOVFxuICAgIH1dLFxuICAgIFtUeXBlcy5mbG9hdDMyLCB7XG4gICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk5VTUJFUlxuICAgIH1dLFxuXG4gICAgW1R5cGVzLnZlYzIsIHtcbiAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuT0JKRUNULFxuICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuVkVDMlxuICAgIH1dLFxuICAgIFtUeXBlcy52ZWMzLCB7XG4gICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcbiAgICAgICAga2luZDogU2hhZGUuT0JKRUNUX0tJTkRTLlZFQzNcbiAgICB9XSxcbiAgICBbVHlwZXMudmVjNCwge1xuICAgICAgICB0eXBlOiBTaGFkZS5UWVBFUy5PQkpFQ1QsXG4gICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5WRUM0XG4gICAgfV0sXG5cbiAgICBbVHlwZXMubWF0Miwge1xuICAgICAgICB0eXBlOiBTaGFkZS5UWVBFUy5PQkpFQ1QsXG4gICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5NQVRSSVgyXG4gICAgfV0sXG4gICAgW1R5cGVzLm1hdDMsIHtcbiAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuT0JKRUNULFxuICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuTUFUUklYM1xuICAgIH1dLFxuICAgIFtUeXBlcy5tYXQ0LCB7XG4gICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcbiAgICAgICAga2luZDogU2hhZGUuT0JKRUNUX0tJTkRTLk1BVFJJWDRcbiAgICB9XVxuXSk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh7dHlwZSwgc2hhcGUsIGFjY2Vzc29ycywgaXNUZXh0dXJlfSkge1xuICAgIC8vIGlmICghdHlwZU1hcC5oYXModHlwZSkpXG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIFxuICAgIGlmIChzaGFwZVswXSA9PT0gMSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXG4gICAgICAgIH0sIHR5cGVNYXAuZ2V0KHR5cGUpKTtcbiAgICAgICAgaWYgKGFjY2Vzc29ycylcbiAgICAgICAgICAgIHJlc3VsdC5hY2Nlc3NvcnMgPSBhY2Nlc3NvcnM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMyAmJiBzaGFwZVsyXSA9PT0gNCAmJiBpc1RleHR1cmUpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuVEVYVFVSRSxcbiAgICAgICAgICAgICAgICBhY2Nlc3NvcnM6IGFjY2Vzc29ycyxcbiAgICAgICAgICAgICAgICB3aWR0aDogc2hhcGVbMF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaGFwZVsxXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBhcnJheVNoYXBlID0gc2hhcGUuc2xpY2UoMCk7XG4gICAgICAgIGNvbnN0IGFycmF5U2l6ZSA9IGFycmF5U2hhcGUuc2hpZnQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlLnNoYXBlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYXJyYXlTaGFwZS5wb3AoKTtcblxuICAgICAgICBjb25zdCBzaGFkZVR5cGVJbmZvID0ge1xuICAgICAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuQVJSQVksXG4gICAgICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgIGV4dHJhOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRpY1NpemU6IGFycmF5U2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGVsZW1lbnRUeXBlSW5mbyA9IHNoYWRlVHlwZUluZm8uZWxlbWVudHMuZXh0cmE7XG4gICAgICAgIHdoaWxlIChhcnJheVNoYXBlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsZW1lbnRUeXBlSW5mby50eXBlID0gU2hhZGUuVFlQRVMuQVJSQVk7XG4gICAgICAgICAgICBlbGVtZW50VHlwZUluZm8uc3RhdGljU2l6ZSA9IGFycmF5U2hhcGUucG9wKCk7XG4gICAgICAgICAgICBlbGVtZW50VHlwZUluZm8uZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgIGVsZW1lbnRUeXBlSW5mby5lbGVtZW50cy5leHRyYSA9IHt9O1xuICAgICAgICAgICAgZWxlbWVudFR5cGVJbmZvID0gZWxlbWVudFR5cGVJbmZvLmVsZW1lbnRzLmV4dHJhO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50VHlwZUluZm8sIHR5cGVNYXAuZ2V0KHR5cGUpKTtcbiAgICAgICAgaWYgKGFjY2Vzc29ycylcbiAgICAgICAgICAgIHNoYWRlVHlwZUluZm8uYWNjZXNzb3JzID0gYWNjZXNzb3JzO1xuXG4gICAgICAgIHJldHVybiBzaGFkZVR5cGVJbmZvO1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gYnVmZmVyID0+IHtcbiAgICBpZiAoYnVmZmVyLnNoYXBlICYmIGJ1ZmZlci5zaGFwZVswXSA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5nZXQoMCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuXG4gICAgaWYgKHR5cGVvZiBidWZmZXIgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoYnVmZmVyLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwid2lkdGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuX2FycmF5U2hhcGVbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcImhlaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5fYXJyYXlTaGFwZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gcGFyc2VJbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuX2FycmF5U2hhcGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldC5waWNrKGlkeCksIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0KGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHBhcnNlSW50KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0KGlkeCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG59XG5cbmluaXQoKVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufSBlbHNlIHtcbiAgLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbiAgQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbiAgQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsInZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoXCJpcy1idWZmZXJcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG5cbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cblxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG5cbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcblxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcblxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihpc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBcImJ1ZmZlclwiXG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3JcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvaW5kZXguanMnKTtcbiIsIi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMS4wLjAgQ29weXJpZ2h0IChjKSAyMDExLTIwMTUsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFtZFJlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGZpbGVQYXRoLCBwYXRoLmRpcm5hbWUobW9kdWxlLmZpbGVuYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW1kUmVxdWlyZTtcbiAgICB9O1xuXG4gICAgLy9GYXZvciBleHBsaWNpdCB2YWx1ZSwgcGFzc2VkIGluIGlmIHRoZSBtb2R1bGUgd2FudHMgdG8gc3VwcG9ydCBOb2RlIDAuNC5cbiAgICByZXF1aXJlRm4gPSByZXF1aXJlRm4gfHwgZnVuY3Rpb24gcmVxKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnJlcXVpcmUuYXBwbHkobW9kdWxlLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciByLCBlLCBtLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBlID0gbG9hZGVyQ2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB1cmk6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vT25seSBzdXBwb3J0IG9uZSBkZWZpbmUgY2FsbCBwZXIgZmlsZVxuICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9Vc2UgdGhlIHJlYWwgdmFyaWFibGVzIGZyb20gbm9kZVxuICAgICAgICAgICAgLy9Vc2UgbW9kdWxlLmV4cG9ydHMgZm9yIGV4cG9ydHMsIHNpbmNlXG4gICAgICAgICAgICAvL3RoZSBleHBvcnRzIGluIGhlcmUgaXMgYW1kZWZpbmUgZXhwb3J0cy5cbiAgICAgICAgICAgIGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIG0gPSBtb2R1bGU7XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBtb2R1bGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzLCB0aGV5IGFyZSBzdHJpbmdzLCBzbyBuZWVkXG4gICAgICAgIC8vdG8gY29udmVydCB0aGVtIHRvIGRlcGVuZGVuY3kgdmFsdWVzLlxuICAgICAgICBpZiAoZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIoZGVwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ2FsbCB0aGUgZmFjdG9yeSB3aXRoIHRoZSByaWdodCBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeS5hcHBseShtLmV4cG9ydHMsIGRlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gbS5leHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGlkLCByZWxJZCkge1xuICAgICAgICAvL1NwbGl0IHRoZSBJRCBieSBhICEgc28gdGhhdFxuICAgICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKCchJyksXG4gICAgICAgICAgICBvcmlnaW5hbElkID0gaWQsXG4gICAgICAgICAgICBwcmVmaXgsIHBsdWdpbjtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuXG4gICAgICAgICAgICAvL1N0cmFpZ2h0IG1vZHVsZSBsb29rdXAuIElmIGl0IGlzIG9uZSBvZiB0aGUgc3BlY2lhbCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBpdCwgb3RoZXJ3aXNlLCBkZWxlZ2F0ZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGlkID09PSAncmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9hZGVyQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHN5c3RlbVJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbVJlcXVpcmUob3JpZ2luYWxJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2R1bGUgd2l0aCBJRDogJyArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIGEgcGx1Z2luIGluIHBsYXkuXG4gICAgICAgICAgICBwcmVmaXggPSBpZC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpZC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwbHVnaW4gPSBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcHJlZml4LCByZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwbHVnaW4ubm9ybWFsaXplKGlkLCBtYWtlTm9ybWFsaXplKHJlbElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplIHRoZSBJRCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmxvYWQoaWQsIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpLCBtYWtlTG9hZChpZCksIHt9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9DcmVhdGUgYSBkZWZpbmUgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIG1vZHVsZSBhc2tpbmcgZm9yIGFtZGVmaW5lLlxuICAgIGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IGlkO1xuICAgICAgICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHMgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9TZXQgdXAgcHJvcGVydGllcyBmb3IgdGhpcyBtb2R1bGUuIElmIGFuIElELCB0aGVuIHVzZVxuICAgICAgICAvL2ludGVybmFsIGNhY2hlLiBJZiBubyBJRCwgdGhlbiB1c2UgdGhlIGV4dGVybmFsIHZhcmlhYmxlc1xuICAgICAgICAvL2ZvciB0aGlzIG5vZGUgbW9kdWxlLlxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vUHV0IHRoZSBtb2R1bGUgaW4gZGVlcCBmcmVlemUgdW50aWwgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwgZm9yIGl0LlxuICAgICAgICAgICAgZGVmaW5lQ2FjaGVbaWRdID0gW2lkLCBkZXBzLCBmYWN0b3J5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWZpbmUucmVxdWlyZSwgd2hpY2ggaGFzIGFjY2VzcyB0byBhbGwgdGhlIHZhbHVlcyBpbiB0aGVcbiAgICAvL2NhY2hlLiBVc2VmdWwgZm9yIEFNRCBtb2R1bGVzIHRoYXQgYWxsIGhhdmUgSURzIGluIHRoZSBmaWxlLFxuICAgIC8vYnV0IG5lZWQgdG8gZmluYWxseSBleHBvcnQgYSB2YWx1ZSB0byBub2RlIGJhc2VkIG9uIG9uZSBvZiB0aG9zZVxuICAgIC8vSURzLlxuICAgIGRlZmluZS5yZXF1aXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7fTtcblxuICAgIHJldHVybiBkZWZpbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW1kZWZpbmU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iLCJcbnZhciB3YWxrZXMgPSByZXF1aXJlKCd3YWxrZXMnKTtcbnZhciB3b3JrbGlzdCA9IHJlcXVpcmUoJy4uLycpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4uL3NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF2YWlsYWJsZUV4cHJlc3Npb25zO1xuXG4vKlxuU28gaGVyZSBpcyB0aGUgc3Rvcnk6XG5FYWNoIG5vZGUgaXMgc3VwcG9zZWQgdG8gaGF2ZSBhIGBTZXRgIG9mIGV4cHJlc3Npb25zLiBBbmQgZm9yIGVhY2ggZXhwcmVzc2lvbixcbkkgd2FudCB0byBzYXZlIHRoZSBgU2V0YCBvZiBjb250YWluZWQgdmFyaWFibGVzIGZvciBlYXNpZXIga2lsbGluZy5cblxuU2luY2UgSlMgaGFzIG5vIHJlY29yZHMgeWV0IChzZWUgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46cmVjb3JkcyApXG5hbmQgbm8gY29uY2VwdCBvZiBzdHJ1Y3R1cmFsIGVxdWFsaXR5LCBhbiBleHByZXNzaW9uIHJlcHJlc2VudGVkIGJ5IGFuIEFTVCBub2RlXG5pcyAqbmV2ZXIgZXZlciogZXF1YWwgdG8gYW4gc3RydWN0dXJhbGx5IGVxdWFsIGV4cHJlc3Npb24gdW5sZXNzIGl0cyB0aGVcbmlkZW50aWNhbCBub2RlLlxuVGhlIHNhbWUgZ29lcyBmb3IgYFNldGBzLiBTaW5jZSB0aGV5IGFyZSBqdXN0IHNoaW1tZWQgdXNpbmcgbm9ybWFsIE9iamVjdHMsIHRoZXlcbmFyZSAqbmV2ZXIgZXZlciogZXF1YWwsIGFsdGhvdWdoIHRoZXkgY29udGFpbiB0aGUgZXhhY3Qgc2FtZSBtZW1iZXJzLlxuXG5TbyBhcyBhIHdvcmthcm91bmQsIEkgYEpTT04uc3RyaW5naWZ5YCB0aGUgZXhwcmVzc2lvbiB0byBzYXZlIGl0IGluIHRoZSBTZXQgYW5kXG51c2UgYSBtYXBwaW5nIHRhYmxlIHRvIGdldCB0byB0aGUgZXhwcmVzc2lvbiBvYmplY3QgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHNldCBvZlxudmFyaWFibGVzLlxuXG5PZiBjb3Vyc2UsIEkgY291bGQganVzdCB1c2UgYSBjdXN0b20gU2V0IGltcGxlbWVudGF0aW9uIHdoaWNoIHVzZXMgYSBjdXN0b21cbmVxdWFsaXR5IGNoZWNrIGZ1bmN0aW9uLiBCdXQgSSB3YW50IHRvIGJlIGZvcndhcmQtY29tcGF0aWJsZSB3aXRoIHRoZSB1cGNvbWluZ1xuRVM2IHN0YW5kYXJkLCB3aGljaCBzaG91bGQgcHJvdmlkZSBhIE8oMSkgU2V0cywgaW5zdGVhZCBvZiB0aGUgTyhuKSBzaGltLlxuKi9cblxuZnVuY3Rpb24gYXZhaWxhYmxlRXhwcmVzc2lvbnMoY2ZnKSB7XG5cdHZhciBleHByZXNzaW9uTWFwID0ge307XG5cblx0ZnVuY3Rpb24gZmluZEV4cHJlc3Npb25zKGFzdCkge1xuXHRcdHZhciBleHByZXNzaW9ucyA9IG5ldyBTZXQoKTtcblx0XHQvLyBGSVhNRToganVzdCBoYW5kbGluZyBiaW5hcnkgZXhwcmVzc2lvbnMgc28gZmFyXG5cdFx0d2Fsa2VzKGFzdCwge1xuXHRcdFx0SWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFNldCh0aGlzLm5hbWUpO1xuXHRcdFx0fSxcblx0XHRcdExpdGVyYWw6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBTZXQoKTtcblx0XHRcdH0sXG5cdFx0XHRCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0XHR2YXIgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzKTtcblx0XHRcdFx0ZXhwcmVzc2lvbnMuYWRkKHN0cmluZ2lmaWVkKTtcblx0XHRcdFx0aWYgKHN0cmluZ2lmaWVkIGluIGV4cHJlc3Npb25NYXApIHtcblx0XHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbk1hcFtzdHJpbmdpZmllZF0udmFyaWFibGVzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByaWdodCA9IHJlY3Vyc2UodGhpcy5yaWdodCk7XG5cdFx0XHRcdHZhciBsZWZ0ID0gcmVjdXJzZSh0aGlzLmxlZnQpO1xuXHRcdFx0XHR2YXIgdmFyaWFibGVzID0gU2V0LnVuaW9uKGxlZnQsIHJpZ2h0KTtcblx0XHRcdFx0ZXhwcmVzc2lvbk1hcFtzdHJpbmdpZmllZF0gPSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbjogdGhpcyxcblx0XHRcdFx0XHR2YXJpYWJsZXM6IHZhcmlhYmxlc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdmFyaWFibGVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBleHByZXNzaW9ucztcblx0fVxuXG5cdC8vIHJ1biB0aGUgYWxnb3JpdGhtXG5cdHZhciBvdXRwdXQgPSB3b3JrbGlzdChjZmcsIGZ1bmN0aW9uIChpbnB1dCwgbGlzdCkge1xuXHRcdGlmICh0aGlzLnR5cGUgfHwgIXRoaXMuYXN0Tm9kZSlcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR2YXIga2lsbCA9IHRoaXMua2lsbCA9IHRoaXMua2lsbCB8fCBmaW5kQXNzaWdubWVudHModGhpcy5hc3ROb2RlKTtcblx0XHR2YXIgZ2VuZXJhdGUgPSB0aGlzLmdlbmVyYXRlID0gdGhpcy5nZW5lcmF0ZSB8fCBmaW5kRXhwcmVzc2lvbnModGhpcy5hc3ROb2RlKTtcblx0XHR2YXIga2lsbGVkID0gbmV3IFNldChpbnB1dC52YWx1ZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGV4cHIpIHtcblx0XHRcdHZhciB2YXJpYWJsZXMgPSBleHByZXNzaW9uTWFwW2V4cHJdLnZhcmlhYmxlcztcblx0XHRcdHJldHVybiAhU2V0LmludGVyc2VjdCh2YXJpYWJsZXMsIGtpbGwpLnNpemU7XG5cdFx0fSkpO1xuXHRcdHJldHVybiBTZXQudW5pb24oa2lsbGVkLCBnZW5lcmF0ZSk7XG5cdH0sIHtkaXJlY3Rpb246ICdmb3J3YXJkJywgbWVyZ2U6IHdvcmtsaXN0Lm1lcmdlKFNldC5pbnRlcnNlY3QpfSk7XG5cblx0Ly8gZ28gb3ZlciBhbGwgdGhlIG5vZGVzIGFuZCBwdXNoIGRvd24gdGhlIHJlYWwgb2JqZWN0cyBpbnRvIHRoZSBvdXRwdXRcblx0Y2ZnWzJdLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcblx0XHR2YXIgb3V0ID0gb3V0cHV0LmdldChub2RlKTtcblx0XHRvdXRwdXQuc2V0KG5vZGUsIG5ldyBTZXQob3V0LnZhbHVlcygpLm1hcChmdW5jdGlvbiAoZXhwcikge1xuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb25NYXBbZXhwcl0uZXhwcmVzc2lvbjtcblx0XHR9KSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmaW5kQXNzaWdubWVudHMoYXN0KSB7XG5cdHZhciB2YXJpYWJsZXMgPSBuZXcgU2V0KCk7XG5cdHdhbGtlcyhhc3QsIHtcblx0XHRBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdGlmICh0aGlzLmxlZnQudHlwZSA9PT0gJ0lkZW50aWZpZXInKVxuXHRcdFx0XHR2YXJpYWJsZXMuYWRkKHRoaXMubGVmdC5uYW1lKTtcblx0XHRcdHJlY3Vyc2UodGhpcy5yaWdodCk7XG5cdFx0fSxcblx0XHRWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHR2YXJpYWJsZXMuYWRkKHRoaXMuaWQubmFtZSk7XG5cdFx0XHRpZiAodGhpcy5pbml0KVxuXHRcdFx0XHRyZWN1cnNlKHRoaXMuaW5pdCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHZhcmlhYmxlcztcbn1cblxuIiwiXG5leHBvcnRzLmxpdmVWYXJpYWJsZXMgPSByZXF1aXJlKCcuL2xpdmV2YXJpYWJsZXMnKTtcbmV4cG9ydHMuYXZhaWxhYmxlRXhwcmVzc2lvbnMgPSByZXF1aXJlKCcuL2F2YWlsYWJsZWV4cHJlc3Npb25zJyk7XG5cbiIsIlxudmFyIHdhbGtlcyA9IHJlcXVpcmUoJ3dhbGtlcycpO1xudmFyIHdvcmtsaXN0ID0gcmVxdWlyZSgnLi4vJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vc2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbGl2ZVZhcmlhYmxlcztcblxuZnVuY3Rpb24gbGl2ZVZhcmlhYmxlcyhjZmcpIHtcblx0cmV0dXJuIHdvcmtsaXN0KGNmZywgZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0aWYgKHRoaXMudHlwZSB8fCAhdGhpcy5hc3ROb2RlKVxuXHRcdFx0cmV0dXJuIGlucHV0O1xuXG5cdFx0cmV0dXJuIFNldC51bmlvbihuZXcgU2V0KFt0aGlzXSwgaW5wdXQpKTtcblx0fSwge2RpcmVjdGlvbjogJ2ZvcndhcmQnLCAgICAgICAgIG1lcmdlOiB3b3JrbGlzdC5tZXJnZShTZXQuaW50ZXJzZWN0KX0pO1xufVxuXG5mdW5jdGlvbiBmaW5kQXNzaWdubWVudHMoYXN0Tm9kZSkge1xuXHR2YXIgdmFyaWFibGVzID0gbmV3IFNldCgpO1xuXHR3YWxrZXMoYXN0Tm9kZSwge1xuXHRcdEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0aWYgKHRoaXMubGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpXG5cdFx0XHRcdHZhcmlhYmxlcy5hZGQodGhpcy5sZWZ0Lm5hbWUpO1xuXHRcdFx0cmVjdXJzZSh0aGlzLnJpZ2h0KTtcblx0XHR9LFxuXHRcdEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uICgpIHt9LFxuXHRcdEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge30sXG5cdFx0VmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0dmFyaWFibGVzLmFkZCh0aGlzLmlkLm5hbWUpO1xuXHRcdFx0aWYgKHRoaXMuaW5pdClcblx0XHRcdFx0cmVjdXJzZSh0aGlzLmluaXQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiB2YXJpYWJsZXM7XG59XG5mdW5jdGlvbiBmaW5kVmFyaWFibGVzKGFzdE5vZGUpIHtcblx0dmFyIHZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcblx0d2Fsa2VzKGFzdE5vZGUsIHtcblx0XHRBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdGlmICh0aGlzLmxlZnQudHlwZSAhPT0gJ0lkZW50aWZpZXInKVxuXHRcdFx0XHRyZWN1cnNlKHRoaXMubGVmdCk7XG5cdFx0XHRyZWN1cnNlKHRoaXMucmlnaHQpO1xuXHRcdH0sXG5cdFx0RnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKCkge30sXG5cdFx0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXJpYWJsZXMuYWRkKHRoaXMubmFtZSk7XG5cdFx0fSxcblx0XHRNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0cmVjdXJzZSh0aGlzLm9iamVjdCk7XG5cdFx0fSxcblx0XHRQcm9wZXJ0eTogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdHJlY3Vyc2UodGhpcy52YWx1ZSk7XG5cdFx0fSxcblx0XHRWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHRyZWN1cnNlKHRoaXMuaW5pdCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHZhcmlhYmxlcztcbn1cblxuIiwiXG52YXIgUXVldWUgPSByZXF1aXJlKCcuL3F1ZXVlJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi9zZXQnKTtcblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHdvcmtsaXN0O1xuXG4vLyBleHBvc2UgdGhlIHV0aWxpdGllcyB0byBoYXZlIHRoZW0gdGVzdGVkIHNlcGFyYXRlbHlcbmV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcbmV4cG9ydHMuU2V0ID0gU2V0O1xuZXhwb3J0cy5leGFtcGxlcyA9IHJlcXVpcmUoJy4vZXhhbXBsZXMnKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBhIGdlbmVyYWwgd29ya2xpc3QgYWxnb3JpdGhtXG4gKiBgY2ZnYCBpcyBhIGNvbnRyb2wgZmxvdyBncmFwaCBjcmVhdGVkIGJ5IGBlc2dyYXBoYCxcbiAqIGB0cmFuc2ZlckZ1bmN0aW9uYCBnZXRzIGNhbGxlZCB3aXRoICh0aGlzID0gbm9kZSwgaW5wdXQsIHdvcmtsaXN0KVxuICogaXQgb3BlcmF0ZXMgb24gdGhlIGlucHV0IGBTZXRgIGFuZCBjYW4gcmV0dXJuIGFuIG91dHB1dCBzZXQsIGluIHdoaWNoIGNhc2VcbiAqIHRoZSB3b3JrbGlzdCBhbGdvcml0aG0gYXV0b21hdGljYWxseSBlbnF1ZXVlcyBhbGwgdGhlIHN1Y2Nlc3NvciBub2Rlcywgb3IgaXRcbiAqIG1pZ2h0IHJldHVybiBhbiB7b3V0cHV0OiBvdXRwdXQsIGVucXVldWU6IGZhbHNlfSBvYmplY3QgaW4gd2hpY2ggY2FzZSBpdCBpc1xuICogaXRzZWxmIHJlc3BvbnNpYmxlIHRvIGVucXVldWUgdGhlIHN1Y2Nlc3NvciBub2Rlcy5cbiAqIGBvcHRpb25zYCBkZWZpbmVzIHRoZSBgZGlyZWN0aW9uYCwgYSBgbWVyZ2VgIGZ1bmN0aW9uIGFuZCBhbiBgZXF1YWxzYFxuICogZnVuY3Rpb24gd2hpY2ggbWVyZ2UgdGhlIGlucHV0cyB0byBhIG5vZGUgYW5kIGRldGVybWluZSBpZiBhIG5vZGUgaGFzIGNoYW5nZWRcbiAqIGl0cyBvdXRwdXQgcmVzcGVjdGl2ZWx5LlxuICogUmV0dXJucyBhIGBNYXBgIGZyb20gbm9kZSAtPiBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gd29ya2xpc3QoY2ZnLCB0cmFuc2ZlckZ1bmN0aW9uLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR2YXIgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgJ2ZvcndhcmQnO1xuXHR2YXIgbWVyZ2UgPSBvcHRpb25zLm1lcmdlIHx8IHdvcmtsaXN0Lm1lcmdlKFNldC51bmlvbik7XG5cdHZhciBlcXVhbHMgPSBvcHRpb25zLmVxdWFscyB8fCBTZXQuZXF1YWxzO1xuXHR2YXIgbGlzdCA9IG5ldyBRdWV1ZSgpO1xuXHRpZiAoZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcblx0XHRsaXN0LnB1c2goY2ZnWzBdKTtcblx0XHR2YXIgcHJlZGVjZXNzb3JzID0gd29ya2xpc3QucHJlZGVjZXNzb3JzO1xuXHRcdHZhciBzdWNjZXNzb3JzID0gd29ya2xpc3Quc3VjY2Vzc29ycztcblx0fSBlbHNlIHtcblx0XHRsaXN0LnB1c2goY2ZnWzFdKTtcblx0XHR2YXIgcHJlZGVjZXNzb3JzID0gd29ya2xpc3Quc3VjY2Vzc29ycztcblx0XHR2YXIgc3VjY2Vzc29ycyA9IHdvcmtsaXN0LnByZWRlY2Vzc29ycztcblx0fVxuXHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IG5ldyBTZXQoKTtcblxuXHR2YXIgb3V0cHV0ID0gbmV3IE1hcCgpO1xuXHR3aGlsZSAobGlzdC5sZW5ndGgpIHtcblx0XHR2YXIgbm9kZSA9IGxpc3Quc2hpZnQoKTtcblx0XHR2YXIgcHJlID0gcHJlZGVjZXNzb3JzKG5vZGUpXG5cdFx0XHQubWFwKGZ1bmN0aW9uIChuKSB7cmV0dXJuIG91dHB1dC5nZXQobik7fSlcblx0XHR2YXIgaW5wdXQgPSBwcmUubGVuZ3RoID8gbWVyZ2UocHJlKSA6IHN0YXJ0O1xuXHRcdHZhciBvbGRPdXRwdXQgPSBvdXRwdXQuZ2V0KG5vZGUpO1xuXHRcdHZhciBvdXQgPSB0cmFuc2ZlckZ1bmN0aW9uLmNhbGwobm9kZSwgaW5wdXQsIGxpc3QsIG9sZE91dHB1dCk7XG5cdFx0aWYgKCFvdXQgfHwgb3V0IGluc3RhbmNlb2YgU2V0KVxuXHRcdFx0b3V0ID0ge291dHB1dDogb3V0LCBlbnF1ZXVlOiB0cnVlfTtcblx0XHRvdXRwdXQuc2V0KG5vZGUsIG91dC5vdXRwdXQpO1xuXHRcdGlmIChvdXQuZW5xdWV1ZSAmJiAoIW9sZE91dHB1dCB8fCAhZXF1YWxzKG91dC5vdXRwdXQsIG9sZE91dHB1dCkpKVxuXHRcdFx0c3VjY2Vzc29ycyhub2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChhU3VjY2Vzc29yKSB7XHRsaXN0LnB1c2goYVN1Y2Nlc3Nvcik7XHR9KTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufTtcblxud29ya2xpc3QucHJlZGVjZXNzb3JzID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0cmV0dXJuIG5vZGUucHJldjtcbn07XG5cbndvcmtsaXN0LnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5uZXh0O1xufTtcblxud29ya2xpc3QubWVyZ2UgPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChpbnB1dHMpIHtcblx0XHRpZiAoaW5wdXRzLmxlbmd0aCA9PSAxKVxuXHRcdFx0cmV0dXJuIG5ldyBTZXQoaW5wdXRzWzBdKTtcblx0XHRyZXR1cm4gaW5wdXRzLnJlZHVjZShmbik7XG5cdH07XG59O1xuXG4iLCJcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbi8qKlxuICogVGhpcyBpcyBhIHJlYWxseSBzbWFsbCBwcmlvcml0eSBxdWV1ZSB0aGF0IG1ha2VzIHN1cmUgdGhhdCBkdXBsaWNhdGUgZWxlbWVudHNcbiAqIGFyZSBiZWluZyBpbnNlcnRlZCBhdCB0aGUgZW5kXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKCkge1xuXHR2YXIgcSA9IFtdO1xuXHRxLl9fcHJvdG9fXyA9IFF1ZXVlLnByb3RvdHlwZTtcblx0cmV0dXJuIHE7XG59XG5cblF1ZXVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcblF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gUXVldWVfcHVzaChlbGVtKSB7XG5cdHZhciBwb3MgPSB0aGlzLmluZGV4T2YoZWxlbSk7XG5cdGlmIChwb3MgIT0gLTEpXG5cdFx0dGhpcy5zcGxpY2UocG9zLCAxKTtcblx0QXJyYXkucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBlbGVtKTtcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuXG4vKipcbiAqIEVTNiBTZXRzIGluIGBub2RlIC0taGFybW9ueWAgZG8gbm90IHByb3ZpZGUgYC52YWx1ZXMoKWAgb3IgYGZvciBvZmAgaXRlcmF0aW9uXG4gKiB5ZXQsIHNvIHRoZXkgYXJlIHByZXR0eSB1c2VsZXNzIDotKFxuICogVGhpcyBTZXQgYWxzbyBkb2VzIG5vdCB1c2UgYE9iamVjdC5pc2A7IHdlIGRvIG5vdCBjYXJlIGFib3V0IE5hTiwgLTAsICswXG4gKi9cbmZ1bmN0aW9uIFNldChlbGVtZW50cykge1xuXHR0aGlzLl92YWx1ZXMgPSBbXTtcblx0aWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuXHRcdGVsZW1lbnRzLmZvckVhY2godGhpcy5hZGQuYmluZCh0aGlzKSk7XG5cdGVsc2UgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgU2V0KVxuXHRcdGVsZW1lbnRzLl92YWx1ZXMuZm9yRWFjaCh0aGlzLmFkZC5iaW5kKHRoaXMpKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXQucHJvdG90eXBlLCAnc2l6ZScsIHtcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoO1xuXHR9XG59KTtcblNldC5wcm90b3R5cGUuX2kgPSBmdW5jdGlvbiBTZXRfX2koZWxlbSkge1xuXHRyZXR1cm4gdGhpcy5fdmFsdWVzLmluZGV4T2YoZWxlbSk7XG59O1xuU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTZXRfYWRkKGVsZW0pIHtcblx0aWYgKCF0aGlzLmhhcyhlbGVtKSlcblx0XHR0aGlzLl92YWx1ZXMucHVzaChlbGVtKTtcbn07XG5TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIFNldF9oYXMoZWxlbSkge1xuXHRyZXR1cm4gISF+dGhpcy5faShlbGVtKTtcbn07XG5TZXQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIFNldF9kZWxldGUoZWxlbSkge1xuXHR2YXIgaSA9IHRoaXMuX2koZWxlbSk7XG5cdGlmICghfmkpXG5cdFx0cmV0dXJuO1xuXHR0aGlzLl92YWx1ZXMuc3BsaWNlKGksIDEpO1xufTtcblNldC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gU2V0X3ZhbHVlcygpIHtcblx0cmV0dXJuIFtdLmNvbmNhdCh0aGlzLl92YWx1ZXMpO1xufTtcblxuLy8gZm9yd2FyZCBzb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyBmcm9tIEFycmF5LnByb3RvdHlwZVxuW1xuXHQnc29tZScsXG5cdCdtYXAnLFxuXHQnZXZlcnknLFxuXHQnZmlsdGVyJyxcblx0J2ZvckVhY2gnXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRTZXQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZVttZXRob2RdLmFwcGx5KHRoaXMuX3ZhbHVlcywgYXJndW1lbnRzKTtcblx0fVxufSk7XG5cbi8vIHNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG5TZXQucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gU2V0X2ZpcnN0KCkge1xuXHRyZXR1cm4gdGhpcy5fdmFsdWVzWzBdO1xufTtcblNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYikge1xuXHRpZiAoIWEgJiYgYilcblx0XHRyZXR1cm4gbmV3IFNldChiKTtcblx0aWYgKCFiICYmIGEpXG5cdFx0cmV0dXJuIG5ldyBTZXQoYSk7XG5cdHZhciBzID0gbmV3IFNldCgpO1xuXHRhLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChiLmhhcyh2YWwpKVxuXHRcdFx0cy5hZGQodmFsKTtcblx0fSk7XG5cdHJldHVybiBzO1xufTtcblNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uKGEsIGIpIHtcblx0aWYgKCFhICYmIGIpXG5cdFx0cmV0dXJuIG5ldyBTZXQoYik7XG5cdHZhciBzID0gbmV3IFNldChhKTtcblx0aWYgKGIpXG5cdFx0Yi5mb3JFYWNoKHMuYWRkLmJpbmQocykpO1xuXHRyZXR1cm4gcztcbn07XG5TZXQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcblx0aWYgKGEuc2l6ZSAhPSBiLnNpemUpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gYS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIGIuaGFzKHZhbCk7XG5cdH0pO1xufTtcblNldC5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGEsIGIpIHtcblx0dmFyIHMgPSBuZXcgU2V0KGEpO1xuXHRiLmZvckVhY2gocy5kZWxldGUuYmluZChzKSk7XG5cdHJldHVybiBzO1xufTtcblxuIiwiLyohXG4gKiBAZGVzY3JpcHRpb24gUmVjdXJzaXZlIG9iamVjdCBleHRlbmRpbmdcbiAqIEBhdXRob3IgVmlhY2hlc2xhdiBMb3RzbWFub3YgPGxvdHNtYW5vdjg5QGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IFZpYWNoZXNsYXYgTG90c21hbm92XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2ZcbiAqIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SXG4gKiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVJcbiAqIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNTcGVjaWZpY1ZhbHVlKHZhbCkge1xuXHRyZXR1cm4gKFxuXHRcdHZhbCBpbnN0YW5jZW9mIEJ1ZmZlclxuXHRcdHx8IHZhbCBpbnN0YW5jZW9mIERhdGVcblx0XHR8fCB2YWwgaW5zdGFuY2VvZiBSZWdFeHBcblx0KSA/IHRydWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVTcGVjaWZpY1ZhbHVlKHZhbCkge1xuXHRpZiAodmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG5cdFx0dmFyIHggPSBuZXcgQnVmZmVyKHZhbC5sZW5ndGgpO1xuXHRcdHZhbC5jb3B5KHgpO1xuXHRcdHJldHVybiB4O1xuXHR9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUodmFsLmdldFRpbWUoKSk7XG5cdH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2l0dWF0aW9uJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWN1cnNpdmUgY2xvbmluZyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZGVlcENsb25lQXJyYXkoYXJyKSB7XG5cdHZhciBjbG9uZSA9IFtdO1xuXHRhcnIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gIT09IG51bGwpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG5cdFx0XHRcdGNsb25lW2luZGV4XSA9IGRlZXBDbG9uZUFycmF5KGl0ZW0pO1xuXHRcdFx0fSBlbHNlIGlmIChpc1NwZWNpZmljVmFsdWUoaXRlbSkpIHtcblx0XHRcdFx0Y2xvbmVbaW5kZXhdID0gY2xvbmVTcGVjaWZpY1ZhbHVlKGl0ZW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVbaW5kZXhdID0gZGVlcEV4dGVuZCh7fSwgaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsb25lW2luZGV4XSA9IGl0ZW07XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEV4dGVuaW5nIG9iamVjdCB0aGF0IGVudGVyZWQgaW4gZmlyc3QgYXJndW1lbnQuXG4gKlxuICogUmV0dXJucyBleHRlbmRlZCBvYmplY3Qgb3IgZmFsc2UgaWYgaGF2ZSBubyB0YXJnZXQgb2JqZWN0IG9yIGluY29ycmVjdCB0eXBlLlxuICpcbiAqIElmIHlvdSB3aXNoIHRvIGNsb25lIHNvdXJjZSBvYmplY3QgKHdpdGhvdXQgbW9kaWZ5IGl0KSwganVzdCB1c2UgZW1wdHkgbmV3XG4gKiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQsIGxpa2UgdGhpczpcbiAqICAgZGVlcEV4dGVuZCh7fSwgeW91ck9ial8xLCBbeW91ck9ial9OXSk7XG4gKi9cbnZhciBkZWVwRXh0ZW5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLypvYmpfMSwgW29ial8yXSwgW29ial9OXSovKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuXHRcdHJldHVybiBhcmd1bWVudHNbMF07XG5cdH1cblxuXHR2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXG5cdC8vIGNvbnZlcnQgYXJndW1lbnRzIHRvIGFycmF5IGFuZCBjdXQgb2ZmIHRhcmdldCBvYmplY3Rcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG5cdHZhciB2YWwsIHNyYywgY2xvbmU7XG5cblx0YXJncy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0XHQvLyBza2lwIGFyZ3VtZW50IGlmIGl0IGlzIGFycmF5IG9yIGlzbid0IG9iamVjdFxuXHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0c3JjID0gdGFyZ2V0W2tleV07IC8vIHNvdXJjZSB2YWx1ZVxuXHRcdFx0dmFsID0gb2JqW2tleV07IC8vIG5ldyB2YWx1ZVxuXG5cdFx0XHQvLyByZWN1cnNpb24gcHJldmVudGlvblxuXHRcdFx0aWYgKHZhbCA9PT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBpZiBuZXcgdmFsdWUgaXNuJ3Qgb2JqZWN0IHRoZW4ganVzdCBvdmVyd3JpdGUgYnkgbmV3IHZhbHVlXG5cdFx0XHQgKiBpbnN0ZWFkIG9mIGV4dGVuZGluZy5cblx0XHRcdCAqL1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fCB2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSB2YWw7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8ganVzdCBjbG9uZSBhcnJheXMgKGFuZCByZWN1cnNpdmUgY2xvbmUgb2JqZWN0cyBpbnNpZGUpXG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGRlZXBDbG9uZUFycmF5KHZhbCk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gY3VzdG9tIGNsb25pbmcgYW5kIG92ZXJ3cml0ZSBmb3Igc3BlY2lmaWMgb2JqZWN0c1xuXHRcdFx0fSBlbHNlIGlmIChpc1NwZWNpZmljVmFsdWUodmFsKSkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGNsb25lU3BlY2lmaWNWYWx1ZSh2YWwpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIG92ZXJ3cml0ZSBieSBuZXcgdmFsdWUgaWYgc291cmNlIGlzbid0IG9iamVjdCBvciBhcnJheVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygc3JjICE9PSAnb2JqZWN0JyB8fCBzcmMgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShzcmMpKSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gZGVlcEV4dGVuZCh7fSwgdmFsKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBzb3VyY2UgdmFsdWUgYW5kIG5ldyB2YWx1ZSBpcyBvYmplY3RzIGJvdGgsIGV4dGVuZGluZy4uLlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBkZWVwRXh0ZW5kKHNyYywgdmFsKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTQgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgSW5ndmFyIFN0ZXBhbnlhbiA8bWVAcnJldmVyc2VyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE0IEl2YW4gTmlrdWxpbiA8aWZhYWFuQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTMgTWljaGFlbCBGaWNhcnJhIDxlc2NvZGVnZW4uY29weXJpZ2h0QG1pY2hhZWwuZmljYXJyYS5tZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIElyYWtsaSBHb3phbGlzaHZpbGkgPHJmb2JpY0BnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBSb2JlcnQgR3VzdC1CYXJkb24gPGRvbmF0ZUByb2JlcnQuZ3VzdC1iYXJkb24ub3JnPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9obiBGcmVlbWFuIDxqZnJlZW1hbjA4QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExLTIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLypnbG9iYWwgZXhwb3J0czp0cnVlLCByZXF1aXJlOnRydWUsIGdsb2JhbDp0cnVlKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFN5bnRheCxcbiAgICAgICAgUHJlY2VkZW5jZSxcbiAgICAgICAgQmluYXJ5UHJlY2VkZW5jZSxcbiAgICAgICAgU291cmNlTm9kZSxcbiAgICAgICAgZXN0cmF2ZXJzZSxcbiAgICAgICAgZXN1dGlscyxcbiAgICAgICAgaXNBcnJheSxcbiAgICAgICAgYmFzZSxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBqc29uLFxuICAgICAgICByZW51bWJlcixcbiAgICAgICAgaGV4YWRlY2ltYWwsXG4gICAgICAgIHF1b3RlcyxcbiAgICAgICAgZXNjYXBlbGVzcyxcbiAgICAgICAgbmV3bGluZSxcbiAgICAgICAgc3BhY2UsXG4gICAgICAgIHBhcmVudGhlc2VzLFxuICAgICAgICBzZW1pY29sb25zLFxuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbixcbiAgICAgICAgZGlyZWN0aXZlLFxuICAgICAgICBleHRyYSxcbiAgICAgICAgcGFyc2UsXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgc291cmNlQ29kZSxcbiAgICAgICAgcHJlc2VydmVCbGFua0xpbmVzLFxuICAgICAgICBGT1JNQVRfTUlOSUZZLFxuICAgICAgICBGT1JNQVRfREVGQVVMVFM7XG5cbiAgICBlc3RyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xuICAgIGVzdXRpbHMgPSByZXF1aXJlKCdlc3V0aWxzJyk7XG5cbiAgICBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcblxuICAgIC8vIEdlbmVyYXRpb24gaXMgZG9uZSBieSBnZW5lcmF0ZUV4cHJlc3Npb24uXG4gICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIENvZGVHZW5lcmF0b3IuRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRpb24gaXMgZG9uZSBieSBnZW5lcmF0ZVN0YXRlbWVudC5cbiAgICBmdW5jdGlvbiBpc1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHJldHVybiBDb2RlR2VuZXJhdG9yLlN0YXRlbWVudC5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIFByZWNlZGVuY2UgPSB7XG4gICAgICAgIFNlcXVlbmNlOiAwLFxuICAgICAgICBZaWVsZDogMSxcbiAgICAgICAgQXdhaXQ6IDEsXG4gICAgICAgIEFzc2lnbm1lbnQ6IDEsXG4gICAgICAgIENvbmRpdGlvbmFsOiAyLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uOiAyLFxuICAgICAgICBMb2dpY2FsT1I6IDMsXG4gICAgICAgIExvZ2ljYWxBTkQ6IDQsXG4gICAgICAgIEJpdHdpc2VPUjogNSxcbiAgICAgICAgQml0d2lzZVhPUjogNixcbiAgICAgICAgQml0d2lzZUFORDogNyxcbiAgICAgICAgRXF1YWxpdHk6IDgsXG4gICAgICAgIFJlbGF0aW9uYWw6IDksXG4gICAgICAgIEJpdHdpc2VTSElGVDogMTAsXG4gICAgICAgIEFkZGl0aXZlOiAxMSxcbiAgICAgICAgTXVsdGlwbGljYXRpdmU6IDEyLFxuICAgICAgICBVbmFyeTogMTMsXG4gICAgICAgIFBvc3RmaXg6IDE0LFxuICAgICAgICBDYWxsOiAxNSxcbiAgICAgICAgTmV3OiAxNixcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGU6IDE3LFxuICAgICAgICBNZW1iZXI6IDE4LFxuICAgICAgICBQcmltYXJ5OiAxOVxuICAgIH07XG5cbiAgICBCaW5hcnlQcmVjZWRlbmNlID0ge1xuICAgICAgICAnfHwnOiBQcmVjZWRlbmNlLkxvZ2ljYWxPUixcbiAgICAgICAgJyYmJzogUHJlY2VkZW5jZS5Mb2dpY2FsQU5ELFxuICAgICAgICAnfCc6IFByZWNlZGVuY2UuQml0d2lzZU9SLFxuICAgICAgICAnXic6IFByZWNlZGVuY2UuQml0d2lzZVhPUixcbiAgICAgICAgJyYnOiBQcmVjZWRlbmNlLkJpdHdpc2VBTkQsXG4gICAgICAgICc9PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICchPSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICc9PT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnIT09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJ2lzJzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJ2lzbnQnOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnPCc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJz4nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc8PSc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJz49JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnaW4nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICdpbnN0YW5jZW9mJzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPDwnOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJz4+JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICc+Pj4nOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJysnOiBQcmVjZWRlbmNlLkFkZGl0aXZlLFxuICAgICAgICAnLSc6IFByZWNlZGVuY2UuQWRkaXRpdmUsXG4gICAgICAgICcqJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJyUnOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlLFxuICAgICAgICAnLyc6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmVcbiAgICB9O1xuXG4gICAgLy9GbGFnc1xuICAgIHZhciBGX0FMTE9XX0lOID0gMSxcbiAgICAgICAgRl9BTExPV19DQUxMID0gMSA8PCAxLFxuICAgICAgICBGX0FMTE9XX1VOUEFSQVRIX05FVyA9IDEgPDwgMixcbiAgICAgICAgRl9GVU5DX0JPRFkgPSAxIDw8IDMsXG4gICAgICAgIEZfRElSRUNUSVZFX0NUWCA9IDEgPDwgNCxcbiAgICAgICAgRl9TRU1JQ09MT05fT1BUID0gMSA8PCA1O1xuXG4gICAgLy9FeHByZXNzaW9uIGZsYWcgc2V0c1xuICAgIC8vTk9URTogRmxhZyBvcmRlcjpcbiAgICAvLyBGX0FMTE9XX0lOXG4gICAgLy8gRl9BTExPV19DQUxMXG4gICAgLy8gRl9BTExPV19VTlBBUkFUSF9ORVdcbiAgICB2YXIgRV9GVFQgPSBGX0FMTE9XX0NBTEwgfCBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9UVEYgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19DQUxMLFxuICAgICAgICBFX1RUVCA9IEZfQUxMT1dfSU4gfCBGX0FMTE9XX0NBTEwgfCBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9URkYgPSBGX0FMTE9XX0lOLFxuICAgICAgICBFX0ZGVCA9IEZfQUxMT1dfVU5QQVJBVEhfTkVXLFxuICAgICAgICBFX1RGVCA9IEZfQUxMT1dfSU4gfCBGX0FMTE9XX1VOUEFSQVRIX05FVztcblxuICAgIC8vU3RhdGVtZW50IGZsYWcgc2V0c1xuICAgIC8vTk9URTogRmxhZyBvcmRlcjpcbiAgICAvLyBGX0FMTE9XX0lOXG4gICAgLy8gRl9GVU5DX0JPRFlcbiAgICAvLyBGX0RJUkVDVElWRV9DVFhcbiAgICAvLyBGX1NFTUlDT0xPTl9PUFRcbiAgICB2YXIgU19URkZGID0gRl9BTExPV19JTixcbiAgICAgICAgU19URkZUID0gRl9BTExPV19JTiB8IEZfU0VNSUNPTE9OX09QVCxcbiAgICAgICAgU19GRkZGID0gMHgwMCxcbiAgICAgICAgU19URlRGID0gRl9BTExPV19JTiB8IEZfRElSRUNUSVZFX0NUWCxcbiAgICAgICAgU19UVEZGID0gRl9BTExPV19JTiB8IEZfRlVOQ19CT0RZO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgICAgICAgYmFzZTogbnVsbCxcbiAgICAgICAgICAgIHBhcnNlOiBudWxsLFxuICAgICAgICAgICAgY29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICcgICAgJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogMCxcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0TXVsdGlsaW5lQ29tbWVudDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld2xpbmU6ICdcXG4nLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAnICcsXG4gICAgICAgICAgICAgICAganNvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVudW1iZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhleGFkZWNpbWFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdW90ZXM6ICdzaW5nbGUnLFxuICAgICAgICAgICAgICAgIGVzY2FwZWxlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcmVudGhlc2VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbWljb2xvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2FmZUNvbmNhdGVuYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlQmxhbmtMaW5lczogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3o6IHtcbiAgICAgICAgICAgICAgICBjb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGFybGVzc0dlbmVyYXRvcjogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IG51bGwsXG4gICAgICAgICAgICBzb3VyY2VNYXBSb290OiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwV2l0aENvZGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgICAgIHZlcmJhdGltOiBudWxsLFxuICAgICAgICAgICAgc291cmNlQ29kZTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1JlcGVhdChzdHIsIG51bSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgZm9yIChudW0gfD0gMDsgbnVtID4gMDsgbnVtID4+Pj0gMSwgc3RyICs9IHN0cikge1xuICAgICAgICAgICAgaWYgKG51bSAmIDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0xpbmVUZXJtaW5hdG9yKHN0cikge1xuICAgICAgICByZXR1cm4gKC9bXFxyXFxuXS9nKS50ZXN0KHN0cik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kc1dpdGhMaW5lVGVybWluYXRvcihzdHIpIHtcbiAgICAgICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW4gJiYgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3Ioc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvdmVycmlkZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlRGVlcGx5KHRhcmdldCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFzaE9iamVjdCh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb3ZlcnJpZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZURlZXBseSh0YXJnZXRba2V5XSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdXBkYXRlRGVlcGx5KHt9LCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgcG9pbnQsIHRlbXAsIGV4cG9uZW50LCBwb3M7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIGxpdGVyYWwgd2hvc2UgdmFsdWUgaXMgTmFOJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtZXJpYyBsaXRlcmFsIHdob3NlIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IDEgLyAwKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbiA/ICdudWxsJyA6IHJlbnVtYmVyID8gJzFlNDAwJyA6ICcxZSs0MDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgaWYgKCFyZW51bWJlciB8fCByZXN1bHQubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvaW50ID0gcmVzdWx0LmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKCFqc29uICYmIHJlc3VsdC5jaGFyQ29kZUF0KDApID09PSAweDMwICAvKiAwICovICYmIHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICBwb2ludCA9IDA7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoJ2UrJywgJ2UnKTtcbiAgICAgICAgZXhwb25lbnQgPSAwO1xuICAgICAgICBpZiAoKHBvcyA9IHRlbXAuaW5kZXhPZignZScpKSA+IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gK3RlbXAuc2xpY2UocG9zICsgMSk7XG4gICAgICAgICAgICB0ZW1wID0gdGVtcC5zbGljZSgwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludCA+PSAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCAtPSB0ZW1wLmxlbmd0aCAtIHBvaW50IC0gMTtcbiAgICAgICAgICAgIHRlbXAgPSArKHRlbXAuc2xpY2UoMCwgcG9pbnQpICsgdGVtcC5zbGljZShwb2ludCArIDEpKSArICcnO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IDA7XG4gICAgICAgIHdoaWxlICh0ZW1wLmNoYXJDb2RlQXQodGVtcC5sZW5ndGggKyBwb3MgLSAxKSA9PT0gMHgzMCAgLyogMCAqLykge1xuICAgICAgICAgICAgLS1wb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAhPT0gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgLT0gcG9zO1xuICAgICAgICAgICAgdGVtcCA9IHRlbXAuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb25lbnQgIT09IDApIHtcbiAgICAgICAgICAgIHRlbXAgKz0gJ2UnICsgZXhwb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0ZW1wLmxlbmd0aCA8IHJlc3VsdC5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgKGhleGFkZWNpbWFsICYmIHZhbHVlID4gMWUxMiAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiYgKHRlbXAgPSAnMHgnICsgdmFsdWUudG9TdHJpbmcoMTYpKS5sZW5ndGggPCByZXN1bHQubGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICAgICArdGVtcCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHZhbGlkIFJlZ0V4cCBleHByZXNzaW9uLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vaXYgRW5naW5lXG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpIHtcbiAgICAgICAgLy8gbm90IGhhbmRsaW5nICdcXCcgYW5kIGhhbmRsaW5nIFxcdTIwMjggb3IgXFx1MjAyOSB0byB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICBpZiAoKGNoICYgfjEpID09PSAweDIwMjgpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJldmlvdXNJc0JhY2tzbGFzaCA/ICd1JyA6ICdcXFxcdScpICsgKChjaCA9PT0gMHgyMDI4KSA/ICcyMDI4JyA6ICcyMDI5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDEwIHx8IGNoID09PSAxMykgeyAgLy8gXFxuLCBcXHJcbiAgICAgICAgICAgIHJldHVybiAocHJldmlvdXNJc0JhY2tzbGFzaCA/ICcnIDogJ1xcXFwnKSArICgoY2ggPT09IDEwKSA/ICduJyA6ICdyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVnRXhwKHJlZykge1xuICAgICAgICB2YXIgbWF0Y2gsIHJlc3VsdCwgZmxhZ3MsIGksIGl6LCBjaCwgY2hhcmFjdGVySW5CcmFjaywgcHJldmlvdXNJc0JhY2tzbGFzaDtcblxuICAgICAgICByZXN1bHQgPSByZWcudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAocmVnLnNvdXJjZSkge1xuICAgICAgICAgICAgLy8gZXh0cmFjdCBmbGFnIGZyb20gdG9TdHJpbmcgcmVzdWx0XG4gICAgICAgICAgICBtYXRjaCA9IHJlc3VsdC5tYXRjaCgvXFwvKFteL10qKSQvKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbGFncyA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHByZXZpb3VzSXNCYWNrc2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gcmVnLnNvdXJjZS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2ggPSByZWcuc291cmNlLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzSXNCYWNrc2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlckluQnJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gOTMpIHsgIC8vIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDQ3KSB7ICAvLyAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkxKSB7ICAvLyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXNCYWNrc2xhc2ggPSBjaCA9PT0gOTI7ICAvLyBcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5ldyBSZWdFeHAoXCJcXFxcXFxuJykgaXMgcHJvdmlkZWQsIGNyZWF0ZSAvXFxuL1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaWtlIC9cXFxcWy9dL1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJy8nICsgcmVzdWx0ICsgJy8nICsgZmxhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZUFsbG93ZWRDaGFyYWN0ZXIoY29kZSwgbmV4dCkge1xuICAgICAgICB2YXIgaGV4O1xuXG4gICAgICAgIGlmIChjb2RlID09PSAweDA4ICAvKiBcXGIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MEMgIC8qIFxcZiAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcZic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwOSAgLyogXFx0ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGhleCA9IGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChqc29uIHx8IGNvZGUgPiAweEZGKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICcwMDAwJy5zbGljZShoZXgubGVuZ3RoKSArIGhleDtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMDAgJiYgIWVzdXRpbHMuY29kZS5pc0RlY2ltYWxEaWdpdChuZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcMCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDBCICAvKiBcXHYgKi8pIHsgLy8gJ1xcdidcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHgwQic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICcwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVEaXNhbGxvd2VkQ2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4NUMgIC8qIFxcICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxcXFxcJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDBBICAvKiBcXG4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MEQgIC8qIFxcciAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxccic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyMDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgyMDI5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdGx5IGNsYXNzaWZpZWQgY2hhcmFjdGVyJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlRGlyZWN0aXZlKHN0cikge1xuICAgICAgICB2YXIgaSwgaXosIGNvZGUsIHF1b3RlO1xuXG4gICAgICAgIHF1b3RlID0gcXVvdGVzID09PSAnZG91YmxlJyA/ICdcIicgOiAnXFwnJztcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdHIubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjcgIC8qICcgKi8pIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICdcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgIC8qIFwiICovKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnXFwnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAgLyogXFwgKi8pIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVvdGUgKyBzdHIgKyBxdW90ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJywgaSwgbGVuLCBjb2RlLCBzaW5nbGVRdW90ZXMgPSAwLCBkb3VibGVRdW90ZXMgPSAwLCBzaW5nbGUsIHF1b3RlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjcgIC8qICcgKi8pIHtcbiAgICAgICAgICAgICAgICArK3NpbmdsZVF1b3RlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8pIHtcbiAgICAgICAgICAgICAgICArK2RvdWJsZVF1b3RlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyRiAgLyogLyAqLyAmJiBqc29uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSkgfHwgY29kZSA9PT0gMHg1QyAgLyogXFwgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlRGlzYWxsb3dlZENoYXJhY3Rlcihjb2RlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGpzb24gJiYgY29kZSA8IDB4MjAgIC8qIFNQICovKSB8fCAhKGpzb24gfHwgZXNjYXBlbGVzcyB8fCAoY29kZSA+PSAweDIwICAvKiBTUCAqLyAmJiBjb2RlIDw9IDB4N0UgIC8qIH4gKi8pKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNvZGUsIHN0ci5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbmdsZSA9ICEocXVvdGVzID09PSAnZG91YmxlJyB8fCAocXVvdGVzID09PSAnYXV0bycgJiYgZG91YmxlUXVvdGVzIDwgc2luZ2xlUXVvdGVzKSk7XG4gICAgICAgIHF1b3RlID0gc2luZ2xlID8gJ1xcJycgOiAnXCInO1xuXG4gICAgICAgIGlmICghKHNpbmdsZSA/IHNpbmdsZVF1b3RlcyA6IGRvdWJsZVF1b3RlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSArIHJlc3VsdCArIHF1b3RlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyID0gcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBxdW90ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA9PT0gMHgyNyAgLyogJyAqLyAmJiBzaW5nbGUpIHx8IChjb2RlID09PSAweDIyICAvKiBcIiAqLyAmJiAhc2luZ2xlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQgKyBxdW90ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmbGF0dGVuIGFuIGFycmF5IHRvIGEgc3RyaW5nLCB3aGVyZSB0aGUgYXJyYXkgY2FuIGNvbnRhaW5cbiAgICAgKiBlaXRoZXIgc3RyaW5ncyBvciBuZXN0ZWQgYXJyYXlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlblRvU3RyaW5nKGFycikge1xuICAgICAgICB2YXIgaSwgaXosIGVsZW0sIHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGFyci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtID0gYXJyW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlzQXJyYXkoZWxlbSkgPyBmbGF0dGVuVG9TdHJpbmcoZWxlbSkgOiBlbGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBnZW5lcmF0ZWQgdG8gYSBTb3VyY2VOb2RlIHdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChnZW5lcmF0ZWQsIG5vZGUpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIC8vIHdpdGggbm8gc291cmNlIG1hcHMsIGdlbmVyYXRlZCBpcyBlaXRoZXIgYW5cbiAgICAgICAgICAgIC8vIGFycmF5IG9yIGEgc3RyaW5nLiAgaWYgYW4gYXJyYXksIGZsYXR0ZW4gaXQuXG4gICAgICAgICAgICAvLyBpZiBhIHN0cmluZywganVzdCByZXR1cm4gaXRcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGdlbmVyYXRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblRvU3RyaW5nKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZCBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBzb3VyY2VNYXAsIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlTm9kZShub2RlLmxvYy5zdGFydC5saW5lLCBub2RlLmxvYy5zdGFydC5jb2x1bW4sIChzb3VyY2VNYXAgPT09IHRydWUgPyBub2RlLmxvYy5zb3VyY2UgfHwgbnVsbCA6IHNvdXJjZU1hcCksIGdlbmVyYXRlZCwgbm9kZS5uYW1lIHx8IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vRW1wdHlTcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIChzcGFjZSkgPyBzcGFjZSA6ICcgJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqb2luKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0U291cmNlLFxuICAgICAgICAgICAgcmlnaHRTb3VyY2UsXG4gICAgICAgICAgICBsZWZ0Q2hhckNvZGUsXG4gICAgICAgICAgICByaWdodENoYXJDb2RlO1xuXG4gICAgICAgIGxlZnRTb3VyY2UgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGxlZnQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChsZWZ0U291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtyaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICByaWdodFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmlnaHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyaWdodFNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdF07XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgcmlnaHRDaGFyQ29kZSA9IHJpZ2h0U291cmNlLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUgfHxcbiAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnQocmlnaHRDaGFyQ29kZSkgfHxcbiAgICAgICAgICAgIGxlZnRDaGFyQ29kZSA9PT0gMHgyRiAgLyogLyAqLyAmJiByaWdodENoYXJDb2RlID09PSAweDY5ICAvKiBpICovKSB7IC8vIGluZml4IHdvcmQgb3BlcmF0b3JzIGFsbCBzdGFydCB3aXRoIGBpYFxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCBub0VtcHR5U3BhY2UoKSwgcmlnaHRdO1xuICAgICAgICB9IGVsc2UgaWYgKGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UobGVmdENoYXJDb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihsZWZ0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShyaWdodENoYXJDb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihyaWdodENoYXJDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCBzcGFjZSwgcmlnaHRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEluZGVudChzdG10KSB7XG4gICAgICAgIHJldHVybiBbYmFzZSwgc3RtdF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aEluZGVudChmbikge1xuICAgICAgICB2YXIgcHJldmlvdXNCYXNlO1xuICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICBiYXNlICs9IGluZGVudDtcbiAgICAgICAgZm4oYmFzZSk7XG4gICAgICAgIGJhc2UgPSBwcmV2aW91c0Jhc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2VzKHN0cikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3Ioc3RyLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzdHIubGVuZ3RoIC0gMSkgLSBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdE11bHRpbGluZUNvbW1lbnQodmFsdWUsIHNwZWNpYWxCYXNlKSB7XG4gICAgICAgIHZhciBhcnJheSwgaSwgbGVuLCBsaW5lLCBqLCBzcGFjZXMsIHByZXZpb3VzQmFzZSwgc247XG5cbiAgICAgICAgYXJyYXkgPSB2YWx1ZS5zcGxpdCgvXFxyXFxufFtcXHJcXG5dLyk7XG4gICAgICAgIHNwYWNlcyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgLy8gZmlyc3QgbGluZSBkb2Vzbid0IGhhdmUgaW5kZW50YXRpb25cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGxpbmUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsaW5lLmxlbmd0aCAmJiBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGxpbmUuY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhY2VzID4gaikge1xuICAgICAgICAgICAgICAgIHNwYWNlcyA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNwZWNpYWxCYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gcGF0dGVybiBsaWtlXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgIHZhciB0ID0gMjA7ICAvKlxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICogdGhpcyBpcyBjb21tZW50XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBpZiAoYXJyYXlbMV1bc3BhY2VzXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEJhc2UgKz0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZSA9IHNwZWNpYWxCYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwYWNlcyAmIDEpIHtcbiAgICAgICAgICAgICAgICAvLyAvKlxuICAgICAgICAgICAgICAgIC8vICAqXG4gICAgICAgICAgICAgICAgLy8gICovXG4gICAgICAgICAgICAgICAgLy8gSWYgc3BhY2VzIGFyZSBvZGQgbnVtYmVyLCBhYm92ZSBwYXR0ZXJuIGlzIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FzdGUgMSBzcGFjZS5cbiAgICAgICAgICAgICAgICAtLXNwYWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc24gPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGFkZEluZGVudChhcnJheVtpXS5zbGljZShzcGFjZXMpKSk7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHNvdXJjZU1hcCA/IHNuLmpvaW4oJycpIDogc247XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlID0gcHJldmlvdXNCYXNlO1xuXG4gICAgICAgIHJldHVybiBhcnJheS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCwgc3BlY2lhbEJhc2UpIHtcbiAgICAgICAgaWYgKGNvbW1lbnQudHlwZSA9PT0gJ0xpbmUnKSB7XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhMaW5lVGVybWluYXRvcihjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBMaW5lVGVybWluYXRvclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAnLy8nICsgY29tbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmZvcm1hdC5pbmRlbnQuYWRqdXN0TXVsdGlsaW5lQ29tbWVudCAmJiAvW1xcblxccl0vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KCcvKicgKyBjb21tZW50LnZhbHVlICsgJyovJywgc3BlY2lhbEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLyonICsgY29tbWVudC52YWx1ZSArICcqLyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudHMoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNvbW1lbnQsIHNhdmUsIHRhaWxpbmdUb1N0YXRlbWVudCwgc3BlY2lhbEJhc2UsIGZyYWdtZW50LFxuICAgICAgICAgICAgZXh0UmFuZ2UsIHJhbmdlLCBwcmV2UmFuZ2UsIHByZWZpeCwgaW5maXgsIHN1ZmZpeCwgY291bnQ7XG5cbiAgICAgICAgaWYgKHN0bXQubGVhZGluZ0NvbW1lbnRzICYmIHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNhdmUgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgICAgICBleHRSYW5nZSA9IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICBwcmVmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhleHRSYW5nZVswXSwgcmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHByZWZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZSYW5nZSA9IHJhbmdlO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5maXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhwcmV2UmFuZ2VbMV0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAoaW5maXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcblxuICAgICAgICAgICAgICAgICAgICBwcmV2UmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdWZmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVsxXSwgZXh0UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHN1ZmZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHNhZmVDb25jYXRlbmF0aW9uICYmIHN0bXQudHlwZSA9PT0gU3ludGF4LlByb2dyYW0gJiYgc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChmcmFnbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHNhdmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG10LnRyYWlsaW5nQ29tbWVudHMpIHtcblxuICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LnRyYWlsaW5nQ29tbWVudHNbMF07XG4gICAgICAgICAgICAgICAgZXh0UmFuZ2UgPSBjb21tZW50LmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcoZXh0UmFuZ2VbMF0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChwcmVmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFpbGluZ1RvU3RhdGVtZW50ID0gIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHNwZWNpYWxCYXNlID0gc3RyaW5nUmVwZWF0KCcgJywgY2FsY3VsYXRlU3BhY2VzKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoW2Jhc2UsIHJlc3VsdCwgaW5kZW50XSkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQudHJhaWxpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFpbGluZ1RvU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGFyZ2V0IGxpa2UgZm9sbG93aW5nIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciB0ID0gMjA7ICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKiBUaGlzIGlzIGNvbW1lbnQgb2YgdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgaW5kZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgc3BlY2lhbEJhc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQsIHNwZWNpYWxCYXNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGxlbiAtIDEgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCAnXFxuJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQmxhbmtMaW5lcyhzdGFydCwgZW5kLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGosIG5ld2xpbmVDb3VudCA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gc3RhcnQ7IGogPCBlbmQ7IGorKykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUNvZGVbal0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbmV3bGluZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXplKHRleHQsIGN1cnJlbnQsIHNob3VsZCkge1xuICAgICAgICBpZiAoY3VycmVudCA8IHNob3VsZCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHRleHQsICcpJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5zcGxpdCgvXFxyXFxufFxcbi8pO1xuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBpejsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBuZXdsaW5lICsgYmFzZSArIHJlc3VsdFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmVyYmF0aW0oZXhwciwgcHJlY2VkZW5jZSkge1xuICAgICAgICB2YXIgdmVyYmF0aW0sIHJlc3VsdCwgcHJlYztcbiAgICAgICAgdmVyYmF0aW0gPSBleHByW2V4dHJhLnZlcmJhdGltXTtcblxuICAgICAgICBpZiAodHlwZW9mIHZlcmJhdGltID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcodmVyYmF0aW0pLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZlcmJhdGltIGlzIG9iamVjdFxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyh2ZXJiYXRpbS5jb250ZW50KTtcbiAgICAgICAgICAgIHByZWMgPSAodmVyYmF0aW0ucHJlY2VkZW5jZSAhPSBudWxsKSA/IHZlcmJhdGltLnByZWNlZGVuY2UgOiBQcmVjZWRlbmNlLlNlcXVlbmNlO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgcHJlYywgcHJlY2VkZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIGV4cHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvZGVHZW5lcmF0b3IoKSB7XG4gICAgfVxuXG4gICAgLy8gSGVscGVycy5cblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLm1heWJlQmxvY2sgPSBmdW5jdGlvbihzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0LCBub0xlYWRpbmdDb21tZW50LCB0aGF0ID0gdGhpcztcblxuICAgICAgICBub0xlYWRpbmdDb21tZW50ID0gIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzO1xuXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NwYWNlLCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIGZsYWdzKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguRW1wdHlTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgfVxuXG4gICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIG5ld2xpbmUsXG4gICAgICAgICAgICAgICAgYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdCwgZmxhZ3MpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUubWF5YmVCbG9ja1N1ZmZpeCA9IGZ1bmN0aW9uIChzdG10LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGVuZHMgPSBlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmICghZXh0cmEuY29tbWVudCB8fCAhc3RtdC5sZWFkaW5nQ29tbWVudHMpICYmICFlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgc3BhY2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZXN1bHQsIG5ld2xpbmUsIGJhc2VdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUlkZW50aWZpZXIobm9kZSkge1xuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChub2RlLm5hbWUsIG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXN5bmNQcmVmaXgobm9kZSwgc3BhY2VSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbm9kZS5hc3luYyA/ICdhc3luYycgKyAoc3BhY2VSZXF1aXJlZCA/IG5vRW1wdHlTcGFjZSgpIDogc3BhY2UpIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTdGFyU3VmZml4KG5vZGUpIHtcbiAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gbm9kZS5nZW5lcmF0b3IgJiYgIWV4dHJhLm1vei5zdGFybGVzc0dlbmVyYXRvcjtcbiAgICAgICAgcmV0dXJuIGlzR2VuZXJhdG9yID8gJyonICsgc3BhY2UgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU1ldGhvZFByZWZpeChwcm9wKSB7XG4gICAgICAgIHZhciBmdW5jID0gcHJvcC52YWx1ZTtcbiAgICAgICAgaWYgKGZ1bmMuYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUFzeW5jUHJlZml4KGZ1bmMsICFwcm9wLmNvbXB1dGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIHNwYWNlIGJlZm9yZSBtZXRob2QgbmFtZVxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlU3RhclN1ZmZpeChmdW5jKSA/ICcqJyA6ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdCwgaGFzRGVmYXVsdDtcblxuICAgICAgICBoYXNEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uICYmXG4gICAgICAgICAgICAgICAgIW5vZGUucmVzdCAmJiAoIW5vZGUuZGVmYXVsdHMgfHwgbm9kZS5kZWZhdWx0cy5sZW5ndGggPT09IDApICYmXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmIG5vZGUucGFyYW1zWzBdLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBhcmcgPT4geyB9IGNhc2VcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIHRydWUpLCBnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5wYXJhbXNbMF0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uID8gW2dlbmVyYXRlQXN5bmNQcmVmaXgobm9kZSwgZmFsc2UpXSA6IFtdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgIGlmIChub2RlLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaGFzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IG5vZGUucGFyYW1zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiBub2RlLmRlZmF1bHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUFzc2lnbm1lbnQobm9kZS5wYXJhbXNbaV0sIG5vZGUuZGVmYXVsdHNbaV0sICc9JywgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVQYXR0ZXJuKG5vZGUucGFyYW1zW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnJlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJy4uLicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihub2RlLnJlc3QpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgZXhwcjtcblxuICAgICAgICByZXN1bHQgPSB0aGlzLmdlbmVyYXRlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnPT4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLmJvZHksIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpO1xuICAgICAgICAgICAgaWYgKGV4cHIudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBbJygnLCBleHByLCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhwcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2sobm9kZS5ib2R5LCBTX1RURkYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlSXRlcmF0aW9uRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gWydmb3InICsgc3BhY2UgKyAnKCddLCB0aGF0ID0gdGhpcztcbiAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0bXQubGVmdC5raW5kICsgbm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQubGVmdC5kZWNsYXJhdGlvbnNbMF0sIFNfRkZGRikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmxlZnQsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIG9wZXJhdG9yKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtqb2luKFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnJpZ2h0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICksICcpJ107XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKGV4cHIsIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCddJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUFzc2lnbm1lbnQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIG9wZXJhdG9yLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICBpZiAoUHJlY2VkZW5jZS5Bc3NpZ25tZW50IDwgcHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obGVmdCwgUHJlY2VkZW5jZS5DYWxsLCBmbGFncyksXG4gICAgICAgICAgICAgICAgc3BhY2UgKyBvcGVyYXRvciArIHNwYWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHJpZ2h0LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuc2VtaWNvbG9uID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gICAgICAgIGlmICghc2VtaWNvbG9ucyAmJiBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnOyc7XG4gICAgfTtcblxuICAgIC8vIFN0YXRlbWVudHMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLlN0YXRlbWVudCA9IHtcblxuICAgICAgICBCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UsIGNvbnRlbnQsIHJlc3VsdCA9IFsneycsIG5ld2xpbmVdLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGZ1bmN0aW9ucyB3aXRob3V0IGFueSBjb2RlXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keS5sZW5ndGggPT09IDAgJiYgcHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gc3RtdC5yYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlWzFdIC0gcmFuZ2VbMF0gPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocmFuZ2VbMF0gKyAxLCByYW5nZVsxXSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWyd7J107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpLCBpeiwgZnJhZ21lbnQsIGJvZHlGbGFncztcbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgRl9GVU5DX0JPRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfRElSRUNUSVZFX0NUWDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuYm9keS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmVmb3JlIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50c1swXS5leHRlbmRlZFJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ3snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQucmFuZ2VbMF0sIHN0bXQuYm9keVswXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmV0d2VlbiBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSAtIDFdLnRyYWlsaW5nQ29tbWVudHMgICYmICFzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaSAtIDFdLnJhbmdlWzFdLCBzdG10LmJvZHlbaV0ucmFuZ2VbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzICYmIHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYm9keVtpXSwgYm9keUZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzICYmIGkgPCBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBhZGQgYSBuZXcgbGluZSBpZiB0aGVyZSBhcmUgbGVhZGluZyBjb21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG5leHQgc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSArIDFdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBhZnRlciB0aGUgbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaV0udHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2ldLnJhbmdlWzFdLCBzdG10LnJhbmdlWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoJ30nKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdicmVhayAnICsgc3RtdC5sYWJlbC5uYW1lICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdicmVhaycgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlICcgKyBzdG10LmxhYmVsLm5hbWUgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0JvZHk6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lXSwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBpejtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5ib2R5W2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgcmVzdWx0ICA9IFsnY2xhc3MgJyArIHN0bXQuaWQubmFtZV07XG4gICAgICAgICAgICBpZiAoc3RtdC5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKCdleHRlbmRzJywgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zdXBlckNsYXNzLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5LCBTX1RGRlQpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYXcgJiYgc3RtdC5yYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RtdC5yYXcgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRGlyZWN0aXZlKHN0bXQuZGlyZWN0aXZlKSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgYGRvIDQyIHdoaWxlIChjb25kKWAgaXMgU3ludGF4IEVycm9yLiBXZSBuZWVkIHNlbWljb2xvbi5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKCdkbycsIHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIFNfVEZGRikpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICd3aGlsZScgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAnKScgKyB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIENhdGNoQ2xhdXNlOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnY2F0Y2gnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQucGFyYW0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGlmIChzdG10Lmd1YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIGd1YXJkID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5ndWFyZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKDIsIDAsICcgaWYgJywgZ3VhcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgU19URkZGKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVidWdnZXInICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnOyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgJ2V4cG9ydCcgXSwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgYm9keUZsYWdzID0gKGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSA/IFNfVEZGVCA6IFNfVEZGRjtcblxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgSG9pc3RhYmxlRGVjbGFyYXRpb25bRGVmYXVsdF1cbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IEFzc2lnbm1lbnRFeHByZXNzaW9uW0luXSA7XG4gICAgICAgICAgICBpZiAoc3RtdFsnZGVmYXVsdCddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb24sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmRlY2xhcmF0aW9uLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCBWYXJpYWJsZVN0YXRlbWVudFxuICAgICAgICAgICAgLy8gZXhwb3J0IERlY2xhcmF0aW9uW0RlZmF1bHRdXG4gICAgICAgICAgICBpZiAoc3RtdC5kZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmRlY2xhcmF0aW9uLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXhwb3J0ICogRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICAvLyBleHBvcnQgRXhwb3J0Q2xhdXNlW05vUmVmZXJlbmNlXSBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIC8vIGV4cG9ydCBFeHBvcnRDbGF1c2UgO1xuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAneycgKyBzcGFjZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdG10LnNwZWNpZmllcnNbMF0udHlwZSA9PT0gU3ludGF4LkV4cG9ydEJhdGNoU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbMF0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICd7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuc3BlY2lmaWVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vZHVsZVNwZWNpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlbWljb2xvbihmbGFncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNDbGFzc1ByZWZpeGVkKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnNsaWNlKDAsIDUpICE9PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoNSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IDB4N0IgIC8qICd7JyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uUHJlZml4ZWQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgOCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdCg4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMHgyOCAvKiAnKCcgKi8gfHwgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjb2RlKSB8fCBjb2RlID09PSAweDJBICAvKiAnKicgKi8gfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQXN5bmNQcmVmaXhlZChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlLCBpLCBpejtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgNSkgIT09ICdhc3luYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoZnJhZ21lbnQuY2hhckNvZGVBdCg1KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSA2LCBpeiA9IGZyYWdtZW50Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGZyYWdtZW50LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoaSwgaSArIDgpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoaSArIDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlID09PSAweDI4IC8qICcoJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGNvZGUgPT09IDB4MkEgIC8qICcqJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbiwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXTtcbiAgICAgICAgICAgIC8vIDEyLjQgJ3snLCAnZnVuY3Rpb24nLCAnY2xhc3MnIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgcG9zaXRpb24uXG4gICAgICAgICAgICAvLyB3cmFwIGV4cHJlc3Npb24gd2l0aCBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGFyQ29kZUF0KDApID09PSAweDdCICAvKiAneycgKi8gfHwgIC8vIE9iamVjdEV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaXNDbGFzc1ByZWZpeGVkKGZyYWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uUHJlZml4ZWQoZnJhZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmNQcmVmaXhlZChmcmFnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGl2ZSAmJiAoZmxhZ3MgJiBGX0RJUkVDVElWRV9DVFgpICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJygnLCByZXN1bHQsICcpJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEVTNjogMTUuMi4xIHZhbGlkIGltcG9ydCBkZWNsYXJhdGlvbnM6XG4gICAgICAgICAgICAvLyAgICAgLSBpbXBvcnQgSW1wb3J0Q2xhdXNlIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgLy8gICAgIC0gaW1wb3J0IE1vZHVsZVNwZWNpZmllciA7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBjdXJzb3IsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBJbXBvcnRDbGF1c2UgaXMgcHJlc2VudCxcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIGBpbXBvcnQgTW9kdWxlU3BlY2lmaWVyYCBzbyBza2lwIGBmcm9tYFxuICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyIGlzIFN0cmluZ0xpdGVyYWwuXG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydCBNb2R1bGVTcGVjaWZpZXIgO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdpbXBvcnQnLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc291cmNlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGltcG9ydCBJbXBvcnRDbGF1c2UgRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgJ2ltcG9ydCdcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjdXJzb3IgPSAwO1xuXG4gICAgICAgICAgICAvLyBJbXBvcnRlZEJpbmRpbmdcbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXS50eXBlID09PSBTeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgKytjdXJzb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0udHlwZSA9PT0gU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lU3BhY2VJbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkSW1wb3J0c1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd7Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzdG10LnNwZWNpZmllcnMubGVuZ3RoIC0gY3Vyc29yKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHsgLi4uIH0gZnJvbSBcIi4uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd9JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGZyb20gXCIuLi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjdXJzb3IsIGl6ID0gc3RtdC5zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UgKyAnfScgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgJ2Zyb20nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGl0ZW1GbGFncyA9IChmbGFncyAmIEZfQUxMT1dfSU4pID8gRV9UVFQgOiBFX0ZUVDtcbiAgICAgICAgICAgIGlmIChzdG10LmluaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmlkLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGl0ZW1GbGFncyksXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAnPScsXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgaXRlbUZsYWdzKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBhdHRlcm4oc3RtdC5pZCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBpdGVtRmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gVmFyaWFibGVEZWNsYXJhdG9yIGlzIHR5cGVkIGFzIFN0YXRlbWVudCxcbiAgICAgICAgICAgIC8vIGJ1dCBqb2luZWQgd2l0aCBjb21tYSAobm90IExpbmVUZXJtaW5hdG9yKS5cbiAgICAgICAgICAgIC8vIFNvIGlmIGNvbW1lbnQgaXMgYXR0YWNoZWQgdG8gdGFyZ2V0IG5vZGUsIHdlIHNob3VsZCBzcGVjaWFsaXplLlxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIG5vZGUsIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IFsgc3RtdC5raW5kIF07XG5cbiAgICAgICAgICAgIGJvZHlGbGFncyA9IChmbGFncyAmIEZfQUxMT1dfSU4pID8gU19URkZGIDogU19GRkZGO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBibG9jaygpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGl6ID0gc3RtdC5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50ICYmIG5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChibG9jayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtqb2luKFxuICAgICAgICAgICAgICAgICd0aHJvdycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICApLCB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgZ3VhcmRlZEhhbmRsZXJzO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBbJ3RyeScsIHRoaXMubWF5YmVCbG9jayhzdG10LmJsb2NrLCBTX1RGRkYpXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmJsb2NrLCByZXN1bHQpO1xuXG4gICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIG9sZCBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuaGFuZGxlcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJzW2ldLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3VhcmRlZEhhbmRsZXJzID0gc3RtdC5ndWFyZGVkSGFuZGxlcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGd1YXJkZWRIYW5kbGVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KGd1YXJkZWRIYW5kbGVyc1tpXSwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChndWFyZGVkSGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5ldyBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHN0bXQuaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5oYW5kbGVyLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJbaV0sIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcltpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlciwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydmaW5hbGx5JywgdGhpcy5tYXliZUJsb2NrKHN0bXQuZmluYWxpemVyLCBTX1RGRkYpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudCwgaSwgaXosIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdzd2l0Y2gnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZGlzY3JpbWluYW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJyArIHNwYWNlICsgJ3snICsgbmV3bGluZVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdG10LmNhc2VzKSB7XG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5jYXNlcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmNhc2VzW2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KCd9JykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBTd2l0Y2hDYXNlOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCBpLCBpeiwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbignY2FzZScsIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc6J1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnZGVmYXVsdDonXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBpeiA9IHN0bXQuY29uc2VxdWVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGl6ICYmIHN0bXQuY29uc2VxdWVudFswXS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0Lm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50WzBdLCBTX1RGRkYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBpeiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxICYmIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5jb25zZXF1ZW50W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgIT09IGl6ICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBJZlN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBib2R5RmxhZ3MsIHNlbWljb2xvbk9wdGlvbmFsLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2lmJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VtaWNvbG9uT3B0aW9uYWwgPSBmbGFncyAmIEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgIGlmIChzZW1pY29sb25PcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RtdC5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50LCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5jb25zZXF1ZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZS50eXBlID09PSBTeW50YXguSWZTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsnZWxzZSAnLCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYWx0ZXJuYXRlLCBib2R5RmxhZ3MpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGpvaW4oJ2Vsc2UnLCB0aGlzLm1heWJlQmxvY2soc3RtdC5hbHRlcm5hdGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnQsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2ZvcicgKyBzcGFjZSArICcoJ107XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5pbml0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaW5pdCwgU19GRkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGX0FMTE9XX0lOIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfRlRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC51cGRhdGUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQoJ2luJywgc3RtdCwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSXRlcmF0aW9uRm9yU3RhdGVtZW50KCdvZicsIHN0bXQsIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKTtcbiAgICAgICAgfSxcblxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3RtdC5sYWJlbC5uYW1lICsgJzonLCB0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRildO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb2dyYW06IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIGksIGl6LCBib2R5RmxhZ3M7XG4gICAgICAgICAgICBpeiA9IHN0bXQuYm9keS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQgPSBbc2FmZUNvbmNhdGVuYXRpb24gJiYgaXogPiAwID8gJ1xcbicgOiAnJ107XG4gICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGVEY7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghc2FmZUNvbmNhdGVuYXRpb24gJiYgaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGJlZm9yZSB0aGUgZmlyc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQucmFuZ2VbMF0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmV0d2VlbiBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2kgLSAxXS50cmFpbGluZ0NvbW1lbnRzICYmICFzdG10LmJvZHlbaV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpIC0gMV0ucmFuZ2VbMV0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXogJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSArIDFdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYWZ0ZXIgdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpXS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpXS5yYW5nZVsxXSwgc3RtdC5yYW5nZVsxXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXN5bmNQcmVmaXgoc3RtdCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVN0YXJTdWZmaXgoc3RtdCkgfHwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVJZGVudGlmaWVyKHN0bXQuaWQpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoc3RtdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtqb2luKFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgKSwgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ3JldHVybicgKyB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICB9LFxuXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnd2l0aCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5vYmplY3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtZXJnZShDb2RlR2VuZXJhdG9yLnByb3RvdHlwZSwgQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQpO1xuXG4gICAgLy8gRXhwcmVzc2lvbnMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24gPSB7XG5cbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6O1xuICAgICAgICAgICAgaWYgKFByZWNlZGVuY2UuU2VxdWVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb25zW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUFzc2lnbm1lbnQoZXhwci5sZWZ0LCBleHByLnJpZ2h0LCBleHByLm9wZXJhdG9yLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZSh0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIpLCBQcmVjZWRlbmNlLkFycm93RnVuY3Rpb24sIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoUHJlY2VkZW5jZS5Db25kaXRpb25hbCA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudGVzdCwgUHJlY2VkZW5jZS5Mb2dpY2FsT1IsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnPycgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jb25zZXF1ZW50LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnOicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hbHRlcm5hdGUsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLkNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQmluYXJ5RXhwcmVzc2lvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBjdXJyZW50UHJlY2VkZW5jZSwgZnJhZ21lbnQsIGxlZnRTb3VyY2U7XG4gICAgICAgICAgICBjdXJyZW50UHJlY2VkZW5jZSA9IEJpbmFyeVByZWNlZGVuY2VbZXhwci5vcGVyYXRvcl07XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlY2VkZW5jZSA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIubGVmdCwgY3VycmVudFByZWNlZGVuY2UsIGZsYWdzKTtcblxuICAgICAgICAgICAgbGVmdFNvdXJjZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKSA9PT0gMHgyRiAvKiAvICovICYmIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0KGV4cHIub3BlcmF0b3IuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZnJhZ21lbnQsIG5vRW1wdHlTcGFjZSgpLCBleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihmcmFnbWVudCwgZXhwci5vcGVyYXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwgY3VycmVudFByZWNlZGVuY2UgKyAxLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yID09PSAnLycgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICcvJyB8fFxuICAgICAgICAgICAgZXhwci5vcGVyYXRvci5zbGljZSgtMSkgPT09ICc8JyAmJiBmcmFnbWVudC50b1N0cmluZygpLnNsaWNlKDAsIDMpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgIC8vIElmICcvJyBjb25jYXRzIHdpdGggJy8nIG9yIGA8YCBjb25jYXRzIHdpdGggYCEtLWAsIGl0IGlzIGludGVycHJldGVkIGFzIGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJ2luJyAmJiAhKGZsYWdzICYgRl9BTExPV19JTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIGN1cnJlbnRQcmVjZWRlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpejtcbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVEYpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHJbJ2FyZ3VtZW50cyddLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfQ0FMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuQ2FsbCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBsZW5ndGgsIGksIGl6LCBpdGVtRmxhZ3M7XG4gICAgICAgICAgICBsZW5ndGggPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfQ0FMTCBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgLy8gRl9BTExPV19VTlBBUkFUSF9ORVcgbWF5IGJlY29tZSBmYWxzZS5cbiAgICAgICAgICAgIGl0ZW1GbGFncyA9IChmbGFncyAmIEZfQUxMT1dfVU5QQVJBVEhfTkVXICYmICFwYXJlbnRoZXNlcyAmJiBsZW5ndGggPT09IDApID8gRV9URlQgOiBFX1RGRjtcblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihcbiAgICAgICAgICAgICAgICAnbmV3JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNhbGxlZSwgUHJlY2VkZW5jZS5OZXcsIGl0ZW1GbGFncylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghKGZsYWdzICYgRl9BTExPV19VTlBBUkFUSF9ORVcpIHx8IHBhcmVudGhlc2VzIHx8IGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKCcpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gbGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk5ldywgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcblxuICAgICAgICAgICAgLy8gRl9BTExPV19VTlBBUkFUSF9ORVcgYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgIHJlc3VsdCA9IFt0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLm9iamVjdCwgUHJlY2VkZW5jZS5DYWxsLCAoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpID8gRV9UVEYgOiBFX1RGRildO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0eSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgZmxhZ3MgJiBGX0FMTE9XX0NBTEwgPyBFX1RUVCA6IEVfVEZUKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub2JqZWN0LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsICYmIHR5cGVvZiBleHByLm9iamVjdC52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGFsbCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDEuIE5vIGZsb2F0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgMi4gRG9uJ3QgaGF2ZSBleHBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAzLiBUaGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBkZWNpbWFsIGRpZ2l0XG4gICAgICAgICAgICAgICAgICAgIC8vICAgNC4gTm90IGhleGFkZWNpbWFsIE9SIG9jdGFsIG51bWJlciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhZGQgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmluZGV4T2YoJy4nKSA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhL1tlRXhYXS8udGVzdChmcmFnbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQoZnJhZ21lbnQuY2hhckNvZGVBdChmcmFnbWVudC5sZW5ndGggLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZyYWdtZW50Lmxlbmd0aCA+PSAyICYmIGZyYWdtZW50LmNoYXJDb2RlQXQoMCkgPT09IDQ4KSAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIucHJvcGVydHkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuTWVtYmVyLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIHJpZ2h0Q2hhckNvZGUsIGxlZnRTb3VyY2UsIGxlZnRDaGFyQ29kZTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5VbmFyeSwgRV9UVFQpO1xuXG4gICAgICAgICAgICBpZiAoc3BhY2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihleHByLm9wZXJhdG9yLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvci5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgdm9pZCwgdHlwZW9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBgdHlwZW9mIFtdYCwgbm90IGB0eXBlb2ZbXWBcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGluc2VydGluZyBzcGFjZXMgYmV0d2VlbiBvcGVyYXRvciBhbmQgYXJndW1lbnQgaWYgaXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlrZSwgYCFjb25kYFxuICAgICAgICAgICAgICAgICAgICBsZWZ0U291cmNlID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDaGFyQ29kZSA9IGxlZnRTb3VyY2UuY2hhckNvZGVBdChsZWZ0U291cmNlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENoYXJDb2RlID0gZnJhZ21lbnQudG9TdHJpbmcoKS5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKGxlZnRDaGFyQ29kZSA9PT0gMHgyQiAgLyogKyAqLyB8fCBsZWZ0Q2hhckNvZGUgPT09IDB4MkQgIC8qIC0gKi8pICYmIGxlZnRDaGFyQ29kZSA9PT0gcmlnaHRDaGFyQ29kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnQobGVmdENoYXJDb2RlKSAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydChyaWdodENoYXJDb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlVuYXJ5LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChleHByLmRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3lpZWxkKic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5hcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5ZaWVsZCwgRV9UVFQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLllpZWxkLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBd2FpdEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgZXhwci5kZWxlZ2F0ZSA/ICdhd2FpdConIDogJ2F3YWl0JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLkF3YWl0LCBFX1RUVClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5Bd2FpdCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZXhwci5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5VbmFyeSwgRV9UVFQpXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuVW5hcnksXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuUG9zdGZpeCwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICBleHByLm9wZXJhdG9yXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLlBvc3RmaXgsXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFzeW5jUHJlZml4KGV4cHIsIHRydWUpLFxuICAgICAgICAgICAgICAgICdmdW5jdGlvbidcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlU3RhclN1ZmZpeChleHByKSB8fCBub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIuaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVTdGFyU3VmZml4KGV4cHIpIHx8IHNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwcikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJyonO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5BcnJheUV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBtdWx0aWxpbmUsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZXhwci5lbGVtZW50cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgcmVzdWx0ID0gWydbJywgbXVsdGlsaW5lID8gbmV3bGluZSA6ICcnXTtcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cHIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBpbmRlbnQgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmVsZW1lbnRzW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIChtdWx0aWxpbmUgPyBuZXdsaW5lIDogc3BhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbJ2NsYXNzJ107XG4gICAgICAgICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmlkLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbignZXh0ZW5kcycsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuc3VwZXJDbGFzcywgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlU3RhdGVtZW50KGV4cHIuYm9keSwgU19URkZUKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZXhwclsnc3RhdGljJ10pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ3N0YXRpYycgKyBzcGFjZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIua2luZCA9PT0gJ2dldCcgfHwgZXhwci5raW5kID09PSAnc2V0Jykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBqb2luKGV4cHIua2luZCwgdGhpcy5nZW5lcmF0ZVByb3BlcnR5S2V5KGV4cHIua2V5LCBleHByLmNvbXB1dGVkKSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwci52YWx1ZSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNZXRob2RQcmVmaXgoZXhwciksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwci52YWx1ZSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUHJvcGVydHk6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKGV4cHIua2luZCA9PT0gJ2dldCcgfHwgZXhwci5raW5kID09PSAnc2V0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGV4cHIua2luZCwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwci52YWx1ZSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVByb3BlcnR5S2V5KGV4cHIua2V5LCBleHByLmNvbXB1dGVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNZXRob2RQcmVmaXgoZXhwciksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwci52YWx1ZSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCksXG4gICAgICAgICAgICAgICAgJzonICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci52YWx1ZSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgbXVsdGlsaW5lLCByZXN1bHQsIGZyYWdtZW50LCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFleHByLnByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBleHByLnByb3BlcnRpZXMubGVuZ3RoID4gMTtcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbMF0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgIC8vIGlzc3VlcyA0XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHRyYW5zZm9ybSBmcm9tXG4gICAgICAgICAgICAgICAgLy8gICBkZWphdnUuQ2xhc3MuZGVjbGFyZSh7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgbWV0aG9kMjogZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgICAgICAvLyAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgLy8gICBkZWphdnUuQ2xhc3MuZGVjbGFyZSh7bWV0aG9kMjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIH19KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0xpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbICd7Jywgc3BhY2UsIGZyYWdtZW50LCBzcGFjZSwgJ30nIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWyAneycsIG5ld2xpbmUsIGluZGVudCwgZnJhZ21lbnQgXTtcblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ30nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgbXVsdGlsaW5lLCBwcm9wZXJ0eSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIucHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3t9JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGV4cHIucHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eS5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFsneycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJyBdO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBpbmRlbnQgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydGllc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIChtdWx0aWxpbmUgPyBuZXdsaW5lIDogc3BhY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gYmFzZSA6ICcnKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAndGhpcyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWRlbnRpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihleHByLmlkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsnKiddO1xuICAgICAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICdhcycgKyBub0VtcHR5U3BhY2UoKSArIGdlbmVyYXRlSWRlbnRpZmllcihleHByLmlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeHBvcnRTcGVjaWZpZXIoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyBleHByLmlkLm5hbWUgXTtcbiAgICAgICAgICAgIGlmIChleHByLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSArICdhcycgKyBub0VtcHR5U3BhY2UoKSArIGdlbmVyYXRlSWRlbnRpZmllcihleHByLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTGl0ZXJhbDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmF3O1xuICAgICAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ3JhdycpICYmIHBhcnNlICYmIGV4dHJhLnJhdykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IHBhcnNlKGV4cHIucmF3KS5ib2R5WzBdLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXcudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXcudmFsdWUgPT09IGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwci5yYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCB1c2UgcmF3IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlU3RyaW5nKGV4cHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlTnVtYmVyKGV4cHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByLnZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUmVnRXhwKGV4cHIudmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRvckV4cHJlc3Npb24gc2hvdWxkIGJlIHBhcmVudGhlc2l6ZWQgd2l0aCAoLi4uKSwgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gd2l0aCBbLi4uXVxuICAgICAgICAgICAgLy8gRHVlIHRvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4MzQ2OCBwb3NpdGlvbiBvZiBleHByLmJvZHkgY2FuIGRpZmZlciBpbiBTcGlkZXJtb25rZXkgYW5kIEVTNlxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgZnJhZ21lbnQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgcmVzdWx0ID0gKGV4cHIudHlwZSA9PT0gU3ludGF4LkdlbmVyYXRvckV4cHJlc3Npb24pID8gWycoJ10gOiBbJ1snXTtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLm1vei5jb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJvZHksIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5ibG9ja3MubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJsb2Nrc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwIHx8IGV4dHJhLm1vei5jb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAnaWYnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5maWx0ZXIsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWyAnKCcsIGZyYWdtZW50LCAnKScgXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXh0cmEubW96LmNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYm9keSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCgoZXhwci50eXBlID09PSBTeW50YXguR2VuZXJhdG9yRXhwcmVzc2lvbikgPyAnKScgOiAnXScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGV4cHIubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBleHByLmxlZnQua2luZCwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoZXhwci5sZWZ0LmRlY2xhcmF0aW9uc1swXSwgU19GRkZGKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRUKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKGZyYWdtZW50LCBleHByLm9mID8gJ29mJyA6ICdpbicpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKGZyYWdtZW50LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnJpZ2h0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gWyAnZm9yJyArIHNwYWNlICsgJygnLCBmcmFnbWVudCwgJyknIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3ByZWFkRWxlbWVudDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICcuLi4nLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUZsYWdzID0gRV9UVEY7XG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfQ0FMTCkpIHtcbiAgICAgICAgICAgICAgICBpdGVtRmxhZ3MgPSBFX1RGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci50YWcsIFByZWNlZGVuY2UuQ2FsbCwgaXRlbUZsYWdzKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnF1YXNpLCBQcmVjZWRlbmNlLlByaW1hcnksIEVfRkZUKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlRhZ2dlZFRlbXBsYXRlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIFwiY29va2VkXCIuIFNpbmNlIHRhZ2dlZCB0ZW1wbGF0ZSBjYW4gdXNlIHJhdyB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gcmVwcmVzZW50YXRpb24uIFNvIGlmIHdlIGRvIHNvLCBpdCBicmVha3MgdGhlIHNjcmlwdCBzZW1hbnRpY3MuXG4gICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZS5yYXc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6O1xuICAgICAgICAgICAgcmVzdWx0ID0gWyAnYCcgXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5xdWFzaXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucXVhc2lzW2ldLCBQcmVjZWRlbmNlLlByaW1hcnksIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyR7JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnfScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdgJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5MaXRlcmFsKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIG1lcmdlKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24pO1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHR5cGU7XG5cbiAgICAgICAgdHlwZSA9IGV4cHIudHlwZSB8fCBTeW50YXguUHJvcGVydHk7XG5cbiAgICAgICAgaWYgKGV4dHJhLnZlcmJhdGltICYmIGV4cHIuaGFzT3duUHJvcGVydHkoZXh0cmEudmVyYmF0aW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVWZXJiYXRpbShleHByLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbdHlwZV0oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKGV4cHIscmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIGV4cHIpO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgZnJhZ21lbnQ7XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpc1tzdG10LnR5cGVdKHN0bXQsIGZsYWdzKTtcblxuICAgICAgICAvLyBBdHRhY2ggY29tbWVudHNcblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYWRkQ29tbWVudHMoc3RtdCwgcmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtICYmICFzYWZlQ29uY2F0ZW5hdGlvbiAmJiBuZXdsaW5lID09PSAnJyAmJiAgZnJhZ21lbnQuY2hhckF0KGZyYWdtZW50Lmxlbmd0aCAtIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlTWFwID8gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnJlcGxhY2VSaWdodCgvXFxzKyQvLCAnJykgOiBmcmFnbWVudC5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCwgc3RtdCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50ZXJuYWwobm9kZSkge1xuICAgICAgICB2YXIgY29kZWdlbjtcblxuICAgICAgICBjb2RlZ2VuID0gbmV3IENvZGVHZW5lcmF0b3IoKTtcbiAgICAgICAgaWYgKGlzU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbi5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBTX1RGRkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW4uZ2VuZXJhdGVFeHByZXNzaW9uKG5vZGUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGU6ICcgKyBub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMoKSwgcmVzdWx0LCBwYWlyO1xuXG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE9ic29sZXRlIG9wdGlvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmluZGVudGBcbiAgICAgICAgICAgIC8vICAgYG9wdGlvbnMuYmFzZWBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIHRoZW0sIHdlIGNhbiB1c2UgYG9wdGlvbi5mb3JtYXQuaW5kZW50YC5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZSA9IG9wdGlvbnMuaW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlID0gb3B0aW9ucy5iYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IHVwZGF0ZURlZXBseShkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpbmRlbnQgPSBvcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gb3B0aW9ucy5iYXNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gc3RyaW5nUmVwZWF0KGluZGVudCwgb3B0aW9ucy5mb3JtYXQuaW5kZW50LmJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gb3B0aW9ucy5mb3JtYXQuanNvbjtcbiAgICAgICAgcmVudW1iZXIgPSBvcHRpb25zLmZvcm1hdC5yZW51bWJlcjtcbiAgICAgICAgaGV4YWRlY2ltYWwgPSBqc29uID8gZmFsc2UgOiBvcHRpb25zLmZvcm1hdC5oZXhhZGVjaW1hbDtcbiAgICAgICAgcXVvdGVzID0ganNvbiA/ICdkb3VibGUnIDogb3B0aW9ucy5mb3JtYXQucXVvdGVzO1xuICAgICAgICBlc2NhcGVsZXNzID0gb3B0aW9ucy5mb3JtYXQuZXNjYXBlbGVzcztcbiAgICAgICAgbmV3bGluZSA9IG9wdGlvbnMuZm9ybWF0Lm5ld2xpbmU7XG4gICAgICAgIHNwYWNlID0gb3B0aW9ucy5mb3JtYXQuc3BhY2U7XG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1hdC5jb21wYWN0KSB7XG4gICAgICAgICAgICBuZXdsaW5lID0gc3BhY2UgPSBpbmRlbnQgPSBiYXNlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50aGVzZXMgPSBvcHRpb25zLmZvcm1hdC5wYXJlbnRoZXNlcztcbiAgICAgICAgc2VtaWNvbG9ucyA9IG9wdGlvbnMuZm9ybWF0LnNlbWljb2xvbnM7XG4gICAgICAgIHNhZmVDb25jYXRlbmF0aW9uID0gb3B0aW9ucy5mb3JtYXQuc2FmZUNvbmNhdGVuYXRpb247XG4gICAgICAgIGRpcmVjdGl2ZSA9IG9wdGlvbnMuZGlyZWN0aXZlO1xuICAgICAgICBwYXJzZSA9IGpzb24gPyBudWxsIDogb3B0aW9ucy5wYXJzZTtcbiAgICAgICAgc291cmNlTWFwID0gb3B0aW9ucy5zb3VyY2VNYXA7XG4gICAgICAgIHNvdXJjZUNvZGUgPSBvcHRpb25zLnNvdXJjZUNvZGU7XG4gICAgICAgIHByZXNlcnZlQmxhbmtMaW5lcyA9IG9wdGlvbnMuZm9ybWF0LnByZXNlcnZlQmxhbmtMaW5lcyAmJiBzb3VyY2VDb2RlICE9PSBudWxsO1xuICAgICAgICBleHRyYSA9IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHNvdXJjZU1hcCkge1xuICAgICAgICAgICAgaWYgKCFleHBvcnRzLmJyb3dzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgZW52aXJvbm1lbnQgaXMgbm9kZS5qc1xuICAgICAgICAgICAgICAgIC8vIEFuZCBwcmV2ZW50IGZyb20gaW5jbHVkaW5nIHNvdXJjZS1tYXAgYnkgYnJvd3NlcmlmeVxuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSByZXF1aXJlKCdzb3VyY2UtbWFwJykuU291cmNlTm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgU291cmNlTm9kZSA9IGdsb2JhbC5zb3VyY2VNYXAuU291cmNlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlSW50ZXJuYWwobm9kZSk7XG5cbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHBhaXIgPSB7Y29kZTogcmVzdWx0LnRvU3RyaW5nKCksIG1hcDogbnVsbH07XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zb3VyY2VNYXBXaXRoQ29kZSA/IHBhaXIgOiBwYWlyLmNvZGU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHBhaXIgPSByZXN1bHQudG9TdHJpbmdXaXRoU291cmNlTWFwKHtcbiAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMuZmlsZSxcbiAgICAgICAgICAgIHNvdXJjZVJvb3Q6IG9wdGlvbnMuc291cmNlTWFwUm9vdFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VDb250ZW50KSB7XG4gICAgICAgICAgICBwYWlyLm1hcC5zZXRTb3VyY2VDb250ZW50KG9wdGlvbnMuc291cmNlTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNvdXJjZUNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWlyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhaXIubWFwLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgRk9STUFUX01JTklGWSA9IHtcbiAgICAgICAgaW5kZW50OiB7XG4gICAgICAgICAgICBzdHlsZTogJycsXG4gICAgICAgICAgICBiYXNlOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlbnVtYmVyOiB0cnVlLFxuICAgICAgICBoZXhhZGVjaW1hbDogdHJ1ZSxcbiAgICAgICAgcXVvdGVzOiAnYXV0bycsXG4gICAgICAgIGVzY2FwZWxlc3M6IHRydWUsXG4gICAgICAgIGNvbXBhY3Q6IHRydWUsXG4gICAgICAgIHBhcmVudGhlc2VzOiBmYWxzZSxcbiAgICAgICAgc2VtaWNvbG9uczogZmFsc2VcbiAgICB9O1xuXG4gICAgRk9STUFUX0RFRkFVTFRTID0gZ2V0RGVmYXVsdE9wdGlvbnMoKS5mb3JtYXQ7XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICAgIGV4cG9ydHMuYXR0YWNoQ29tbWVudHMgPSBlc3RyYXZlcnNlLmF0dGFjaENvbW1lbnRzO1xuICAgIGV4cG9ydHMuUHJlY2VkZW5jZSA9IHVwZGF0ZURlZXBseSh7fSwgUHJlY2VkZW5jZSk7XG4gICAgZXhwb3J0cy5icm93c2VyID0gZmFsc2U7XG4gICAgZXhwb3J0cy5GT1JNQVRfTUlOSUZZID0gRk9STUFUX01JTklGWTtcbiAgICBleHBvcnRzLkZPUk1BVF9ERUZBVUxUUyA9IEZPUk1BVF9ERUZBVUxUUztcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbi8qanNsaW50IHZhcnM6ZmFsc2UsIGJpdHdpc2U6dHJ1ZSovXG4vKmpzaGludCBpbmRlbnQ6NCovXG4vKmdsb2JhbCBleHBvcnRzOnRydWUsIGRlZmluZTp0cnVlKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcyxcbiAgICAvLyBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoKHJvb3QuZXN0cmF2ZXJzZSA9IHt9KSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBjbG9uZShleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFN5bnRheCxcbiAgICAgICAgaXNBcnJheSxcbiAgICAgICAgVmlzaXRvck9wdGlvbixcbiAgICAgICAgVmlzaXRvcktleXMsXG4gICAgICAgIG9iamVjdENyZWF0ZSxcbiAgICAgICAgb2JqZWN0S2V5cyxcbiAgICAgICAgQlJFQUssXG4gICAgICAgIFNLSVAsXG4gICAgICAgIFJFTU9WRTtcblxuICAgIGZ1bmN0aW9uIGlnbm9yZUpTSGludEVycm9yKCkgeyB9XG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sIGtleSwgdmFsO1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBkZWVwQ29weSh2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlnbm9yZUpTSGludEVycm9yKHNoYWxsb3dDb3B5KTtcblxuICAgIC8vIGJhc2VkIG9uIExMVk0gbGliYysrIHVwcGVyX2JvdW5kIC8gbG93ZXJfYm91bmRcbiAgICAvLyBNSVQgTGljZW5zZVxuXG4gICAgZnVuY3Rpb24gdXBwZXJCb3VuZChhcnJheSwgZnVuYykge1xuICAgICAgICB2YXIgZGlmZiwgbGVuLCBpLCBjdXJyZW50O1xuXG4gICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgZGlmZiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICAgICAgICAgIGlmIChmdW5jKGFycmF5W2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gZGlmZiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgZnVuYykge1xuICAgICAgICB2YXIgZGlmZiwgbGVuLCBpLCBjdXJyZW50O1xuXG4gICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgZGlmZiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICAgICAgICAgIGlmIChmdW5jKGFycmF5W2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gZGlmZiArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGlnbm9yZUpTSGludEVycm9yKGxvd2VyQm91bmQpO1xuXG4gICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGKCkgeyB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgICAgICAgICByZXR1cm4gbmV3IEYoKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBrZXlzID0gW10sIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gbykge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZCh0bywgZnJvbSkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZnJvbSksIGtleSwgaSwgbGVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogJ0NvbXByZWhlbnNpb25CbG9jaycsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogJ0V4cG9ydEJhdGNoU3BlY2lmaWVyJyxcbiAgICAgICAgRXhwb3J0RGVjbGFyYXRpb246ICdFeHBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246ICdHZW5lcmF0b3JFeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6ICdNb2R1bGVTcGVjaWZpZXInLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXG4gICAgICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xuICAgIH07XG5cbiAgICBWaXNpdG9yS2V5cyA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdkZWZhdWx0cycsICdyZXN0JywgJ2JvZHknXSxcbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogWydib2R5J10sXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIENhdGNoQ2xhdXNlOiBbJ3BhcmFtJywgJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NCb2R5OiBbJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogWydpZCcsICdib2R5JywgJ3N1cGVyQ2xhc3MnXSxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiBbJ2lkJywgJ2JvZHknLCAnc3VwZXJDbGFzcyddLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6IFsnbGVmdCcsICdyaWdodCddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiBbJ2Jsb2NrcycsICdmaWx0ZXInLCAnYm9keSddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogWydib2R5JywgJ3Rlc3QnXSxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogW10sXG4gICAgICAgIEV4cG9ydERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydpZCcsICduYW1lJ10sXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IFsnZXhwcmVzc2lvbiddLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IFsnaW5pdCcsICd0ZXN0JywgJ3VwZGF0ZScsICdib2R5J10sXG4gICAgICAgIEZvckluU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydpZCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnaWQnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2lkJywgJ25hbWUnXSxcbiAgICAgICAgTGl0ZXJhbDogW10sXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IFsnbGFiZWwnLCAnYm9keSddLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IFsnb2JqZWN0JywgJ3Byb3BlcnR5J10sXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogW10sXG4gICAgICAgIE5ld0V4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiBbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIFByb2dyYW06IFsnYm9keSddLFxuICAgICAgICBQcm9wZXJ0eTogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogWydkaXNjcmltaW5hbnQnLCAnY2FzZXMnXSxcbiAgICAgICAgU3dpdGNoQ2FzZTogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnXSxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBbJ3RhZycsICdxdWFzaSddLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IFtdLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IFsncXVhc2lzJywgJ2V4cHJlc3Npb25zJ10sXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiBbJ2Jsb2NrJywgJ2hhbmRsZXJzJywgJ2hhbmRsZXInLCAnZ3VhcmRlZEhhbmRsZXJzJywgJ2ZpbmFsaXplciddLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9ucyddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IFsnaWQnLCAnaW5pdCddLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogWyd0ZXN0JywgJ2JvZHknXSxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogWydvYmplY3QnLCAnYm9keSddLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IFsnYXJndW1lbnQnXVxuICAgIH07XG5cbiAgICAvLyB1bmlxdWUgaWRcbiAgICBCUkVBSyA9IHt9O1xuICAgIFNLSVAgPSB7fTtcbiAgICBSRU1PVkUgPSB7fTtcblxuICAgIFZpc2l0b3JPcHRpb24gPSB7XG4gICAgICAgIEJyZWFrOiBCUkVBSyxcbiAgICAgICAgU2tpcDogU0tJUCxcbiAgICAgICAgUmVtb3ZlOiBSRU1PVkVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHBhcmVudCwga2V5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbdGhpcy5rZXldID0gbm9kZTtcbiAgICB9O1xuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMucGFyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQobm9kZSwgcGF0aCwgd3JhcCwgcmVmKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMud3JhcCA9IHdyYXA7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRyb2xsZXIoKSB7IH1cblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gcHJvcGVydHkgcGF0aCBhcnJheSBmcm9tIHJvb3QgdG8gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgaiwganosIHJlc3VsdCwgZWxlbWVudDtcblxuICAgICAgICBmdW5jdGlvbiBhZGRUb1BhdGgocmVzdWx0LCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGp6ID0gcGF0aC5sZW5ndGg7IGogPCBqejsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGhbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByb290IG5vZGVcbiAgICAgICAgaWYgKCF0aGlzLl9fY3VycmVudC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWwsIHNlY29uZCBub2RlIGlzIHJvb3QgZWxlbWVudFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMiwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLl9fbGVhdmVsaXN0W2ldO1xuICAgICAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgZWxlbWVudC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCB0aGlzLl9fY3VycmVudC5wYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiB0eXBlIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgfHwgdGhpcy5fX2N1cnJlbnQud3JhcDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBhcnJheSBvZiBwYXJlbnQgZWxlbWVudHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24gcGFyZW50cygpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMSwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX19sZWF2ZWxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnQubm9kZTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19leGVjdXRlID0gZnVuY3Rpb24gX19leGVjdXRlKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBwcmV2aW91cywgcmVzdWx0O1xuXG4gICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBwcmV2aW91cyAgPSB0aGlzLl9fY3VycmVudDtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrLmNhbGwodGhpcywgZWxlbWVudC5ub2RlLCB0aGlzLl9fbGVhdmVsaXN0W3RoaXMuX19sZWF2ZWxpc3QubGVuZ3RoIC0gMV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBwcmV2aW91cztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gbm90aWZ5IGNvbnRyb2wgc2tpcCAvIGJyZWFrXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KGZsYWcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gZmxhZztcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHNraXAgY2hpbGQgbm9kZXMgb2YgY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoU0tJUCk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBicmVhayB0cmF2ZXJzYWxzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGVbJ2JyZWFrJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KEJSRUFLKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJlbW92ZSBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShSRU1PVkUpO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2luaXRpYWxpemUgPSBmdW5jdGlvbihyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHRoaXMudmlzaXRvciA9IHZpc2l0b3I7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuX193b3JrbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fbGVhdmVsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gdmlzaXRvci5mYWxsYmFjayA9PT0gJ2l0ZXJhdGlvbic7XG4gICAgICAgIHRoaXMuX19rZXlzID0gVmlzaXRvcktleXM7XG4gICAgICAgIGlmICh2aXNpdG9yLmtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuX19rZXlzID0gZXh0ZW5kKG9iamVjdENyZWF0ZSh0aGlzLl9fa2V5cyksIHZpc2l0b3Iua2V5cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlVHlwZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybikgJiYgJ3Byb3BlcnRpZXMnID09PSBrZXk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IG9iamVjdEtleXMobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlc1tjdXJyZW50XTtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50MiA9IGNhbmRpZGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChjYW5kaWRhdGUsIGtleSwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbShlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV4dEVsZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZWYucmVtb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByZWZlcmVuY2UgaXMgYW4gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBrZXkgPSBlbGVtZW50LnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5yZWYucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVtb3ZlZCBmcm9tIGFycmF5LCB0aGVuIGRlY3JlYXNlIGZvbGxvd2luZyBpdGVtcycga2V5cy5cbiAgICAgICAgICAgICAgICBpID0gd29ya2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsZW0gPSB3b3JrbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtLnJlZiAmJiBuZXh0RWxlbS5yZWYucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICAobmV4dEVsZW0ucmVmLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLS1uZXh0RWxlbS5yZWYua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbCxcbiAgICAgICAgICAgIG91dGVyLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgb3V0ZXIgPSB7XG4gICAgICAgICAgICByb290OiByb290XG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBuZXcgUmVmZXJlbmNlKG91dGVyLCAncm9vdCcpKTtcbiAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgbnVsbFxuICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3JrbGlzdC5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBTS0lQIHx8IHRhcmdldCA9PT0gU0tJUCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2tleXNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gb2JqZWN0S2V5cyhub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbmV3IFJlZmVyZW5jZShjYW5kaWRhdGUsIGN1cnJlbnQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG5ldyBSZWZlcmVuY2Uobm9kZSwga2V5KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIudHJhdmVyc2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucmVwbGFjZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRDb21tZW50UmFuZ2UoY29tbWVudCwgdG9rZW5zKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG5cbiAgICAgICAgdGFyZ2V0ID0gdXBwZXJCb3VuZCh0b2tlbnMsIGZ1bmN0aW9uIHNlYXJjaCh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnJhbmdlWzBdID4gY29tbWVudC5yYW5nZVswXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gW2NvbW1lbnQucmFuZ2VbMF0sIGNvbW1lbnQucmFuZ2VbMV1dO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0IC09IDE7XG4gICAgICAgIGlmICh0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0cmVlLCBwcm92aWRlZENvbW1lbnRzLCB0b2tlbnMpIHtcbiAgICAgICAgLy8gQXQgZmlyc3QsIHdlIHNob3VsZCBjYWxjdWxhdGUgZXh0ZW5kZWQgY29tbWVudCByYW5nZXMuXG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdLCBjb21tZW50LCBsZW4sIGksIGN1cnNvcjtcblxuICAgICAgICBpZiAoIXRyZWUucmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0YWNoQ29tbWVudHMgbmVlZHMgcmFuZ2UgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRva2VucyBhcnJheSBpcyBlbXB0eSwgd2UgYXR0YWNoIGNvbW1lbnRzIHRvIHRyZWUgYXMgJ2xlYWRpbmdDb21tZW50cydcbiAgICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZWRDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gWzAsIHRyZWUucmFuZ2VbMF1dO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKGV4dGVuZENvbW1lbnRSYW5nZShkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIEpvaG4gRnJlZW1hbidzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPiBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPT09IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdIDwgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdID09PSBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSAnMS44LjEtZGV2JztcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcbiAgICBleHBvcnRzLnRyYXZlcnNlID0gdHJhdmVyc2U7XG4gICAgZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gYXR0YWNoQ29tbWVudHM7XG4gICAgZXhwb3J0cy5WaXNpdG9yS2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgIGV4cG9ydHMuVmlzaXRvck9wdGlvbiA9IFZpc2l0b3JPcHRpb247XG4gICAgZXhwb3J0cy5Db250cm9sbGVyID0gQ29udHJvbGxlcjtcbiAgICBleHBvcnRzLmNsb25lRW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG9uZSh7fSk7IH07XG5cbiAgICByZXR1cm4gZXhwb3J0cztcbn0pKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXNjb2RlZ2VuXCIsXG4gICAgICAgIFwicmF3XCI6IFwiZXNjb2RlZ2VuQDEuNi4xXCIsXG4gICAgICAgIFwicmF3U3BlY1wiOiBcIjEuNi4xXCIsXG4gICAgICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICAgICAgXCJzcGVjXCI6IFwiMS42LjFcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiXG4gICAgICB9LFxuICAgICAgXCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3NoYWRlanNcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcImVzY29kZWdlbkAxLjYuMVwiLFxuICBcIl9pZFwiOiBcImVzY29kZWdlbkAxLjYuMVwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL2VzY29kZWdlblwiLFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcImVtYWlsXCI6IFwidXRhdGFuZS50ZWFAZ21haWwuY29tXCIsXG4gICAgXCJuYW1lXCI6IFwiY29uc3RlbGxhdGlvblwiXG4gIH0sXG4gIFwiX25wbVZlcnNpb25cIjogXCIyLjAuMC1hbHBoYS01XCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJlc2NvZGVnZW5cIixcbiAgICBcInJhd1wiOiBcImVzY29kZWdlbkAxLjYuMVwiLFxuICAgIFwicmF3U3BlY1wiOiBcIjEuNi4xXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIjEuNi4xXCIsXG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZXNjb2RlZ2VuLy0vZXNjb2RlZ2VuLTEuNi4xLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCIzNjdkZTE3ZDg1MTA1NDBkMTJiYzZkY2I4YjNmOTE4MzkxMjY1ODE1XCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcImVzY29kZWdlbkAxLjYuMVwiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQvc2hhZGVqc1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJlc2NvZGVnZW5cIjogXCIuL2Jpbi9lc2NvZGVnZW4uanNcIixcbiAgICBcImVzZ2VuZXJhdGVcIjogXCIuL2Jpbi9lc2dlbmVyYXRlLmpzXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29kZWdlbi9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJlc3ByaW1hXCI6IFwiXjEuMi4yXCIsXG4gICAgXCJlc3RyYXZlcnNlXCI6IFwiXjEuOS4xXCIsXG4gICAgXCJlc3V0aWxzXCI6IFwiXjEuMS42XCIsXG4gICAgXCJvcHRpb25hdG9yXCI6IFwiXjAuNS4wXCIsXG4gICAgXCJzb3VyY2UtbWFwXCI6IFwifjAuMS40MFwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQ01BU2NyaXB0IGNvZGUgZ2VuZXJhdG9yXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImFjb3JuLTZ0bzVcIjogXCJeMC4xMS4xLTI1XCIsXG4gICAgXCJibHVlYmlyZFwiOiBcIl4yLjMuMTFcIixcbiAgICBcImJvd2VyLXJlZ2lzdHJ5LWNsaWVudFwiOiBcIl4wLjIuMVwiLFxuICAgIFwiY2hhaVwiOiBcIl4xLjEwLjBcIixcbiAgICBcImNvbW1vbmpzLWV2ZXJ5d2hlcmVcIjogXCJeMC45LjdcIixcbiAgICBcImVzcHJpbWEtbW96XCI6IFwiKlwiLFxuICAgIFwiZ3VscFwiOiBcIl4zLjguMTBcIixcbiAgICBcImd1bHAtZXNsaW50XCI6IFwiXjAuMi4wXCIsXG4gICAgXCJndWxwLW1vY2hhXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJzZW12ZXJcIjogXCJeNC4xLjBcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHt9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiMzY3ZGUxN2Q4NTEwNTQwZDEyYmM2ZGNiOGIzZjkxODM5MTI2NTgxNVwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VzY29kZWdlbi8tL2VzY29kZWdlbi0xLjYuMS50Z3pcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MC4xMC4wXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJMSUNFTlNFLkJTRFwiLFxuICAgIFwiTElDRU5TRS5zb3VyY2UtbWFwXCIsXG4gICAgXCJSRUFETUUubWRcIixcbiAgICBcImJpblwiLFxuICAgIFwiZXNjb2RlZ2VuLmpzXCIsXG4gICAgXCJwYWNrYWdlLmpzb25cIlxuICBdLFxuICBcImdpdEhlYWRcIjogXCIxY2E2NjRmNjhkY2YyMjBiNzZjOWRjNTYyYjIzMzdjNWUwYjQyMjdkXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29kZWdlblwiLFxuICBcImxpY2Vuc2VzXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJCU0RcIixcbiAgICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vZXN0b29scy9lc2NvZGVnZW4vcmF3L21hc3Rlci9MSUNFTlNFLkJTRFwiXG4gICAgfVxuICBdLFxuICBcIm1haW5cIjogXCJlc2NvZGVnZW4uanNcIixcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJlbWFpbFwiOiBcInV0YXRhbmUudGVhQGdtYWlsLmNvbVwiLFxuICAgICAgXCJuYW1lXCI6IFwiY29uc3RlbGxhdGlvblwiXG4gICAgfVxuICBdLFxuICBcIm5hbWVcIjogXCJlc2NvZGVnZW5cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJzb3VyY2UtbWFwXCI6IFwifjAuMS40MFwiXG4gIH0sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2VuLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcImNqc2lmeSAtYSBwYXRoOiB0b29scy9lbnRyeS1wb2ludC5qcyA+IGVzY29kZWdlbi5icm93c2VyLmpzXCIsXG4gICAgXCJidWlsZC1taW5cIjogXCJjanNpZnkgLW1hIHBhdGg6IHRvb2xzL2VudHJ5LXBvaW50LmpzID4gZXNjb2RlZ2VuLmJyb3dzZXIubWluLmpzXCIsXG4gICAgXCJsaW50XCI6IFwiZ3VscCBsaW50XCIsXG4gICAgXCJyZWxlYXNlXCI6IFwibm9kZSB0b29scy9yZWxlYXNlLmpzXCIsXG4gICAgXCJ0ZXN0XCI6IFwiZ3VscCB0cmF2aXNcIixcbiAgICBcInVuaXQtdGVzdFwiOiBcImd1bHAgdGVzdFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjEuNi4xXCJcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBkb3Q7XG5cbmZ1bmN0aW9uIGRvdChjZmcsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHZhciBjb3VudGVyID0gb3B0aW9ucy5jb3VudGVyIHx8IDA7XG5cdHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcblxuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBub2RlcyA9IGNmZ1syXTtcblx0dmFyIGk7XG5cdHZhciBub2RlO1xuXG5cdC8vIHByaW50IGFsbCB0aGUgbm9kZXM6XG5cdGZvciAoaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdG5vZGUgPSBub2Rlc1tpXTtcblx0XHR2YXIgbGFiZWwgPSBub2RlLmxhYmVsIHx8IG5vZGUudHlwZTtcblx0XHRpZiAoIWxhYmVsICYmIHNvdXJjZSAmJiBub2RlLmFzdE5vZGUucmFuZ2UpIHtcblx0XHRcdHZhciBhc3QgPSBub2RlLmFzdE5vZGU7XG5cdFx0XHR2YXIgcmFuZ2UgPSBhc3QucmFuZ2U7XG5cdFx0XHR2YXIgYWRkID0gJyc7XG5cdFx0XHQvLyBzcGVjaWFsIGNhc2Ugc29tZSBzdGF0ZW1lbnRzIHRvIGdldCB0aGVtIHByb3Blcmx5IHByaW50ZWRcblx0XHRcdGlmIChhc3QudHlwZSA9PT0gJ1N3aXRjaENhc2UnKSB7XG5cdFx0XHRcdGlmIChhc3QudGVzdCkge1xuXHRcdFx0XHRcdHJhbmdlID0gW3JhbmdlWzBdLCBhc3QudGVzdC5yYW5nZVsxXV07XG5cdFx0XHRcdFx0YWRkID0gJzonO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJhbmdlID0gW3JhbmdlWzBdLCByYW5nZVswXV07XG5cdFx0XHRcdFx0YWRkID0nZGVmYXVsdDonO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnRm9ySW5TdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdHJhbmdlID0gW3JhbmdlWzBdLCBhc3QucmlnaHQucmFuZ2VbMV1dO1xuXHRcdFx0XHRhZGQgPSAnKSc7XG5cdFx0XHR9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnQ2F0Y2hDbGF1c2UnKSB7XG5cdFx0XHRcdHJhbmdlID0gW3JhbmdlWzBdLCBhc3QucGFyYW0ucmFuZ2VbMV1dO1xuXHRcdFx0XHRhZGQgPSAnKSc7XG5cdFx0XHR9XG5cblx0XHRcdGxhYmVsID0gc291cmNlLnNsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSlcblx0XHRcdFx0LnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuXHRcdFx0XHQucmVwbGFjZSgvXFx0L2csICcgICAgJylcblx0XHRcdFx0LnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArIGFkZDtcblx0XHR9XG5cdFx0aWYgKCFsYWJlbCAmJiBub2RlLmFzdE5vZGUpIHtcblx0XHRcdGxhYmVsID0gbm9kZS5hc3ROb2RlLnR5cGU7XG5cdFx0fVxuXHRcdG91dHB1dC5wdXNoKCduJyArIChjb3VudGVyICsgaSkgKyAnIFtsYWJlbD1cIicgKyBsYWJlbCArICdcIicpO1xuXHRcdGlmICh+WydlbnRyeScsICdleGl0J10uaW5kZXhPZihub2RlLnR5cGUpKVxuXHRcdFx0b3V0cHV0LnB1c2goJywgc3R5bGU9XCJyb3VuZGVkXCInKTtcblx0XHRvdXRwdXQucHVzaCgnXVxcbicpO1xuXHR9XG5cblx0Ly8gcHJpbnQgYWxsIHRoZSBlZGdlczpcblx0Zm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bm9kZSA9IG5vZGVzW2ldO1xuXHRcdFsnbm9ybWFsJywgJ3RydWUnLCAnZmFsc2UnLCAnZXhjZXB0aW9uJ10uZm9yRWFjaChlYWNoVHlwZSk7XG5cdH1cblx0ZnVuY3Rpb24gZWFjaFR5cGUodHlwZSkge1xuXHRcdHZhciBuZXh0ID0gbm9kZVt0eXBlXTtcblx0XHRpZiAoIW5leHQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRvdXRwdXQucHVzaCgnbicgKyAoY291bnRlciArIGkpICsgJyAtPiBuJyArIChjb3VudGVyICsgbm9kZXMuaW5kZXhPZihuZXh0KSkgKyAnIFsnKTtcblx0XHRpZiAodHlwZSA9PT0gJ2V4Y2VwdGlvbicpXG5cdFx0XHRvdXRwdXQucHVzaCgnY29sb3I9XCJyZWRcIiwgbGFiZWw9XCJleGNlcHRpb25cIicpO1xuXHRcdGVsc2UgaWYgKH5bJ3RydWUnLCAnZmFsc2UnXS5pbmRleE9mKHR5cGUpKVxuXHRcdFx0b3V0cHV0LnB1c2goJ2xhYmVsPVwiJyArIHR5cGUgKyAnXCInKTtcblx0XHRvdXRwdXQucHVzaCgnXVxcbicpO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMuY291bnRlciAhPT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMuY291bnRlcis9IG5vZGVzLmxlbmd0aDtcblxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufVxuXG4iLCJcbnZhciB3YWxrZXIgPSByZXF1aXJlKCd3YWxrZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250cm9sRmxvd0dyYXBoO1xubW9kdWxlLmV4cG9ydHMuZG90ID0gcmVxdWlyZSgnLi9kb3QnKTtcblxuLy8gRklYTUU6IHN3aXRjaC9jYXNlIHdpdGggZGVmYXVsdCBiZWZvcmUgb3RoZXIgY2FzZXM/XG4vLyBGSVhNRTogY2F0Y2ggY3JlYXRlcyBhIG5ldyBzY29wZSwgc28gc2hvdWxkIHNvbWVob3cgYmUgaGFuZGxlZCBkaWZmZXJlbnRseVxuXG4vLyBUT0RPOiB0cnkvZmluYWxseTogZmluYWxseSBmb2xsb3dzIHRyeSwgYnV0IGRvZXMgbm90IHJldHVybiB0byBub3JtYWwgZmxvdz9cblxuLy8gVE9ETzogbGFiZWxlZCBicmVhay9jb250aW51ZVxuLy8gVE9ETzogV2l0aFN0YXRlbWVudFxuXG4vLyBUT0RPOiBhdm9pZCBhZGRpbmcgYW5kIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYXN0IG5vZGVzXG5cbi8qKlxuICogUmV0dXJucyBbZW50cnksIGV4aXRdIGBGbG93Tm9kZWBzIGZvciB0aGUgcGFzc2VkIGluIEFTVFxuICovXG5mdW5jdGlvbiBDb250cm9sRmxvd0dyYXBoKGFzdE5vZGUsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHZhciBwYXJlbnRTdGFjayA9IFtdO1xuXHR2YXIgZXhpdE5vZGUgPSBuZXcgRmxvd05vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsICdleGl0Jyk7XG5cdHZhciBjYXRjaFN0YWNrID0gW2V4aXROb2RlXTtcblx0dmFyIG9taXRFeGNlcHRpb25zID0gISFvcHRpb25zLm9taXRFeGNlcHRpb25zO1xuXG5cdGNyZWF0ZU5vZGVzKGFzdE5vZGUpO1xuXHRsaW5rU2libGluZ3MoYXN0Tm9kZSk7XG5cdFxuXHR3YWxrZXIoYXN0Tm9kZSwge1xuXHRcdENhdGNoQ2xhdXNlOiBmdW5jdGlvbiAobm9kZSwgcmVjdXJzZSkge1xuXHRcdFx0bm9kZS5jZmcuY29ubmVjdChnZXRFbnRyeShub2RlLmJvZHkpKTtcblx0XHRcdHJlY3Vyc2Uobm9kZS5ib2R5KTtcblx0XHR9LFxuXHRcdERvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0XHRtYXlUaHJvdyhub2RlLnRlc3QpO1xuXHRcdFx0bm9kZS50ZXN0LmNmZ1xuXHRcdFx0XHQuY29ubmVjdChnZXRFbnRyeShub2RlLmJvZHkpLCAndHJ1ZScpXG5cdFx0XHRcdC5jb25uZWN0KGdldFN1Y2Nlc3Nvcihub2RlKSwgJ2ZhbHNlJyk7XG5cdFx0XHRyZWN1cnNlKG5vZGUuYm9keSk7XG5cdFx0fSxcblx0XHRFeHByZXNzaW9uU3RhdGVtZW50OiBjb25uZWN0TmV4dCxcblx0XHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0XHRpZiAobm9kZS50ZXN0KSB7XG5cdFx0XHRcdG1heVRocm93KG5vZGUudGVzdCk7XG5cdFx0XHRcdG5vZGUudGVzdC5jZmdcblx0XHRcdFx0XHQuY29ubmVjdChnZXRFbnRyeShub2RlLmJvZHkpLCAndHJ1ZScpXG5cdFx0XHRcdFx0LmNvbm5lY3QoZ2V0U3VjY2Vzc29yKG5vZGUpLCAnZmFsc2UnKTtcblx0XHRcdFx0aWYgKG5vZGUudXBkYXRlKVxuXHRcdFx0XHRcdG5vZGUudXBkYXRlLmNmZy5jb25uZWN0KG5vZGUudGVzdC5jZmcpO1xuXHRcdFx0fSBlbHNlIGlmIChub2RlLnVwZGF0ZSlcblx0XHRcdFx0bm9kZS51cGRhdGUuY2ZnLmNvbm5lY3QoZ2V0RW50cnkobm9kZS5ib2R5KSk7XG5cdFx0XHRpZiAobm9kZS51cGRhdGUpXG5cdFx0XHRcdG1heVRocm93KG5vZGUudXBkYXRlKTtcblx0XHRcdGlmIChub2RlLmluaXQpIHtcblx0XHRcdFx0bWF5VGhyb3cobm9kZS5pbml0KTtcblx0XHRcdFx0bm9kZS5pbml0LmNmZy5jb25uZWN0KG5vZGUudGVzdCAmJiBub2RlLnRlc3QuY2ZnIHx8IGdldEVudHJ5KG5vZGUuYm9keSkpO1xuXHRcdFx0fVxuXHRcdFx0cmVjdXJzZShub2RlLmJvZHkpO1xuXHRcdH0sXG5cdFx0Rm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0XHRtYXlUaHJvdyhub2RlKTtcblx0XHRcdG5vZGUuY2ZnXG5cdFx0XHRcdC5jb25uZWN0KGdldEVudHJ5KG5vZGUuYm9keSksICd0cnVlJylcblx0XHRcdFx0LmNvbm5lY3QoZ2V0U3VjY2Vzc29yKG5vZGUpLCAnZmFsc2UnKTtcblx0XHRcdHJlY3Vyc2Uobm9kZS5ib2R5KTtcblx0XHR9LFxuXHRcdElmU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSwgcmVjdXJzZSkge1xuXHRcdFx0cmVjdXJzZShub2RlLmNvbnNlcXVlbnQpO1xuXHRcdFx0bWF5VGhyb3cobm9kZS50ZXN0KTtcblx0XHRcdG5vZGUudGVzdC5jZmcuY29ubmVjdChnZXRFbnRyeShub2RlLmNvbnNlcXVlbnQpLCAndHJ1ZScpO1xuXHRcdFx0aWYgKG5vZGUuYWx0ZXJuYXRlKSB7XG5cdFx0XHRcdHJlY3Vyc2Uobm9kZS5hbHRlcm5hdGUpO1xuXHRcdFx0XHRub2RlLnRlc3QuY2ZnLmNvbm5lY3QoZ2V0RW50cnkobm9kZS5hbHRlcm5hdGUpLCAnZmFsc2UnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUudGVzdC5jZmcuY29ubmVjdChnZXRTdWNjZXNzb3Iobm9kZSksICdmYWxzZScpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0UmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0bWF5VGhyb3cobm9kZSk7XG5cdFx0XHRub2RlLmNmZy5jb25uZWN0KGV4aXROb2RlKTtcblx0XHR9LFxuXHRcdFN3aXRjaENhc2U6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0XHRpZiAobm9kZS50ZXN0KSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSByZWFsIGNhc2UsIGNvbm5lY3QgYHRydWVgIHRvIHRoZSBib2R5XG5cdFx0XHRcdC8vIG9yIHRoZSBib2R5IG9mIHRoZSBuZXh0IGNhc2Vcblx0XHRcdFx0dmFyIGNoZWNrID0gbm9kZTtcblx0XHRcdFx0d2hpbGUgKCFjaGVjay5jb25zZXF1ZW50Lmxlbmd0aCAmJiBjaGVjay5jZmcubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0Y2hlY2sgPSBjaGVjay5jZmcubmV4dFNpYmxpbmcuYXN0Tm9kZTtcblxuXHRcdFx0XHRub2RlLmNmZy5jb25uZWN0KGNoZWNrLmNvbnNlcXVlbnQubGVuZ3RoICYmIGdldEVudHJ5KGNoZWNrLmNvbnNlcXVlbnRbMF0pIHx8IGdldFN1Y2Nlc3Nvcihub2RlLmNmZy5wYXJlbnQpLCAndHJ1ZScpO1xuXG5cdFx0XHRcdC8vIGFuZCBjb25uZWN0IGZhbHNlIHRvIHRoZSBuZXh0IGBjYXNlYFxuXHRcdFx0XHRub2RlLmNmZy5jb25uZWN0KGdldFN1Y2Nlc3Nvcihub2RlKSwgJ2ZhbHNlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBgZGVmYXVsdGAgY2FzZSwgY29ubmVjdCBpdCB0byB0aGUgYm9keSwgb3IgdGhlXG5cdFx0XHRcdC8vIHN1Y2Nlc3NvciBvZiB0aGUgcGFyZW50XG5cdFx0XHRcdG5vZGUuY2ZnLmNvbm5lY3Qobm9kZS5jb25zZXF1ZW50Lmxlbmd0aCAmJiBnZXRFbnRyeShub2RlLmNvbnNlcXVlbnRbMF0pIHx8IGdldFN1Y2Nlc3Nvcihub2RlLmNmZy5wYXJlbnQpKTtcblx0XHRcdH1cblx0XHRcdG5vZGUuY29uc2VxdWVudC5mb3JFYWNoKHJlY3Vyc2UpO1xuXHRcdH0sXG5cdFx0U3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSwgcmVjdXJzZSkge1xuXHRcdFx0bm9kZS5jZmcuY29ubmVjdChub2RlLmNhc2VzWzBdLmNmZyk7XG5cdFx0XHRub2RlLmNhc2VzLmZvckVhY2gocmVjdXJzZSk7XG5cdFx0fSxcblx0XHRUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdG5vZGUuY2ZnLmNvbm5lY3QoZ2V0RXhjZXB0aW9uVGFyZ2V0KG5vZGUpLCAnZXhjZXB0aW9uJyk7XG5cdFx0fSxcblx0XHRUcnlTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cblx0XHRcdHZhciBoYW5kbGVyID0gbm9kZS5oYW5kbGVyICYmIG5vZGUuaGFuZGxlci5jZmcgfHwgZ2V0RW50cnkobm9kZS5maW5hbGl6ZXIpO1xuXHRcdFx0Y2F0Y2hTdGFjay5wdXNoKGhhbmRsZXIpO1xuXHRcdFx0cmVjdXJzZShub2RlLmJsb2NrKTtcblx0XHRcdGNhdGNoU3RhY2sucG9wKCk7XG5cblx0XHRcdGlmIChub2RlLmhhbmRsZXIpXG5cdFx0XHRcdHJlY3Vyc2Uobm9kZS5oYW5kbGVyKTtcblx0XHRcdGlmIChub2RlLmZpbmFsaXplcikge1xuXHRcdFx0XHQvL25vZGUuZmluYWxpemVyLmNmZy5jb25uZWN0KGdldFN1Y2Nlc3Nvcihub2RlKSk7XG5cdFx0XHRcdHJlY3Vyc2Uobm9kZS5maW5hbGl6ZXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0VmFyaWFibGVEZWNsYXJhdGlvbjogY29ubmVjdE5leHQsXG5cdFx0V2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0XHRtYXlUaHJvdyhub2RlLnRlc3QpO1xuXHRcdFx0bm9kZS50ZXN0LmNmZ1xuXHRcdFx0XHQuY29ubmVjdChnZXRFbnRyeShub2RlLmJvZHkpLCAndHJ1ZScpXG5cdFx0XHRcdC5jb25uZWN0KGdldFN1Y2Nlc3Nvcihub2RlKSwgJ2ZhbHNlJyk7XG5cdFx0XHRyZWN1cnNlKG5vZGUuYm9keSk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdHZhciBlbnRyeU5vZGUgPSBuZXcgRmxvd05vZGUoYXN0Tm9kZSwgdW5kZWZpbmVkLCAnZW50cnknKTtcblx0ZW50cnlOb2RlLm5vcm1hbCA9IGdldEVudHJ5KGFzdE5vZGUpO1xuXHR3YWxrZXIoYXN0Tm9kZSwge2RlZmF1bHQ6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0aWYgKCFub2RlLmNmZylcblx0XHRcdHJldHVybjtcblx0XHQvLyBFeHByZXNzaW9uU3RhdGVtZW50cyBzaG91bGQgcmVmZXIgdG8gdGhlaXIgZXhwcmVzc2lvbiBkaXJlY3RseVxuXHRcdGlmIChub2RlLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50Jylcblx0XHRcdG5vZGUuY2ZnLmFzdE5vZGUgPSBub2RlLmV4cHJlc3Npb247XG5cdFx0ZGVsZXRlIG5vZGUuY2ZnO1xuXHRcdHdhbGtlci5jaGVja1Byb3BzKG5vZGUsIHJlY3Vyc2UpO1xuXHR9fSk7XG5cblx0dmFyIGFsbE5vZGVzID0gW107XG5cdHZhciByZXZlcnNlU3RhY2sgPSBbZW50cnlOb2RlXTtcblx0dmFyIGNmZ05vZGU7XG5cdHdoaWxlIChyZXZlcnNlU3RhY2subGVuZ3RoKSB7XG5cdFx0Y2ZnTm9kZSA9IHJldmVyc2VTdGFjay5wb3AoKTtcblx0XHRhbGxOb2Rlcy5wdXNoKGNmZ05vZGUpO1xuXHRcdGNmZ05vZGUubmV4dCA9IFtdO1xuXHRcdFsnZXhjZXB0aW9uJywgJ2ZhbHNlJywgJ3RydWUnLCAnbm9ybWFsJ10uZm9yRWFjaChlYWNoVHlwZSk7XG5cdH1cblx0ZnVuY3Rpb24gZWFjaFR5cGUodHlwZSkge1xuXHRcdHZhciBuZXh0ID0gY2ZnTm9kZVt0eXBlXTtcblx0XHRpZiAoIW5leHQpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKCF+Y2ZnTm9kZS5uZXh0LmluZGV4T2YobmV4dCkpXG5cdFx0XHRjZmdOb2RlLm5leHQucHVzaChuZXh0KTtcblx0XHRpZiAoIX5uZXh0LnByZXYuaW5kZXhPZihjZmdOb2RlKSlcblx0XHRcdG5leHQucHJldi5wdXNoKGNmZ05vZGUpO1xuXHRcdGlmICghfnJldmVyc2VTdGFjay5pbmRleE9mKG5leHQpICYmICFuZXh0Lm5leHQpXG5cdFx0XHRyZXZlcnNlU3RhY2sucHVzaChuZXh0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEV4Y2VwdGlvblRhcmdldCgpIHtcblx0XHRyZXR1cm4gY2F0Y2hTdGFja1tjYXRjaFN0YWNrLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWF5VGhyb3cobm9kZSkge1xuXHRcdGlmICghb21pdEV4Y2VwdGlvbnMgJiYgZXhwcmVzc2lvblRocm93cyhub2RlKSlcblx0XHRcdG5vZGUuY2ZnLmNvbm5lY3QoZ2V0RXhjZXB0aW9uVGFyZ2V0KG5vZGUpLCAnZXhjZXB0aW9uJyk7XG5cdH1cblx0ZnVuY3Rpb24gZXhwcmVzc2lvblRocm93cyhhc3ROb2RlKSB7XG5cdFx0aWYgKHR5cGVvZiBhc3ROb2RlICE9PSAnb2JqZWN0JyB8fCAnRnVuY3Rpb25FeHByZXNzaW9uJyA9PT0gYXN0Tm9kZS50eXBlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChhc3ROb2RlLnR5cGUgJiYgfnRocm93VHlwZXMuaW5kZXhPZihhc3ROb2RlLnR5cGUpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0dmFyIHNlbGYgPSBhc3ROb2RlO1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyhzZWxmKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHZhciBwcm9wID0gc2VsZltrZXldO1xuXHRcdFx0aWYgKHByb3AgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcC5zb21lKGV4cHJlc3Npb25UaHJvd3MpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcClcblx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb25UaHJvd3MocHJvcCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEp1bXBUYXJnZXQoYXN0Tm9kZSwgdHlwZXMpIHtcblx0XHR2YXIgcGFyZW50ID0gYXN0Tm9kZS5jZmcucGFyZW50O1xuXHRcdHdoaWxlICghfnR5cGVzLmluZGV4T2YocGFyZW50LnR5cGUpICYmIHBhcmVudC5jZmcucGFyZW50KVxuXHRcdFx0cGFyZW50ID0gcGFyZW50LmNmZy5wYXJlbnQ7XG5cdFx0cmV0dXJuIH50eXBlcy5pbmRleE9mKHBhcmVudC50eXBlKSA/IHBhcmVudCA6IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjb25uZWN0TmV4dChub2RlKSB7XG5cdFx0bWF5VGhyb3cobm9kZSk7XG5cdFx0bm9kZS5jZmcuY29ubmVjdChnZXRTdWNjZXNzb3Iobm9kZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVudHJ5IG5vZGUgb2YgYSBzdGF0ZW1lbnRcblx0ICovXG5cdGZ1bmN0aW9uIGdldEVudHJ5KGFzdE5vZGUpIHtcblx0XHR2YXIgdGFyZ2V0O1xuXHRcdHN3aXRjaCAoYXN0Tm9kZS50eXBlKSB7XG5cdFx0XHRjYXNlICdCcmVha1N0YXRlbWVudCc6XG5cdFx0XHRcdHRhcmdldCA9IGdldEp1bXBUYXJnZXQoYXN0Tm9kZSwgYnJlYWtUYXJnZXRzKTtcblx0XHRcdFx0cmV0dXJuIHRhcmdldCA/IGdldFN1Y2Nlc3Nvcih0YXJnZXQpIDogZXhpdE5vZGU7XG5cdFx0XHRjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG5cdFx0XHRcdHRhcmdldCA9IGdldEp1bXBUYXJnZXQoYXN0Tm9kZSwgY29udGludWVUYXJnZXRzKTtcblx0XHRcdFx0c3dpdGNoICh0YXJnZXQudHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ0ZvclN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZSBnb2VzIHRvIHRoZSB1cGRhdGUsIHRlc3Qgb3IgYm9keVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldC51cGRhdGUgJiYgdGFyZ2V0LnVwZGF0ZS5jZmcgfHwgdGFyZ2V0LnRlc3QgJiYgdGFyZ2V0LnRlc3QuY2ZnIHx8IGdldEVudHJ5KHRhcmdldC5ib2R5KTtcblx0XHRcdFx0XHRjYXNlICdGb3JJblN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNmZztcblx0XHRcdFx0XHRjYXNlICdEb1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRcdFx0Y2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldC50ZXN0LmNmZztcblx0XHRcdFx0fVxuXHRcdFx0Ly8gdW5yZWFjaGVkXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlICdCbG9ja1N0YXRlbWVudCc6XG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlICdQcm9ncmFtJzpcblx0XHRcdFx0cmV0dXJuIGFzdE5vZGUuYm9keS5sZW5ndGggJiYgZ2V0RW50cnkoYXN0Tm9kZS5ib2R5WzBdKSB8fCBnZXRTdWNjZXNzb3IoYXN0Tm9kZSk7XG5cdFx0XHRjYXNlICdEb1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIGdldEVudHJ5KGFzdE5vZGUuYm9keSk7XG5cdFx0XHRjYXNlICdFbXB0eVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBnZXRTdWNjZXNzb3IoYXN0Tm9kZSk7XG5cdFx0XHRjYXNlICdGb3JTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gYXN0Tm9kZS5pbml0ICYmIGFzdE5vZGUuaW5pdC5jZmcgfHwgYXN0Tm9kZS50ZXN0ICYmIGFzdE5vZGUudGVzdC5jZmcgfHwgZ2V0RW50cnkoYXN0Tm9kZS5ib2R5KTtcblx0XHRcdGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuXHRcdFx0XHRyZXR1cm4gZ2V0U3VjY2Vzc29yKGFzdE5vZGUpO1xuXHRcdFx0Y2FzZSAnSWZTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gYXN0Tm9kZS50ZXN0LmNmZztcblx0XHRcdGNhc2UgJ1N3aXRjaFN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBnZXRFbnRyeShhc3ROb2RlLmNhc2VzWzBdKTtcblx0XHRcdGNhc2UgJ1RyeVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBnZXRFbnRyeShhc3ROb2RlLmJsb2NrKTtcblx0XHRcdGNhc2UgJ1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIGFzdE5vZGUudGVzdC5jZmc7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gYXN0Tm9kZS5jZmc7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdWNjZXNzb3Igbm9kZSBvZiBhIHN0YXRlbWVudFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0U3VjY2Vzc29yKGFzdE5vZGUpIHtcblx0XHQvLyBwYXJ0IG9mIGEgYmxvY2sgLT4gaXQgYWxyZWFkeSBoYXMgYSBuZXh0U2libGluZ1xuXHRcdGlmIChhc3ROb2RlLmNmZy5uZXh0U2libGluZylcblx0XHRcdHJldHVybiBhc3ROb2RlLmNmZy5uZXh0U2libGluZztcblx0XHR2YXIgcGFyZW50ID0gYXN0Tm9kZS5jZmcucGFyZW50O1xuXHRcdGlmICghcGFyZW50KSAvLyBpdCBoYXMgbm8gcGFyZW50IC0+IGV4aXROb2RlXG5cdFx0XHRyZXR1cm4gZXhpdE5vZGU7XG5cdFx0c3dpdGNoIChwYXJlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBwYXJlbnQudGVzdC5jZmc7XG5cdFx0XHRjYXNlICdGb3JTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gcGFyZW50LnVwZGF0ZSAmJiBwYXJlbnQudXBkYXRlLmNmZyB8fCBwYXJlbnQudGVzdCAmJiBwYXJlbnQudGVzdC5jZmcgfHwgZ2V0RW50cnkocGFyZW50LmJvZHkpO1xuXHRcdFx0Y2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gcGFyZW50LmNmZztcblx0XHRcdGNhc2UgJ1RyeVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBwYXJlbnQuZmluYWxpemVyICYmIGFzdE5vZGUgIT09IHBhcmVudC5maW5hbGl6ZXIgJiYgZ2V0RW50cnkocGFyZW50LmZpbmFsaXplcikgfHwgZ2V0U3VjY2Vzc29yKHBhcmVudCk7XG5cdFx0XHRjYXNlICdTd2l0Y2hDYXNlJzpcblx0XHRcdFx0Ly8gdGhlIHN1Y2Vzc29yIG9mIGEgc3RhdGVtZW50IGF0IHRoZSBlbmQgb2YgYSBjYXNlIGJsb2NrIGlzXG5cdFx0XHRcdC8vIHRoZSBlbnRyeSBvZiB0aGUgbmV4dCBjYXNlcyBjb25zZXF1ZW50XG5cdFx0XHRcdGlmICghcGFyZW50LmNmZy5uZXh0U2libGluZylcblx0XHRcdFx0XHRyZXR1cm4gZ2V0U3VjY2Vzc29yKHBhcmVudCk7XG5cdFx0XHRcdHZhciBjaGVjayA9IHBhcmVudC5jZmcubmV4dFNpYmxpbmcuYXN0Tm9kZTtcblx0XHRcdFx0d2hpbGUgKCFjaGVjay5jb25zZXF1ZW50Lmxlbmd0aCAmJiBjaGVjay5jZmcubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0Y2hlY2sgPSBjaGVjay5jZmcubmV4dFNpYmxpbmcuYXN0Tm9kZTtcblx0XHRcdFx0Ly8gb3IgdGhlIG5leHQgc3RhdGVtZW50IGFmdGVyIHRoZSBzd2l0Y2gsIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNhc2VzXG5cdFx0XHRcdHJldHVybiBjaGVjay5jb25zZXF1ZW50Lmxlbmd0aCAmJiBnZXRFbnRyeShjaGVjay5jb25zZXF1ZW50WzBdKSB8fCBnZXRTdWNjZXNzb3IocGFyZW50LnBhcmVudCk7XG5cdFx0XHRjYXNlICdXaGlsZVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBwYXJlbnQudGVzdC5jZmc7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZ2V0U3VjY2Vzc29yKHBhcmVudCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBGbG93Tm9kZSBmb3IgZXZlcnkgQVNUIG5vZGVcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKGFzdE5vZGUpIHtcblx0XHR3YWxrZXIoYXN0Tm9kZSwgeyBkZWZhdWx0OiBmdW5jdGlvbiAobm9kZSwgcmVjdXJzZSkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHBhcmVudFN0YWNrLmxlbmd0aCA/IHBhcmVudFN0YWNrW3BhcmVudFN0YWNrLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXHRcdFx0Y3JlYXRlTm9kZShub2RlLCBwYXJlbnQpO1xuXHRcdFx0Ly8gZG8gbm90IHJlY3Vyc2UgZm9yIEZ1bmN0aW9uRGVjbGFyYXRpb24gb3IgYW55IHN1Yi1leHByZXNzaW9uXG5cdFx0XHRpZiAobm9kZS50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicgfHwgfm5vZGUudHlwZS5pbmRleE9mKCdFeHByZXNzaW9uJykpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHBhcmVudFN0YWNrLnB1c2gobm9kZSk7XG5cdFx0XHR3YWxrZXIuY2hlY2tQcm9wcyhub2RlLCByZWN1cnNlKTtcblx0XHRcdHBhcmVudFN0YWNrLnBvcCgpO1xuXHRcdH19KTtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKGFzdE5vZGUsIHBhcmVudCkge1xuXHRcdGlmICghYXN0Tm9kZS5jZmcpXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXN0Tm9kZSwgJ2NmZycsIHt2YWx1ZTogbmV3IEZsb3dOb2RlKGFzdE5vZGUsIHBhcmVudCksIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpbmtzIGluIHRoZSBuZXh0IHNpYmxpbmcgZm9yIG5vZGVzIGluc2lkZSBhIGJsb2NrXG5cdCAqL1xuXHRmdW5jdGlvbiBsaW5rU2libGluZ3MoYXN0Tm9kZSkge1xuXHRcdGZ1bmN0aW9uIGJhY2tUb0Zyb250KGxpc3QsIHJlY3Vyc2UpIHtcblx0XHRcdC8vIGxpbmsgYWxsIHRoZSBjaGlsZHJlbiB0byB0aGUgbmV4dCBzaWJsaW5nIGZyb20gYmFjayB0byBmcm9udCxcblx0XHRcdC8vIHNvIHRoZSBub2RlcyBhbHJlYWR5IGhhdmUgLm5leHRTaWJsaW5nXG5cdFx0XHQvLyBzZXQgd2hlbiB0aGVpciBnZXRFbnRyeSBpcyBjYWxsZWRcblx0XHRcdGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGxpc3RbaV07XG5cdFx0XHRcdGlmIChpIDwgbGlzdC5sZW5ndGggLSAxKVxuXHRcdFx0XHRcdGNoaWxkLmNmZy5uZXh0U2libGluZyA9IGdldEVudHJ5KGxpc3RbaSArIDFdKTtcblx0XHRcdFx0cmVjdXJzZShjaGlsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIEJsb2NrT3JQcm9ncmFtKG5vZGUsIHJlY3Vyc2UpIHtcblx0XHRcdGJhY2tUb0Zyb250KG5vZGUuYm9keSwgcmVjdXJzZSk7XG5cdFx0fVxuXHRcdHdhbGtlcihhc3ROb2RlLCB7XG5cdFx0XHRCbG9ja1N0YXRlbWVudDogQmxvY2tPclByb2dyYW0sXG5cdFx0XHRQcm9ncmFtOiBCbG9ja09yUHJvZ3JhbSxcblx0XHRcdEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uICgpIHt9LFxuXHRcdFx0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRcdFN3aXRjaENhc2U6IGZ1bmN0aW9uIChub2RlLCByZWN1cnNlKSB7XG5cdFx0XHRcdGJhY2tUb0Zyb250KG5vZGUuY29uc2VxdWVudCwgcmVjdXJzZSk7XG5cdFx0XHR9LFxuXHRcdFx0U3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSwgcmVjdXJzZSkge1xuXHRcdFx0XHRiYWNrVG9Gcm9udChub2RlLmNhc2VzLCByZWN1cnNlKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIFtlbnRyeU5vZGUsIGV4aXROb2RlLCBhbGxOb2Rlc107XG59XG5cbmZ1bmN0aW9uIEZsb3dOb2RlKGFzdE5vZGUsIHBhcmVudCwgdHlwZSkge1xuXHR0aGlzLmFzdE5vZGUgPSBhc3ROb2RlO1xuXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblx0dGhpcy50eXBlID0gdHlwZTtcblx0dGhpcy5wcmV2ID0gW107XG59XG5GbG93Tm9kZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChuZXh0LCB0eXBlKSB7XG5cdHRoaXNbdHlwZSB8fCAnbm9ybWFsJ10gPSBuZXh0O1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbnZhciBjb250aW51ZVRhcmdldHMgPSBbXG5cdCdGb3JTdGF0ZW1lbnQnLFxuXHQnRm9ySW5TdGF0ZW1lbnQnLFxuXHQnRG9XaGlsZVN0YXRlbWVudCcsXG5cdCdXaGlsZVN0YXRlbWVudCddO1xudmFyIGJyZWFrVGFyZ2V0cyA9IGNvbnRpbnVlVGFyZ2V0cy5jb25jYXQoWydTd2l0Y2hTdGF0ZW1lbnQnXSk7XG52YXIgdGhyb3dUeXBlcyA9IFtcblx0J0Fzc2lnbm1lbnRFeHByZXNzaW9uJywgLy8gYXNzaWduaW5nIHRvIHVuZGVmIG9yIG5vbi13cml0YWJsZSBwcm9wXG5cdCdCaW5hcnlFeHByZXNzaW9uJywgLy8gaW5zdGFuY2VvZiBhbmQgaW4gb24gbm9uLW9iamVjdHNcblx0J0NhbGxFeHByZXNzaW9uJywgLy8gb2J2aW91c2x5XG5cdCdNZW1iZXJFeHByZXNzaW9uJywgLy8gZ2V0dGVycyBtYXkgdGhyb3dcblx0J05ld0V4cHJlc3Npb24nLCAvLyBvYnZpb3VzbHlcblx0J1VuYXJ5RXhwcmVzc2lvbicgLy8gZGVsZXRlIG5vbi1kZWxldGFibGUgcHJvcFxuXTtcblxuIiwiLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBub2V4cGFuZHRhYiB0ZXh0d2lkdGg9ODAgd3JhcCA6ICovXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB3YWxrZXI7XG5cbmZ1bmN0aW9uIHdhbGtlcihhc3ROb2RlLCBmdW5jdGlvblRhYmxlLCBvZmZzZXQpIHtcblx0ZnVuY3Rpb24gc3RvcCgpIHsgdGhyb3cgc3RvcDsgfVxuXHR2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uIChhc3ROb2RlKSB7XG5cdFx0aWYgKCFhc3ROb2RlIHx8IHR5cGVvZiBhc3ROb2RlICE9PSAnb2JqZWN0JyB8fCAhYXN0Tm9kZS50eXBlKSB7XG5cdFx0XHRyZXR1cm4gYXN0Tm9kZTtcblx0XHR9XG5cblx0XHQvLyByYW5nZSBiYXNlZCByZWN1cnNpb246IG9ubHkgcmVjdXJzZSB3aGVuIHRoZSBhc3ROb2RlIGlzIGluIHJhbmdlXG5cdFx0aWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIGFzdE5vZGUucmFuZ2UgJiZcblx0XHQgICAgKGFzdE5vZGUucmFuZ2VbMF0gPiBvZmZzZXQgfHwgYXN0Tm9kZS5yYW5nZVsxXSA8IG9mZnNldCkpIHtcblx0XHRcdHJldHVybiBhc3ROb2RlO1xuXHRcdH1cblxuXHRcdHZhciBmbiA9IGZ1bmN0aW9uVGFibGVbYXN0Tm9kZS50eXBlXSB8fCBmdW5jdGlvblRhYmxlLmRlZmF1bHQgfHwgY2hlY2tQcm9wcztcblx0XHRyZXR1cm4gZm4oYXN0Tm9kZSwgcmVjdXJzZSwgc3RvcCk7XG5cdH07XG5cdHZhciByZXQ7XG5cdHRyeSB7XG5cdFx0cmV0ID0gcmVjdXJzZShhc3ROb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChlICE9PSBzdG9wKVxuXHRcdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BzKG5vZGUsIHJlY3Vyc2UpIHtcblx0dmFyIG1hcHBlZCA9IHt9O1xuXHRPYmplY3Qua2V5cyhub2RlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgcHJvcCA9IG5vZGVba2V5XTtcblx0XHR2YXIgcmV0ID0gcHJvcDtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShwcm9wKSkge1xuXHRcdFx0cmV0ID0gcHJvcC5tYXAocmVjdXJzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IHJlY3Vyc2UocHJvcCk7XG5cdFx0fVxuXG5cdFx0bWFwcGVkW2tleV0gPSByZXQ7XG5cdH0pO1xuXHRyZXR1cm4gbWFwcGVkO1xufVxuXG53YWxrZXIuY2hlY2tQcm9wcyA9IGNoZWNrUHJvcHM7XG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qanNsaW50IGJpdHdpc2U6dHJ1ZSBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCBlc3ByaW1hOnRydWUsIGRlZmluZTp0cnVlLCBleHBvcnRzOnRydWUsIHdpbmRvdzogdHJ1ZSxcbnRocm93RXJyb3JUb2xlcmFudDogdHJ1ZSxcbnRocm93RXJyb3I6IHRydWUsIGdlbmVyYXRlU3RhdGVtZW50OiB0cnVlLCBwZWVrOiB0cnVlLFxucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbjogdHJ1ZSwgcGFyc2VCbG9jazogdHJ1ZSwgcGFyc2VFeHByZXNzaW9uOiB0cnVlLFxucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uOiB0cnVlLCBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbjogdHJ1ZSxcbnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50czogdHJ1ZSwgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXI6IHRydWUsXG5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb246IHRydWUsXG5wYXJzZVVuYXJ5RXhwcmVzc2lvbjogdHJ1ZSxcbnBhcnNlU3RhdGVtZW50OiB0cnVlLCBwYXJzZVNvdXJjZUVsZW1lbnQ6IHRydWUgKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLFxuICAgIC8vIFJoaW5vLCBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzcHJpbWEgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVG9rZW4sXG4gICAgICAgIFRva2VuTmFtZSxcbiAgICAgICAgRm5FeHByVG9rZW5zLFxuICAgICAgICBTeW50YXgsXG4gICAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgICAgTWVzc2FnZXMsXG4gICAgICAgIFJlZ2V4LFxuICAgICAgICBTeW50YXhUcmVlRGVsZWdhdGUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGRlbGVnYXRlLFxuICAgICAgICBsb29rYWhlYWQsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBleHRyYTtcblxuICAgIFRva2VuID0ge1xuICAgICAgICBCb29sZWFuTGl0ZXJhbDogMSxcbiAgICAgICAgRU9GOiAyLFxuICAgICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgICBLZXl3b3JkOiA0LFxuICAgICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICAgIFB1bmN0dWF0b3I6IDcsXG4gICAgICAgIFN0cmluZ0xpdGVyYWw6IDgsXG4gICAgICAgIFJlZ3VsYXJFeHByZXNzaW9uOiA5XG4gICAgfTtcblxuICAgIFRva2VuTmFtZSA9IHt9O1xuICAgIFRva2VuTmFtZVtUb2tlbi5Cb29sZWFuTGl0ZXJhbF0gPSAnQm9vbGVhbic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLkVPRl0gPSAnPGVuZD4nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uS2V5d29yZF0gPSAnS2V5d29yZCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLk51bGxMaXRlcmFsXSA9ICdOdWxsJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5QdW5jdHVhdG9yXSA9ICdQdW5jdHVhdG9yJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcblxuICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cbiAgICBGbkV4cHJUb2tlbnMgPSBbJygnLCAneycsICdbJywgJ2luJywgJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgJ25ldycsXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4nLCAnY2FzZScsICdkZWxldGUnLCAndGhyb3cnLCAndm9pZCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICc9JywgJys9JywgJy09JywgJyo9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXG4gICAgICAgICAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAnKycsICctJywgJyonLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcbiAgICAgICAgICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXG4gICAgICAgICAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J107XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCdcbiAgICB9O1xuXG4gICAgUHJvcGVydHlLaW5kID0ge1xuICAgICAgICBEYXRhOiAxLFxuICAgICAgICBHZXQ6IDIsXG4gICAgICAgIFNldDogNFxuICAgIH07XG5cbiAgICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICAgIE1lc3NhZ2VzID0ge1xuICAgICAgICBVbmV4cGVjdGVkVG9rZW46ICAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXG4gICAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAgJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcbiAgICAgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcbiAgICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAgJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRFT1M6ICAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxuICAgICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgICAgSW52YWxpZExIU0luRm9ySW46ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxuICAgICAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxuICAgICAgICBOb0NhdGNoT3JGaW5hbGx5OiAgJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0TW9kZVdpdGg6ICAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFZhck5hbWU6ICAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1OYW1lOiAgJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAgJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REZWxldGU6ICAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0RHVwbGljYXRlUHJvcGVydHk6ICAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBBY2Nlc3NvckRhdGFQcm9wZXJ0eTogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgZGF0YSBhbmQgYWNjZXNzb3IgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgICAgQWNjZXNzb3JHZXRTZXQ6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIG11bHRpcGxlIGdldC9zZXQgYWNjZXNzb3JzIHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1Bvc3RmaXg6ICAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUHJlZml4OiAgJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAgJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZSdcbiAgICB9O1xuXG4gICAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgICBSZWdleCA9IHtcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMFxcdTA4QTItXFx1MDhBQ1xcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdGXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzNcXHUwQzM1LVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkYwXFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFDXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OTdcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTgwLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMFxcdTA4QTItXFx1MDhBQ1xcdTA4RTQtXFx1MDhGRVxcdTA5MDAtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAxLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzNcXHUwQzM1LVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MlxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDJcXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGMFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFDXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFEMDAtXFx1MURFNlxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OTdcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0JcXHVBQTgwLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTI2XFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgICAvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cbiAgICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU3KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG5cbiAgICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XG4gICAgfVxuXG4gICAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICAgIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpO1xuICAgIH1cblxuICAgIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSkgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICAgIH1cblxuICAgIC8vIDcuNi4xLjIgRnV0dXJlIFJlc2VydmVkIFdvcmRzXG5cbiAgICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICBjYXNlICdzdXBlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAgIC8vICd5aWVsZCcgYW5kICdsZXQnIGFyZSBmb3IgY29tcGF0aWJsaXR5IHdpdGggU3BpZGVyTW9ua2V5IGFuZCBFUy5uZXh0LlxuICAgICAgICAvLyBTb21lIG90aGVycyBhcmUgZnJvbSBmdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXG5cbiAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gNy40IENvbW1lbnRzXG5cbiAgICBmdW5jdGlvbiBhZGRDb21tZW50KHR5cGUsIHZhbHVlLCBzdGFydCwgZW5kLCBsb2MpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQsIGF0dGFjaGVyO1xuXG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLCAnQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb24nKTtcblxuICAgICAgICAvLyBCZWNhdXNlIHRoZSB3YXkgdGhlIGFjdHVhbCB0b2tlbiBpcyBzY2FubmVkLCBvZnRlbiB0aGUgY29tbWVudHNcbiAgICAgICAgLy8gKGlmIGFueSkgYXJlIHNraXBwZWQgdHdpY2UgZHVyaW5nIHRoZSBsZXhpY2FsIGFuYWx5c2lzLlxuICAgICAgICAvLyBUaHVzLCB3ZSBuZWVkIHRvIHNraXAgYWRkaW5nIGEgY29tbWVudCBpZiB0aGUgY29tbWVudCBhcnJheSBhbHJlYWR5XG4gICAgICAgIC8vIGhhbmRsZWQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5sYXN0Q29tbWVudFN0YXJ0ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBjb21tZW50LmxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwU2luZ2xlTGluZUNvbW1lbnQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCBjaCwgY29tbWVudDtcblxuICAgICAgICBzdGFydCA9IGluZGV4IC0gb2Zmc2V0O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIG9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyBvZmZzZXQsIGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnTGluZScsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCAtIDEsIGxvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgb2Zmc2V0LCBpbmRleCk7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwTXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgc3RhcnQgPSBpbmRleCAtIDI7XG4gICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDJGKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIDIsIGluZGV4IC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0Jsb2NrJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNoLCBzdGFydDtcblxuICAgICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkYpIHsgLy8gVSswMDJGIGlzICcvJ1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkYpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyQSkgeyAgLy8gVSswMDJBIGlzICcqJ1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBza2lwTXVsdGlMaW5lQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHsgLy8gVSswMDJEIGlzICctJ1xuICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcbiAgICAgICAgICAgICAgICBpZiAoKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDB4MkQpICYmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDIpID09PSAweDNFKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4M0MpIHsgLy8gVSswMDNDIGlzICc8J1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDQpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgPGBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYCFgXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAtYFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgLWBcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KDQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciBjaCwgaWQ7XG5cbiAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgICAgaWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBjaDtcblxuICAgICAgICBzdGFydCA9IGluZGV4Kys7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVzY2FwZWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIDcuNyBQdW5jdHVhdG9yc1xuXG4gICAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGluZGV4LFxuICAgICAgICAgICAgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSxcbiAgICAgICAgICAgIGNvZGUyLFxuICAgICAgICAgICAgY2gxID0gc291cmNlW2luZGV4XSxcbiAgICAgICAgICAgIGNoMixcbiAgICAgICAgICAgIGNoMyxcbiAgICAgICAgICAgIGNoNDtcblxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcblxuICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgY2FzZSAweDJFOiAgLy8gLiBkb3RcbiAgICAgICAgY2FzZSAweDI4OiAgLy8gKCBvcGVuIGJyYWNrZXRcbiAgICAgICAgY2FzZSAweDI5OiAgLy8gKSBjbG9zZSBicmFja2V0XG4gICAgICAgIGNhc2UgMHgzQjogIC8vIDsgc2VtaWNvbG9uXG4gICAgICAgIGNhc2UgMHgyQzogIC8vICwgY29tbWFcbiAgICAgICAgY2FzZSAweDdCOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXG4gICAgICAgIGNhc2UgMHg3RDogIC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcbiAgICAgICAgY2FzZSAweDVCOiAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6ICAvLyBdXG4gICAgICAgIGNhc2UgMHgzQTogIC8vIDpcbiAgICAgICAgY2FzZSAweDNGOiAgLy8gP1xuICAgICAgICBjYXNlIDB4N0U6ICAvLyB+XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg3Qikge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgICAgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICAgICAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyQjogIC8vICtcbiAgICAgICAgICAgICAgICBjYXNlIDB4MkQ6ICAvLyAtXG4gICAgICAgICAgICAgICAgY2FzZSAweDJGOiAgLy8gL1xuICAgICAgICAgICAgICAgIGNhc2UgMHgzQzogIC8vIDxcbiAgICAgICAgICAgICAgICBjYXNlIDB4M0U6ICAvLyA+XG4gICAgICAgICAgICAgICAgY2FzZSAweDVFOiAgLy8gXlxuICAgICAgICAgICAgICAgIGNhc2UgMHg3QzogIC8vIHxcbiAgICAgICAgICAgICAgICBjYXNlIDB4MjU6ICAvLyAlXG4gICAgICAgICAgICAgICAgY2FzZSAweDI2OiAgLy8gJlxuICAgICAgICAgICAgICAgIGNhc2UgMHgyQTogIC8vICpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2FzZSAweDIxOiAvLyAhXG4gICAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIT09IGFuZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cbiAgICAgICAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgICAgICAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDQsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgICAgY2gzID0gY2g0LnN1YnN0cigwLCAzKTtcblxuICAgICAgICBpZiAoY2gzID09PSAnPj4+JyB8fCBjaDMgPT09ICc8PD0nIHx8IGNoMyA9PT0gJz4+PScpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoMyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXIgMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ICsrIC0tIDw8ID4+ICYmIHx8XG4gICAgICAgIGNoMiA9IGNoMy5zdWJzdHIoMCwgMik7XG5cbiAgICAgICAgaWYgKChjaDEgPT09IGNoMlsxXSAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB8fCBjaDIgPT09ICc9PicpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoMixcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6IDwgPiA9ICEgKyAtICogJSAmIHwgXiAvXG4gICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgfVxuXG4gICAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bWJlciwgMTYpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgICAgb2N0YWw6IHRydWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIGksIGNoO1xuXG4gICAgICAgIC8vIEltcGxpY2l0IG9jdGFsLCB1bmxlc3MgdGhlcmUgaXMgYSBub24tb2N0YWwgZGlnaXQuXG4gICAgICAgIC8vIChBbm5leCBCLjEuMSBvbiBOdW1lcmljIExpdGVyYWxzKVxuICAgICAgICBmb3IgKGkgPSBpbmRleCArIDE7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICc4JyB8fCBjaCA9PT0gJzknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgICAgIHZhciBudW1iZXIsIHN0YXJ0LCBjaDtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksXG4gICAgICAgICAgICAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgbnVtYmVyID0gJyc7XG4gICAgICAgIGlmIChjaCAhPT0gJy4nKSB7XG4gICAgICAgICAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAgIC8vIEhleCBudW1iZXIgc3RhcnRzIHdpdGggJzB4Jy5cbiAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSGV4TGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0TGluZVN0YXJ0O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSxcbiAgICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICArK2luZGV4O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICBzdGFydExpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cEJvZHkoKSB7XG4gICAgICAgIHZhciBjaCwgc3RyLCBjbGFzc01hcmtlciwgdGVybWluYXRlZCwgYm9keTtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgICAgc3RyID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgLy8gRUNNQS0yNjIgNy44LjVcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogYm9keSxcbiAgICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgICAgICAgdmFyIGNoLCBzdHIsIGZsYWdzLCByZXN0b3JlO1xuXG4gICAgICAgIHN0ciA9ICcnO1xuICAgICAgICBmbGFncyA9ICcnO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNvdXJjZVtyZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBmbGFncyxcbiAgICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gICAgICAgIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHBhdHRlcm4sIHZhbHVlO1xuXG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgICAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gICAgICAgIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XG4gICAgICAgIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlJlZ3VsYXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2V4ID0gc2NhblJlZ0V4cCgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyBsaWtlbHkgJy8nIG9yICcvPSdcbiAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmFuZ2VbMF0gPT09IHBvcyAmJiB0b2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlZ2V4LmxpdGVyYWwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkdmFuY2VTbGFzaCgpIHtcbiAgICAgICAgdmFyIHByZXZUb2tlbixcbiAgICAgICAgICAgIGNoZWNrVG9rZW47XG4gICAgICAgIC8vIFVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxuICAgICAgICBwcmV2VG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIXByZXZUb2tlbikge1xuICAgICAgICAgICAgLy8gTm90aGluZyBiZWZvcmUgdGhhdDogaXQgY2Fubm90IGJlIGEgZGl2aXNpb24uXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICddJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuUGFyZW5Ub2tlbiAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrVG9rZW4udmFsdWUgPT09ICdpZicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2hpbGUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2ZvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2l0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVja1Rva2VuIGRldGVybWluZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBhIGRlY2xhcmF0aW9uIG9yIGFuIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgaWYgKEZuRXhwclRva2Vucy5pbmRleE9mKGNoZWNrVG9rZW4udmFsdWUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgZGVjbGFyYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmIHByZXZUb2tlbi52YWx1ZSAhPT0gJ3RoaXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgICAgdmFyIGNoO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5FT0YsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcbiAgICAgICAgaWYgKGNoID09PSAweDI4IHx8IGNoID09PSAweDI5IHx8IGNoID09PSAweDNCKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXG4gICAgICAgIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjaCA9PT0gMHgyRSkge1xuICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGFzaCAoLykgVSswMDJGIGNhbiBhbHNvIHN0YXJ0IGEgcmVnZXguXG4gICAgICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjaCA9PT0gMHgyRikge1xuICAgICAgICAgICAgcmV0dXJuIGFkdmFuY2VTbGFzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFRva2VuKCkge1xuICAgICAgICB2YXIgbG9jLCB0b2tlbiwgcmFuZ2UsIHZhbHVlO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdG9rZW4gPSBhZHZhbmNlKCk7XG4gICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcblxuICAgICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQ7XG5cbiAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgICBpbmRleCA9IHBvcztcbiAgICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbHVtbikge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbihzdGFydExpbmUsIHN0YXJ0Q29sdW1uKTtcbiAgICAgICAgdGhpcy5lbmQgPSBuZXcgUG9zaXRpb24obGluZSwgY29sdW1uKTtcbiAgICB9XG5cbiAgICBTeW50YXhUcmVlRGVsZWdhdGUgPSB7XG5cbiAgICAgICAgbmFtZTogJ1N5bnRheFRyZWUnLFxuXG4gICAgICAgIHByb2Nlc3NDb21tZW50OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIGxhc3RDaGlsZCwgdHJhaWxpbmdDb21tZW50cztcblxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LlByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS50cmFpbGluZ0NvbW1lbnRzWzBdLnJhbmdlWzBdID49IG5vZGUucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGV4dHJhLnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEuYm90dG9tUmlnaHRTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5ib3R0b21SaWdodFN0YWNrW2V4dHJhLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoIC0gMV0udHJhaWxpbmdDb21tZW50cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEuYm90dG9tUmlnaHRTdGFja1tleHRyYS5ib3R0b21SaWdodFN0YWNrLmxlbmd0aCAtIDFdLnRyYWlsaW5nQ29tbWVudHNbMF0ucmFuZ2VbMF0gPj0gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gZXh0cmEuYm90dG9tUmlnaHRTdGFja1tleHRyYS5ib3R0b21SaWdodFN0YWNrLmxlbmd0aCAtIDFdLnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBleHRyYS5ib3R0b21SaWdodFN0YWNrW2V4dHJhLmJvdHRvbVJpZ2h0U3RhY2subGVuZ3RoIC0gMV0udHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVhdGluZyB0aGUgc3RhY2suXG4gICAgICAgICAgICB3aGlsZSAoZXh0cmEuYm90dG9tUmlnaHRTdGFjay5sZW5ndGggPiAwICYmIGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2tbZXh0cmEuYm90dG9tUmlnaHRTdGFjay5sZW5ndGggLSAxXS5yYW5nZVswXSA+PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgbGFzdENoaWxkID0gZXh0cmEuYm90dG9tUmlnaHRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzICYmIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHNbbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxXS5yYW5nZVsxXSA8PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCAmJiBleHRyYS5sZWFkaW5nQ29tbWVudHNbZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDFdLnJhbmdlWzFdIDw9IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGV4dHJhLmxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhLmJvdHRvbVJpZ2h0U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXJrRW5kOiBmdW5jdGlvbiAobm9kZSwgc3RhcnRUb2tlbikge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VG9rZW4uc3RhcnRMaW5lTnVtYmVyID09PSB1bmRlZmluZWQgPyAgc3RhcnRUb2tlbi5saW5lTnVtYmVyIDogc3RhcnRUb2tlbi5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VG9rZW4uc3RhcnQgLSAoc3RhcnRUb2tlbi5zdGFydExpbmVTdGFydCA9PT0gdW5kZWZpbmVkID8gIHN0YXJ0VG9rZW4ubGluZVN0YXJ0IDogc3RhcnRUb2tlbi5zdGFydExpbmVTdGFydCksXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbW1lbnQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3N0UHJvY2VzczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSBleHRyYS5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQXJyYXlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgY2FsbGVlOiBjYWxsZWUsXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQ2F0Y2hDbGF1c2U6IGZ1bmN0aW9uIChwYXJhbSwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2F0Y2hDbGF1c2UsXG4gICAgICAgICAgICAgICAgcGFyYW06IHBhcmFtLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LFxuICAgICAgICAgICAgICAgIGFsdGVybmF0ZTogYWx0ZXJuYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKGJvZHksIHRlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkRvV2hpbGVTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVtcHR5U3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FbXB0eVN0YXRlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUZvclN0YXRlbWVudDogZnVuY3Rpb24gKGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRm9yU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgICAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUZvckluU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkZvckluU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgZWFjaDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoaWQsIHBhcmFtcywgZGVmYXVsdHMsIGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUlkZW50aWZpZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSWZTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklmU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudCxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGU6IGFsdGVybmF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYWJlbGVkU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwsIGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTGl0ZXJhbDogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICByYXc6IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGFjY2Vzc29yID09PSAnWycsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZU5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgY2FsbGVlOiBjYWxsZWUsXG4gICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk9iamVjdEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb3N0Zml4RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUHJvZ3JhbTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb2dyYW0sXG4gICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQcm9wZXJ0eTogZnVuY3Rpb24gKGtpbmQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVJldHVyblN0YXRlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IGV4cHJlc3Npb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVN3aXRjaENhc2U6IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hDYXNlLFxuICAgICAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTd2l0Y2hTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgZGlzY3JpbWluYW50OiBkaXNjcmltaW5hbnQsXG4gICAgICAgICAgICAgICAgY2FzZXM6IGNhc2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaGlzRXhwcmVzc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaHJvd1N0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVHJ5U3RhdGVtZW50OiBmdW5jdGlvbiAoYmxvY2ssIGd1YXJkZWRIYW5kbGVycywgaGFuZGxlcnMsIGZpbmFsaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVHJ5U3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGJsb2NrOiBibG9jayxcbiAgICAgICAgICAgICAgICBndWFyZGVkSGFuZGxlcnM6IGd1YXJkZWRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgZmluYWxpemVyOiBmaW5hbGl6ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICcrKycgfHwgb3BlcmF0b3IgPT09ICctLScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5VbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKGRlY2xhcmF0aW9ucywga2luZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGRlY2xhcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKGlkLCBpbml0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGluaXQ6IGluaXRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5XaGlsZVN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlV2l0aFN0YXRlbWVudDogZnVuY3Rpb24gKG9iamVjdCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguV2l0aFN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgICAgaW5kZXggPSBwb3M7XG4gICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKHRva2VuLCBtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChpbmRleCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgdG9rZW4ubGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5zdGFydDtcbiAgICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgICAgZXJyb3IuY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gbXNnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yVG9sZXJhbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgaWYgKGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCB8fCB0b2tlbi52YWx1ZSAhPT0ga2V5d29yZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgdmFyIGxpbmUsIG9sZEluZGV4ID0gaW5kZXgsIG9sZExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgb2xkTGluZVN0YXJ0ID0gbGluZVN0YXJ0LCBvbGRMb29rYWhlYWQgPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNCIHx8IG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyICE9PSBsaW5lKSB7XG4gICAgICAgICAgICBpbmRleCA9IG9sZEluZGV4O1xuICAgICAgICAgICAgbGluZU51bWJlciA9IG9sZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBvbGRMaW5lU3RhcnQ7XG4gICAgICAgICAgICBsb29rYWhlYWQgPSBvbGRMb29rYWhlYWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBwcm92aWRlZCBleHByZXNzaW9uIGlzIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cblxuICAgIGZ1bmN0aW9uIGlzTGVmdEhhbmRTaWRlKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHwgZXhwci50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10sIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXgoKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5RnVuY3Rpb24ocGFyYW0sIGZpcnN0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0cmljdCwgYm9keSwgc3RhcnRUb2tlbjtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoZmlyc3QgJiYgc3RyaWN0ICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW1bMF0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdCwgTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtLCBbXSwgYm9keSksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlTGl0ZXJhbCh0b2tlbiksIHN0YXJ0VG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlSWRlbnRpZmllcih0b2tlbi52YWx1ZSksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoKSB7XG4gICAgICAgIHZhciB0b2tlbiwga2V5LCBpZCwgdmFsdWUsIHBhcmFtLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG5cbiAgICAgICAgICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBBc3NpZ25tZW50OiBHZXR0ZXIgYW5kIFNldHRlci5cblxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiAhbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoJ2dldCcsIGtleSwgdmFsdWUpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgIW1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKFtdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbSA9IFsgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSBdO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24ocGFyYW0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlUHJvcGVydHkoJ3NldCcsIGtleSwgdmFsdWUpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVQcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWx1ZSksIHN0YXJ0VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVQcm9wZXJ0eSgnaW5pdCcsIGtleSwgdmFsdWUpLCBzdGFydFRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIHByb3BlcnR5LCBuYW1lLCBrZXksIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZywgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gcHJvcGVydHkua2V5Lm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0b1N0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2luZCA9IChwcm9wZXJ0eS5raW5kID09PSAnaW5pdCcpID8gUHJvcGVydHlLaW5kLkRhdGEgOiAocHJvcGVydHkua2luZCA9PT0gJ2dldCcpID8gUHJvcGVydHlLaW5kLkdldCA6IFByb3BlcnR5S2luZC5TZXQ7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIG5hbWU7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXBba2V5XSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBba2V5XSAmIGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JHZXRTZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcFtrZXldIHw9IGtpbmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcFtrZXldID0ga2luZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuXG4gICAgLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBleHByID0gIGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVMaXRlcmFsKGxleCgpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCd0aGlzJykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlVGhpc0V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gKHRva2VuLnZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVMaXRlcmFsKGNvbGxlY3RSZWdleCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZUxpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChleHByLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUlkZW50aWZpZXIodG9rZW4udmFsdWUpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGNhbGxlZSwgYXJncywgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBleHBlY3RLZXl3b3JkKCduZXcnKTtcbiAgICAgICAgY2FsbGVlID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCk7XG4gICAgICAgIGFyZ3MgPSBtYXRjaCgnKCcpID8gcGFyc2VBcmd1bWVudHMoKSA6IFtdO1xuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZU5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSwgc3RhcnRUb2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgICB2YXIgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgIGV4cHIgPSBtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uKCkgOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcbiAgICAgICAgYXNzZXJ0KHN0YXRlLmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gbWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbigpIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnLicpIHx8IG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZWdhdGUubWFya0VuZChleHByLCBzdGFydFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCB0b2tlbiwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCk7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBpZiAoKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSAmJiAhcGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAxMS4zLjEsIDExLjMuMlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByID0gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVQb3N0Zml4RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciksIHN0YXJ0VG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgLy8gMTEuNC40LCAxMS40LjVcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5tYXJrRW5kKGV4cHIsIHN0YXJ0VG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5tYXJrRW5kKGV4cHIsIHN0YXJ0VG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgZXhwciA9IGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgYWxsb3dJbikge1xuICAgICAgICB2YXIgcHJlYyA9IDA7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgIHByZWMgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgcHJlYyA9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgIHByZWMgPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICBwcmVjID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcHJlYyA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgIHByZWMgPSA2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgY2FzZSAnaW5zdGFuY2VvZic6XG4gICAgICAgICAgICBwcmVjID0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgIHByZWMgPSBhbGxvd0luID8gNyA6IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc8PCc6XG4gICAgICAgIGNhc2UgJz4+JzpcbiAgICAgICAgY2FzZSAnPj4+JzpcbiAgICAgICAgICAgIHByZWMgPSA4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcHJlYyA9IDk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcHJlYyA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByZWM7XG4gICAgfVxuXG4gICAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbiAgICAvLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuICAgIC8vIDExLjcgQml0d2lzZSBTaGlmdCBPcGVyYXRvcnNcbiAgICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4gICAgLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgICAvLyAxMS4xMCBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcbiAgICAvLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIG1hcmtlciwgbWFya2VycywgZXhwciwgdG9rZW4sIHByZWMsIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGk7XG5cbiAgICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgICBsZWZ0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgc3RhY2sgPSBbbGVmdCwgdG9rZW4sIHJpZ2h0XTtcblxuICAgICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgbWFya2VyKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxuICAgICAgICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgZXhwciA9IHN0YWNrW2ldO1xuICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICB3aGlsZSAoaSA+IDEpIHtcbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIG1hcmtlciA9IG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICBkZWxlZ2F0ZS5tYXJrRW5kKGV4cHIsIG1hcmtlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGV4cHIgPSBkZWxlZ2F0ZS5jcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICAgICAgICAgIGRlbGVnYXRlLm1hcmtFbmQoZXhwciwgc3RhcnRUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xMyBBc3NpZ25tZW50IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsZWZ0LCByaWdodCwgbm9kZSwgc3RhcnRUb2tlbjtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBub2RlID0gbGVmdCA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXNzaWduKCkpIHtcbiAgICAgICAgICAgIC8vIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cbiAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUobGVmdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxMS4xMy4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChsZWZ0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgbm9kZSA9IGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG9rZW4udmFsdWUsIGxlZnQsIHJpZ2h0KSwgc3RhcnRUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBleHByID0gZGVsZWdhdGUuY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uKFsgZXhwciBdKTtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZWdhdGUubWFya0VuZChleHByLCBzdGFydFRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDEyLjEgQmxvY2tcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlbWVudDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2ssIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZVN0YXRlbWVudExpc3QoKTtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVCbG9ja1N0YXRlbWVudChibG9jayksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIC8vIDEyLjIgVmFyaWFibGUgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVJZGVudGlmaWVyKHRva2VuLnZhbHVlKSwgc3RhcnRUb2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKGtpbmQpIHtcbiAgICAgICAgdmFyIGluaXQgPSBudWxsLCBpZCwgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgIGluaXQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSwgc3RhcnRUb2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihraW5kKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IHdoaWxlIChpbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpO1xuICAgIH1cblxuICAgIC8vIGtpbmQgbWF5IGJlIGBjb25zdGAgb3IgYGxldGBcbiAgICAvLyBCb3RoIGFyZSBleHBlcmltZW50YWwgYW5kIG5vdCBpbiB0aGUgc3BlY2lmaWNhdGlvbiB5ZXQuXG4gICAgLy8gc2VlIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6Y29uc3RcbiAgICAvLyBhbmQgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpsZXRcbiAgICBmdW5jdGlvbiBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24oa2luZCkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZChraW5kKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGtpbmQpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIC8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVtcHR5U3RhdGVtZW50KCkge1xuICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUVtcHR5U3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICAgIH1cblxuICAgIC8vIDEyLjUgSWYgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlmU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgdGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2lmJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgIH1cblxuICAgIC8vIDEyLjYgSXRlcmF0aW9uIFN0YXRlbWVudHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGJvZHksIHRlc3QsIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RvJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZURvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGJvZHksIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgZGVjbGFyYXRpb25zLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgdG9rZW4udmFsdWUpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGluaXQsIHRlc3QsIHVwZGF0ZSwgbGVmdCwgcmlnaHQsIGJvZHksIG9sZEluSXRlcmF0aW9uLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICAgIGluaXQgPSB0ZXN0ID0gdXBkYXRlID0gbnVsbDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmb3InKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCd2YXInKSB8fCBtYXRjaEtleXdvcmQoJ2xldCcpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXQgPSBwYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGluaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgICAgICAgICAgZGVsZWdhdGUuY3JlYXRlRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkgOlxuICAgICAgICAgICAgICAgIGRlbGVnYXRlLmNyZWF0ZUZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyAxMi43IFRoZSBjb250aW51ZSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29udGludWVTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGwsIGtleTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjb250aW51ZScpO1xuXG4gICAgICAgIC8vIE9wdGltaXplIHRoZSBtb3N0IGNvbW1vbiBmb3JtOiAnY29udGludWU7Jy5cbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzQikge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG51bGwsIGtleTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdicmVhaycpO1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzQikge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGlmICghKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUJyZWFrU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIGxhYmVsLm5hbWU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5sYWJlbFNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZUJyZWFrU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyAxMi45IFRoZSByZXR1cm4gc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJldHVyblN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gbnVsbDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdyZXR1cm4nKTtcblxuICAgICAgICBpZiAoIXN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLklsbGVnYWxSZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3JldHVybicgZm9sbG93ZWQgYnkgYSBzcGFjZSBhbmQgYW4gaWRlbnRpZmllciBpcyB2ZXJ5IGNvbW1vbi5cbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgyMCkge1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZVJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJ30nKSAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG9iamVjdCwgYm9keTtcblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAvLyBUT0RPKGlrYXJpZW5hdG9yKTogU2hvdWxkIHdlIHVwZGF0ZSB0aGUgdGVzdCBjYXNlcyBpbnN0ZWFkP1xuICAgICAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIG9iamVjdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVXaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTAgVGhlIHN3aXRoIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgdGVzdCwgY29uc2VxdWVudCA9IFtdLCBzdGF0ZW1lbnQsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHRlc3QgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwZWN0S2V5d29yZCgnY2FzZScpO1xuICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykgfHwgbWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgbWF0Y2hLZXl3b3JkKCdjYXNlJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjb25zZXF1ZW50LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZVN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3dpdGNoU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgZGlzY3JpbWluYW50LCBjYXNlcywgY2xhdXNlLCBvbGRJblN3aXRjaCwgZGVmYXVsdEZvdW5kO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3N3aXRjaCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGRpc2NyaW1pbmFudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIGNhc2VzID0gW107XG5cbiAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZVN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhdXNlID0gcGFyc2VTd2l0Y2hDYXNlKCk7XG4gICAgICAgICAgICBpZiAoY2xhdXNlLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlcy5wdXNoKGNsYXVzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IG9sZEluU3dpdGNoO1xuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5jcmVhdGVTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTMgVGhlIHRocm93IHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaHJvd1N0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpO1xuICAgIH1cblxuICAgIC8vIDEyLjE0IFRoZSB0cnkgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNhdGNoQ2xhdXNlKCkge1xuICAgICAgICB2YXIgcGFyYW0sIGJvZHksIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICAvLyAxMi4xNC4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChwYXJhbS5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RDYXRjaFZhcmlhYmxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICBib2R5ID0gcGFyc2VCbG9jaygpO1xuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVDYXRjaENsYXVzZShwYXJhbSwgYm9keSksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgYmxvY2ssIGhhbmRsZXJzID0gW10sIGZpbmFsaXplciA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndHJ5Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChwYXJzZUNhdGNoQ2xhdXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZmluYWxseScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDAgJiYgIWZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUuY3JlYXRlVHJ5U3RhdGVtZW50KGJsb2NrLCBbXSwgaGFuZGxlcnMsIGZpbmFsaXplcik7XG4gICAgfVxuXG4gICAgLy8gMTIuMTUgVGhlIGRlYnVnZ2VyIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpIHtcbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmNyZWF0ZURlYnVnZ2VyU3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgLy8gMTIgU3RhdGVtZW50c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0eXBlID0gbG9va2FoZWFkLnR5cGUsXG4gICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgbGFiZWxlZEJvZHksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzdGFydFRva2VuO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VFbXB0eVN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZUJyZWFrU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xuICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlQ29udGludWVTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZURvV2hpbGVTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICBjYXNlICdmb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlRm9yU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZUlmU3RhdGVtZW50KCksIHN0YXJ0VG9rZW4pO1xuICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChwYXJzZVJldHVyblN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VUaHJvd1N0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGNhc2UgJ3RyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VUcnlTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKSwgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICBjYXNlICd3aGlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQocGFyc2VXaGlsZVN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKHBhcnNlV2l0aFN0YXRlbWVudCgpLCBzdGFydFRva2VuKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgLy8gMTIuMTIgTGFiZWxsZWQgU3RhdGVtZW50c1xuICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpICYmIG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBleHByLm5hbWU7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgZXhwci5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubGFiZWxTZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBsYWJlbGVkQm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGFiZWxTZXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUxhYmVsZWRTdGF0ZW1lbnQoZXhwciwgbGFiZWxlZEJvZHkpLCBzdGFydFRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gZGVsZWdhdGUubWFya0VuZChkZWxlZ2F0ZS5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICAvLyAxMyBGdW5jdGlvbiBEZWZpbml0aW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keSwgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGFiZWxTZXQgPSBzdGF0ZS5sYWJlbFNldDtcbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgb2xkSW5GdW5jdGlvbkJvZHkgPSBzdGF0ZS5pbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IHt9O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0gb2xkTGFiZWxTZXQ7XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gb2xkSW5GdW5jdGlvbkJvZHk7XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlQmxvY2tTdGF0ZW1lbnQoc291cmNlRWxlbWVudHMpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgdmFyIHBhcmFtLCBwYXJhbXMgPSBbXSwgdG9rZW4sIHN0cmljdGVkLCBwYXJhbVNldCwga2V5LCBtZXNzYWdlO1xuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAga2V5ID0gJyQnICsgdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1TZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1TZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcGFyYW1TZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgc3RyaWN0ZWQ6IHN0cmljdGVkLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgaWQsIHBhcmFtcyA9IFtdLCBib2R5LCB0b2tlbiwgc3RyaWN0ZWQsIHRtcCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCBwcmV2aW91c1N0cmljdCwgc3RhcnRUb2tlbjtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKTtcbiAgICAgICAgcGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgc3RyaWN0ZWQgPSB0bXAuc3RyaWN0ZWQ7XG4gICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRtcC5maXJzdFJlc3RyaWN0ZWQ7XG4gICAgICAgIGlmICh0bXAubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRtcC5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZUZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgW10sIGJvZHkpLCBzdGFydFRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBpZCA9IG51bGwsIHN0cmljdGVkLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHRtcCwgcGFyYW1zID0gW10sIGJvZHksIHByZXZpb3VzU3RyaWN0LCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpO1xuICAgICAgICBwYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlLm1hcmtFbmQoZGVsZWdhdGUuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIFtdLCBib2R5KSwgc3RhcnRUb2tlbik7XG4gICAgfVxuXG4gICAgLy8gMTQgUHJvZ3JhbVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50KCkge1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24obG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHNvdXJjZUVsZW1lbnQsIHNvdXJjZUVsZW1lbnRzID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgICB2YXIgYm9keSwgc3RhcnRUb2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBwZWVrKCk7XG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHN0cmljdCA9IGZhbHNlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZS5tYXJrRW5kKGRlbGVnYXRlLmNyZWF0ZVByb2dyYW0oYm9keSksIHN0YXJ0VG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS50b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgdG9rZW5zO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGVnYXRlID0gU3ludGF4VHJlZURlbGVnYXRlO1xuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICAgIH07XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcblxuICAgICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBPZiBjb3Vyc2Ugd2UgY29sbGVjdCB0b2tlbnMgaGVyZS5cbiAgICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgZXh0cmEudG9rZW5pemUgPSB0cnVlO1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBmaWVsZHMgYXJlIG5lY2Vzc2FyeSB0byBjb21wdXRlIHRoZSBSZWdleCB0b2tlbnMuXG4gICAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gLTE7XG4gICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gLTE7XG5cbiAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYS50b2tlbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobGV4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGVnYXRlID0gU3ludGF4VHJlZURlbGVnYXRlO1xuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICAgIH07XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG4gICAgICAgICAgICBleHRyYS5hdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5hdHRhY2hDb21tZW50O1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsICYmIG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5zb3VyY2UgPSB0b1N0cmluZyhvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5ib3R0b21SaWdodFN0YWNrID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5jb21tZW50cyA9IGV4dHJhLmNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgLy8gU3luYyB3aXRoICouanNvbiBtYW5pZmVzdHMuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gJzEuMi41JztcblxuICAgIGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIC8vIERlZXAgY29weS5cbiAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZXhwb3J0cy5TeW50YXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSwgdHlwZXMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobmFtZSBpbiBTeW50YXgpIHtcbiAgICAgICAgICAgIGlmIChTeW50YXguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tuYW1lXSA9IFN5bnRheFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmZyZWV6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0eXBlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfSgpKTtcblxufSkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlKi9cbihmdW5jdGlvbiBjbG9uZShleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFN5bnRheCxcbiAgICAgICAgaXNBcnJheSxcbiAgICAgICAgVmlzaXRvck9wdGlvbixcbiAgICAgICAgVmlzaXRvcktleXMsXG4gICAgICAgIG9iamVjdENyZWF0ZSxcbiAgICAgICAgb2JqZWN0S2V5cyxcbiAgICAgICAgQlJFQUssXG4gICAgICAgIFNLSVAsXG4gICAgICAgIFJFTU9WRTtcblxuICAgIGZ1bmN0aW9uIGlnbm9yZUpTSGludEVycm9yKCkgeyB9XG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZXBDb3B5KG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sIGtleSwgdmFsO1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBkZWVwQ29weSh2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iaikge1xuICAgICAgICB2YXIgcmV0ID0ge30sIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlnbm9yZUpTSGludEVycm9yKHNoYWxsb3dDb3B5KTtcblxuICAgIC8vIGJhc2VkIG9uIExMVk0gbGliYysrIHVwcGVyX2JvdW5kIC8gbG93ZXJfYm91bmRcbiAgICAvLyBNSVQgTGljZW5zZVxuXG4gICAgZnVuY3Rpb24gdXBwZXJCb3VuZChhcnJheSwgZnVuYykge1xuICAgICAgICB2YXIgZGlmZiwgbGVuLCBpLCBjdXJyZW50O1xuXG4gICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgZGlmZiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICAgICAgICAgIGlmIChmdW5jKGFycmF5W2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gZGlmZiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgZnVuYykge1xuICAgICAgICB2YXIgZGlmZiwgbGVuLCBpLCBjdXJyZW50O1xuXG4gICAgICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgZGlmZiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICAgICAgICAgIGlmIChmdW5jKGFycmF5W2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gZGlmZiArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGlnbm9yZUpTSGludEVycm9yKGxvd2VyQm91bmQpO1xuXG4gICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGKCkgeyB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgICAgICAgICByZXR1cm4gbmV3IEYoKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBrZXlzID0gW10sIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gbykge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZCh0bywgZnJvbSkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZnJvbSksIGtleSwgaSwgbGVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46ICdBc3NpZ25tZW50UGF0dGVybicsXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBBd2FpdEV4cHJlc3Npb246ICdBd2FpdEV4cHJlc3Npb24nLCAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6ICdDb21wcmVoZW5zaW9uQmxvY2snLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiAnQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24nLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiAnRGlyZWN0aXZlU3RhdGVtZW50JyxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgR2VuZXJhdG9yRXhwcmVzc2lvbjogJ0dlbmVyYXRvckV4cHJlc3Npb24nLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogJ01vZHVsZVNwZWNpZmllcicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXG4gICAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN1cGVyOiAnU3VwZXInLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcbiAgICB9O1xuXG4gICAgVmlzaXRvcktleXMgPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogWydhcmd1bWVudCddLCAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6IFsnYm9keSddLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBDYXRjaENsYXVzZTogWydwYXJhbScsICdib2R5J10sXG4gICAgICAgIENsYXNzQm9keTogWydib2R5J10sXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IFsnaWQnLCAnc3VwZXJDbGFzcycsICdib2R5J10sXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogWydpZCcsICdzdXBlckNsYXNzJywgJ2JvZHknXSxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiBbJ2xlZnQnLCAncmlnaHQnXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogWydibG9ja3MnLCAnZmlsdGVyJywgJ2JvZHknXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogW10sXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogW10sXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IFsnYm9keScsICd0ZXN0J10sXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBbXSxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IFsnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbiddLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydleHBvcnRlZCcsICdsb2NhbCddLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBbJ2V4cHJlc3Npb24nXSxcbiAgICAgICAgRm9yU3RhdGVtZW50OiBbJ2luaXQnLCAndGVzdCcsICd1cGRhdGUnLCAnYm9keSddLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IFsnaWQnLCAncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydsb2NhbCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2ltcG9ydGVkJywgJ2xvY2FsJ10sXG4gICAgICAgIExpdGVyYWw6IFtdLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBbJ2xhYmVsJywgJ2JvZHknXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRhUHJvcGVydHk6IFsnbWV0YScsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6IFtdLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIE9iamVjdFBhdHRlcm46IFsncHJvcGVydGllcyddLFxuICAgICAgICBQcm9ncmFtOiBbJ2JvZHknXSxcbiAgICAgICAgUHJvcGVydHk6IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIFJlc3RFbGVtZW50OiBbICdhcmd1bWVudCcgXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN1cGVyOiBbXSxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBbJ2Rpc2NyaW1pbmFudCcsICdjYXNlcyddLFxuICAgICAgICBTd2l0Y2hDYXNlOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCddLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IFsndGFnJywgJ3F1YXNpJ10sXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogW10sXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogWydxdWFzaXMnLCAnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246IFtdLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6IFsnYmxvY2snLCAnaGFuZGxlcicsICdmaW5hbGl6ZXInXSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbnMnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBbJ2lkJywgJ2luaXQnXSxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IFsndGVzdCcsICdib2R5J10sXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFsnb2JqZWN0JywgJ2JvZHknXSxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J11cbiAgICB9O1xuXG4gICAgLy8gdW5pcXVlIGlkXG4gICAgQlJFQUsgPSB7fTtcbiAgICBTS0lQID0ge307XG4gICAgUkVNT1ZFID0ge307XG5cbiAgICBWaXNpdG9yT3B0aW9uID0ge1xuICAgICAgICBCcmVhazogQlJFQUssXG4gICAgICAgIFNraXA6IFNLSVAsXG4gICAgICAgIFJlbW92ZTogUkVNT1ZFXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShwYXJlbnQsIGtleSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShub2RlKSB7XG4gICAgICAgIHRoaXMucGFyZW50W3RoaXMua2V5XSA9IG5vZGU7XG4gICAgfTtcblxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNwbGljZSh0aGlzLmtleSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5vZGUsIHBhdGgsIHdyYXAsIHJlZikge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLndyYXAgPSB3cmFwO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250cm9sbGVyKCkgeyB9XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIHByb3BlcnR5IHBhdGggYXJyYXkgZnJvbSByb290IHRvIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICAgICAgICB2YXIgaSwgaXosIGosIGp6LCByZXN1bHQsIGVsZW1lbnQ7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkVG9QYXRoKHJlc3VsdCwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqeiA9IHBhdGgubGVuZ3RoOyBqIDwgano7ICsraikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5fX2N1cnJlbnQucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsLCBzZWNvbmQgbm9kZSBpcyByb290IGVsZW1lbnRcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDIsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fX2xlYXZlbGlzdFtpXTtcbiAgICAgICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIGVsZW1lbnQucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgdGhpcy5fX2N1cnJlbnQucGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gdHlwZSBvZiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlIHx8IHRoaXMuX19jdXJyZW50LndyYXA7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gYXJyYXkgb2YgcGFyZW50IGVsZW1lbnRzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uIHBhcmVudHMoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9fbGVhdmVsaXN0W2ldLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdXJyZW50Lm5vZGU7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9fZXhlY3V0ZSA9IGZ1bmN0aW9uIF9fZXhlY3V0ZShjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICB2YXIgcHJldmlvdXMsIHJlc3VsdDtcblxuICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcHJldmlvdXMgID0gdGhpcy5fX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZSwgdGhpcy5fX2xlYXZlbGlzdFt0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aCAtIDFdLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gcHJldmlvdXM7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIG5vdGlmeSBjb250cm9sIHNraXAgLyBicmVha1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeShmbGFnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IGZsYWc7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBza2lwIGNoaWxkIG5vZGVzIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KFNLSVApO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gYnJlYWsgdHJhdmVyc2Fsc1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlWydicmVhayddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShCUkVBSyk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZW1vdmUgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoUkVNT1ZFKTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19pbml0aWFsaXplID0gZnVuY3Rpb24ocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB0aGlzLnZpc2l0b3IgPSB2aXNpdG9yO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLl9fd29ya2xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fX2xlYXZlbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19mYWxsYmFjayA9IHZpc2l0b3IuZmFsbGJhY2sgPT09ICdpdGVyYXRpb24nO1xuICAgICAgICB0aGlzLl9fa2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgICAgICBpZiAodmlzaXRvci5rZXlzKSB7XG4gICAgICAgICAgICB0aGlzLl9fa2V5cyA9IGV4dGVuZChvYmplY3RDcmVhdGUodGhpcy5fX2tleXMpLCB2aXNpdG9yLmtleXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBub2RlLnR5cGUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvcGVydHkobm9kZVR5cGUsIGtleSkge1xuICAgICAgICByZXR1cm4gKG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbiB8fCBub2RlVHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4pICYmICdwcm9wZXJ0aWVzJyA9PT0ga2V5O1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgd29ya2xpc3QsXG4gICAgICAgICAgICBsZWF2ZWxpc3QsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGN1cnJlbnQyLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIHNlbnRpbmVsO1xuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBudWxsKSk7XG4gICAgICAgIGxlYXZlbGlzdC5wdXNoKG5ldyBFbGVtZW50KG51bGwsIG51bGwsIG51bGwsIG51bGwpKTtcblxuICAgICAgICB3aGlsZSAod29ya2xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gd29ya2xpc3QucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBzZW50aW5lbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBsZWF2ZWxpc3QucG9wKCk7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmxlYXZlLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCByZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFNLSVAgfHwgcmV0ID09PSBTS0lQKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgZWxlbWVudC53cmFwO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fa2V5c1tub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBvYmplY3RLZXlzKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZVR5cGUgKyAnLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVbY3VycmVudDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eShub2RlVHlwZSwgY2FuZGlkYXRlc1tjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlW2N1cnJlbnQyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW0oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG5leHRFbGVtLFxuICAgICAgICAgICAgICAgIHBhcmVudDtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVmLnJlbW92ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcmVmZXJlbmNlIGlzIGFuIGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAga2V5ID0gZWxlbWVudC5yZWYua2V5O1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQucmVmLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHJlbW92ZWQgZnJvbSBhcnJheSwgdGhlbiBkZWNyZWFzZSBmb2xsb3dpbmcgaXRlbXMnIGtleXMuXG4gICAgICAgICAgICAgICAgaSA9IHdvcmtsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRFbGVtID0gd29ya2xpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbS5yZWYgJiYgbmV4dEVsZW0ucmVmLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAgKG5leHRFbGVtLnJlZi5rZXkgPCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC0tbmV4dEVsZW0ucmVmLmtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlVHlwZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWwsXG4gICAgICAgICAgICBvdXRlcixcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZShyb290LCB2aXNpdG9yKTtcblxuICAgICAgICBzZW50aW5lbCA9IHt9O1xuXG4gICAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgICB3b3JrbGlzdCA9IHRoaXMuX193b3JrbGlzdDtcbiAgICAgICAgbGVhdmVsaXN0ID0gdGhpcy5fX2xlYXZlbGlzdDtcblxuICAgICAgICAvLyBpbml0aWFsaXplXG4gICAgICAgIG91dGVyID0ge1xuICAgICAgICAgICAgcm9vdDogcm9vdFxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQocm9vdCwgbnVsbCwgbnVsbCwgbmV3IFJlZmVyZW5jZShvdXRlciwgJ3Jvb3QnKSk7XG4gICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBudWxsLFxuICAgICAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBCUkVBSyAmJiB0YXJnZXQgIT09IFNLSVAgJiYgdGFyZ2V0ICE9PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gUkVNT1ZFIHx8IHRhcmdldCA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsZW0oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IuZW50ZXIsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAvLyBzbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgbnVsbCBpbiB0aGlzIHBsYWNlXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBCUkVBSyAmJiB0YXJnZXQgIT09IFNLSVAgJiYgdGFyZ2V0ICE9PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZWYucmVwbGFjZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gUkVNT1ZFIHx8IHRhcmdldCA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIG51bGxcbiAgICAgICAgICAgIG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29ya2xpc3QucHVzaChzZW50aW5lbCk7XG4gICAgICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCB0YXJnZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgZWxlbWVudC53cmFwO1xuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgIGlmICghY2FuZGlkYXRlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IG9iamVjdEtleXMobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZVR5cGUgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlW2N1cnJlbnQyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBuZXcgUmVmZXJlbmNlKG5vZGUsIGtleSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnJlcGxhY2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kQ29tbWVudFJhbmdlKGNvbW1lbnQsIHRva2Vucykge1xuICAgICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICAgIHRhcmdldCA9IHVwcGVyQm91bmQodG9rZW5zLCBmdW5jdGlvbiBzZWFyY2godG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5yYW5nZVswXSA+IGNvbW1lbnQucmFuZ2VbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFtjb21tZW50LnJhbmdlWzBdLCBjb21tZW50LnJhbmdlWzFdXTtcblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPSB0b2tlbnNbdGFyZ2V0XS5yYW5nZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCAtPSAxO1xuICAgICAgICBpZiAodGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoQ29tbWVudHModHJlZSwgcHJvdmlkZWRDb21tZW50cywgdG9rZW5zKSB7XG4gICAgICAgIC8vIEF0IGZpcnN0LCB3ZSBzaG91bGQgY2FsY3VsYXRlIGV4dGVuZGVkIGNvbW1lbnQgcmFuZ2VzLlxuICAgICAgICB2YXIgY29tbWVudHMgPSBbXSwgY29tbWVudCwgbGVuLCBpLCBjdXJzb3I7XG5cbiAgICAgICAgaWYgKCF0cmVlLnJhbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGFjaENvbW1lbnRzIG5lZWRzIHJhbmdlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2tlbnMgYXJyYXkgaXMgZW1wdHksIHdlIGF0dGFjaCBjb21tZW50cyB0byB0cmVlIGFzICdsZWFkaW5nQ29tbWVudHMnXG4gICAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFswLCB0cmVlLnJhbmdlWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29tbWVudHMucHVzaChleHRlbmRDb21tZW50UmFuZ2UoZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSksIHRva2VucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBiYXNlZCBvbiBKb2huIEZyZWVtYW4ncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID4gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID09PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA8IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA9PT0gY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuU3ludGF4ID0gU3ludGF4O1xuICAgIGV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbiAgICBleHBvcnRzLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGV4cG9ydHMuYXR0YWNoQ29tbWVudHMgPSBhdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlZpc2l0b3JLZXlzID0gVmlzaXRvcktleXM7XG4gICAgZXhwb3J0cy5WaXNpdG9yT3B0aW9uID0gVmlzaXRvck9wdGlvbjtcbiAgICBleHBvcnRzLkNvbnRyb2xsZXIgPSBDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuY2xvbmVFbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb25lKHt9KTsgfTtcblxuICAgIHJldHVybiBleHBvcnRzO1xufShleHBvcnRzKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcImVzdHJhdmVyc2VANC4xLjFcIixcbiAgICAgIFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC9zaGFkZWpzXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJlc3RyYXZlcnNlQDQuMS4xXCIsXG4gIFwiX2lkXCI6IFwiZXN0cmF2ZXJzZUA0LjEuMVwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL2VzdHJhdmVyc2VcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI0LjEuMVwiLFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcImVtYWlsXCI6IFwidXRhdGFuZS50ZWFAZ21haWwuY29tXCIsXG4gICAgXCJuYW1lXCI6IFwiY29uc3RlbGxhdGlvblwiXG4gIH0sXG4gIFwiX25wbVZlcnNpb25cIjogXCIyLjE0LjRcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcImVzdHJhdmVyc2VcIixcbiAgICBcInJhd1wiOiBcImVzdHJhdmVyc2VANC4xLjFcIixcbiAgICBcInJhd1NwZWNcIjogXCI0LjEuMVwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCI0LjEuMVwiLFxuICAgIFwidHlwZVwiOiBcInZlcnNpb25cIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIlxuICBdLFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VzdHJhdmVyc2UvLS9lc3RyYXZlcnNlLTQuMS4xLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCJmNmNhY2E3Mjg5MzNhODUwZWY5MDY2MWQwZTE3OTgyYmE0NzExMWEyXCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcImVzdHJhdmVyc2VANC4xLjFcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3NoYWRlanNcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzdHJhdmVyc2UvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge30sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQ01BU2NyaXB0IEpTIEFTVCB0cmF2ZXJzYWwgZnVuY3Rpb25zXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImNoYWlcIjogXCJeMi4xLjFcIixcbiAgICBcImNvZmZlZS1zY3JpcHRcIjogXCJeMS44LjBcIixcbiAgICBcImVzcHJlZVwiOiBcIl4xLjExLjBcIixcbiAgICBcImd1bHBcIjogXCJeMy44LjEwXCIsXG4gICAgXCJndWxwLWJ1bXBcIjogXCJeMC4yLjJcIixcbiAgICBcImd1bHAtZmlsdGVyXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJndWxwLWdpdFwiOiBcIl4xLjAuMVwiLFxuICAgIFwiZ3VscC10YWctdmVyc2lvblwiOiBcIl4xLjIuMVwiLFxuICAgIFwianNoaW50XCI6IFwiXjIuNS42XCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjEuMFwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge30sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCJmNmNhY2E3Mjg5MzNhODUwZWY5MDY2MWQwZTE3OTgyYmE0NzExMWEyXCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lc3RyYXZlcnNlLy0vZXN0cmF2ZXJzZS00LjEuMS50Z3pcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MC4xMC4wXCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiYmJjY2NiZmU5ODI5NjU4NWU0MzExYzg3NTVlMWQwMGRjZDU4MWUzY1wiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXN0cmF2ZXJzZVwiLFxuICBcImluc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwibGljZW5zZVwiOiBcIkJTRC0yLUNsYXVzZVwiLFxuICBcIm1haW5cIjogXCJlc3RyYXZlcnNlLmpzXCIsXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImNvbnN0ZWxsYXRpb25cIixcbiAgICAgIFwiZW1haWxcIjogXCJ1dGF0YW5lLnRlYUBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibWljaGFlbGZpY2FycmFcIixcbiAgICAgIFwiZW1haWxcIjogXCJucG1AbWljaGFlbC5maWNhcnJhLm1lXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIm56YWthc1wiLFxuICAgICAgXCJlbWFpbFwiOiBcIm5pY2hvbGFzQG5jemNvbnN1bHRpbmcuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwibmFtZVwiOiBcImVzdHJhdmVyc2VcIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS9lc3Rvb2xzL2VzdHJhdmVyc2UuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImxpbnRcIjogXCJqc2hpbnQgZXN0cmF2ZXJzZS5qc1wiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4tc2NyaXB0IGxpbnQgJiYgbnBtIHJ1bi1zY3JpcHQgdW5pdC10ZXN0XCIsXG4gICAgXCJ1bml0LXRlc3RcIjogXCJtb2NoYSAtLWNvbXBpbGVycyBjb2ZmZWU6Y29mZmVlLXNjcmlwdC9yZWdpc3RlclwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjQuMS4xXCJcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyAnQVMgSVMnXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnTmV3RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdPYmplY3RFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSXRlcmF0aW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnQ29udGludWVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnVGhyb3dTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnVHJ5U3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU291cmNlRWxlbWVudChub2RlKSB7XG4gICAgICByZXR1cm4gaXNTdGF0ZW1lbnQobm9kZSkgfHwgbm9kZSAhPSBudWxsICYmIG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWlsaW5nU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zZXF1ZW50O1xuXG4gICAgICAgIGNhc2UgJ0xhYmVsZWRTdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBjdXJyZW50O1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBub2RlLmNvbnNlcXVlbnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT0gbnVsbCkgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IHRyYWlsaW5nU3RhdGVtZW50KGN1cnJlbnQpO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRXhwcmVzc2lvbjogaXNFeHByZXNzaW9uLFxuICAgICAgICBpc1N0YXRlbWVudDogaXNTdGF0ZW1lbnQsXG4gICAgICAgIGlzSXRlcmF0aW9uU3RhdGVtZW50OiBpc0l0ZXJhdGlvblN0YXRlbWVudCxcbiAgICAgICAgaXNTb3VyY2VFbGVtZW50OiBpc1NvdXJjZUVsZW1lbnQsXG4gICAgICAgIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudDogaXNQcm9ibGVtYXRpY0lmU3RhdGVtZW50LFxuXG4gICAgICAgIHRyYWlsaW5nU3RhdGVtZW50OiB0cmFpbGluZ1N0YXRlbWVudFxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMy0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE0IEl2YW4gTmlrdWxpbiA8aWZhYWFuQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSZWdleCwgTk9OX0FTQ0lJX1dISVRFU1BBQ0VTO1xuXG4gICAgLy8gU2VlIGB0b29scy9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cbiAgICBSZWdleCA9IHtcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMFxcdTA4QTItXFx1MDhBQ1xcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdGXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzNcXHUwQzM1LVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkYwXFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFDXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OTdcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTgwLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMFxcdTA4QTItXFx1MDhBQ1xcdTA4RTQtXFx1MDhGRVxcdTA5MDAtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAxLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzNcXHUwQzM1LVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MlxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDJcXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGMFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFDXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFEMDAtXFx1MURFNlxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OTdcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3OTNcXHVBN0EwLVxcdUE3QUFcXHVBN0Y4LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0JcXHVBQTgwLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTI2XFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gNDggJiYgY2ggPD0gNTcpOyAgIC8vIDAuLjlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiBpc0RlY2ltYWxEaWdpdChjaCkgfHwgICAgLy8gMC4uOVxuICAgICAgICAgICAgKDk3IDw9IGNoICYmIGNoIDw9IDEwMikgfHwgIC8vIGEuLmZcbiAgICAgICAgICAgICg2NSA8PSBjaCAmJiBjaCA8PSA3MCk7ICAgICAvLyBBLi5GXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpOyAgIC8vIDAuLjdcbiAgICB9XG5cbiAgICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICAgIE5PTl9BU0NJSV9XSElURVNQQUNFUyA9IFtcbiAgICAgICAgMHgxNjgwLCAweDE4MEUsXG4gICAgICAgIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLFxuICAgICAgICAweDIwMkYsIDB4MjA1RixcbiAgICAgICAgMHgzMDAwLFxuICAgICAgICAweEZFRkZcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAgICAgICAgIChjaCA+PSAweDE2ODAgJiYgTk9OX0FTQ0lJX1dISVRFU1BBQ0VTLmluZGV4T2YoY2gpID49IDApO1xuICAgIH1cblxuICAgIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgICB9XG5cbiAgICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gOTcgJiYgY2ggPD0gMTIyKSB8fCAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA9PT0gMzYpIHx8IChjaCA9PT0gOTUpIHx8ICAgICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID09PSA5MikgfHwgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gOTcgJiYgY2ggPD0gMTIyKSB8fCAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSA0OCAmJiBjaCA8PSA1NykgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgICAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAgICAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIChjaCA9PT0gOTIpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNEZWNpbWFsRGlnaXQ6IGlzRGVjaW1hbERpZ2l0LFxuICAgICAgICBpc0hleERpZ2l0OiBpc0hleERpZ2l0LFxuICAgICAgICBpc09jdGFsRGlnaXQ6IGlzT2N0YWxEaWdpdCxcbiAgICAgICAgaXNXaGl0ZVNwYWNlOiBpc1doaXRlU3BhY2UsXG4gICAgICAgIGlzTGluZVRlcm1pbmF0b3I6IGlzTGluZVRlcm1pbmF0b3IsXG4gICAgICAgIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICAgICAgaXNJZGVudGlmaWVyUGFydDogaXNJZGVudGlmaWVyUGFydFxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY29kZSA9IHJlcXVpcmUoJy4vY29kZScpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgLy8geWllbGQgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGtleXdvcmQgdW5kZXIgbm9uLXN0cmljdCBtb2RlLlxuICAgICAgICBpZiAoIXN0cmljdCAmJiBpZCA9PT0gJ3lpZWxkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0tleXdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmRFUzYoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8IChpZCA9PT0gJ3RyeScpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZEVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ251bGwnIHx8IGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScgfHwgaXNLZXl3b3JkRVM1KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkRVM2KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnbnVsbCcgfHwgaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJyB8fCBpc0tleXdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZShpZCkge1xuICAgICAgICB2YXIgaSwgaXosIGNoO1xuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gaWQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKCFjb2RlLmlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBjaCA9PT0gOTIpIHsgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGlkLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gaWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICghY29kZS5pc0lkZW50aWZpZXJQYXJ0KGNoKSB8fCBjaCA9PT0gOTIpIHsgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllckVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWZpZXJOYW1lKGlkKSAmJiAhaXNSZXNlcnZlZFdvcmRFUzUoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyRVM2KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllck5hbWUoaWQpICYmICFpc1Jlc2VydmVkV29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNLZXl3b3JkRVM1OiBpc0tleXdvcmRFUzUsXG4gICAgICAgIGlzS2V5d29yZEVTNjogaXNLZXl3b3JkRVM2LFxuICAgICAgICBpc1Jlc2VydmVkV29yZEVTNTogaXNSZXNlcnZlZFdvcmRFUzUsXG4gICAgICAgIGlzUmVzZXJ2ZWRXb3JkRVM2OiBpc1Jlc2VydmVkV29yZEVTNixcbiAgICAgICAgaXNSZXN0cmljdGVkV29yZDogaXNSZXN0cmljdGVkV29yZCxcbiAgICAgICAgaXNJZGVudGlmaWVyTmFtZTogaXNJZGVudGlmaWVyTmFtZSxcbiAgICAgICAgaXNJZGVudGlmaWVyRVM1OiBpc0lkZW50aWZpZXJFUzUsXG4gICAgICAgIGlzSWRlbnRpZmllckVTNjogaXNJZGVudGlmaWVyRVM2XG4gICAgfTtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZXhwb3J0cy5hc3QgPSByZXF1aXJlKCcuL2FzdCcpO1xuICAgIGV4cG9ydHMuY29kZSA9IHJlcXVpcmUoJy4vY29kZScpO1xuICAgIGV4cG9ydHMua2V5d29yZCA9IHJlcXVpcmUoJy4va2V5d29yZCcpO1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjMuMFxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG4vLyBFTkQgSEVBREVSXG5cbmV4cG9ydHMuZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvY29tbW9uLmpzXCIpO1xuZXhwb3J0cy5tYXQyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDIuanNcIik7XG5leHBvcnRzLm1hdDJkID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDJkLmpzXCIpO1xuZXhwb3J0cy5tYXQzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDMuanNcIik7XG5leHBvcnRzLm1hdDQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0NC5qc1wiKTtcbmV4cG9ydHMucXVhdCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9xdWF0LmpzXCIpO1xuZXhwb3J0cy52ZWMyID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzIuanNcIik7XG5leHBvcnRzLnZlYzMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMy5qc1wiKTtcbmV4cG9ydHMudmVjNCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWM0LmpzXCIpOyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbi8qKlxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBuYW1lIGdsTWF0cml4XG4gKi9cbnZhciBnbE1hdHJpeCA9IHt9O1xuXG4vLyBDb25zdGFudHNcbmdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDAwMTtcbmdsTWF0cml4LkFSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5nbE1hdHJpeC5SQU5ET00gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIEdMTUFUX0FSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4qIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuKlxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xuKi9cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsTWF0cml4O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cbnZhciBtYXQyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhYSA9IGFbMF0sIGFiID0gYVsxXSwgYWMgPSBhWzJdLCBhZCA9IGFbM10sXG4gICAgICAgIGF0eCA9IGFbNF0sIGF0eSA9IGFbNV07XG5cbiAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgaWYoIWRldCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0MmQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0MmQubXVsID0gbWF0MmQubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMDtcbiAgICBvdXRbMV0gPSBhMTtcbiAgICBvdXRbMl0gPSBhMjtcbiAgICBvdXRbM10gPSBhMztcbiAgICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICAgIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IC1zO1xuICAgIG91dFszXSA9IGM7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IHZbMV07XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IHZbMF07XG4gICAgb3V0WzVdID0gdlsxXTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0MmQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDJkLmZyb2IgPSBmdW5jdGlvbiAoYSkgeyBcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIDEpKVxufTsgXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MmQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXG4gICAgICAgIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMCxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcbiAgICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgb3V0WzNdID0gYjExICogZGV0O1xuICAgIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gICAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXG4gICAgICAgIGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV0sXG4gICAgICAgIGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICAgIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcblxuICAgIG91dFszXSA9IGExMDtcbiAgICBvdXRbNF0gPSBhMTE7XG4gICAgb3V0WzVdID0gYTEyO1xuXG4gICAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gICAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICAgIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICAgIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gICAgb3V0WzZdID0gYTIwO1xuICAgIG91dFs3XSA9IGEyMTtcbiAgICBvdXRbOF0gPSBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gdlswXTtcbiAgICBvdXRbN10gPSB2WzFdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gLXM7XG4gICAgb3V0WzRdID0gYztcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHZbMV07XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MztcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG52YXIgbWF0NCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQ0LmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gdlsyXTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQ7XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcbiAgICBcbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG4gICAgXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjO1xuICAgIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICAgIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gICAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICAgIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICAgIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWFJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gMTtcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gLXM7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21ZUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAtcztcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHM7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVpSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IHM7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gLXM7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcykge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyLFxuICAgICAgICBzeCA9IHNbMF0sXG4gICAgICAgIHN5ID0gc1sxXSxcbiAgICAgICAgc3ogPSBzWzJdO1xuXG4gICAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gICAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gICAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICAgIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICAgIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4gPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICB4MiA9IHggKyB4LFxuICAgICAgeTIgPSB5ICsgeSxcbiAgICAgIHoyID0geiArIHosXG5cbiAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgeHkgPSB4ICogeTIsXG4gICAgICB4eiA9IHggKiB6MixcbiAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgeXogPSB5ICogejIsXG4gICAgICB6eiA9IHogKiB6MixcbiAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgd3kgPSB3ICogeTIsXG4gICAgICB3eiA9IHcgKiB6MixcbiAgICAgIFxuICAgICAgc3ggPSBzWzBdLFxuICAgICAgc3kgPSBzWzFdLFxuICAgICAgc3ogPSBzWzJdLFxuXG4gICAgICBveCA9IG9bMF0sXG4gICAgICBveSA9IG9bMV0sXG4gICAgICBveiA9IG9bMl07XG4gICAgICBcbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gICAgICAgIFxuICByZXR1cm4gb3V0O1xufTtcblxubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcgPSBmdW5jdGlvbiAob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG52YXIgbWF0MyA9IHJlcXVpcmUoXCIuL21hdDMuanNcIik7XG52YXIgdmVjMyA9IHJlcXVpcmUoXCIuL3ZlYzMuanNcIik7XG52YXIgdmVjNCA9IHJlcXVpcmUoXCIuL3ZlYzQuanNcIik7XG5cbi8qKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBuYW1lIHF1YXRcbiAqL1xudmFyIHF1YXQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZhciB4VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xuICAgIHZhciB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgICAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIGlmICh2ZWMzLmxlbmd0aCh0bXB2ZWMzKSA8IDAuMDAwMDAxKVxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgICAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgICAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgICAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICAgICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuXG4gICAgICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICAgICAgbWF0cls0XSA9IHVwWzFdO1xuICAgICAgICBtYXRyWzddID0gdXBbMl07XG5cbiAgICAgICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgICAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgICAgIG1hdHJbOF0gPSAtdmlld1syXTtcblxuICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBxdWF0LmZyb21NYXQzKG91dCwgbWF0cikpO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5xdWF0LnNldEF4aXNBbmdsZSA9IGZ1bmN0aW9uKG91dCwgYXhpcywgcmFkKSB7XG4gICAgcmFkID0gcmFkICogMC41O1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5hZGQgPSB2ZWM0LmFkZDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5tdWwgPSBxdWF0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICAgIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICAgIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jYWxjdWxhdGVXID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlcnAgPSB2ZWM0LmxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2xlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgLy8gYmVuY2htYXJrczpcbiAgICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgdmFyICAgICAgICBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAgIC8vIGNhbGMgY29zaW5lXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICAgIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICBieCA9IC0gYng7XG4gICAgICAgIGJ5ID0gLSBieTtcbiAgICAgICAgYnogPSAtIGJ6O1xuICAgICAgICBidyA9IC0gYnc7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcbiAgICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICB9IGVsc2UgeyAgICAgICAgXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2UgXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgc2NhbGUxID0gdDtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNxbGVycCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZW1wMSA9IHF1YXQuY3JlYXRlKCk7XG4gIHZhciB0ZW1wMiA9IHF1YXQuY3JlYXRlKCk7XG4gIFxuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICAgIHF1YXQuc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHF1YXQuc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHF1YXQuc2xlcnAob3V0LCB0ZW1wMSwgdGVtcDIsIDIgKiB0ICogKDEgLSB0KSk7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTMsXG4gICAgICAgIGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuICAgIFxuICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICAgIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3FyTGVuID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbU1hdDMgPSBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gICAgdmFyIGZSb290O1xuXG4gICAgaWYgKCBmVHJhY2UgPiAwLjAgKSB7XG4gICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgICAgICBvdXRbMF0gPSAobVs1XS1tWzddKSpmUm9vdDtcbiAgICAgICAgb3V0WzFdID0gKG1bNl0tbVsyXSkqZlJvb3Q7XG4gICAgICAgIG91dFsyXSA9IChtWzFdLW1bM10pKmZSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHx3fCA8PSAxLzJcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoIG1bNF0gPiBtWzBdIClcbiAgICAgICAgICBpID0gMTtcbiAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgICAgIGkgPSAyO1xuICAgICAgICB2YXIgaiA9IChpKzEpJTM7XG4gICAgICAgIHZhciBrID0gKGkrMiklMztcbiAgICAgICAgXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICAgICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgICAgIG91dFszXSA9IChtW2oqMytrXSAtIG1bayozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5xdWF0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdxdWF0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBxdWF0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjMlxuICovXG52YXIgdmVjMiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpdiA9IHZlYzIuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIG91dFswXSA9IG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMyO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5oZXJtaXRlID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxLFxuICAgICAgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0LFxuICAgICAgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSksXG4gICAgICBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmJlemllciA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdCxcbiAgICAgIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yVGltZXMyID0gdCAqIHQsXG4gICAgICBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3byxcbiAgICAgIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcixcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgICB3ID0gdyB8fCAxLjA7XG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICB2YXIgcCA9IFtdLCByPVtdO1xuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0ICBwWzBdID0gYVswXSAtIGJbMF07XG5cdCAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQgIC8vcGVyZm9ybSByb3RhdGlvblxuXHQgIHJbMF0gPSBwWzBdO1xuXHQgIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcblx0ICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cblx0ICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdCAgb3V0WzBdID0gclswXSArIGJbMF07XG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XG5cdCAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVZID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICBcdHJbMV0gPSBwWzFdO1xuICBcdHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVaID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICBcdHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzJdID0gcFsyXTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG52ZWMzLmFuZ2xlID0gZnVuY3Rpb24oYSwgYikge1xuICAgXG4gICAgdmFyIHRlbXBBID0gdmVjMy5mcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIHZhciB0ZW1wQiA9IHZlYzMuZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKTtcbiBcbiAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICAgIHZlYzMubm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG4gXG4gICAgdmFyIGNvc2luZSA9IHZlYzMuZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgfSAgICAgXG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMztcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xudmFyIHZlYzQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0Lm11bCA9IHZlYzQubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXYgPSB2ZWM0LmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXN0ID0gdmVjNC5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckRpc3QgPSB2ZWM0LnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWM0Lmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmxlbiA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyTGVuID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gLWFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IHggKiBsZW47XG4gICAgICAgIG91dFsxXSA9IHkgKiBsZW47XG4gICAgICAgIG91dFsyXSA9IHogKiBsZW47XG4gICAgICAgIG91dFszXSA9IHcgKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjNC5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXSxcbiAgICAgICAgYXcgPSBhWzNdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIC8vVE9ETzogVGhpcyBpcyBhIHByZXR0eSBhd2Z1bCB3YXkgb2YgZG9pbmcgdGhpcy4gRmluZCBzb21ldGhpbmcgYmV0dGVyLlxuICAgIG91dFswXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIG91dFsxXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIG91dFsyXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIG91dFszXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICAgIHZlYzQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB2ZWM0LnNjYWxlKG91dCwgb3V0LCBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICAgIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gICAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTsgdmVjWzNdID0gYVtpKzNdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTsgYVtpKzNdID0gdmVjWzNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjNC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjNCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjNDtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS43LjAgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIGxvZGFzaCA0LjAuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpLiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IGdsb2JhbC5BcnJheS5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBnbG9iYWwuT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGdsb2JhbC5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKGdsb2JhbCwgJ01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaGFzaCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIEhhc2goKSB7fVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIGhhc2hIYXMoaGFzaCwga2V5KSAmJiBkZWxldGUgaGFzaFtrZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGhhc2gsIGtleSkge1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGhhc2hba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChoYXNoLCBrZXkpID8gaGFzaFtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGhhc2hba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChoYXNoLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoaGFzaCwga2V5LCB2YWx1ZSkge1xuICBoYXNoW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSB2YWx1ZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7ICdoYXNoJzogbmV3IEhhc2gsICdtYXAnOiBNYXAgPyBuZXcgTWFwIDogW10sICdzdHJpbmcnOiBuZXcgSGFzaCB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChpc0tleWFibGUoa2V5KSkge1xuICAgIHJldHVybiBoYXNoRGVsZXRlKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBkYXRhLnN0cmluZyA6IGRhdGEuaGFzaCwga2V5KTtcbiAgfVxuICByZXR1cm4gTWFwID8gZGF0YS5tYXBbJ2RlbGV0ZSddKGtleSkgOiBhc3NvY0RlbGV0ZShkYXRhLm1hcCwga2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoaXNLZXlhYmxlKGtleSkpIHtcbiAgICByZXR1cm4gaGFzaEdldCh0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gZGF0YS5zdHJpbmcgOiBkYXRhLmhhc2gsIGtleSk7XG4gIH1cbiAgcmV0dXJuIE1hcCA/IGRhdGEubWFwLmdldChrZXkpIDogYXNzb2NHZXQoZGF0YS5tYXAsIGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChpc0tleWFibGUoa2V5KSkge1xuICAgIHJldHVybiBoYXNoSGFzKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBkYXRhLnN0cmluZyA6IGRhdGEuaGFzaCwga2V5KTtcbiAgfVxuICByZXR1cm4gTWFwID8gZGF0YS5tYXAuaGFzKGtleSkgOiBhc3NvY0hhcyhkYXRhLm1hcCwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoaXNLZXlhYmxlKGtleSkpIHtcbiAgICBoYXNoU2V0KHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBkYXRhLnN0cmluZyA6IGRhdGEuaGFzaCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoTWFwKSB7XG4gICAgZGF0YS5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGFzc29jU2V0KGRhdGEubWFwLCBrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgYXNzb2NpYXRpdmUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhc3NvY0RlbGV0ZShhcnJheSwga2V5KSB7XG4gIHZhciBpbmRleCA9IGFzc29jSW5kZXhPZihhcnJheSwga2V5KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGFycmF5LnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXNzb2NHZXQoYXJyYXksIGtleSkge1xuICB2YXIgaW5kZXggPSBhc3NvY0luZGV4T2YoYXJyYXksIGtleSk7XG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBhcnJheVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGFzc29jaWF0aXZlIGFycmF5IHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhc3NvY0hhcyhhcnJheSwga2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gKiBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGFzc29jaWF0aXZlIGFycmF5IGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NTZXQoYXJyYXksIGtleSwgdmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGFycmF5W2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgKHR5cGUgPT0gJ3N0cmluZycgJiYgdmFsdWUgIT09ICdfX3Byb3RvX18nKSB8fCB2YWx1ZSA9PSBudWxsO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycywgYW5kXG4gIC8vIFBoYW50b21KUyAxLjkgd2hpY2ggcmV0dXJucyAnZnVuY3Rpb24nIGZvciBgTm9kZUxpc3RgIGluc3RhbmNlcy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmdW5jVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgKGlzSG9zdE9iamVjdCh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yKS50ZXN0KHZhbHVlKTtcbn1cblxuLy8gQXZvaWQgaW5oZXJpdGluZyBmcm9tIGBPYmplY3QucHJvdG90eXBlYCB3aGVuIHBvc3NpYmxlLlxuSGFzaC5wcm90b3R5cGUgPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiBvYmplY3RQcm90bztcblxuLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcERlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsIi8qKlxuICogbG9kYXNoIDQuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJ2xvZGFzaC5fbWFwY2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBnbG9iYWwuQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2sodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IHZhbHVlc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7ICdhcnJheSc6IFtdLCAnbWFwJzogbnVsbCB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgYXJyYXkgPSBkYXRhLmFycmF5O1xuXG4gIHJldHVybiBhcnJheSA/IGFzc29jRGVsZXRlKGFycmF5LCBrZXkpIDogZGF0YS5tYXBbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBhcnJheSA9IGRhdGEuYXJyYXk7XG5cbiAgcmV0dXJuIGFycmF5ID8gYXNzb2NHZXQoYXJyYXksIGtleSkgOiBkYXRhLm1hcC5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBhcnJheSA9IGRhdGEuYXJyYXk7XG5cbiAgcmV0dXJuIGFycmF5ID8gYXNzb2NIYXMoYXJyYXksIGtleSkgOiBkYXRhLm1hcC5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgYXJyYXkgPSBkYXRhLmFycmF5O1xuXG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhcnJheS5sZW5ndGggPCAoTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBhc3NvY1NldChhcnJheSwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuYXJyYXkgPSBudWxsO1xuICAgICAgZGF0YS5tYXAgPSBuZXcgTWFwQ2FjaGUoYXJyYXkpO1xuICAgIH1cbiAgfVxuICB2YXIgbWFwID0gZGF0YS5tYXA7XG4gIGlmIChtYXApIHtcbiAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBhc3NvY2lhdGl2ZSBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jRGVsZXRlKGFycmF5LCBrZXkpIHtcbiAgdmFyIGluZGV4ID0gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgYXJyYXkucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBhc3NvY2lhdGl2ZSBhcnJheSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBhc3NvY0dldChhcnJheSwga2V5KSB7XG4gIHZhciBpbmRleCA9IGFzc29jSW5kZXhPZihhcnJheSwga2V5KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGFycmF5W2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gYXNzb2NpYXRpdmUgYXJyYXkgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSGFzKGFycmF5LCBrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAqIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICovXG5mdW5jdGlvbiBhc3NvY1NldChhcnJheSwga2V5LCB2YWx1ZSkge1xuICB2YXIgaW5kZXggPSBhc3NvY0luZGV4T2YoYXJyYXksIGtleSk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXlbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgU3RhY2tgIGNhY2hlLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKlxuICogbG9kYXNoIDQuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBrZXlzID0gcmVxdWlyZSgnbG9kYXNoLmtleXMnKSxcbiAgICByZXN0ID0gcmVxdWlyZSgnbG9kYXNoLnJlc3QnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGg7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IGdsb2JhbC5PYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoKCFlcShvYmpWYWx1ZSwgdmFsdWUpIHx8XG4gICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0V2l0aChzb3VyY2UsIHByb3BzLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29weU9iamVjdGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGZ1bmN0aW9uIHRvXG4gKiBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdFdpdGgoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogc291cmNlW2tleV07XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIHJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IChsZW5ndGgtLSwgY3VzdG9taXplcikgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJlxuICAgICEodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgaXNGdW5jdGlvbih2YWx1ZSkpICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMsIGFuZFxuICAvLyBQaGFudG9tSlMgMS45IHdoaWNoIHJldHVybnMgJ2Z1bmN0aW9uJyBmb3IgYE5vZGVMaXN0YCBpbnN0YW5jZXMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxvb3NlbHkgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb25cbiAqIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmUgPSA1O1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuZCA9IDQ7XG4gKiBCYXIucHJvdG90eXBlLmYgPSA2O1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMywgJ2UnOiA1IH1cbiAqL1xudmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCIvKipcbiAqIGxvZGFzaCA0LjAuMiAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgU3RhY2sgPSByZXF1aXJlKCdsb2Rhc2guX3N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnbG9kYXNoLl9hcnJheWVhY2gnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlZm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKS4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9XG5jbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID1cbmNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9XG5jbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPSBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzZXRUYWddID0gY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IGdsb2JhbC5PYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZ2xvYmFsLkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXksXG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShnbG9iYWwsICdNYXAnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUoZ2xvYmFsLCAnU2V0Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzIGFuZCBzZXRzLiAqL1xudmFyIG1hcEN0b3JTdHJpbmcgPSBNYXAgPyBmdW5jVG9TdHJpbmcuY2FsbChNYXApIDogJycsXG4gICAgc2V0Q3RvclN0cmluZyA9IFNldCA/IGZ1bmNUb1N0cmluZy5jYWxsKFNldCkgOiAnJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBTeW1ib2wgPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoKCFlcShvYmpWYWx1ZSwgdmFsdWUpIHx8XG4gICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIGlmIChpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lT2JqZWN0KGlzRnVuYyA/IHt9IDogdmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcbiAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gaXNBcnIgPyByZXN1bHQgOiBjb3B5U3ltYm9scyh2YWx1ZSwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgfHwge307XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyKSB7XG4gIHZhciBDdG9yID0gYnVmZmVyLmNvbnN0cnVjdG9yLFxuICAgICAgcmVzdWx0ID0gbmV3IEN0b3IoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cbiAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXApIHtcbiAgdmFyIEN0b3IgPSBtYXAuY29uc3RydWN0b3I7XG4gIHJldHVybiBhcnJheVJlZHVjZShtYXBUb0FycmF5KG1hcCksIGFkZE1hcEVudHJ5LCBuZXcgQ3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIEN0b3IgPSByZWdleHAuY29uc3RydWN0b3IsXG4gICAgICByZXN1bHQgPSBuZXcgQ3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG5cbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQpIHtcbiAgdmFyIEN0b3IgPSBzZXQuY29uc3RydWN0b3I7XG4gIHJldHVybiBhcnJheVJlZHVjZShzZXRUb0FycmF5KHNldCksIGFkZFNldEVudHJ5LCBuZXcgQ3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBTeW1ib2wgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gdHlwZWRBcnJheS5idWZmZXIsXG4gICAgICBDdG9yID0gdHlwZWRBcnJheS5jb25zdHJ1Y3RvcjtcblxuICByZXR1cm4gbmV3IEN0b3IoaXNEZWVwID8gY2xvbmVCdWZmZXIoYnVmZmVyKSA6IGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0V2l0aChzb3VyY2UsIHByb3BzLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29weU9iamVjdGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGZ1bmN0aW9uIHRvXG4gKiBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdFdpdGgoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogc291cmNlW2tleV07XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2wgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzIHx8IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vLyBGYWxsYmFjayBmb3IgSUUgMTEgcHJvdmlkaW5nIGB0b1N0cmluZ1RhZ2AgdmFsdWVzIGZvciBtYXBzIGFuZCBzZXRzLlxuaWYgKChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHwgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IG51bGwsXG4gICAgICAgIGN0b3JTdHJpbmcgPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nID8gZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBpZiAoY3RvclN0cmluZyA9PSBtYXBDdG9yU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBUYWc7XG4gICAgICB9XG4gICAgICBpZiAoY3RvclN0cmluZyA9PSBzZXRDdG9yU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZXRUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICByZXR1cm4gYmFzZUNyZWF0ZShpc0Z1bmN0aW9uKEN0b3IpID8gQ3Rvci5wcm90b3R5cGUgOiB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLCBhbmRcbiAgLy8gUGhhbnRvbUpTIDEuOSB3aGljaCByZXR1cm5zICdmdW5jdGlvbicgZm9yIGBOb2RlTGlzdGAgaW5zdGFuY2VzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZ1bmNUb1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAoaXNIb3N0T2JqZWN0KHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3IpLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBsb2Rhc2ggNC4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpID8gK3ZhbHVlIDogLTE7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGg7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IGdsb2JhbC5PYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgLy8gQXZvaWQgYSBidWcgaW4gSUUgMTAtMTEgd2hlcmUgb2JqZWN0cyB3aXRoIGEgW1tQcm90b3R5cGVdXSBvZiBgbnVsbGAsXG4gIC8vIHRoYXQgYXJlIGNvbXBvc2VkIGVudGlyZWx5IG9mIGluZGV4IHByb3BlcnRpZXMsIHJldHVybiBgZmFsc2VgIGZvclxuICAvLyBgaGFzT3duUHJvcGVydHlgIGNoZWNrcyBvZiB0aGVtLlxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgfHxcbiAgICAodHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJiBrZXkgaW4gb2JqZWN0ICYmIGdldFByb3RvdHlwZU9mKG9iamVjdCkgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3Qgc2tpcCB0aGUgY29uc3RydWN0b3JcbiAqIHByb3BlcnR5IG9mIHByb3RvdHlwZXMgb3IgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICByZXR1cm4gbmF0aXZlS2V5cyhPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAqL1xudmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBpbmRleCBrZXlzIGZvciBgb2JqZWN0YCB2YWx1ZXMgb2YgYXJyYXlzLFxuICogYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIHN0cmluZ3MsIG90aGVyd2lzZSBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheXxudWxsfSBSZXR1cm5zIGluZGV4IGtleXMsIGVsc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBpbmRleEtleXMob2JqZWN0KSB7XG4gIHZhciBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogdW5kZWZpbmVkO1xuICByZXR1cm4gKGlzTGVuZ3RoKGxlbmd0aCkgJiYgKGlzQXJyYXkob2JqZWN0KSB8fCBpc1N0cmluZyhvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpKVxuICAgID8gYmFzZVRpbWVzKGxlbmd0aCwgU3RyaW5nKVxuICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBpbmNvcnJlY3RseSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJlxuICAgICEodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgaXNGdW5jdGlvbih2YWx1ZSkpICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUgRnVuY3Rpb25cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycywgYW5kXG4gIC8vIFBoYW50b21KUyAxLjkgd2hpY2ggcmV0dXJucyAnZnVuY3Rpb24nIGZvciBgTm9kZUxpc3RgIGluc3RhbmNlcy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbG9vc2VseSBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpO1xuICBpZiAoIShpc1Byb3RvIHx8IGlzQXJyYXlMaWtlKG9iamVjdCkpKSB7XG4gICAgcmV0dXJuIGJhc2VLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIGluZGV4ZXMgPSBpbmRleEtleXMob2JqZWN0KSxcbiAgICAgIHNraXBJbmRleGVzID0gISFpbmRleGVzLFxuICAgICAgcmVzdWx0ID0gaW5kZXhlcyB8fCBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChiYXNlSGFzKG9iamVjdCwga2V5KSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSAmJlxuICAgICAgICAhKGlzUHJvdG8gJiYga2V5ID09ICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCIvKipcbiAqIGxvZGFzaCA0LjAuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgZ2xvYmFsYC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3MgPyBhcmdzLmxlbmd0aCA6IDA7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBnbG9iYWwuT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzIGFuIGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAqIH0pO1xuICpcbiAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHRvSW50ZWdlcihzdGFydCksIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcnJheSk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJyYXkpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFycmF5KTtcbiAgICB9XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgaW5kZXggPSAtMTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLCBhbmRcbiAgLy8gUGhhbnRvbUpTIDEuOSB3aGljaCByZXR1cm5zICdmdW5jdGlvbicgZm9yIGBOb2RlTGlzdGAgaW5zdGFuY2VzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsb29zZWx5IGJhc2VkIG9uIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMnKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICB2YXIgcmVtYWluZGVyID0gdmFsdWUgJSAxO1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gKHJlbWFpbmRlciA/IHZhbHVlIC0gcmVtYWluZGVyIDogdmFsdWUpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMnKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IGlzRnVuY3Rpb24odmFsdWUudmFsdWVPZikgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gICAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICAgKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gICAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc2V0ID0ge307XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gICAqL1xuICBBcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIGlzRHVwbGljYXRlID0gdGhpcy5oYXMoYVN0cik7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgfVxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXSA9IGlkeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgICBpZiAodGhpcy5oYXMoYVN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gICAqXG4gICAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbiAgLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4gIC8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuICAvLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbiAgLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuICAvLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbiAgLy9cbiAgLy8gICBDb250aW51YXRpb25cbiAgLy8gICB8ICAgIFNpZ25cbiAgLy8gICB8ICAgIHxcbiAgLy8gICBWICAgIFZcbiAgLy8gICAxMDEwMTFcblxuICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbiAgLy8gYmluYXJ5OiAwMTExMTFcbiAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gICAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gICAqL1xuICBmdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICByZXR1cm4gYVZhbHVlIDwgMFxuICAgICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICAgKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICAgIHJldHVybiBpc05lZ2F0aXZlXG4gICAgICA/IC1zaGlmdGVkXG4gICAgICA6IHNoaWZ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgICBkbyB7XG4gICAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgICAgfVxuICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICAgIHJldHVybiBlbmNvZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAgICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFPdXRQYXJhbSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcbiAgICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChpID49IHN0ckxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICB9XG4gICAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQXQoaSsrKSk7XG4gICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICAgIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgICBhT3V0UGFyYW0ucmVzdCA9IGFTdHIuc2xpY2UoaSk7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgY2hhclRvSW50TWFwID0ge307XG4gIHZhciBpbnRUb0NoYXJNYXAgPSB7fTtcblxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgICAuc3BsaXQoJycpXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGNoLCBpbmRleCkge1xuICAgICAgY2hhclRvSW50TWFwW2NoXSA9IGluZGV4O1xuICAgICAgaW50VG9DaGFyTWFwW2luZGV4XSA9IGNoO1xuICAgIH0pO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGFOdW1iZXIpIHtcbiAgICBpZiAoYU51bWJlciBpbiBpbnRUb0NoYXJNYXApIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbYU51bWJlcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgYU51bWJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IHRvIGFuIGludGVnZXIuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NF9kZWNvZGUoYUNoYXIpIHtcbiAgICBpZiAoYUNoYXIgaW4gY2hhclRvSW50TWFwKSB7XG4gICAgICByZXR1cm4gY2hhclRvSW50TWFwW2FDaGFyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhIHZhbGlkIGJhc2UgNjQgZGlnaXQ6IFwiICsgYUNoYXIpO1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIC8vXG4gICAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAgIC8vICAgICAgdGhlIG5leHQgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgbGVzcyB0aGFuIHRoYXQgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHdoaWNoIGlzIGxlc3MgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZVxuICAgIC8vICAgICAgcmV0dXJuIC0xLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgLy8gYUhheXN0YWNrW21pZF0gaXMgZ3JlYXRlciB0aGFuIG91ciBuZWVkbGUuXG4gICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gV2UgZGlkIG5vdCBmaW5kIGFuIGV4YWN0IG1hdGNoLCByZXR1cm4gdGhlIG5leHQgY2xvc2VzdCBvbmVcbiAgICAgIC8vICh0ZXJtaW5hdGlvbiBjYXNlIDIpLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBsZXNzIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMikgb3IgKDMpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAgICogdGhlIGluZGV4IG9mIG5leHQgbG93ZXN0IHZhbHVlIGNoZWNrZWQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzXG4gICAqIGJlY2F1c2UgbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGVcbiAgICogcG9pbnRzLCBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3NcbiAgICoganVzdCBtZWFucyB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gICAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAgICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAgICovXG4gIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKVxuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICAgKiBwb3NpdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gICAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gICAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG4gIH1cblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICAgKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAgICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAgICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAgICpcbiAgICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICAgIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAgICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAgICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gICAqIGNvcHkuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICB9O1xuXG4gIGV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuXG4gIC8qKlxuICAgKiBBIFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gICAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICAgKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAgICogICAgIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICBzb3VyY2VzID0gc291cmNlcy5tYXAodXRpbC5ub3JtYWxpemUpO1xuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgICAgc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpXG4gICAgICAgIC5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIpIHtcbiAgICAgIHZhciBjID0gYVN0ci5jaGFyQXQoMCk7XG4gICAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgc3RyID0gYVN0cjtcbiAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIuY2hhckF0KDApID09PSAnLCcpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcblxuICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHByZXZpb3VzU291cmNlICsgdGVtcC52YWx1ZSk7XG4gICAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHRoaXMuX25hbWVzLmF0KHByZXZpb3VzTmFtZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICAgKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yKSB7XG4gICAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gICAqIGluY2x1c2l2ZS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgdGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBuYW1lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGlibGUuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAqIGFuZCBsaW5lIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIEluZmluaXR5LCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3RcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBJbmZpbml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbmVlZGxlLm9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbLS1pbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcHBpbmdzLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZVxuICAgICAgICB9O1xuICAgICAgfSkuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICAgKlxuICAgKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gICAqICAgICAgdG9rZW4uXG4gICAqXG4gICAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICAgKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAgIC8vIENhc2UgMS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7JztcbiAgICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbiAgdmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuICAvLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbiAgdmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4gIC8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2ZcbiAgLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3NcbiAgLy8gdmVyc2lvbnMhXG4gIHZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4gIC8qKlxuICAgKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gICAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICAgKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAgICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gICAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAgICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gICAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICAgKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gICAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICAgIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gICAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICAgIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAgICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAgICovXG4gIFNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICAgIHZhciBuZXdMaW5lID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gXCJcIjtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLmpvaW4oXCJcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoYUNodW5rKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgdmFyIG5ld0NoaWxkcmVuO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICB9XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICAgKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAgICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICAgKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gICAqIG1hcC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgIGNvZGU6IFwiXCIsXG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG4gIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gICAqIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICAgKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gICAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gICAgfVxuICB9XG4gIGV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG4gIHZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xuICB2YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbiAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgICBwYXRoOiBtYXRjaFs1XVxuICAgIH07XG4gIH1cbiAgZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG4gIGZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgICB2YXIgdXJsID0gJyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gICAgfVxuICAgIHVybCArPSAnLy8nO1xuICAgIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gICAqXG4gICAqIC0gUmVwbGFjZXMgY29uc2VxdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAgICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAgICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gICAqXG4gICAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICAgIHZhciBwYXRoID0gYVBhdGg7XG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSB1cmwucGF0aDtcbiAgICB9XG4gICAgdmFyIGlzQWJzb2x1dGUgPSAocGF0aC5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gICAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgICB1cCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgIHVwLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgdXJsLnBhdGggPSBwYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4gIC8qKlxuICAgKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICAgKlxuICAgKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICAgKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAgICogICBmaXJzdC5cbiAgICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gICAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICAgKiAgIGlzIHJldHVybmVkLlxuICAgKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gICAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAgICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG4gICAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgICBhUGF0aCA9IFwiLlwiO1xuICAgIH1cbiAgICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgICB9XG5cbiAgICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICAgIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgICB9XG5cbiAgICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICA/IGFQYXRoXG4gICAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgfVxuICAgIHJldHVybiBqb2luZWQ7XG4gIH1cbiAgZXhwb3J0cy5qb2luID0gam9pbjtcblxuICAvKipcbiAgICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG5cbiAgICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgICAvLyBYWFg6IEl0IGlzIHBvc3NpYmxlIHRvIHJlbW92ZSB0aGlzIGJsb2NrLCBhbmQgdGhlIHRlc3RzIHN0aWxsIHBhc3MhXG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09IFwiL1wiICYmIHVybCAmJiB1cmwucGF0aCA9PSBcIi9cIikge1xuICAgICAgcmV0dXJuIGFQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMFxuICAgICAgPyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSlcbiAgICAgIDogYVBhdGg7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgIHZhciBzMiA9IGFTdHIyIHx8IFwiXCI7XG4gICAgcmV0dXJuIChzMSA+IHMyKSAtIChzMSA8IHMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcDtcblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmVcbiAgICogY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM7XG5cbn0pO1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHdhbGtlcjtcblxuZnVuY3Rpb24gd2Fsa2VyKGFzdE5vZGUsIGZ1bmN0aW9uVGFibGUsIG9mZnNldCkge1xuXHRmdW5jdGlvbiBzdG9wKCkgeyB0aHJvdyBzdG9wOyB9XG5cdHZhciByZWN1cnNlID0gZnVuY3Rpb24gKGFzdE5vZGUpIHtcblx0XHRpZiAoIWFzdE5vZGUgfHwgdHlwZW9mIGFzdE5vZGUgIT09ICdvYmplY3QnIHx8ICFhc3ROb2RlLnR5cGUpXG5cdFx0XHRyZXR1cm4gYXN0Tm9kZTtcblx0XHQvLyByYW5nZSBiYXNlZCByZWN1cnNpb246IG9ubHkgcmVjdXJzZSB3aGVuIHRoZSBhc3ROb2RlIGlzIGluIHJhbmdlXG5cdFx0aWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIGFzdE5vZGUucmFuZ2UgJiZcblx0XHQgICAgKGFzdE5vZGUucmFuZ2VbMF0gPiBvZmZzZXQgfHwgYXN0Tm9kZS5yYW5nZVsxXSA8IG9mZnNldCkpXG5cdFx0XHRyZXR1cm4gYXN0Tm9kZTtcblx0XHRcblx0XHR2YXIgZm4gPSBmdW5jdGlvblRhYmxlW2FzdE5vZGUudHlwZV0gfHwgZnVuY3Rpb25UYWJsZS5kZWZhdWx0IHx8IGNoZWNrUHJvcHM7XG5cdFx0cmV0dXJuIGZuLmNhbGwoYXN0Tm9kZSwgcmVjdXJzZSwgc3RvcCk7XG5cdH1cblx0dmFyIHJldDtcblx0dHJ5IHtcblx0XHRyZXQgPSByZWN1cnNlKGFzdE5vZGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKGUgIT09IHN0b3ApXG5cdFx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcHMocmVjdXJzZSkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciBtYXBwZWQgPSB7fTtcblx0T2JqZWN0LmtleXMoc2VsZikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHByb3AgPSBzZWxmW2tleV07XG5cdFx0dmFyIHJldCA9IHByb3A7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcCkpXG5cdFx0XHRyZXQgPSBwcm9wLm1hcChyZWN1cnNlKTtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSByZWN1cnNlKHByb3ApO1xuXHRcdG1hcHBlZFtrZXldID0gcmV0O1xuXHR9KTtcblx0cmV0dXJuIG1hcHBlZDtcbn1cblxud2Fsa2VyLmNoZWNrUHJvcHMgPSBjaGVja1Byb3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTY29wZSA9IHJlcXVpcmUoXCIuLi91dGlscy9zY29wZVwiKTtcbnZhciBhbm5vdGF0ZSA9IHJlcXVpcmUoXCIuLi91dGlscy9hbm5vdGF0ZVwiKTtcbnZhciB0b2phdmFTY3JpcHQgPSByZXF1aXJlKFwiLi4vdXRpbHMvdG9famF2YXNjcmlwdFwiKTtcbnZhciBpbmZlcmVuY2UgPSByZXF1aXJlKFwiLi90eXBlaW5mZXJlbmNlL3R5cGVpbmZlcmVuY2VcIik7XG52YXIgVHlwZXMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlc1wiKS5UWVBFUztcbnZhciBzdGF0aWNUcmFuc2Zvcm1lciA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy9zdGF0aWNUcmFuc2Zvcm1lclwiKTtcbnZhciBkZXRlcm1pbmVSZXR1cm5UeXBlID0gcmVxdWlyZShcIi4vZGV0ZXJtaW5lX3JldHVybl90eXBlXCIpO1xudmFyIGluc2VydEJ1ZmZlckFjY2Vzc29ycyA9IHJlcXVpcmUoXCIuL2luc2VydF9idWZmZXJfYWNjZXNzb3JzXCIpO1xudmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uL3R5cGUtc3lzdGVtL3R5cGVpbmZvXCIpO1xudmFyIGVzcHJpbWEgPSByZXF1aXJlKFwiZXNwcmltYVwiKTtcblxuZnVuY3Rpb24gQW5hbHl6ZXIoY29udGV4dCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xufVxuXG5BbmFseXplci5wcm90b3R5cGUuaW5qZWN0TWFpbkZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGluamVjdFBhcmFtZXRlcnMpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRleHQuZ2V0U2NvcGUoKS5kZWNsYXJlcyhuYW1lKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgLy8gRmlyc3QgcGFyYW1ldGVyIGlzIHNldCBhcyBnbG9iYWwgX2VudiBvYmplY3QgdG8gYmUgYWNjZXNzaWJsZSBmb3JtIEJSREZzXG4gICAgLy8gVGhpcyBpcyBhIGJpZyBoYWNrLCBuZWVkIGJldHRlciBpbmplY3Rpb24gbWVjaGFuaXNtXG4gICAgaWYgKGluamVjdFBhcmFtZXRlcnNbMF0gJiYgaW5qZWN0UGFyYW1ldGVyc1swXS5leHRyYSkge1xuICAgICAgICB2YXIgZW52QW5ub3RhdGlvbiA9IG5ldyBUeXBlSW5mbyhpbmplY3RQYXJhbWV0ZXJzWzBdLmV4dHJhKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5nZXRTY29wZSgpLmRlY2xhcmUoXCJfZW52XCIpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmdldFNjb3BlKCkudXBkYXRlVHlwZUluZm8oXCJfZW52XCIsIGVudkFubm90YXRpb24pO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGluamVjdFBhcmFtZXRlcnNbMF0uZXh0cmEucHJvcGVydGllcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdmFyIGFjY2Vzc29ycyA9IHByb3BlcnRpZXNbcHJvcGVydHldLmFjY2Vzc29ycztcbiAgICAgICAgICAgIHZhciBraW5kID0gcHJvcGVydGllc1twcm9wZXJ0eV0ua2luZDtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXNzb3JzLmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByb3BlcnR5ICsgXCJfZ2V0XCI7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuZ2V0U2NvcGUoKS5kZWNsYXJlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jb250ZXh0LmdldFNjb3BlKCkudXBkYXRlVHlwZUluZm8obmFtZSwgbmV3IFR5cGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSBlc3ByaW1hLnBhcnNlKGFjY2Vzc29ycy5nZXQpLmJvZHlbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29wZWROYW1lID0gc2VsZi5fY29udGV4dC5nZXRTY29wZSgpLmdldElkZW50aWZpZXIobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlTmFtZSA9IHNjb3BlZE5hbWUucmVwbGFjZSgvXFwuL2csICdfJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5pZC5uYW1lID0gc2FmZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuYWRkU3BlY2lhbGl6ZWRGdW5jdGlvbihuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3Q6IGFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcIlZlYzNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TmFtZTogc2VsZi5fY29udGV4dC5nZXRTYWZlVW5pcXVlTmFtZShzYWZlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc29ycy5nZXQgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbmFtZSA9IHByb3BlcnR5ICsgXCJfZ2V0XCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYuX2NvbnRleHQuZ2V0U2NvcGUoKS5kZWNsYXJlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxmLl9jb250ZXh0LmdldFNjb3BlKCkudXBkYXRlVHlwZUluZm8obmFtZSwgbmV3IFR5cGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAvLyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBhc3QgPSBlc3ByaW1hLnBhcnNlKGFjY2Vzc29ycy5nZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxmLl9jb250ZXh0LmFkZEZ1bmN0aW9uVGVtcGxhdGUoc2VsZi5fY29udGV4dC5nZXRTY29wZSgpLmdldElkZW50aWZpZXIobmFtZSksIGFzdC5ib2R5WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi5zcGVjaWFsaXplRnVuY3Rpb24obmFtZSwgW25ldyBUeXBlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHR5cGU6IFwiZmxvYXRcIlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gfSksIGtpbmQgPT09IFwiVGV4dHVyZVwiID8gbmV3IFR5cGVJbmZvKHt0eXBlOiBcIm9iamVjdFwiLCBraW5kOiBcIlZlYzJcIn0pIDogbmV3IFR5cGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHR5cGU6IFwiaW50XCJcbiAgICAgICAgICAgICAgICAgICAgLy8gfSldKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzb3JzLmdldCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhY2Nlc3NvcnMuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcGVydHkgKyBcIl9zZXRcIjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY29udGV4dC5nZXRTY29wZSgpLmRlY2xhcmUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuZ2V0U2NvcGUoKS51cGRhdGVUeXBlSW5mbyhuYW1lLCBuZXcgVHlwZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IGVzcHJpbWEucGFyc2UoYWNjZXNzb3JzLnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuYWRkRnVuY3Rpb25UZW1wbGF0ZShzZWxmLl9jb250ZXh0LmdldFNjb3BlKCkuZ2V0SWRlbnRpZmllcihuYW1lKSwgYXN0LmJvZHlbMF0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNwZWNpYWxpemVGdW5jdGlvbihuYW1lLCBbbmV3IFR5cGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmbG9hdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSwgbmV3IFR5cGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50XCJcbiAgICAgICAgICAgICAgICAgICAgfSksIG5ldyBUeXBlSW5mbyhwcm9wZXJ0aWVzW3Byb3BlcnR5XS5lbGVtZW50cy5leHRyYSldKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3JzLnNldCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250ZXh0LnJvb3QuZ2xvYmFsUGFyYW1ldGVyc1tuYW1lXSA9IGluamVjdFBhcmFtZXRlcnM7XG4gICAgdGhpcy5zcGVjaWFsaXplRnVuY3Rpb24obmFtZSwgaW5qZWN0UGFyYW1ldGVycy5tYXAoZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVJbmZvKHBhcmFtZXRlci5leHRyYSlcbiAgICB9KSwgbmFtZSk7XG59O1xuXG5BbmFseXplci5wcm90b3R5cGUuc3BlY2lhbGl6ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtZXRlcnMsIHVuaXF1ZU5hbWUpIHtcbiAgICB2YXIgc2NvcGVkSWRlbnRpZmllciA9IHRoaXMuX2NvbnRleHQuZ2V0U2NvcGUoKS5nZXRJZGVudGlmaWVyKG5hbWUpO1xuICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLmNyZWF0ZVNpZ25hdHVyZShzY29wZWRJZGVudGlmaWVyLCBwYXJhbWV0ZXJzKTtcblxuICAgIGlmICh0aGlzLl9jb250ZXh0Lmhhc1NwZWNpYWxpemVkRnVuY3Rpb24oc2lnbmF0dXJlKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0U3BlY2lhbGl6ZWRGdW5jdGlvbihzaWduYXR1cmUpLmluZm87XG5cbiAgICBpZiAodGhpcy5fY29udGV4dC5oYXNGdW5jdGlvblRlbXBsYXRlKHNjb3BlZElkZW50aWZpZXIpKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuX2NvbnRleHQuZ2V0RnVuY3Rpb25UZW1wbGF0ZShzY29wZWRJZGVudGlmaWVyKTtcbiAgICAgICAgdmFyIGdsb2JhbFVuaXF1ZU5hbWUgPSB1bmlxdWVOYW1lIHx8IHRoaXMuX2NvbnRleHQuZ2V0U2FmZVVuaXF1ZU5hbWUoc2NvcGVkSWRlbnRpZmllci5yZXBsYWNlKC9cXC4vZywgJ18nKSk7XG4gICAgICAgIHZhciBzcGVjaWFsaXplZEZ1bmN0aW9uID0ge307XG4gICAgICAgIHZhciB0ZW1wbGF0ZUNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlKSk7XG4gICAgICAgIHNwZWNpYWxpemVkRnVuY3Rpb24uYXN0ID0gdGhpcy5hbmFseXplRnVuY3Rpb24odGVtcGxhdGVDb3B5LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgc3BlY2lhbGl6ZWRGdW5jdGlvbi5pbmZvID0gc3BlY2lhbGl6ZWRGdW5jdGlvbi5hc3QuZXh0cmEucmV0dXJuSW5mbztcbiAgICAgICAgc3BlY2lhbGl6ZWRGdW5jdGlvbi5pbmZvLm5ld05hbWUgPSBzcGVjaWFsaXplZEZ1bmN0aW9uLmFzdC5pZC5uYW1lID0gZ2xvYmFsVW5pcXVlTmFtZTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hZGRTcGVjaWFsaXplZEZ1bmN0aW9uKHNpZ25hdHVyZSwgc3BlY2lhbGl6ZWRGdW5jdGlvbik7XG4gICAgICAgIHJldHVybiBzcGVjaWFsaXplZEZ1bmN0aW9uLmluZm87XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZnVuY3Rpb24gXCIgKyBuYW1lKTtcbn07XG5cbkFuYWx5emVyLnByb3RvdHlwZS5jcmVhdGVTaWduYXR1cmUgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnMucmVkdWNlKGZ1bmN0aW9uKHNpZ25hdHVyZSwgcGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmUgKyBwYXJhbWV0ZXIuZ2V0VHlwZVN0cmluZygpO1xuICAgIH0sIGZ1bmN0aW9uTmFtZSk7XG59O1xuXG5BbmFseXplci5wcm90b3R5cGUuYW5hbHl6ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmN0aW9uQXN0LCBwYXJhbWV0ZXJUeXBlSW5mb3MpIHtcbiAgICB2YXIgZnVuY3Rpb25TY29wZVxuICAgICAgICA9IG5ldyBTY29wZShmdW5jdGlvbkFzdCwgdGhpcy5fY29udGV4dC5nZXRTY29wZSgpLCB7bmFtZTogZnVuY3Rpb25Bc3QuaWQubmFtZX0pO1xuICAgIHZhciBmdW5jdGlvbkFubm90YXRpb24gPSBhbm5vdGF0ZShmdW5jdGlvbkFzdCk7XG5cbiAgICBmdW5jdGlvbkFzdC5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1ldGVyLCBpZHgpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0ZShwYXJhbWV0ZXIpO1xuICAgICAgICBpZiAoaWR4IDwgcGFyYW1ldGVyVHlwZUluZm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbi5jb3B5RnJvbShwYXJhbWV0ZXJUeXBlSW5mb3NbaWR4XSk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uLnNldER5bmFtaWNWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5ub3RhdGlvbi5zZXRUeXBlKFR5cGVzLlVOREVGSU5FRCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uU2NvcGUuZGVjbGFyZVBhcmFtZXRlcnMoZnVuY3Rpb25Bc3QucGFyYW1zKTtcblxuICAgIHRoaXMuX2NvbnRleHQucHVzaFNjb3BlKGZ1bmN0aW9uU2NvcGUpO1xuXG4gICAgZnVuY3Rpb25Bc3QuYm9keSA9IHRoaXMuYW5hbHl6ZUFzdChmdW5jdGlvbkFzdC5ib2R5KTtcbiAgICBmdW5jdGlvbkFzdC5wYXJhbXMgPSBmdW5jdGlvbkFzdC5wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRlKHBhcmFtKTtcbiAgICAgICAgcmV0dXJuICFhbm5vdGF0aW9uLmlzVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbkFubm90YXRpb24uc2V0UmV0dXJuSW5mbyhkZXRlcm1pbmVSZXR1cm5UeXBlKGZ1bmN0aW9uQXN0LmJvZHkpKTtcbiAgICB0aGlzLl9jb250ZXh0LnBvcFNjb3BlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb25Bc3Q7XG59O1xuXG5BbmFseXplci5wcm90b3R5cGUuYW5hbHl6ZUFzdCA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICBhc3QgPSBpbmZlcmVuY2UuaW5mZXIoYXN0LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9vcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIFJlbW92ZS9SZXBsYWNlIGRlYWQgY29kZSBhbmQgc3RhdGljIGV4cHJlc3Npb25zXG4gICAgYXN0ID0gc3RhdGljVHJhbnNmb3JtZXIudHJhbnNmb3JtKGFzdCwgdGhpcy5fb3B0aW9ucyk7XG4gICAgLy9mdW5jdGlvbkFTdC5ib2R5ID0gZXh0cmFjdENhcHR1cmVkVmFyaWFibGVzKGZ1bmN0aW9uQVN0LmJvZHksIHRoaXMuX2NvbnRleHQsIHRoaXMuX29wdGlvbnMpO1xuXG4gICAgLy8gYXN0ID0gdGhpcy5fb3B0aW9ucy5leHRyYWN0VW5pZm9ybUV4cHJlc3Npb25zID8gdW5pZm9ybUFuYWx5c2lzLmV4dHJhY3QoYXN0LCB0aGlzLl9vcHRpb25zKSA6IGFzdDtcblxuICAgIC8vZm5Bc3ROb2RlLmJvZHkgPSBvcHRpb25zLnNlbWFudGljQW5hbHlzaXMgPyBzZW1hbnRpY3MoZm5Bc3ROb2RlLmJvZHksIG9wdGlvbnMpIDogZm5Bc3ROb2RlLmJvZHk7XG4gICAgYXN0ID0gaW5zZXJ0QnVmZmVyQWNjZXNzb3JzKHRoaXMuX2NvbnRleHQsIGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbn07XG5cbkFuYWx5emVyLnByb3RvdHlwZS5pbmplY3RNZW1vcnkgPSBmdW5jdGlvbiAoYXN0LCBtZW1vcnkpIHtcbiAgICB2YXIgbWVtQW5ub3RhdGlvbiA9IG5ldyBUeXBlSW5mbyhtZW1vcnkuZXh0cmEpO1xuICAgIHRoaXMuX2NvbnRleHQuZ2V0U2NvcGUoKS5kZWNsYXJlKFwiX19tZW1cIik7XG4gICAgdGhpcy5fY29udGV4dC5nZXRTY29wZSgpLnVwZGF0ZVR5cGVJbmZvKFwiX19tZW1cIiwgbWVtQW5ub3RhdGlvbik7XG4gICAgdGhpcy5fY29udGV4dC5yb290Lmdsb2JhbFBhcmFtZXRlcnNbXCJfX21lbVwiXSA9IG1lbW9yeTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gbWVtb3J5LmV4dHJhLnByb3BlcnRpZXM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBhY2Nlc3NvcnMgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5XS5hY2Nlc3NvcnM7XG4gICAgICAgIGlmIChhY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NvcnMuZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wZXJ0eSArIFwiX2dldFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuZ2V0U2NvcGUoKS5kZWNsYXJlKG5hbWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuZ2V0U2NvcGUoKS51cGRhdGVUeXBlSW5mbyhuYW1lLCBuZXcgVHlwZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIGFzdCA9IGVzcHJpbWEucGFyc2UoYWNjZXNzb3JzLmdldCkuYm9keVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGVkTmFtZSA9IHNlbGYuX2NvbnRleHQuZ2V0U2NvcGUoKS5nZXRJZGVudGlmaWVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBzYWZlTmFtZSA9IHNjb3BlZE5hbWUucmVwbGFjZSgvXFwuL2csICdfJyk7XG4gICAgICAgICAgICAgICAgYXN0LmlkLm5hbWUgPSBzYWZlTmFtZTtcbiAgICAgICAgICAgICAgICBzZWxmLl9jb250ZXh0LmFkZFNwZWNpYWxpemVkRnVuY3Rpb24obmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBhc3Q6IGFzdCxcbiAgICAgICAgICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiVmVjM1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TmFtZTogc2VsZi5fY29udGV4dC5nZXRTYWZlVW5pcXVlTmFtZShzYWZlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjY2Vzc29ycy5nZXQgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY2Vzc29ycy5zZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByb3BlcnR5ICsgXCJfc2V0XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5fY29udGV4dC5nZXRTY29wZSgpLmRlY2xhcmUobmFtZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY29udGV4dC5nZXRTY29wZSgpLnVwZGF0ZVR5cGVJbmZvKG5hbWUsIG5ldyBUeXBlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB2YXIgYXN0ID0gZXNwcmltYS5wYXJzZShhY2Nlc3NvcnMuc2V0KS5ib2R5WzBdO1xuICAgICAgICAgICAgICAgIHZhciBzY29wZWROYW1lID0gc2VsZi5fY29udGV4dC5nZXRTY29wZSgpLmdldElkZW50aWZpZXIobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVOYW1lID0gc2NvcGVkTmFtZS5yZXBsYWNlKC9cXC4vZywgJ18nKTtcbiAgICAgICAgICAgICAgICBhc3QuaWQubmFtZSA9IHNhZmVOYW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRleHQuYWRkU3BlY2lhbGl6ZWRGdW5jdGlvbihuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJWZWMzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOYW1lOiBzZWxmLl9jb250ZXh0LmdldFNhZmVVbmlxdWVOYW1lKHNhZmVOYW1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWNjZXNzb3JzLnNldCA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgYXN0LmJvZHkgPSBhc3QuYm9keS5tYXAoZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiICYmIGFzdC5pZC5uYW1lID09PSBcImV2YWx1YXRlXCIpIHtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvblNjb3BlXG4gICAgICAgICAgICAgICAgPSBuZXcgU2NvcGUoYXN0LCBzZWxmLl9jb250ZXh0LmdldFNjb3BlKCksIHtuYW1lOiBhc3QuaWQubmFtZX0pO1xuICAgICAgICAgICAgc2VsZi5fY29udGV4dC5wdXNoU2NvcGUoZnVuY3Rpb25TY29wZSk7XG4gICAgICAgICAgICBhc3QucGFyYW1zW2FzdC5wYXJhbXMubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIl9fbWVtXCIsXG4gICAgICAgICAgICAgICAgZXh0cmE6IG1lbW9yeS5leHRyYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzdC5ib2R5ID0gc2VsZi5hbmFseXplQXN0KGFzdC5ib2R5KTtcbiAgICAgICAgICAgIC8vIGFzdC5ib2R5ID0gaW5zZXJ0QnVmZmVyQWNjZXNzb3JzKHNlbGYuX2NvbnRleHQsIGFzdC5ib2R5KTtcbiAgICAgICAgICAgIHNlbGYuX2NvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRSZXN1bHQoKTtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEFuYWx5emVyO1xuXG4iLCIoZnVuY3Rpb24obnMpe1xuXG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXgsXG4gICAgICAgIGFubm90YXRlID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpLmFubm90YXRlO1xuICAgICAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xuXG5cbiAgICB2YXIgVW5hcnlGdW5jdGlvbnMgPSB7XG4gICAgICAgIFwiIVwiOiBmdW5jdGlvbihhKSB7IHJldHVybiAhYTsgfSxcbiAgICAgICAgXCItXCI6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIC1hOyB9LFxuICAgICAgICBcIitcIjogZnVuY3Rpb24oYSkgeyByZXR1cm4gK2E7IH0sXG4gICAgICAgIFwidHlwZW9mXCI6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHR5cGVvZiBhOyB9LFxuICAgICAgICBcInZvaWRcIjogZnVuY3Rpb24oYSkgeyByZXR1cm4gdm9pZCBhOyB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihhKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICB9O1xuXG4gICAgdmFyIEJpbmFyeUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgXCIrXCIgOiBmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEgKyBiOyB9LFxuICAgICAgICBcIi1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAtIGI7IH0sXG4gICAgICAgIFwiL1wiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhIC8gYjsgfSxcbiAgICAgICAgXCIqXCIgOiBmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEgKiBiOyB9LFxuICAgICAgICBcIiVcIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAlIGI7IH0sXG5cbiAgICAgICAgXCI9PVwiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhID09IGI7IH0sXG4gICAgICAgIFwiIT1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAhPSBiOyB9LFxuICAgICAgICBcIj09PVwiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhID09PSBiOyB9LFxuICAgICAgICBcIiE9PVwiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhICE9PSBiOyB9LFxuICAgICAgICBcIjxcIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA8IGI7IH0sXG4gICAgICAgIFwiPD1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA8PSBiOyB9LFxuICAgICAgICBcIj5cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA+IGI7IH0sXG4gICAgICAgIFwiPj1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA+PSBiOyB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvbnN0YW50VmFsdWUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5yYXcgIT09IHVuZGVmaW5lZCA/IG5vZGUucmF3IDogbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBudW1iZXIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4obnVtYmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVsbFwiOiByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiB8fCBub2RlLnR5cGUgPT0gU3ludGF4LkNhbGxFeHByZXNzaW9uICB8fCBub2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgfHwgbm9kZS50eXBlID09IFN5bnRheC5OZXdFeHByZXNzaW9uIHx8IG5vZGUudHlwZSA9PSBTeW50YXguTG9naWNhbEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhbm5vdGF0ZShub2RlKS5nZXRDb25zdGFudFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LlVuYXJ5RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0ZShub2RlKS5nZXRUeXBlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihVbmFyeUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShub2RlLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeUZ1bmN0aW9uc1tub2RlLm9wZXJhdG9yXShnZXRDb25zdGFudFZhbHVlKG5vZGUuYXJndW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJVbmtub3duIHVuYXJ5IG9wZXJhdG9yOiBcIiArIG5vZGUub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZihCaW5hcnlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobm9kZS5vcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmluYXJ5RnVuY3Rpb25zW25vZGUub3BlcmF0b3JdKGdldENvbnN0YW50VmFsdWUobm9kZS5sZWZ0KSwgZ2V0Q29uc3RhbnRWYWx1ZShub2RlLnJpZ2h0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiVW5rbm93biBiaW5hcnkgb3BlcmF0b3I6IFwiICsgbm9kZS5vcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkV2YWx1YXRpbmcgc3RhdGljIHZhbHVlIGZvciBub2RlIHR5cGU6IFwiICsgbm9kZS50eXBlKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBnZXRDb25zdGFudFRydXRoVmFsdWUobm9kZSkge1xuICAgICAgICB2YXIgYU5vZGUgPSBhbm5vdGF0ZShub2RlKTtcblxuICAgICAgICAvLyAhIXVuZGVmaW5lZCA9PSBmYWxzZTtcbiAgICAgICAgaWYgKGFOb2RlLmlzTnVsbE9yVW5kZWZpbmVkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vICEhe30gPT0gdHJ1ZVxuICAgICAgICBpZiAoYU5vZGUuaXNPYmplY3QoKSB8fCB0aGlzLmlzRnVuY3Rpb24oKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMsIGl0IGRlcGVuZHMgb24gdGhlIHZhbHVlLFxuICAgICAgICAvLyB0aHVzIHdlIGNhbiBvbmx5IGV2YWx1YXRlIHRoaXMgZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICAgIGlmIChhTm9kZS5oYXNDb25zdGFudFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWFOb2RlLmdldENvbnN0YW50VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGV4cG9ydHMuZ2V0Q29uc3RhbnRWYWx1ZSA9IGdldENvbnN0YW50VmFsdWU7XG4gICAgZXhwb3J0cy5nZXRDb25zdGFudFRydXRoVmFsdWUgPSBnZXRDb25zdGFudFRydXRoVmFsdWU7XG5cblxuXG59KGV4cG9ydHMpKTtcbiIsIihmdW5jdGlvbiAobnMpIHtcblxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9jb21tb24uanNcIiksXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcbiAgICAgICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcblxuICAgIC8vIHZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XG5cbiAgICB2YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheCxcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcbiAgICAgICAgQU5OTyA9IGNvbW1vbi5BTk5PO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gQVNUOiBFbGltaW5hdGUgYnJhbmNoZXMgZHVlIHRvIHN0YXRpYyBjb25kaXRpb25zXG4gICAgICogYW5kIHBlcmZvcm1zIGNvbnN0YW50IGZvbGRpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXN0XG4gICAgICogQHJldHVybnMgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHRyYW5zZm9ybSA9IG5zLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhc3QsIG9wdCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIob3B0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybShhc3QpO1xuICAgIH1cblxuICAgIHZhciBUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdGhpcy5mb2xkQ29uc3RhbnRzID0gb3B0LmZvbGRDb25zdGFudHMgIT09IHVuZGVmaW5lZCA/IG9wdC5mb2xkQ29uc3RhbnRzIDogdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgZXN0cmF2ZXJzZS5Db250cm9sbGVyKCk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyLnJlcGxhY2UoYXN0LCB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0gQU5OTyhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlSW5mby5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5JZlN0YXRlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVJZlN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVMb2dpY2FsRXhwcmVzc2lvbihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmhhbmRsZUFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmhhbmRsZVZhcmlhYmxlRGVjbGFyYXRvcihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk5ld0V4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVOZXdFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZih0aGF0LmZvbGRDb25zdGFudHMgJiYgaXNFeHByZXNzaW9uKG5vZGUudHlwZSwgcGFyZW50LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5mb2xkQ29uc3RhbnRFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICBoYW5kbGVJZlN0YXRlbWVudDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gQU5OTyhub2RlLnRlc3QpO1xuXG4gICAgICAgICAgICBpZiAodGVzdC5oYXNDb25zdGFudFZhbHVlKCkgfHwgdGVzdC5jYW5PYmplY3QoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5za2lwKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRpY1ZhbHVlID0gdGVzdC5nZXRTdGF0aWNUcnV0aFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1ZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0obm9kZS5jb25zZXF1ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShub2RlLmFsdGVybmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FbXB0eVN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgaGFuZGxlQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSBBTk5PKG5vZGUudGVzdCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXN0Lmhhc0NvbnN0YW50VmFsdWUoKSB8fCB0ZXN0LmNhbk9iamVjdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLnNraXAoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGljVmFsdWUgPSB0ZXN0LmdldFN0YXRpY1RydXRoVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlTG9naWNhbEV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IEFOTk8obm9kZS5sZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IEFOTk8obm9kZS5yaWdodCk7XG4gICAgICAgICAgICB2YXIgbGVmdEJvb2wgPSBsZWZ0LmdldFN0YXRpY1RydXRoVmFsdWUoKTtcbiAgICAgICAgICAgIHZhciByaWdodEJvb2wgPSByaWdodC5nZXRTdGF0aWNUcnV0aFZhbHVlKCk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcInx8XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdEJvb2wgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdEJvb2wgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVmdCBpcyBkeW5hbWljLCBsZXQncyBjaGVjayByaWdodFxuICAgICAgICAgICAgICAgIGlmIChyaWdodEJvb2wgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBcIiYmXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdEJvb2wgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZWZ0Qm9vbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVmdCBpcyBkeW5hbWljLCBsZXQncyBjaGVjayByaWdodFxuICAgICAgICAgICAgICAgIGlmIChyaWdodEJvb2wgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHRoZSByZXN1bHQgdHlwZSBpcyBhbHdheXMgdGhlIG9uZSBvZiB0aGUgbGVmdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRCb29sID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhlIHJlc3VsdCBtdXN0IGJlIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogeyB0eXBlOiBcImJvb2xlYW5cIn1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5mb2xkQ29uc3RhbnRFeHByZXNzaW9uKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZU5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzLCBuZXdBcmdzID0gW107XG4gICAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IEFOTk8oYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTaW1wbGVTdGF0aWModHlwZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZ3MucHVzaChnZW5lcmF0ZUxpdGVyYWxGcm9tVHlwZUluZm8odHlwZUluZm8pKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBuZXdBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBub2RlLmRlY2xhcmF0aW9ucywgbmV3RGVjbGFyYXRpb25zID0gW10sIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0gQU5OTyhkZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlSW5mby5pc1VuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghbmV3RGVjbGFyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FbXB0eVN0YXRlbWVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb25zID0gbmV3RGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZVZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmluaXQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmluaXQgPSB0aGlzLmZvbGRDb25zdGFudEV4cHJlc3Npb24obm9kZS5pbml0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9sZENvbnN0YW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBhbm5vID0gQU5OTyhub2RlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGRDb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTaW1wbGVTdGF0aWMoYW5ubykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlTGl0ZXJhbEZyb21UeXBlSW5mbyhhbm5vKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljT2JqZWN0KGFubm8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUNvbnN0cnVjdG9yRnJvbVR5cGVJbmZvKGFubm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1NpbXBsZVN0YXRpYyh0eXBlSW5mbykge1xuICAgICAgICByZXR1cm4gdHlwZUluZm8uaGFzQ29uc3RhbnRWYWx1ZSgpICYmICEodHlwZUluZm8uaXNPYmplY3QoKSB8fCB0eXBlSW5mby5pc051bGxPclVuZGVmaW5lZCgpKTtcbiAgICB9XG5cbiAgICAgZnVuY3Rpb24gaXNTdGF0aWNPYmplY3QodHlwZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVJbmZvLmhhc0NvbnN0YW50VmFsdWUoKSAmJiB0eXBlSW5mby5pc1ZlY3RvcigpO1xuICAgIH1cblxuICAgIHZhciBjX2V4cHJlc3Npb25zID0gW1N5bnRheC5CaW5hcnlFeHByZXNzaW9uLCBTeW50YXguVW5hcnlFeHByZXNzaW9uLCBTeW50YXguTWVtYmVyRXhwcmVzc2lvbl07XG4gICAgdmFyIGNfcGFyZW50TGl0ZXJhbEV4cHJlc3Npb25zID0gW1N5bnRheC5CaW5hcnlFeHByZXNzaW9uLCBTeW50YXguUmV0dXJuU3RhdGVtZW50LCBTeW50YXguQ2FsbEV4cHJlc3Npb25dO1xuXG5cbiAgICBmdW5jdGlvbiBpc0V4cHJlc3Npb24odHlwZSwgcGFyZW50VHlwZSkge1xuICAgICAgICBpZih0eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGNfcGFyZW50TGl0ZXJhbEV4cHJlc3Npb25zLmluZGV4T2YocGFyZW50VHlwZSkgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjX2V4cHJlc3Npb25zLmluZGV4T2YodHlwZSkgIT09IC0xO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvckZyb21UeXBlSW5mbyh0eXBlSW5mbykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlSW5mby5nZXRDb25zdGFudFZhbHVlKCksIHNpemUsIG5hbWUsIGFyZ3VtZW50cyA9IFtdO1xuICAgICAgICBzd2l0Y2godHlwZUluZm8uZ2V0S2luZCgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiVmVjMlwiOiBzaXplID0gMjsgbmFtZSA9IFwiVmVjMlwiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWZWMzXCI6IHNpemUgPSAzOyBuYW1lID0gXCJWZWMzXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlZlYzRcIjogc2l6ZSA9IDQ7IG5hbWUgPSBcIlZlYzRcIjsgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yIGluIHN0YXRpYyB0cmFuc2Zvcm1hdGlvbi4gVW5rbm93biBraW5kOiBcIiArIHR5cGVJbmZvLmdldEtpbmQoKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50cy5wdXNoKGdlbmVyYXRlRmxvYXRMaXRlcmFsRnJvbVZhbHVlKHZhbHVlLmRhdGFbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcbiAgICAgICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1xuICAgICAgICB9XG4gICAgICAgIEFOTk8ocmVzdWx0KS5jb3B5RnJvbSh0eXBlSW5mbyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVGbG9hdExpdGVyYWxGcm9tVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFyIG5lZWRzU2lnbiA9IHZhbHVlIDwgMDtcblxuICAgICAgICB2YXIgbGl0ZXJhbCA9IHsgdHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiBuZWVkc1NpZ24gPyAtdmFsdWUgOiB2YWx1ZSB9O1xuICAgICAgICBBTk5PKGxpdGVyYWwpLnNldFR5cGUoU2hhZGUuVFlQRVMuTlVNQkVSKTtcblxuICAgICAgICBpZiAoIW5lZWRzU2lnbilcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuXG4gICAgICAgIHZhciBleHByZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5VbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiLVwiLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBsaXRlcmFsXG4gICAgICAgIH1cbiAgICAgICAgQU5OTyhleHByZXNzaW9uKS5zZXRUeXBlKFNoYWRlLlRZUEVTLk5VTUJFUik7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTGl0ZXJhbEZyb21UeXBlSW5mbyh0eXBlSW5mbykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlSW5mby5nZXRDb25zdGFudFZhbHVlKCk7XG4gICAgICAgIHZhciBpc05lZ2F0aXZlID0gdmFsdWUgPCAwO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBpc05lZ2F0aXZlID8gLXZhbHVlIDogdmFsdWVcbiAgICAgICAgfTtcblx0XHR2YXIgdGkgPSBBTk5PKHJlc3VsdCk7XG5cdFx0dGkuY29weUZyb20odHlwZUluZm8pO1xuXG4gICAgICAgIGlmKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHRyYS5jb25zdGFudFZhbHVlID0gLXZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5VbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiLVwiLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiByZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpID0gQU5OTyhyZXN1bHQpO1xuXHRcdFx0dGkuY29weUZyb20odHlwZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG5cblxuXG5cblxuXG5cblxufShleHBvcnRzKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcblxudmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi4vYmFzZS9jb250ZXh0LmpzXCIpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi9iYXNlL2NvbW1vbi5qc1wiKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG52YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKTtcblxuLy8gU2hvcnRjdXRzXG52YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcbnZhciBhbm5vdGF0ZSA9IHJlcXVpcmUoXCIuLi91dGlscy9cIikuYW5ub3RhdGU7XG5cbmZ1bmN0aW9uIEFuYWx5c2lzQ29udGV4dChwcm9ncmFtLCBvcHRpb25zKSB7XG5cdENvbnRleHQuY2FsbCh0aGlzLCBwcm9ncmFtLCBvcHRpb25zKTtcblxuXHRhc3NlcnQuZXF1YWwocHJvZ3JhbS50eXBlLCBTeW50YXguUHJvZ3JhbSk7XG5cblx0dGhpcy5yb290Lmdsb2JhbFBhcmFtZXRlcnMgPSB7fTtcblx0dGhpcy5fZnVuY3Rpb25UZW1wbGF0ZXMgPSBuZXcgTWFwKCk7XG5cdHRoaXMuX3NwZWNpYWxpemVkRnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuXHR0aGlzLmNvbnN0YW50cyA9IG51bGw7XG59XG5cbnV0aWwuaW5oZXJpdHMoQW5hbHlzaXNDb250ZXh0LCBDb250ZXh0KTtcblxuQW5hbHlzaXNDb250ZXh0LnByb3RvdHlwZS5nZXRGdW5jdGlvblRlbXBsYXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0cmV0dXJuIHRoaXMuX2Z1bmN0aW9uVGVtcGxhdGVzLmdldChuYW1lKTtcbn07XG5cbkFuYWx5c2lzQ29udGV4dC5wcm90b3R5cGUuYWRkRnVuY3Rpb25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XG5cdHRoaXMuX2Z1bmN0aW9uVGVtcGxhdGVzLnNldChuYW1lLCBub2RlKTtcbn07XG5cbkFuYWx5c2lzQ29udGV4dC5wcm90b3R5cGUuaGFzRnVuY3Rpb25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHJldHVybiB0aGlzLl9mdW5jdGlvblRlbXBsYXRlcy5oYXMobmFtZSk7XG59O1xuXG5BbmFseXNpc0NvbnRleHQucHJvdG90eXBlLmdldFNwZWNpYWxpemVkRnVuY3Rpb24gPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG5cdHJldHVybiB0aGlzLl9zcGVjaWFsaXplZEZ1bmN0aW9ucy5nZXQoc2lnbmF0dXJlKTtcbn07XG5cbkFuYWx5c2lzQ29udGV4dC5wcm90b3R5cGUuYWRkU3BlY2lhbGl6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uIChzaWduYXR1cmUsIHNwZWNpYWxpemVkRnVuY3Rpb24pIHtcblx0dGhpcy5fc3BlY2lhbGl6ZWRGdW5jdGlvbnMuc2V0KHNpZ25hdHVyZSwgc3BlY2lhbGl6ZWRGdW5jdGlvbik7XG59O1xuXG5BbmFseXNpc0NvbnRleHQucHJvdG90eXBlLmhhc1NwZWNpYWxpemVkRnVuY3Rpb24gPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG5cdHJldHVybiB0aGlzLl9zcGVjaWFsaXplZEZ1bmN0aW9ucy5oYXMoc2lnbmF0dXJlKTtcbn07XG5cbkFuYWx5c2lzQ29udGV4dC5wcm90b3R5cGUuZ2V0VHlwZUluZm8gPSBmdW5jdGlvbihub2RlKSB7XG5cdHJldHVybiBjb21tb24uZ2V0VHlwZUluZm8obm9kZSwgdGhpcy5nZXRTY29wZSgpLCB0aGlzLmNvbnN0YW50cywgdHJ1ZSk7XG59O1xuXG5BbmFseXNpc0NvbnRleHQucHJvdG90eXBlLnNldENvbnN0YW50cyA9IGZ1bmN0aW9uKGMpIHtcblx0dGhpcy5jb25zdGFudHMgPSBjO1xufTtcblxuQW5hbHlzaXNDb250ZXh0LnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcblx0Ly8gKFJlLSlhZGQgZGVyaXZlZCBmdW5jdGlvbiB0byB0aGUgcHJvZ3JhbVxuXHRhZGREZXJpdmVkTWV0aG9kcyh0aGlzLnJvb3QsIHRoaXMpO1xuXHRyZXR1cm4gdGhpcy5yb290O1xufTtcblxuQW5hbHlzaXNDb250ZXh0LnByb3RvdHlwZS5kZWNsYXJlID0gZnVuY3Rpb24oYXN0LCBpbkRlY2xhcmF0aW9uKSB7XG5cdHZhciBzY29wZSA9IHRoaXMuZ2V0U2NvcGUoKSwgY29udGV4dCA9IHRoaXM7XG5cdGlmIChhc3QudHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuXHRcdHZhciBkZWNsYXJhdGlvbnMgPSBhc3QuZGVjbGFyYXRpb25zO1xuXHRcdGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlY2xhcmF0aW9uKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gYW5ub3RhdGUoZGVjbGFyYXRpb24pO1xuXG5cdFx0XHRpZiAoZGVjbGFyYXRpb24uaWQudHlwZSAhPSBTeW50YXguSWRlbnRpZmllcikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIHZhcmlhYmxlIG5hbWVzIGFyZSBub3QgeWV0IHN1cHBvcnRlZFwiKTtcblx0XHRcdH1cblx0XHRcdHZhciB2YXJpYWJsZU5hbWUgPSBkZWNsYXJhdGlvbi5pZC5uYW1lO1xuXHRcdFx0c2NvcGUuZGVjbGFyZSh2YXJpYWJsZU5hbWUsIHRydWUsIGRlY2xhcmF0aW9uKTtcblxuXHRcdFx0aWYgKGRlY2xhcmF0aW9uLmluaXQpIHtcblx0XHRcdFx0dmFyIGluaXQgPSBhbm5vdGF0ZShkZWNsYXJhdGlvbi5pbml0KTtcblx0XHRcdFx0c2NvcGUudXBkYXRlVHlwZUluZm8odmFyaWFibGVOYW1lLCBpbml0LCBkZWNsYXJhdGlvbik7XG5cdFx0XHRcdGlmIChkZWNsYXJhdGlvbi5pbml0LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5kZWNsYXJlKGRlY2xhcmF0aW9uLmluaXQsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQuc2V0VHlwZShTaGFkZS5UWVBFUy5VTkRFRklORUQpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdH0gZWxzZSBpZiAoYXN0LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIGluRGVjbGFyYXRpb24pIHtcblx0XHR2YXIgdHlwZUluZm8gPSBhbm5vdGF0ZShhc3QucmlnaHQpO1xuXG5cdFx0aWYgKGFzdC5sZWZ0LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgdmFyaWFibGUgbmFtZXMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuXHRcdH1cblx0XHR2YXIgdmFyaWFibGVOYW1lID0gYXN0LmxlZnQubmFtZTtcblx0XHRzY29wZS5kZWNsYXJlKHZhcmlhYmxlTmFtZSwgdHJ1ZSwgYW5ub3RhdGUoYXN0KSk7XG5cdFx0c2NvcGUudXBkYXRlVHlwZUluZm8odmFyaWFibGVOYW1lLCB0eXBlSW5mbywgYXN0KTtcblx0XHRpZiAoYXN0LnJpZ2h0LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG5cdFx0XHRjb250ZXh0LmRlY2xhcmUoYXN0LnJpZ2h0LCB0cnVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBhZGREZXJpdmVkTWV0aG9kcyhwcm9ncmFtLCBjb250ZXh0KSB7XG5cdGNvbnRleHQuX3NwZWNpYWxpemVkRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNwZWNpYWxpemVkRnVuY3Rpb24pIHtcblx0XHRwcm9ncmFtLmJvZHkucHVzaChzcGVjaWFsaXplZEZ1bmN0aW9uLmFzdCk7XG5cdH0pO1xuXG5cdHdhbGsudHJhdmVyc2UocHJvZ3JhbSwge1xuXHRcdGVudGVyOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRpZiAobm9kZS50eXBlID09IFN5bnRheC5DYWxsRXhwcmVzc2lvbikge1xuXHRcdFx0XHRpZiAobm9kZS5leHRyYSAmJiBub2RlLmV4dHJhLm5ld05hbWUpIHtcblx0XHRcdFx0XHRub2RlLmNhbGxlZS5uYW1lID0gbm9kZS5leHRyYS5uZXdOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQW5hbHlzaXNDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTY29wZSA9IHJlcXVpcmUoXCIuLi91dGlscy9zY29wZVwiKTtcbnZhciBUeXBlU3lzdGVtID0gcmVxdWlyZShcIi4uL3R5cGUtc3lzdGVtL3R5cGUtc3lzdGVtLmpzXCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgdmFyIGdsb2JhbFNjb3BlID0gbmV3IFNjb3BlKGFzdCwgbnVsbCwge25hbWU6IFwiZ2xvYmFsXCJ9KTtcbiAgICBnbG9iYWxTY29wZS5kZWNsYXJlUHJlZGVmaW5lZChcIk1hdGhcIixcbiAgICAgICAgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiTWF0aFwiKSk7XG4gICAgZ2xvYmFsU2NvcGUuZGVjbGFyZVByZWRlZmluZWQoXCJWZWMyXCIsXG4gICAgICAgIFR5cGVTeXN0ZW0uZ2V0UHJlZGVmaW5lZE9iamVjdChcIlZlYzJcIikpO1xuICAgIGdsb2JhbFNjb3BlLmRlY2xhcmVQcmVkZWZpbmVkKFwiVmVjM1wiLFxuICAgICAgICBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJWZWMzXCIpKTtcbiAgICBnbG9iYWxTY29wZS5kZWNsYXJlUHJlZGVmaW5lZChcIlZlYzRcIixcbiAgICAgICAgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiVmVjNFwiKSk7XG4gICAgZ2xvYmFsU2NvcGUuZGVjbGFyZVByZWRlZmluZWQoXCJNYXQzXCIsXG4gICAgICAgIFR5cGVTeXN0ZW0uZ2V0UHJlZGVmaW5lZE9iamVjdChcIk1hdDNcIikpO1xuICAgIGdsb2JhbFNjb3BlLmRlY2xhcmVQcmVkZWZpbmVkKFwiTWF0NFwiLFxuICAgICAgICBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJNYXQ0XCIpKTtcbiAgICBnbG9iYWxTY29wZS5kZWNsYXJlUHJlZGVmaW5lZChcInRoaXNcIixcbiAgICAgICAgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiU3lzdGVtXCIpKTtcbiAgICBnbG9iYWxTY29wZS5kZWNsYXJlUHJlZGVmaW5lZChcIlNwYWNlXCIsXG4gICAgICAgIFR5cGVTeXN0ZW0uZ2V0UHJlZGVmaW5lZE9iamVjdChcIlNwYWNlXCIpKTtcbiAgICBnbG9iYWxTY29wZS5kZWNsYXJlUHJlZGVmaW5lZChcIk9iamVjdFwiLFxuICAgICAgICBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJPYmplY3RcIikpO1xuICAgIGdsb2JhbFNjb3BlLmRlY2xhcmVQcmVkZWZpbmVkKFwiU2hhZGVcIixcbiAgICAgICAgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiU2hhZGVcIikpO1xuICAgIGdsb2JhbFNjb3BlLmRlY2xhcmVQcmVkZWZpbmVkKFwiQXJyYXlcIixcbiAgICAgICAgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiQXJyYXlcIikpO1xuICAgIGdsb2JhbFNjb3BlLmRlY2xhcmVQcmVkZWZpbmVkKFwiVGV4dHVyZVwiLFxuICAgICAgICBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJUZXh0dXJlXCIpKTtcbiAgICByZXR1cm4gZ2xvYmFsU2NvcGU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlc3RyYXZlcnNlID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbnZhciBUeXBlcyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2VzXCIpLlRZUEVTO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXR1cm5UeXBlKGZ1bmMsIG9wdCkge1xuICAgIHZhciByZXR1cm5UeXBlID0ge1xuICAgICAgICB0eXBlOiBUeXBlcy5VTkRFRklORURcbiAgICB9O1xuICAgIGVzdHJhdmVyc2UudHJhdmVyc2UoZnVuYywge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVHlwZS50eXBlICE9PSBUeXBlcy5VTkRFRklORUQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93SWZOb3RTYW1lVHlwZShub2RlLmFyZ3VtZW50LmV4dHJhLCByZXR1cm5UeXBlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBub2RlLmFyZ3VtZW50LmV4dHJhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblR5cGU7XG59XG5cbmZ1bmN0aW9uIHRocm93SWZOb3RTYW1lVHlwZShhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgaWYgKGFjdHVhbC50eXBlICE9PSBleHBlY3RlZC50eXBlIHx8IGFjdHVhbC5raW5kICE9PSBleHBlY3RlZC5raW5kKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gc3RhdGVtZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZCFcIik7XG5cbiAgICBpZiAoYWN0dWFsLnR5cGUgPT09IFR5cGVzLk9iamVjdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhhY3R1YWwucHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdGhyb3dJZk5vdFNhbWVUeXBlKGFjdHVhbC5wcm9wZXJ0aWVzW3Byb3BdLCBleHBlY3RlZC5wcm9wZXJ0aWVzW3Byb3BdKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvZ3JhbSwgb3B0KSB7XG4gICAgcmV0dXJuIGRldGVybWluZVJldHVyblR5cGUocHJvZ3JhbSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlc3RyYXZlcnNlID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG52YXIgZXNncmFwaCA9IHJlcXVpcmUoXCJlc2dyYXBoXCIpO1xuXG52YXIgd29ya2xpc3QgPSByZXF1aXJlKFwiYW5hbHlzZXNcIik7XG52YXIgU2V0ID0gd29ya2xpc3QuU2V0O1xuXG52YXIgc2xpY2VyID0gcmVxdWlyZShcIi4vc2xpY2VyXCIpO1xudmFyIFR5cGVzID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZXNcIikuVFlQRVM7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIGV4dHJhY3RBbGxvY2F0aW9uc0luUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgdmFyIGFsbG9jYXRpb25zID0gbmV3IFNldCgpO1xuICAgIGVzdHJhdmVyc2UudHJhdmVyc2UocHJvZ3JhbSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsQWxsb2NhdGlvbnMgPSBleHRyYWN0QWxsb2NhdGlvbnMobm9kZSwgZmluZEFsbG9jYXRpb25zSW5GdW5jdGlvbihub2RlKSk7XG4gICAgICAgICAgICAgICAgYWxsb2NhdGlvbnMgPSBTZXQudW5pb24oYWxsb2NhdGlvbnMsIGxvY2FsQWxsb2NhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3Q6IHByb2dyYW0sXG4gICAgICAgIGFsbG9jYXRpb25zOiBhbGxvY2F0aW9uc1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZEFsbG9jYXRpb25zSW5GdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGFsbG9jYXRpb25zID0gbmV3IFNldCgpO1xuICAgIHZhciBjZmcgPSBlc2dyYXBoKG5vZGUuYm9keSwge29taXRFeGNlcHRpb25zOiB0cnVlfSk7XG4gICAgY2ZnWzJdLmZvckVhY2goZnVuY3Rpb24gKGNmZ05vZGUsIGlkeCkge1xuICAgICAgICBpZiAoY2ZnTm9kZS50eXBlIHx8ICFjZmdOb2RlLmFzdE5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVzdHJhdmVyc2UudHJhdmVyc2UoY2ZnTm9kZS5hc3ROb2RlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXN0Tm9kZS50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzdE5vZGUucmlnaHQudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3ROb2RlLnJpZ2h0LmNhbGxlZS5uYW1lID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXN0Tm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvY2F0aW9ucy5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ZnSW5kZXg6IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzdE5vZGU6IGFzdE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lOiBhc3ROb2RlLmxlZnQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRUeXBlSW5mbzogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh1dGlscy5hbm5vdGF0ZShhc3ROb2RlKS5nZXRBcnJheUVsZW1lbnRUeXBlKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXN0Tm9kZS5sZWZ0LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gYXN0Tm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS5jb21wdXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbG9jYXRpb24gPSBhbGxvY2F0aW9ucy52YWx1ZXMoKS5maW5kKGZ1bmN0aW9uIChhbGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb2NhdGlvbi52YXJOYW1lID09PSBub2RlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gYXN0Tm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViYXJyYXlJbmZvID0gYWxsb2NhdGlvbi5lbGVtZW50VHlwZUluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJhcnJheUluZm8gPSBzdWJhcnJheUluZm8uZXh0cmEuZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViYXJyYXlJbmZvLmV4dHJhLmFzdE5vZGUgPSBhc3ROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3ROb2RlLnJpZ2h0LmNhbGxlZS5uYW1lID09PSBcIlRleHR1cmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3ROb2RlLmxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG9jYXRpb25zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZmdJbmRleDogaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0Tm9kZTogYXN0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWU6IGFzdE5vZGUubGVmdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUZXh0dXJlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWxsb2NhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBbGxvY2F0aW9ucyhub2RlLCBhbGxvY2F0aW9ucykge1xuICAgIHZhciBzY29wZSA9IG5ldyB1dGlscy5TY29wZShub2RlKTtcbiAgICByZXR1cm4gYWxsb2NhdGlvbnMubWFwKGZ1bmN0aW9uIChhbGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBhc3RDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShub2RlKSk7XG4gICAgICAgIHZhciBjZmcgPSBlc2dyYXBoKGFzdENvcHkuYm9keSwge29taXRFeGNlcHRpb25zOiB0cnVlfSk7XG4gICAgICAgIHZhciByZWxldmFudE5vZGVzID0gc2xpY2VyLnNsaWNlKGNmZywgY2ZnWzJdW2FsbG9jYXRpb24uY2ZnSW5kZXhdLCBhbGxvY2F0aW9uLnZhck5hbWUpO1xuICAgICAgICBjZmdbMl0uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSB8fCAhbm9kZS5hc3ROb2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgbm9kZS5hc3ROb2RlLl9yZWxldmFudCA9IHJlbGV2YW50Tm9kZXMuaGFzKG5vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBlc3RyYXZlcnNlLnJlcGxhY2UoY2ZnWzBdLmFzdE5vZGUsIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAoYXN0Tm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzdE5vZGUudGVzdCAmJiBhc3ROb2RlLnRlc3QuX3JlbGV2YW50ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhc3ROb2RlLnR5cGUgPT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICYmIGFzdE5vZGUuZXhwcmVzc2lvbi5fcmVsZXZhbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFzdE5vZGUuX3JlbGV2YW50ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhc3ROb2RlID09PSBjZmdbMl1bYWxsb2NhdGlvbi5jZmdJbmRleF0uYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbHMuYW5ub3RhdGUoYXN0Tm9kZSkuaXNUZXh0dXJlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkFycmF5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGFzdE5vZGUucmlnaHQuYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogYXN0Tm9kZS5yaWdodC5hcmd1bWVudHNbMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVzdHJhdmVyc2UucmVwbGFjZShub2RlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gYWxsb2NhdGlvbi5hc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5OZXdFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodC5jYWxsZWUubmFtZSA9PT0gXCJBcnJheVwiIHx8IG5vZGUucmlnaHQuY2FsbGVlLm5hbWUgPT09IFwiVGV4dHVyZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHNjb3BlLmdldElkZW50aWZpZXIoYWxsb2NhdGlvbi52YXJOYW1lKS5yZXBsYWNlKC9cXC4vZywgJ18nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX19tZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFubm8gPSB1dGlscy5hbm5vdGF0ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm8uc2V0VHlwZShUeXBlcy5PQkpFQ1QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm8uc2V0UHJvcGVydGllcyh7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5uby5zZXRQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHV0aWxzLmFubm90YXRlKG5vZGUucmlnaHQpLmluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmlnaHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbnZQYXJhbU5hbWUgPSBub2RlLnBhcmFtcy5maW5kKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmV4dHJhLmdsb2JhbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGV4dHJhY3RQYXJhbWV0ZXJzID0gcmVxdWlyZShcIi4vZXh0cmFjdF9wYXJhbWV0ZXJzXCIpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgc29vb28gYmFkISBidXQgbmVjZXNzYXJ5IGJlY2F1c2UgZXh0cmFjdFBhcmFtZXRlcnMgcmVxdWlyZXMgYSBwcm9ncmFtIG5vdCBhIGZ1bmN0aW9uIGR1ZSB0byBnbG9iYWwgc2NvcGUgYnMuXG4gICAgICAgIHZhciBmYWtlUHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIGJvZHk6IFthc3RDb3B5XSxcbiAgICAgICAgICAgIHR5cGU6IFwiUHJvZ3JhbVwiXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZTogc2NvcGUuZ2V0SWRlbnRpZmllcihhbGxvY2F0aW9uLnZhck5hbWUpLnJlcGxhY2UoL1xcLi9nLCAnXycpLFxuICAgICAgICAgICAgZWxlbWVudHM6IGFsbG9jYXRpb24uZWxlbWVudFR5cGVJbmZvLFxuICAgICAgICAgICAgaXNUZXh0dXJlOiBhbGxvY2F0aW9uLmlzVGV4dHVyZSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogZXh0cmFjdFBhcmFtZXRlcnMoZmFrZVByb2dyYW0sIHtlbnRyeTogYXN0Q29weS5pZC5uYW1lfSkuc2hhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpemU6IG5ldyBGdW5jdGlvbihlbnZQYXJhbU5hbWUubmFtZSwgdXRpbHMudG9KYXZhU2NyaXB0KGFzdENvcHkuYm9keSkpXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm9ncmFtLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgcmV0dXJuIGV4dHJhY3RBbGxvY2F0aW9uc0luUHJvZ3JhbShwcm9ncmFtKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHdhbGsgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSB3YWxrLlN5bnRheDtcblxudmFyIGFubm90YXRlID0gcmVxdWlyZShcIi4uL3V0aWxzL2Fubm90YXRlXCIpO1xudmFyIFNjb3BlID0gcmVxdWlyZShcIi4uL3V0aWxzL3Njb3BlXCIpO1xuXG4vLyB0b2RvOiBJIGRvbid0IGxpa2UgdXNpbmcgdGhlIGNvbnRleHQncyBzY29wZSBzdGFjayBoZXJlIVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24ocHJnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5hZGRGdW5jdGlvblRlbXBsYXRlKFwiZ2xvYmFsXCIsIHByZyk7XG4gICAgZnVuY3Rpb24gZXh0cmFjdEZ1bmN0aW9ucyhhc3QpIHtcbiAgICAgICAgd2Fsay5yZXBsYWNlKGFzdCwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHx8IG5vZGUudHlwZSA9PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaWQgPSBub2RlLmlkIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb250ZXh0LmdldFNhZmVVbmlxdWVOYW1lKFwiYW5vbnltb3VzRnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbE5hbWUgPSBub2RlLmlkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5zZXRUeXBlKFNoYWRlLlRZUEVTLkZVTkNUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5zZXRGdW5jdGlvbk5hbWUobG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U2NvcGUuZGVjbGFyZShsb2NhbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTY29wZS51cGRhdGVUeXBlSW5mbyhsb2NhbE5hbWUsIGFubm90YXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTY29wZVxuICAgICAgICAgICAgICAgICAgICAgICAgPSBuZXcgU2NvcGUobm9kZSwgcGFyZW50U2NvcGUsIHtuYW1lOiBsb2NhbE5hbWV9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hZGRGdW5jdGlvblRlbXBsYXRlKG5ld1Njb3BlLnRvU3RyaW5nKCksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnB1c2hTY29wZShuZXdTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RGdW5jdGlvbnMobm9kZS5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBTeW50YXguRW1wdHlTdGF0ZW1lbnR9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5vZGUuaWQubmFtZX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXN0LmJvZHkgPSBhc3QuYm9keS5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEudHlwZSAhPSBTeW50YXguRW1wdHlTdGF0ZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4dHJhY3RGdW5jdGlvbnMocHJnKTtcbn07XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgd2FsayA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbnZhciBTY29wZSA9IHJlcXVpcmUoXCIuLy4uL3V0aWxzL3Njb3BlLmpzXCIpO1xudmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xuXG52YXIgZGVyaXZlZFN5c3RlbVBhcmFtZXRlcnMgPSB7XG4gICAgbm9ybWFsaXplZENvb3JkczogW1wiY29vcmRzXCJdLFxuICAgIGhlaWdodDogW1wiY29vcmRzXCJdLFxuICAgIHdpZHRoOiBbXCJjb29yZHNcIl1cbn07XG5cbmZ1bmN0aW9uIG1lcmdlKHJlc3VsdCwgb3RoZXIpIHtcbiAgICB2YXIgaSwgcGFyYW07XG4gICAgZm9yICh2YXIgY29udGFpbmVyIGluIHJlc3VsdCkge1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBvdGhlcltjb250YWluZXJdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJhbSA9IG90aGVyW2NvbnRhaW5lcl1baV07XG4gICAgICAgICAgICBpZiAocmVzdWx0W2NvbnRhaW5lcl0uaW5kZXhPZihwYXJhbSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29udGFpbmVyXS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkU3lzdGVtUGFyYW1ldGVyKHBhcmFtZXRlck5hbWUsIGNvbnRhaW5lciwgcGFyYW1ldGVyTWFwKSB7XG4gICAgLy8gSXMgcGFyYW1ldGVyIGFscmVhZHkgaW4gY29udGFpbmVyP1xuICAgIGlmIChjb250YWluZXIuaW5kZXhPZihwYXJhbWV0ZXJOYW1lKSAhPSAtMSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHBhcmFtZXRlck1hcCAmJiBwYXJhbWV0ZXJNYXAuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyTmFtZSkpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlck1hcFtwYXJhbWV0ZXJOYW1lXTtcbiAgICAgICAgcmVxdWlyZWRQYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBhZGRTeXN0ZW1QYXJhbWV0ZXIocGFyYW0sIGNvbnRhaW5lciwgcGFyYW1ldGVyTWFwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGFpbmVyLnB1c2gocGFyYW1ldGVyTmFtZSk7XG59XG5cbnZhciBmaW5kUGFyYW1ldGVyc0luRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwcm9ncmFtLCBlbnZpcm9ubWVudE9iamVjdFBvc2l0aW9uLCBhbmFseXplZENhbGxzKSB7XG4gICAgdmFyIHNjb3BlID0gbmV3IFNjb3BlKHByb2dyYW0sIG51bGwsIHtuYW1lOiBcImdsb2JhbFwifSk7XG4gICAgdmFyIHNjb3BlU3RhY2sgPSBbc2NvcGVdO1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc2hhZGVyUGFyYW1ldGVyczogW10sXG4gICAgICAgIHN5c3RlbVBhcmFtZXRlcnM6IFtdXG4gICAgfTtcbiAgICBhbmFseXplZENhbGxzID0gYW5hbHl6ZWRDYWxscyB8fCB7fTtcblxuICAgIHZhciBhY3RpdmVQYXJhbSA9IG51bGw7XG5cbiAgICB2YXIgY29udHJvbGxlciA9IG5ldyB3YWxrLkNvbnRyb2xsZXIoKTtcbiAgICBjb250cm9sbGVyLnRyYXZlcnNlKHByb2dyYW0sIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGU7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTY29wZSA9IHNjb3BlU3RhY2tbc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U2NvcGUuZGVjbGFyZShub2RlLmlkLm5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBuZXcgU2NvcGUobm9kZSwgcGFyZW50U2NvcGUsIHtuYW1lOiBub2RlLmlkLm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlU3RhY2sucHVzaChzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTY29wZS5nZXRJZGVudGlmaWVyKG5vZGUuaWQubmFtZSkgPT09IGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50T2JqZWN0UG9zaXRpb24gIT09IC0xICYmIG5vZGUucGFyYW1zLmxlbmd0aCA+IGVudmlyb25tZW50T2JqZWN0UG9zaXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUGFyYW0gPSBub2RlLnBhcmFtc1tlbnZpcm9ubWVudE9iamVjdFBvc2l0aW9uXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVQYXJhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gbm9kZS5hcmd1bWVudHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnIubmFtZSAmJiBjdXJyLm5hbWUgPT0gYWN0aXZlUGFyYW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgICAgIH0sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZVN0YWNrW3Njb3BlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHNjb3BlLmdldElkZW50aWZpZXIobm9kZS5jYWxsZWUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAmJiAhYW5hbHl6ZWRDYWxsc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuYWx5emVkQ2FsbHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlKHJlc3VsdCwgZmluZFBhcmFtZXRlcnNJbkZ1bmN0aW9uKGlkLCBwcm9ncmFtLCBwb3MsIGFuYWx5emVkQ2FsbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFNjb3BlID0gc2NvcGVTdGFja1tzY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50U2NvcGUuZ2V0SWRlbnRpZmllcihub2RlLmlkLm5hbWUpID09PSBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVBhcmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IG5vZGUucHJvcGVydHkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gYSBzcGVjaWZpYyBwYXJhbWV0ZXIgb2YgdGhlIGN1cnJlbnQgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVQYXJhbSAmJiBub2RlLm9iamVjdC5uYW1lID09IGFjdGl2ZVBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTeXN0ZW1QYXJhbWV0ZXIocGFyYW1ldGVyTmFtZSwgcmVzdWx0LnNoYWRlclBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIEluICd0aGlzJyBpcyBhIHN5c3RlbSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vYmplY3QudHlwZSA9PSBTeW50YXguVGhpc0V4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN5c3RlbVBhcmFtZXRlcihwYXJhbWV0ZXJOYW1lLCByZXN1bHQuc3lzdGVtUGFyYW1ldGVycywgZGVyaXZlZFN5c3RlbVBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIEluIGdsb2JhbCB2YXJpYWJsZSAnX2VudidcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vYmplY3QubmFtZSA9PSBcIl9lbnZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3lzdGVtUGFyYW1ldGVyKHBhcmFtZXRlck5hbWUsIHJlc3VsdC5zaGFkZXJQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm9ncmFtLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG9wdC5lbnRyeSA/IFwiZ2xvYmFsLlwiICsgb3B0LmVudHJ5IDogXCJnbG9iYWwuc2hhZGVcIjtcbiAgICB2YXIgcGFyYW1ldGVyUG9zaXRpb24gPSBvcHQucGFyYW0gfHwgMDtcblxuICAgIHJldHVybiBmaW5kUGFyYW1ldGVyc0luRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwcm9ncmFtLCBwYXJhbWV0ZXJQb3NpdGlvbik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzYW5pdGl6ZXIgPSByZXF1aXJlKFwiLi9zYW5pdGl6ZXIvc2FuaXRpemVyLmpzXCIpO1xudmFyIEFuYWx5emVyID0gcmVxdWlyZShcIi4vYW5hbHl6ZXJcIik7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuXG52YXIgcmVzb2x2ZXIgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlLmpzXCIpO1xudmFyIHVuaWZvcm1BbmFseXNpcyA9IHJlcXVpcmUoXCIuL3VuaWZvcm1FeHByZXNzaW9ucy91bmlmb3JtQW5hbHlzaXMuanNcIik7XG52YXIgQW5hbHlzaXNDb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dC5qc1wiKTtcbnZhciBzcGFjZVRyYW5zZm9ybWVyXG5cdD0gcmVxdWlyZShcIi4uL2dlbmVyYXRlL3NwYWNlL3RyYW5zZm9ybS5qc1wiKS5TcGFjZVRyYW5zZm9ybWVyO1xudmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG52YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoXCIuL3JlcXVpcmUvcmVzb2x2ZXJcIik7XG52YXIgdG9KYXZhU2NyaXB0ID0gcmVxdWlyZShcIi4uL3V0aWxzL3RvX2phdmFzY3JpcHRcIik7XG5cbnZhciBleHRyYWN0RnVuY3Rpb25UZW1wbGF0ZXMgPSByZXF1aXJlKFwiLi9leHRyYWN0X2Z1bmN0aW9uX3RlbXBsYXRlc1wiKTtcbnZhciBjcmVhdGVHbG9iYWxTY29wZSA9IHJlcXVpcmUoXCIuL2NyZWF0ZV9nbG9iYWxfc2NvcGVcIik7XG5cbmV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uKGFzdCwgcHJvY2Vzc2luZ0RhdGEsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHByb2Nlc3NpbmdEYXRhID0gcHJvY2Vzc2luZ0RhdGEgfHwge307XG5cblx0YXN0ID0gb3B0aW9ucy5zYW5pdGl6ZSA/IHNhbml0aXplci5zYW5pdGl6ZShhc3QsIG9wdGlvbnMpIDogYXN0O1xuXHRhc3QgPSByZXNvbHZlKGFzdCk7XG5cblx0dmFyIGNvbnRleHQgPSBuZXcgQW5hbHlzaXNDb250ZXh0KGFzdCwgb3B0aW9ucyk7XG5cdGNvbnRleHQucHVzaFNjb3BlKGNyZWF0ZUdsb2JhbFNjb3BlKGFzdCkpO1xuXHRleHRyYWN0RnVuY3Rpb25UZW1wbGF0ZXMoYXN0LCBjb250ZXh0KTtcblx0dmFyIGFuYWx5emVyID0gbmV3IEFuYWx5emVyKGNvbnRleHQsIG9wdGlvbnMpO1xuXHRhbmFseXplci5hbmFseXplQXN0KGFzdCk7XG5cblx0aWYgKG9wdGlvbnMuZW50cnkpXG5cdFx0YW5hbHl6ZXIuaW5qZWN0TWFpbkZ1bmN0aW9uKFxuXHRcdFx0b3B0aW9ucy5lbnRyeSxcblx0XHRcdChvcHRpb25zLmluamVjdCAmJiBvcHRpb25zLmluamVjdFtvcHRpb25zLmVudHJ5XSkgfHwgW10pO1xuXG5cdGFzdCA9IGNvbnRleHQuZ2V0UmVzdWx0KCk7XG5cblx0aWYgKG9wdGlvbnMuZXh0cmFjdEFsbG9jYXRpb25zKSB7XG5cdFx0dmFyIGV4dHJhY3RBbGxvY2F0aW9ucyA9IHJlcXVpcmUoXCIuL2V4dHJhY3RfYWxsb2NhdGlvbnNcIik7XG5cdFx0dmFyIHJlc3VsdCA9IGV4dHJhY3RBbGxvY2F0aW9ucyhhc3QpO1xuXHRcdGFzdCA9IHJlc3VsdC5hc3Q7XG5cdFx0cHJvY2Vzc2luZ0RhdGEuYWxsb2NhdGlvbnMgPSByZXN1bHQuYWxsb2NhdGlvbnM7XG5cdH1cblx0XG5cdC8vIGFzdCA9IG9wdGlvbnMuaW1wbGVtZW50YXRpb24gP1xuXHQvLyBcdHJlc29sdmVyLnJlc29sdmVDbG9zdXJlc1Bvc3RUeXBlSW5mZXJlbmNlKGFzdCwgb3B0aW9ucy5pbXBsZW1lbnRhdGlvbixcblx0Ly8gXHRcdHByb2Nlc3NpbmdEYXRhLCBvcHRpb25zKSA6IGFzdDtcbiAgICAvL1xuXG5cdC8vIGNoZWNrIGZvciByZW1haW5pbmcgY29kZSB0aGUgY29tcGxldGVuZXNzIG9mIGFubm90YXRpb25zXG5cdGlmIChvcHRpb25zLnZhbGlkYXRlKVxuXHRcdHZhbGlkYXRlKGFzdCk7XG5cblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtU3BhY2VzKVxuXHRcdHByb2Nlc3NpbmdEYXRhLnNwYWNlSW5mbyA9IHNwYWNlVHJhbnNmb3JtZXIudHJhbnNmb3JtQWFzdChhc3QsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBhc3Q7XG59O1xuXG5leHBvcnRzLmluamVjdE1lbW9yeSA9IGZ1bmN0aW9uIChhc3QsIG1lbSwgb3B0aW9ucykge1xuXHR2YXIgY29udGV4dCA9IG5ldyBBbmFseXNpc0NvbnRleHQoYXN0LCBvcHRpb25zKTtcblx0Y29udGV4dC5wdXNoU2NvcGUoY3JlYXRlR2xvYmFsU2NvcGUoYXN0KSk7XG5cdC8vIGV4dHJhY3RGdW5jdGlvblRlbXBsYXRlcyhhc3QsIGNvbnRleHQpO1xuXHR2YXIgYW5hbHl6ZXIgPSBuZXcgQW5hbHl6ZXIoY29udGV4dCwgb3B0aW9ucyk7XG5cdC8vIGFuYWx5emVyLmFuYWx5emVBc3QoYXN0KTtcblx0Ly8gYW5hbHl6ZXIuaW5qZWN0TWFpbkZ1bmN0aW9uKFxuXHQvLyBcdG9wdGlvbnMuZW50cnksXG5cdFx0Ly8gKG9wdGlvbnMuaW5qZWN0ICYmIG9wdGlvbnMuaW5qZWN0W29wdGlvbnMuZW50cnldKSB8fCBbXSk7XG5cdHJldHVybiBhbmFseXplci5pbmplY3RNZW1vcnkoYXN0LCBtZW0pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcbnZhciBBTk5PID0gcmVxdWlyZShcIi4uL3V0aWxzL2Fubm90YXRlXCIpO1xudmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uL3R5cGUtc3lzdGVtL3R5cGVpbmZvXCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCwgYXN0KSB7XG4gICAgcmV0dXJuIGVzdHJhdmVyc2UucmVwbGFjZShhc3QsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgcGFyZW50LmxlZnQudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0VHlwZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8ocGFyZW50KTtcbiAgICAgICAgICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKHBhcmVudC5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0QW5ub3RhdGlvbiA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5vYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RBbm5vdGF0aW9uLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RBbm5vdGF0aW9uID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLm9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgbm9kZS5jb21wdXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0QW5ub3RhdGlvbi5pbmZvLmFjY2Vzc29ycyAmJiBvYmplY3RBbm5vdGF0aW9uLmluZm8uYWNjZXNzb3JzLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjb250ZXh0LmdldFNjb3BlKCkuZ2V0SWRlbnRpZmllcihvYmplY3RBbm5vdGF0aW9uLmluZm8uYWNjZXNzb3JzLnNldCkucmVwbGFjZSgvXFwuL2csICdfJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbbm9kZS5vYmplY3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogcmVzdWx0VHlwZS5pbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudE5vZGUuYXJndW1lbnRzLnB1c2gobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50Tm9kZS5hcmd1bWVudHMucHVzaChwYXJlbnQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LkNhbGxFeHByZXNzaW9uICYmIHBhcmVudC5jYWxsZWUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdEFubm90YXRpb24gPSBjb250ZXh0LmdldFR5cGVJbmZvKHBhcmVudC5jYWxsZWUub2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdEFubm90YXRpb24uaXNUZXh0dXJlKCkgJiYgb2JqZWN0QW5ub3RhdGlvbi5pbmZvLmFjY2Vzc29ycyAmJiBvYmplY3RBbm5vdGF0aW9uLmluZm8uYWNjZXNzb3JzLmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjb250ZXh0LmdldFNjb3BlKCkuZ2V0SWRlbnRpZmllcihvYmplY3RBbm5vdGF0aW9uLmluZm8uYWNjZXNzb3JzLmdldCkucmVwbGFjZSgvXFwuL2csICdfJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0VHlwZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8ocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbcGFyZW50LmNhbGxlZS5vYmplY3QsIHBhcmVudC5hcmd1bWVudHNbMF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiByZXN1bHRUeXBlLmluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RBbm5vdGF0aW9uID0gY29udGV4dC5nZXRUeXBlSW5mbyhwYXJlbnQub2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBvYmplY3RBbm5vdGF0aW9uLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdFR5cGUgPSBjb250ZXh0LmdldFR5cGVJbmZvKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzdHJhdmVyc2UudHJhdmVyc2UocGFyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0QW5ub3RhdGlvbi5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0QW5ub3RhdGlvbiA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5vYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgbm9kZS5jb21wdXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RBbm5vdGF0aW9uLmluZm8uYWNjZXNzb3JzICYmIG9iamVjdEFubm90YXRpb24uaW5mby5hY2Nlc3NvcnMuZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY29udGV4dC5nZXRTY29wZSgpLmdldElkZW50aWZpZXIob2JqZWN0QW5ub3RhdGlvbi5pbmZvLmFjY2Vzc29ycy5nZXQpLnJlcGxhY2UoL1xcLi9nLCAnXycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbbm9kZS5vYmplY3QsIG5vZGUucHJvcGVydHldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHJlc3VsdFR5cGUuaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudE5vZGUuYXJndW1lbnRzLnB1c2gobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRyYXZlcnNlID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgZXNwcmltYSA9IHJlcXVpcmUoXCJlc3ByaW1hXCIpO1xudmFyIFN5bnRheCA9IHRyYXZlcnNlLlN5bnRheDtcblxudmFyIFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4uLy4uL3BsdWdpbl9yZWdpc3RyeVwiKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICB2YXIgbW9kdWxlQXN0TWFwID0gcmVzb2x2ZVJlcXVpcmVDYWxscyhwcm9ncmFtKTtcbiAgICBpbmplY3RNb2R1bGVzKHByb2dyYW0sIG1vZHVsZUFzdE1hcCk7XG4gICAgcmVwbGFjZUFzc2lnbm1lbnRzKHByb2dyYW0pO1xuICAgIHJldHVybiBwcm9ncmFtO1xufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVJlcXVpcmVDYWxscyhhc3QsIG1vZHVsZU1hcCkge1xuICAgIHZhciBtb2R1bGVBc3RNYXAgPSBuZXcgTWFwKCk7XG4gICAgdHJhdmVyc2UudHJhdmVyc2UoYXN0LCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkNhbGxFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgJiYgbm9kZS5jYWxsZWUubmFtZSA9PT0gXCJyZXF1aXJlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBjaGVjayB0aGlzICFcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUuYXJndW1lbnRzWzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVBc3RNYXAuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBQbHVnaW5SZWdpc3RyeS5nZXRNb2R1bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZUFzdCA9IHBhcnNlTW9kdWxlKG5hbWUsIGNvZGUpO1xuICAgICAgICAgICAgICAgIG1vZHVsZUFzdE1hcC5zZXQobmFtZSwgbW9kdWxlQXN0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVxdWlyZUNhbGxzKG1vZHVsZUFzdCwgbW9kdWxlQXN0TWFwLCBtb2R1bGVNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZHVsZUFzdE1hcDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0TW9kdWxlcyhwcm9ncmFtLCBtb2R1bGVBc3RNYXApIHtcbiAgICB2YXIgdmFyaWFibGVEZWNsYXJhdGlvbnMgPSB7XG4gICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtdLFxuICAgICAgICBraW5kOiBcInZhclwiXG4gICAgfTtcbiAgICBtb2R1bGVBc3RNYXAuZm9yRWFjaChmdW5jdGlvbiAoYXN0LCBuYW1lKSB7XG4gICAgICAgIHZhcmlhYmxlRGVjbGFyYXRpb25zLmRlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyBcIl9cIiArIFwiZXhwb3J0c1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5PYmplY3RFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QuYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgIHByb2dyYW0uYm9keS5wdXNoKGFzdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICh2YXJpYWJsZURlY2xhcmF0aW9ucy5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMClcbiAgICAgICAgcHJvZ3JhbS5ib2R5LnVuc2hpZnQodmFyaWFibGVEZWNsYXJhdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQXNzaWdubWVudHMocHJvZ3JhbSkge1xuICAgIHRyYXZlcnNlLnJlcGxhY2UocHJvZ3JhbSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodC50eXBlID09PSBTeW50YXguQ2FsbEV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIG5vZGUucmlnaHQuY2FsbGVlLm5hbWUgPT09IFwicmVxdWlyZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUucmlnaHQuYXJndW1lbnRzWzBdLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBub2RlLmxlZnQubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICsgXCJfXCIgKyBcImV4cG9ydHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vZHVsZShuYW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgZm5NYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGFzdCA9IGVzcHJpbWEucGFyc2Uoc291cmNlKTtcbiAgICB0cmF2ZXJzZS50cmF2ZXJzZShhc3QsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05hbWUgPSBuYW1lICsgXCJfXCIgKyBub2RlLmlkLm5hbWU7XG4gICAgICAgICAgICAgICAgZm5NYXAuc2V0KG5vZGUuaWQubmFtZSwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5pZC5uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUubmFtZSA9PT0gXCJleHBvcnRzXCIpIHtcbiAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBuYW1lICsgXCJfXCIgKyBcImV4cG9ydHNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJhdmVyc2UudHJhdmVyc2UoYXN0LCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQ2FsbEV4cHJlc3Npb24gJiYgZm5NYXAuaGFzKG5vZGUuY2FsbGVlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUubmFtZSA9IGZuTWFwLmdldChub2RlLmNhbGxlZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhc3Q7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHdhbGsgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSB3YWxrLlN5bnRheDtcblxuZnVuY3Rpb24gRGVjbGFyYXRpb25TaW1wbGlmaWVyKCkge1xuICAgIHRoaXMuZGVjbGFyYXRpb25TdGFjayA9IFtdO1xufVxuXG5EZWNsYXJhdGlvblNpbXBsaWZpZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihyb290KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHdhbGsucmVwbGFjZShcbiAgICAgICAgcm9vdCxcbiAgICAgICAge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNsYXJhdGlvblN0YWNrLnB1c2goW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkRGVjbGFyZWRJZGVudGlmaWVyKG5vZGUuaWQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5hZGRUb3BEZWNsYXJhdGlvbihub2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZW1vdmVNaWRDb2RlRGVjbGFyYXRpb24obm9kZSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5EZWNsYXJhdGlvblNpbXBsaWZpZXIucHJvdG90eXBlLmFkZERlY2xhcmVkSWRlbnRpZmllciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdG9wU3RhY2sgPSB0aGlzLmRlY2xhcmF0aW9uU3RhY2tbdGhpcy5kZWNsYXJhdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0b3BTdGFjay5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgdG9wU3RhY2sucHVzaChuYW1lKTtcbn07XG5cbkRlY2xhcmF0aW9uU2ltcGxpZmllci5wcm90b3R5cGUuYWRkVG9wRGVjbGFyYXRpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuZGVjbGFyYXRpb25TdGFjay5wb3AoKTtcblxuICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcblxuICAgIHZhciBkZWNsYXJhdGlvblN0YXRlbWVudFxuICAgICAgICA9IHt0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiwgZGVjbGFyYXRpb25zOiBbXSwga2luZDogXCJ2YXJcIn07XG5cbiAgICBkZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgZGVjbGFyYXRpb25TdGF0ZW1lbnQuZGVjbGFyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcixcbiAgICAgICAgICAgIGlkOiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGRlY2xhcmF0aW9ufSxcbiAgICAgICAgICAgIGluaXQ6IG51bGxcbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LlByb2dyYW0pXG4gICAgICAgIG5vZGUuYm9keS51bnNoaWZ0KGRlY2xhcmF0aW9uU3RhdGVtZW50KTtcbiAgICBlbHNlIGlmIChub2RlLmJvZHkuYm9keSlcbiAgICAgICAgbm9kZS5ib2R5LmJvZHkudW5zaGlmdChkZWNsYXJhdGlvblN0YXRlbWVudCk7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5EZWNsYXJhdGlvblNpbXBsaWZpZXIucHJvdG90eXBlLnJlbW92ZU1pZENvZGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCkge1xuICAgIHZhciBuZXdOb2RlO1xuICAgIHZhciBpc0ZvckluaXQgPSAocGFyZW50LnR5cGUgPT09IFN5bnRheC5Gb3JTdGF0ZW1lbnQgJiYgcGFyZW50LmluaXQgPT09IG5vZGUpO1xuICAgIGlmIChpc0ZvckluaXQpXG4gICAgICAgIG5ld05vZGVcbiAgICAgICAgICAgID0ge3R5cGU6IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24sIGV4cHJlc3Npb25zOiBbXSwgbG9jOiBub2RlLmxvY307XG4gICAgZWxzZVxuICAgICAgICBuZXdOb2RlID0ge3R5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCwgYm9keTogW10sIGxvYzogbm9kZS5sb2N9O1xuXG4gICAgbm9kZS5kZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKCFkZWNsYXJhdGlvbi5pbml0KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBleHByZXNzaW9uID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgbGVmdDogZGVjbGFyYXRpb24uaWQsXG4gICAgICAgICAgICByaWdodDogZGVjbGFyYXRpb24uaW5pdCxcbiAgICAgICAgICAgIGxvYzogZGVjbGFyYXRpb24ubG9jXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzRm9ySW5pdCkge1xuICAgICAgICAgICAgbmV3Tm9kZS5leHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGxvYzogZGVjbGFyYXRpb24ubG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3Tm9kZS5ib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGlzRm9ySW5pdCAmJiBuZXdOb2RlLmV4cHJlc3Npb25zLmxlbmd0aCA9PSAxKVxuICAgICAgICByZXR1cm4gbmV3Tm9kZS5leHByZXNzaW9uc1swXTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25TaW1wbGlmaWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB3YWxrID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XG5cbmZ1bmN0aW9uIFJlZHVuZGFudEJsb2Nrc1JlbW92ZXIoKSB7fVxuXG5SZWR1bmRhbnRCbG9ja3NSZW1vdmVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ocm9vdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB3YWxrLnJlcGxhY2UoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5CbG9ja1N0YXRlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJlbW92ZVJlZHVuZGFudEJsb2Nrcyhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5SZWR1bmRhbnRCbG9ja3NSZW1vdmVyLnByb3RvdHlwZS5yZW1vdmVSZWR1bmRhbnRCbG9ja3MgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuYm9keSkpXG4gICAgICAgIG5vZGUuYm9keSA9IG5vZGUuYm9keS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmKG5vZGUudHlwZSA9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuYm9keTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgYikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUmVkdW5kYW50QmxvY2tzUmVtb3ZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxudmFyIERlY2xhcmF0aW9uU2ltcGxpZmllciA9IHJlcXVpcmUoXCIuL2RlY2xhcmF0aW9uX3NpbXBsaWZpZXJcIik7XG52YXIgU3RhdGVtZW50U2ltcGxlZmllciA9IHJlcXVpcmUoXCIuL3N0YXRlbWVudF9zaW1wbGlmaWVyXCIpO1xudmFyIFJlZHVuZGFudEJsb2Nrc1JlbW92ZXIgID0gcmVxdWlyZShcIi4vcmVkdW5kYW50X2Jsb2Nrc19yZW1vdmVyXCIpO1xuXG5leHBvcnRzLnNhbml0aXplID0gZnVuY3Rpb24oYXN0LCBvcHQpIHtcblx0dmFyIGRlY2xhcmF0aW9uU2ltcGxpZmllciA9IG5ldyBEZWNsYXJhdGlvblNpbXBsaWZpZXIoKTtcblx0dmFyIHN0YXRlbWVudFNpbXBsaWZpZXIgPSBuZXcgU3RhdGVtZW50U2ltcGxlZmllcigpO1xuXHR2YXIgcmVkdW5kYW50QmxvY2tzUmVtb3ZlciA9IG5ldyBSZWR1bmRhbnRCbG9ja3NSZW1vdmVyKCk7XG5cdGFzdCA9IGRlY2xhcmF0aW9uU2ltcGxpZmllci5leGVjdXRlKGFzdCk7XG5cdGFzdCA9IHN0YXRlbWVudFNpbXBsaWZpZXIuZXhlY3V0ZShhc3QpO1xuXHRhc3QgPSByZWR1bmRhbnRCbG9ja3NSZW1vdmVyLmV4ZWN1dGUoYXN0KTtcblx0cmV0dXJuIGFzdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcblxudmFyIHdhbGsgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSB3YWxrLlN5bnRheDtcbnZhciBWaXNpdG9yT3B0aW9uID0gd2Fsay5WaXNpdG9yT3B0aW9uO1xuXG52YXIgU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIgPSByZXF1aXJlKFwiLi9zdGF0ZW1lbnRfc3BsaXRfdHJhdmVyc2VyXCIpO1xuXG5mdW5jdGlvbiBTdGF0ZW1lbnRTaW1wbGlmaWVyKCkge1xuICAgIFN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLmNhbGwodGhpcyk7XG5cdHRoaXMuc2tpcEV4dHJhY3Rpb24uZm9ySW5pdFVwZGF0ZSA9IHRydWU7XG5cdHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm8gPSB7fTtcbn1cblxudXRpbC5pbmhlcml0cyhTdGF0ZW1lbnRTaW1wbGlmaWVyLCBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlcik7XG5cblN0YXRlbWVudFNpbXBsaWZpZXIucHJvdG90eXBlLm9uR2F0aGVyU3BsaXRJbmZvID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm8gPSB7fTtcbn07XG5cblN0YXRlbWVudFNpbXBsaWZpZXIucHJvdG90eXBlLnN0YXRlbWVudFNwbGl0RW50ZXIgPSBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcblx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0Y2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuXHRcdHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG5cdGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG5cdFx0cmV0dXJuIHRoaXMuaWRlbnRpZmllckVudGVyKG5vZGUsIHBhcmVudCk7XG5cdGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuXHRjYXNlIFN5bnRheC5VcGRhdGVFeHByZXNzaW9uOlxuXHRcdHJldHVybiB0aGlzLmFzc2lnbm1lbnRFbnRlcihub2RlLCBwYXJlbnQpO1xuXHR9XG59O1xuXG5TdGF0ZW1lbnRTaW1wbGlmaWVyLnByb3RvdHlwZS5zdGF0ZW1lbnRTcGxpdEV4aXQgPSBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcblx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0Y2FzZSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XG5cdGNhc2UgU3ludGF4LlVwZGF0ZUV4cHJlc3Npb246XG5cdFx0cmV0dXJuIHRoaXMuYXNzaWdubWVudEV4aXQobm9kZSwgcGFyZW50KTtcblx0XHRicmVhaztcblx0fVxufTtcblxuU3RhdGVtZW50U2ltcGxpZmllci5wcm90b3R5cGUuaWRlbnRpZmllckVudGVyID0gZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XG5cdGlmIChwYXJlbnQudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbilcblx0XHRyZXR1cm47XG5cdGlmIChwYXJlbnQudHlwZSA9PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgcGFyZW50LmxlZnQgPT0gbm9kZSlcblx0XHRyZXR1cm47XG5cdHZhciBuYW1lID0gbm9kZS5uYW1lO1xuXHRpZiAoIXRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm9bbmFtZV0pXG5cdFx0dGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tuYW1lXSA9IHtyZWFkczogW10sIGxhc3RXcml0ZTogbnVsbH07XG5cdHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm9bbmFtZV0ucmVhZHMucHVzaChub2RlKTtcbn07XG5cblN0YXRlbWVudFNpbXBsaWZpZXIucHJvdG90eXBlLmFzc2lnbm1lbnRFbnRlciA9IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuXHRpZiAocGFyZW50LnR5cGUgPT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpXG5cdFx0cmV0dXJuO1xuXHRpZiAoKG5vZGUubGVmdCB8fCBub2RlLmFyZ3VtZW50KS50eXBlICE9IFN5bnRheC5JZGVudGlmaWVyKVxuXHRcdHRocm93IFNoYWRlLnRocm93RXJyb3IoXG5cdFx0XHRub2RlLFxuXHRcdFx0XCJXZSBvbmx5IHN1cHBvcnQgbmVzdGVkIGFzc2lnbm1lbnRzIGZvciBzaW1wbGUgaWRlbnRpZmllcnMsIG5vdCBvYmplY3RzIG9yIGFycmF5cy5cIik7XG5cblx0aWYgKG5vZGUudHlwZSA9PSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbikge1xuXHRcdHZhciB1c2VQcmV2VmFsdWUgPSAhbm9kZS5wcmVmaXg7XG5cdFx0bm9kZSA9IHt0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXG5cdFx0XHRcdG9wZXJhdG9yOiBcIj1cIixcblx0XHRcdFx0bGVmdDoge1xuXHRcdFx0XHRcdHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuXHRcdFx0XHRcdG5hbWU6IG5vZGUuYXJndW1lbnQubmFtZSxcblx0XHRcdFx0XHRsb2M6IG5vZGUuYXJndW1lbnQubG9jXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJpZ2h0OiB7dHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG5cdFx0XHRcdFx0XHRvcGVyYXRvcjogbm9kZS5vcGVyYXRvciA9PSBcIisrXCIgPyBcIitcIiA6IFwiLVwiLFxuXHRcdFx0XHRcdFx0bGVmdDoge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBTeW50YXguSWRlbnRpZmllcixcblx0XHRcdFx0XHRcdFx0bmFtZTogbm9kZS5hcmd1bWVudC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRsb2M6IG5vZGUuYXJndW1lbnQubG9jXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0cmlnaHQ6IHt0eXBlOiBTeW50YXguTGl0ZXJhbCwgdmFsdWU6IDF9IH0sXG5cdFx0XHRcdFx0XHRsb2M6IG5vZGUubG9jLFxuXHRcdFx0XHRcdFx0X3VzZVByZXZWYWx1ZTogdXNlUHJldlZhbHVlIH07XG5cblx0fSBlbHNlIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uXG5cdFx0XHQgICAmJiBub2RlLm9wZXJhdG9yICE9IFwiPVwiKSB7XG5cdFx0dmFyIGJpbmFyeU9wZXJhdG9yID0gbm9kZS5vcGVyYXRvci5zdWJzdHIoMCwgbm9kZS5vcGVyYXRvci5sZW5ndGggLSAxKTtcblx0XHRub2RlLm9wZXJhdG9yID0gXCI9XCI7XG5cdFx0bm9kZS5yaWdodCA9IHt0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcblx0XHRcdFx0XHQgIG9wZXJhdG9yOiBiaW5hcnlPcGVyYXRvcixcblx0XHRcdFx0XHQgIGxlZnQ6IHtcblx0XHRcdFx0XHRcdCAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG5cdFx0XHRcdFx0XHQgIG5hbWU6IG5vZGUubGVmdC5uYW1lLFxuXHRcdFx0XHRcdFx0ICBsb2M6IG5vZGUucmlnaHQubG9jXG5cdFx0XHRcdFx0ICB9LFxuXHRcdFx0XHRcdCAgcmlnaHQ6IG5vZGUucmlnaHQsXG5cdFx0XHRcdFx0ICBsb2M6IG5vZGUucmlnaHQubG9jIH07XG5cdH1cblx0dmFyIG5hbWUgPSBub2RlLmxlZnQubmFtZTtcblx0dmFyIGVudHJ5ID0gdGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tuYW1lXTtcblx0aWYgKGVudHJ5ICYmIGVudHJ5LnJlYWRzLmxlbmd0aCA+IDApXG5cdFx0bm9kZS5fcHJlSWRlbnRpZmllcldyaXRlciA9IGVudHJ5Lmxhc3RXcml0ZTtcblx0cmV0dXJuIG5vZGU7XG59O1xuXG5TdGF0ZW1lbnRTaW1wbGlmaWVyLnByb3RvdHlwZS5hc3NpZ25tZW50RXhpdCA9IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuXHRpZiAocGFyZW50LnR5cGUgPT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpXG5cdFx0cmV0dXJuO1xuXG5cdHZhciByZWFkT2xkVmFsdWUgPSBub2RlLl91c2VQcmV2VmFsdWU7XG5cdGRlbGV0ZSBub2RlLl91c2VQcmV2VmFsdWU7XG5cblx0dmFyIG9sZE5hbWUgPSBub2RlLmxlZnQubmFtZTtcblx0aWYgKCF0aGlzLnN0YXRlbWVudElkZW50aWZpZXJJbmZvW29sZE5hbWVdKSB7XG5cdFx0dGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tvbGROYW1lXSA9IHtyZWFkczogW10sIGxhc3RXcml0ZTogbnVsbH07XG5cdH1cblxuXHR2YXIgZW50cnkgPSB0aGlzLnN0YXRlbWVudElkZW50aWZpZXJJbmZvW29sZE5hbWVdO1xuXG5cdHZhciByZWFkUmVwbGFjZSA9IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogb2xkTmFtZSwgbG9jOiBub2RlLmxvY307XG5cdGlmIChyZWFkT2xkVmFsdWUgfHwgKG5vZGUuX3ByZUlkZW50aWZpZXJXcml0ZXIgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0ICYmIG5vZGUuX3ByZUlkZW50aWZpZXJXcml0ZXIgPT0gZW50cnkubGFzdFdyaXRlKSkge1xuXHRcdHZhciBuZXdOYW1lID0gdGhpcy5nZXRGcmVlTmFtZSgpO1xuXHRcdGlmICghZW50cnkubGFzdFdyaXRlKSB7XG5cdFx0XHR2YXIgY29weUFzc2lnbm1lbnRcblx0XHRcdFx0PSB7dHlwZTogU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uLFxuXHRcdFx0XHQgICBsZWZ0OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5ld05hbWV9LFxuXHRcdFx0XHQgICByaWdodDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBvbGROYW1lfSxcblx0XHRcdFx0ICAgb3BlcmF0b3I6IFwiPVwiIH07XG5cdFx0XHR0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZC51bnNoaWZ0KGNvcHlBc3NpZ25tZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZW50cnkubGFzdFdyaXRlLmxlZnQubmFtZSA9IG5ld05hbWU7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnkucmVhZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGVudHJ5LnJlYWRzW2ldLm5hbWUgPSBuZXdOYW1lO1xuXHRcdH1cblx0fVxuXHRlbnRyeS5yZWFkcyA9IFtdO1xuXHRkZWxldGUgbm9kZS5fcHJlSWRlbnRpZmllcldyaXRlcjtcblx0ZW50cnkubGFzdFdyaXRlID0gbm9kZTtcblxuXHRpZiAocmVhZE9sZFZhbHVlKVxuXHRcdHJlYWRSZXBsYWNlLm5hbWUgPSBuZXdOYW1lO1xuXHRlbHNlXG5cdFx0dGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tvbGROYW1lXS5yZWFkcy5wdXNoKHJlYWRSZXBsYWNlKTtcblxuXHR0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZC5wdXNoKG5vZGUpO1xuXHRyZXR1cm4gcmVhZFJlcGxhY2U7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRTaW1wbGlmaWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIGRlZXBFeHRlbmQgPSByZXF1aXJlKFwiZGVlcC1leHRlbmRcIik7XG5cbnZhciB3YWxrID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlc1wiKTtcbnZhciBUeXBlcyA9IFNoYWRlLlRZUEVTO1xudmFyIGFubm90YXRlID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2Fubm90YXRlXCIpO1xuXG52YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XG5cbnZhciBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlciA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnNjb3BlcyA9IFtdO1xuXHR0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50cyA9IFtdO1xuXHR0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkID0gW107XG5cdHRoaXMuYXNzaWdubWVudHNUb0JlUHJlcGVuZGVkID0gW107XG5cblx0dGhpcy5za2lwRXh0cmFjdGlvbiA9IHtmb3JJbml0VXBkYXRlOiBmYWxzZX1cbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ocm9vdCkge1xuXHR3YWxrLnJlcGxhY2UoXG5cdFx0cm9vdCxcblx0XHR7ZW50ZXI6IHRoaXMuZW50ZXJOb2RlLmJpbmQodGhpcyksIGxlYXZlOiB0aGlzLmV4aXROb2RlLmJpbmQodGhpcyl9KTtcblx0cmV0dXJuIHJvb3Q7XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUuZ2F0aGVyU3RhdG1lbnRTcGxpdEluZm8gPSBmdW5jdGlvbihub2RlKSB7XG5cdHRoaXMuY3VycmVudFN0YXRlbWVudFRtcFVzZWQgPSBbXTtcblx0dGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQgPSBbXTtcblx0dGhpcy5vbkdhdGhlclNwbGl0SW5mbygpO1xuXHRyZXR1cm4gd2Fsay5yZXBsYWNlKG5vZGUsIHtcblx0XHRlbnRlcjogdGhpcy5zdGF0ZW1lbnRTcGxpdEVudGVyLmJpbmQodGhpcyksXG5cdFx0bGVhdmU6IHRoaXMuc3RhdGVtZW50U3BsaXRFeGl0LmJpbmQodGhpcylcblx0fSk7XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUuc3RhdGVtZW50U3BsaXRFbnRlciA9IGZ1bmN0aW9uKG5vZGVQYXJlbnQpIHtcblx0Ly8gSW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Ncbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5zdGF0ZW1lbnRTcGxpdEV4aXQgPSBmdW5jdGlvbihub2RlUGFyZW50KSB7XG5cdC8vIEltcGxlbWVudGVkIGJ5IHN1YmNsYXNzXG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUub25HYXRoZXJTcGxpdEluZm8gPSBmdW5jdGlvbigpIHtcblx0Ly8gSW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Ncbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5pc1JlZHVuZGFudCA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0dmFyIHJlc3VsdCA9IHRydWU7XG5cdHdhbGsudHJhdmVyc2Uobm9kZSwge1xuXHRcdGVudGVyOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRzd2l0Y2ggKG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XG5cdFx0XHRjYXNlIFN5bnRheC5VcGRhdGVFeHByZXNzaW9uOlxuXHRcdFx0Y2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuXHRcdFx0Y2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcblx0XHRcdGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxuXHRcdFx0XHRyZXN1bHQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5icmVhaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUucHVzaFNjb3BlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBuZXdTY29wZSA9IHtkZWNsYXJlZDogW10sIHRtcERlY2xhcmVkOiBbXSwgdG1wRGVjbGFyZWRUeXBlczogW119O1xuXHR0aGlzLnNjb3Blcy5wdXNoKG5ld1Njb3BlKTtcblx0cmV0dXJuIG5ld1Njb3BlO1xufTtcblxuU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIucHJvdG90eXBlLnBvcFNjb3BlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnNjb3Blcy5wb3AoKTtcbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5nZXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zY29wZXNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV07XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUuYWRkUHJlQ29udGludWVTdGF0ZW1lbnRzID0gZnVuY3Rpb24oXG5cdHN0YXRlbWVudHMpIHtcblx0dmFyIGxhc3Rcblx0XHQ9IHRoaXMucHJlQ29udGludWVTdGF0ZW1lbnRzW3RoaXMucHJlQ29udGludWVTdGF0ZW1lbnRzLmxlbmd0aCAtIDFdO1xuXHRsYXN0LnB1c2guYXBwbHkobGFzdCwgc3RhdGVtZW50cyk7XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUuZ2V0UHJlQ29udGludWVTdGF0ZW1lbnRzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50c1t0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50cy5sZW5ndGggLSAxXTtcbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5lbnRlck5vZGUgPSBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcblx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0Y2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuXHRjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuXHRjYXNlIFN5bnRheC5Qcm9ncmFtOlxuXHRcdHZhciBuZXdTY29wZSA9IHRoaXMucHVzaFNjb3BlKCk7XG5cdFx0aWYgKG5vZGUucGFyYW1zKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdG5ld1Njb3BlLmRlY2xhcmVkLnB1c2gobm9kZS5wYXJhbXNbaV0ubmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHRjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I6XG5cdFx0dGhpcy5hZGREZWNsYXJlZElkZW50aWZpZXIobm9kZS5pZC5uYW1lKTtcblx0XHRicmVhaztcblx0Y2FzZSBTeW50YXguQ29udGludWVTdGF0ZW1lbnQ6XG5cdFx0cmV0dXJuIHRoaXMuZXh0ZW5kQ29udGludWVTdGF0ZW1lbnQobm9kZSk7XG5cdGNhc2UgU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ6XG5cdFx0cmV0dXJuIHRoaXMucGVyZm9ybVN0YXRlbWVudFNwbGl0KG5vZGUsIFt7cHJlOiB0cnVlfV0pO1xuXHRjYXNlIFN5bnRheC5JZlN0YXRlbWVudDpcblx0XHRyZXR1cm4gdGhpcy5wZXJmb3JtU3RhdGVtZW50U3BsaXQobm9kZSwgW3twcm9wOiBcInRlc3RcIiwgcHJlOiB0cnVlfV0pO1xuXHRjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XG5cdFx0aWYgKG5vZGUuYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gdGhpcy5wZXJmb3JtU3RhdGVtZW50U3BsaXQobm9kZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIFt7cHJvcDogXCJhcmd1bWVudFwiLCBwcmU6IHRydWV9XSk7XG5cdFx0YnJlYWs7XG5cdGNhc2UgU3ludGF4LldoaWxlU3RhdGVtZW50OlxuXHRcdHJldHVybiB0aGlzLnBlcmZvcm1TdGF0ZW1lbnRTcGxpdChcblx0XHRcdG5vZGUsIFt7cHJvcDogXCJ0ZXN0XCIsIHByZTogdHJ1ZSwgcG9zdDogdHJ1ZX1dLCBcImJvZHlcIik7XG5cdGNhc2UgU3ludGF4LkZvclN0YXRlbWVudDpcblx0XHR2YXIgZXh0cmFjdGlvbnMgPSBbXTtcblxuXHRcdGlmICghdGhpcy5za2lwRXh0cmFjdGlvbi5mb3JJbml0VXBkYXRlKVxuXHRcdFx0ZXh0cmFjdGlvbnMucHVzaCh7cHJvcDogXCJpbml0XCIsIHByZTogdHJ1ZSwgZXh0cmFjdDogdHJ1ZX0pO1xuXG5cdFx0ZXh0cmFjdGlvbnMucHVzaCh7cHJvcDogXCJ0ZXN0XCIsIHByZTogdHJ1ZSwgcG9zdDogdHJ1ZX0pO1xuXG5cdFx0aWYgKCF0aGlzLnNraXBFeHRyYWN0aW9uLmZvckluaXRVcGRhdGUpXG5cdFx0XHRleHRyYWN0aW9ucy5wdXNoKHtwcm9wOiBcInVwZGF0ZVwiLCBwb3N0OiB0cnVlLCBleHRyYWN0OiB0cnVlfSk7XG5cblx0XHRyZXR1cm4gdGhpcy5wZXJmb3JtU3RhdGVtZW50U3BsaXQobm9kZSwgZXh0cmFjdGlvbnMsIFwiYm9keVwiKTtcblx0Y2FzZSBTeW50YXguRG9XaGlsZVN0YXRlbWVudDpcblx0XHRyZXR1cm4gdGhpcy5wZXJmb3JtU3RhdGVtZW50U3BsaXQobm9kZSwgW3twcm9wOiBcInRlc3RcIiwgcG9zdDogdHJ1ZX1dLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgIFwiYm9keVwiKTtcblx0fVxufTtcblxuU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIucHJvdG90eXBlLmV4aXROb2RlID0gZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XG5cdHN3aXRjaCAobm9kZS50eXBlKSB7XG5cdGNhc2UgU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjpcblx0Y2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcblx0XHRyZXR1cm4gdGhpcy5hZGRUbXBEZWNsYXJhdGlvbihub2RlKTtcblx0Y2FzZSBTeW50YXguUHJvZ3JhbTpcblx0XHR0aGlzLnJlbW92ZVJlZHVuZGFudEJsb2Nrcyhub2RlLCBcImJvZHlcIik7XG5cdFx0cmV0dXJuIHRoaXMuYWRkVG1wRGVjbGFyYXRpb24obm9kZSk7XG5cdGNhc2UgU3ludGF4LkJsb2NrU3RhdGVtZW50OlxuXHRcdHJldHVybiB0aGlzLnJlbW92ZVJlZHVuZGFudEJsb2Nrcyhub2RlLCBcImJvZHlcIik7XG5cdGNhc2UgU3ludGF4LlN3aXRjaENhc2U6XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlUmVkdW5kYW50QmxvY2tzKG5vZGUsIFwiY29uc2VxdWVudFwiKTtcblx0Y2FzZSBTeW50YXguQ29udGludWVTdGF0ZW1lbnQ6XG5cdFx0ZGVsZXRlIG5vZGUuX2V4dGVuZGVkO1xuXHRcdGJyZWFrO1xuXHRjYXNlIFN5bnRheC5XaGlsZVN0YXRlbWVudDpcblx0Y2FzZSBTeW50YXguRm9yU3RhdGVtZW50OlxuXHRjYXNlIFN5bnRheC5Eb1doaWxlU3RhdGVtZW50OlxuXHRcdGlmIChub2RlLl9wcmVDb250aW51ZVN0YWNrZWQpIHtcblx0XHRcdGRlbGV0ZSBub2RlLl9wcmVDb250aW51ZVN0YWNrZWQ7XG5cdFx0XHR0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50cy5wb3AoKTtcblx0XHR9XG5cdFx0YnJlYWs7XG5cdH1cbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5hZGREZWNsYXJlZElkZW50aWZpZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBkZWNsYXJlZCA9IHRoaXMuZ2V0U2NvcGUoKS5kZWNsYXJlZDtcblx0aWYgKGRlY2xhcmVkLmluZGV4T2YobmFtZSkgPT0gLTEpXG5cdFx0ZGVjbGFyZWQucHVzaChuYW1lKTtcbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5pc05hbWVEZWNsYXJlZCA9IGZ1bmN0aW9uKG5hbWUsIHVudHlwZWQpIHtcblx0dmFyIGkgPSB0aGlzLnNjb3Blcy5sZW5ndGg7XG5cdHdoaWxlIChpLS0pIHtcblx0XHRpZiAodGhpcy5zY29wZXNbaV0uZGVjbGFyZWQuaW5kZXhPZihuYW1lKSAhPSAtMSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB1bnR5cGVkICYmIHRoaXMuZ2V0U2NvcGUoKS50bXBEZWNsYXJlZC5pbmRleE9mKG5hbWUpICE9IC0xO1xufTtcblxuU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIucHJvdG90eXBlLmdldEZyZWVOYW1lID0gZnVuY3Rpb24odHlwZSwga2luZCkge1xuXHR2YXIgcmVzdWx0SWR4ID0gMDtcblx0dmFyIHVudHlwZWQgPSAodHlwZSA9PT0gdW5kZWZpbmVkKTtcblx0dmFyIHJlc3VsdCwgcHJlZml4ID0gdGhpcy5fZ2V0VHlwZWRQcmVmaXgodHlwZSwga2luZCk7XG5cdGRvIHtcblx0XHRyZXN1bHQgPSBwcmVmaXggKyByZXN1bHRJZHgrKztcblx0fSB3aGlsZSAodGhpcy5pc05hbWVEZWNsYXJlZChyZXN1bHQsIHVudHlwZWQpXG5cdFx0XHQgfHwgdGhpcy5jdXJyZW50U3RhdGVtZW50VG1wVXNlZC5pbmRleE9mKHJlc3VsdCkgIT0gLTEpO1xuXHR0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkLnB1c2gocmVzdWx0KTtcblx0dmFyIHNjb3BlID0gdGhpcy5nZXRTY29wZSgpO1xuXHRpZiAoc2NvcGUudG1wRGVjbGFyZWQuaW5kZXhPZihyZXN1bHQpID09IC0xKSB7XG5cdFx0c2NvcGUudG1wRGVjbGFyZWQucHVzaChyZXN1bHQpO1xuXHRcdHNjb3BlLnRtcERlY2xhcmVkVHlwZXMucHVzaCh7dHlwZTogdHlwZSwga2luZDoga2luZH0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUuZ2V0U3RhdGVtZW50VG1wVXNlZENvdW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkLmxlbmd0aDtcbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5yZWR1Y2VTdGF0ZW1lbnRUbXBVc2VkID0gZnVuY3Rpb24obmV3Q291bnQpIHtcblx0dGhpcy5jdXJyZW50U3RhdGVtZW50VG1wVXNlZC5sZW5ndGggPSBuZXdDb3VudDtcbn07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5yZW1vdmVTdGF0ZW1lbnRUbXBVc2VkQWZ0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBpZHggPSB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkLmluZGV4T2YobmFtZSk7XG5cdGlmIChpZHggPT0gLTEpXG5cdFx0cmV0dXJuO1xuXHRpZHgrKztcblx0dmFyIHJlbW92ZUNvdW50ID0gdGhpcy5jdXJyZW50U3RhdGVtZW50VG1wVXNlZC5sZW5ndGggLSBpZHg7XG5cdHRoaXMuY3VycmVudFN0YXRlbWVudFRtcFVzZWQuc3BsaWNlKGlkeCwgcmVtb3ZlQ291bnQpO1xufTtcblxuU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIucHJvdG90eXBlLl9nZXRUeXBlZFByZWZpeCA9IGZ1bmN0aW9uKHR5cGUsIGtpbmQpIHtcblx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZClcblx0XHRyZXR1cm4gXCJfdG1wXCI7XG5cdHN3aXRjaCAodHlwZSkge1xuXHRjYXNlIFR5cGVzLkJPT0xFQU46XG5cdFx0cmV0dXJuIFwiX2Jvb2xUbXBcIjtcblx0Y2FzZSBUeXBlcy5OVU1CRVI6XG5cdFx0cmV0dXJuIFwiX251bVRtcFwiO1xuXHRjYXNlIFR5cGVzLklOVDpcblx0XHRyZXR1cm4gXCJfaW50VG1wXCI7XG5cdGNhc2UgVHlwZXMuU1RSSU5HOlxuXHRcdHJldHVybiBcIl9zdHJpbmdUbXBcIjtcblx0Y2FzZSBUeXBlcy5PQkpFQ1Q6XG5cdFx0c3dpdGNoIChraW5kKSB7XG5cdFx0Y2FzZSBcIlZlYzJcIjpcblx0XHRcdHJldHVybiBcIl92ZWMyVG1wXCI7XG5cdFx0Y2FzZSBcIlZlYzNcIjpcblx0XHRcdHJldHVybiBcIl92ZWMzVG1wXCI7XG5cdFx0Y2FzZSBcIlZlYzRcIjpcblx0XHRcdHJldHVybiBcIl92ZWM0VG1wXCI7XG5cdFx0Y2FzZSBcIk1hdDNcIjpcblx0XHRcdHJldHVybiBcIl9tYXQzVG1wXCI7XG5cdFx0Y2FzZSBcIk1hdDRcIjpcblx0XHRcdHJldHVybiBcIl9tYXQ0VG1wXCI7XG5cdFx0fVxuXHR9XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUucGVyZm9ybVN0YXRlbWVudFNwbGl0ID0gZnVuY3Rpb24oXG5cdG5vZGUsIHN1YlByb3BlcnRpZXMsIGJvZHlQcm9wZXJ0eSkge1xuXHRpZiAoYm9keVByb3BlcnR5ICYmICFub2RlLl9wcmVDb250aW51ZVN0YWNrZWQpIHtcblx0XHR0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50cy5wdXNoKFtdKTtcblx0XHRub2RlLl9wcmVDb250aW51ZVN0YWNrZWQgPSB0cnVlO1xuXHR9XG5cblx0dmFyIG9yaWdpbmFsTm9kZSA9IG5vZGUsIHJldHVybk5vZGUgPSBub2RlO1xuXHR2YXIgaSA9IHN1YlByb3BlcnRpZXMubGVuZ3RoO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0dmFyIHByb3BlcnR5ID0gc3ViUHJvcGVydGllc1tpXS5wcm9wO1xuXHRcdHZhciB0YXJnZXQgPSBvcmlnaW5hbE5vZGU7XG5cdFx0aWYgKHByb3BlcnR5KVxuXHRcdFx0dGFyZ2V0ID0gb3JpZ2luYWxOb2RlW3Byb3BlcnR5XTtcblx0XHRpZiAocHJvcGVydHkgJiYgc3ViUHJvcGVydGllc1tpXS5leHRyYWN0KSB7XG5cdFx0XHR0aGlzLm9uR2F0aGVyU3BsaXRJbmZvKCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkID0gW107XG5cdFx0XHR0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZCA9IHRhcmdldCA/IFt0YXJnZXRdIDogW107XG5cdFx0XHRvcmlnaW5hbE5vZGVbcHJvcGVydHldID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5nYXRoZXJTdGF0bWVudFNwbGl0SW5mbyh0YXJnZXQpO1xuXHRcdFx0aWYgKHByb3BlcnR5KVxuXHRcdFx0XHRvcmlnaW5hbE5vZGVbcHJvcGVydHldID0gdGFyZ2V0O1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm5Ob2RlID0gdGFyZ2V0O1xuXHRcdH1cblx0XHRpZiAodGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHN1YlByb3BlcnRpZXNbaV0ucHJlKSB7XG5cdFx0XHRcdHJldHVybk5vZGUgPSB0aGlzLmdldFNwbGl0dGVkU3RhdGVtZW50QmxvY2soXG5cdFx0XHRcdFx0dGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQsIHJldHVybk5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN1YlByb3BlcnRpZXNbaV0ucG9zdCkge1xuXHRcdFx0XHR2YXIgYm9keSA9IG9yaWdpbmFsTm9kZVtib2R5UHJvcGVydHldO1xuXHRcdFx0XHR2YXIgc3RhdGVtZW50cyA9IHRoaXMuZ2V0U3BsaXR0ZWRTdGF0ZW1lbnRCbG9jayhcblx0XHRcdFx0XHR0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZCk7XG5cdFx0XHRcdGlmIChib2R5ICYmIGJvZHkudHlwZSA9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcblx0XHRcdFx0XHRib2R5LmJvZHkucHVzaChzdGF0ZW1lbnRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoYm9keSlcblx0XHRcdFx0XHRcdHN0YXRlbWVudHMuYm9keS51bnNoaWZ0KGJvZHkpO1xuXHRcdFx0XHRcdG9yaWdpbmFsTm9kZVtib2R5UHJvcGVydHldID0gc3RhdGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFByZUNvbnRpbnVlU3RhdGVtZW50cyh0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXR1cm5Ob2RlO1xufTtcblxuU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIucHJvdG90eXBlLmV4dGVuZENvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAobm9kZS5fZXh0ZW5kZWQpXG5cdFx0cmV0dXJuO1xuXHRub2RlLl9leHRlbmRlZCA9IHRydWU7XG5cdHZhciBzdGF0ZW1lbnRzID0gdGhpcy5nZXRQcmVDb250aW51ZVN0YXRlbWVudHMoKTtcblx0aWYgKHN0YXRlbWVudHMubGVuZ3RoID09IDApXG5cdFx0cmV0dXJuIG5vZGU7XG5cdHJldHVybiB0aGlzLmdldFNwbGl0dGVkU3RhdGVtZW50QmxvY2soc3RhdGVtZW50cywgbm9kZSk7XG59O1xuXG5TdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5wcm90b3R5cGUuZ2V0U3BsaXR0ZWRTdGF0ZW1lbnRCbG9ja1xuXHQ9IGZ1bmN0aW9uKHN0YXRlbWVudHMsIG5vZGUpIHtcblx0XHQgIHZhciByZXN1bHRcblx0XHRcdCAgPSB7dHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LCBib2R5OiBbXSwgbG9jOiBub2RlICYmIG5vZGUubG9jfTtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0ICB2YXIgYXNzaWdubWVudCA9IGRlZXBFeHRlbmQoe30sIHN0YXRlbWVudHNbaV0pO1xuXHRcdFx0ICByZXN1bHQuYm9keS5wdXNoKHtcblx0XHRcdFx0ICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcblx0XHRcdFx0ICBleHByZXNzaW9uOiBhc3NpZ25tZW50LFxuXHRcdFx0XHQgIGxvYzogYXNzaWdubWVudC5sb2Ncblx0XHRcdCAgfSk7XG5cdFx0ICB9XG5cdFx0ICBpZiAobm9kZSAmJiAobm9kZS50eXBlICE9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50XG5cdFx0XHRcdFx0ICAgfHwgIXRoaXMuaXNSZWR1bmRhbnQobm9kZSkpKSB7XG5cdFx0XHQgIHJlc3VsdC5ib2R5LnB1c2gobm9kZSk7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZS5yZW1vdmVSZWR1bmRhbnRCbG9ja3Ncblx0PSBmdW5jdGlvbihub2RlLCBwcm9wZXJ0eU5hbWUpIHtcblx0XHQgIHZhciBsaXN0ID0gbm9kZVtwcm9wZXJ0eU5hbWVdO1xuXHRcdCAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblx0XHQgIHdoaWxlIChpLS0pIHtcblx0XHRcdCAgaWYgKGxpc3RbaV0udHlwZSA9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcblx0XHRcdFx0ICB2YXIgYXJncyA9IFtpLCAxXTtcblx0XHRcdFx0ICBhcmdzLnB1c2guYXBwbHkoYXJncywgbGlzdFtpXS5ib2R5KTtcblx0XHRcdFx0ICBsaXN0LnNwbGljZS5hcHBseShsaXN0LCBhcmdzKTtcblx0XHRcdCAgfVxuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIG5vZGU7XG5cdCAgfTtcblxuU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIucHJvdG90eXBlLmFkZFRtcERlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuXHR2YXIgdG1wRGVjbGFyZWQgPSB0aGlzLmdldFNjb3BlKCkudG1wRGVjbGFyZWQsXG5cdFx0dG1wRGVjbGFyZWRUeXBlcyA9IHRoaXMuZ2V0U2NvcGUoKS50bXBEZWNsYXJlZFR5cGVzO1xuXHRpZiAodG1wRGVjbGFyZWQubGVuZ3RoID09IDApXG5cdFx0cmV0dXJuO1xuXHR2YXIgbGlzdDtcblx0aWYgKG5vZGUudHlwZSA9PSBTeW50YXguUHJvZ3JhbSlcblx0XHRsaXN0ID0gbm9kZS5ib2R5O1xuXHRlbHNlXG5cdFx0bGlzdCA9IG5vZGUuYm9keS5ib2R5O1xuXHR2YXIgZGVjbGFyYXRpb24gPSBudWxsO1xuXHRpZiAobGlzdFswXS50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKVxuXHRcdGRlY2xhcmF0aW9uID0gbGlzdFswXTtcblx0ZWxzZSB7XG5cdFx0ZGVjbGFyYXRpb25cblx0XHRcdD0ge3R5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLCBkZWNsYXJhdGlvbnM6IFtdLCBraW5kOiBcInZhclwifTtcblx0XHRsaXN0LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdG1wRGVjbGFyZWQubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgZGVjbGFyYXRvciA9IHtcblx0XHRcdHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG5cdFx0XHRpZDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiB0bXBEZWNsYXJlZFtpXX0sXG5cdFx0XHRpbml0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodG1wRGVjbGFyZWRUeXBlc1tpXS50eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFubm90YXRlKGRlY2xhcmF0b3IpXG5cdFx0XHRcdC5zZXRUeXBlKHRtcERlY2xhcmVkVHlwZXNbaV0udHlwZSwgdG1wRGVjbGFyZWRUeXBlc1tpXS5raW5kKTtcblx0XHR9XG5cdFx0ZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRvcik7XG5cdH1cblxuXHR0aGlzLnBvcFNjb3BlKCk7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgd29ya2xpc3QgPSByZXF1aXJlKFwiYW5hbHlzZXNcIik7XG52YXIgU2V0ID0gd29ya2xpc3QuU2V0O1xuXG52YXIgYXN0VG9vbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvYXN0XCIpO1xudmFyIGRvbWluYW5jZSA9IHJlcXVpcmUoXCIuLi91dGlscy9kb21pbmFuY2VcIik7XG5cbmV4cG9ydHMuc2xpY2UgPSBmdW5jdGlvbiAoY2ZnLCBzdGFydE5vZGUsIHZhcmlhYmxlTmFtZSkge1xuICAgIHZhciBwb3N0RG9taW5hdG9ycyA9IGRvbWluYW5jZS5jb21wdXRlUG9zdERvbWluYXRvcnMoY2ZnKTtcbiAgICB2YXIgaW5pdGlhbFNldCA9IG5ldyBTZXQoW3ZhcmlhYmxlTmFtZV0pO1xuXG4gICAgdmFyIG9sZFMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIFIgPSBkaXJlY3RSZWxldmFudFZhcmlhYmxlcyhjZmcsIHN0YXJ0Tm9kZSwgaW5pdGlhbFNldCwgcG9zdERvbWluYXRvcnMpO1xuICAgIHZhciBTID0gZ2V0UmVsZXZhbnRTdGF0ZW1lbnRzKGNmZyk7XG4gICAgdmFyIEIgPSBnZXRSZWxldmFudEJyYW5jaFN0YXRlbWVudHMoY2ZnLCBTKTtcblxuICAgIHdoaWxlICghU2V0LmVxdWFscyhTLCBvbGRTKSkge1xuICAgICAgICBvbGRTID0gUztcblxuICAgICAgICB2YXIgbmV3UiA9IEIudmFsdWVzKCkucmVkdWNlKGZ1bmN0aW9uKGlucHV0LCBub2RlKSB7XG4gICAgICAgICAgICB2YXIgc1IgPSBkaXJlY3RSZWxldmFudFZhcmlhYmxlcyhjZmcsIG5vZGUsIGFzdFRvb2xzLmZpbmRWYXJpYWJsZVJlZmVyZW5jZXMobm9kZS5hc3ROb2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VNYXAoaW5wdXQsIHNSKTtcbiAgICAgICAgfSwgUik7XG5cbiAgICAgICAgUyA9IFNldC51bmlvbihCLCBnZXRSZWxldmFudFN0YXRlbWVudHMoY2ZnKSk7XG4gICAgICAgIEIgPSBnZXRSZWxldmFudEJyYW5jaFN0YXRlbWVudHMoY2ZnLCBTKTtcbiAgICAgICAgUiA9IG5ld1I7XG4gICAgfVxuICAgIHJldHVybiBTO1xufTtcblxuZnVuY3Rpb24gZGlyZWN0UmVsZXZhbnRWYXJpYWJsZXMoY2ZnLCBzdGFydE5vZGUsIHZhcmlhYmxlcywgcG9zdERvbWluYXRvcnMpIHtcbiAgICB2YXIgb2xkU3RhcnQgPSBjZmdbMV07XG4gICAgdmFyIG9sZE5leHQgPSBzdGFydE5vZGUubmV4dDtcblxuICAgIGNmZ1sxXSA9IHN0YXJ0Tm9kZTtcbiAgICBjZmdbMV0ubmV4dCA9IFtdO1xuXG4gICAgdmFyIFIgPSB3b3JrbGlzdChjZmcsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy50eXBlIHx8ICF0aGlzLmFzdE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAgICAgdGhpcy5yZWYgPSB0aGlzLnJlZiB8fCBhc3RUb29scy5maW5kVmFyaWFibGVSZWZlcmVuY2VzKHRoaXMuYXN0Tm9kZSk7XG4gICAgICAgIHRoaXMuZGVmID0gdGhpcy5kZWYgfHwgYXN0VG9vbHMuZmluZFZhcmlhYmxlRGVmaW5pdGlvbnModGhpcy5hc3ROb2RlKTtcbiAgICAgICAgdGhpcy5pbmZsID0gdGhpcy5pbmZsIHx8IGNvbXB1dGVJbmZsdWVuY2UodGhpcywgcG9zdERvbWluYXRvcnMuZ2V0KHRoaXMpKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKFNldC5pbnRlcnNlY3QodGhpcy5kZWYsIGlucHV0KS5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFJlbGV2YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFNldC51bmlvbihyZXN1bHQsIHRoaXMucmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGdlbmVyYXRlZCA9IG5ldyBTZXQoaW5wdXQudmFsdWVzKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gIXNlbGYuZGVmLmhhcyh2KTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gU2V0LnVuaW9uKHJlc3VsdCwgZ2VuZXJhdGVkKTtcblxuICAgIH0sIHtkaXJlY3Rpb246IFwiYmFja3dhcmRcIiwgc3RhcnQ6IHZhcmlhYmxlc30pO1xuXG4gICAgY2ZnWzFdLm5leHQgPSBvbGROZXh0O1xuICAgIGNmZ1sxXSA9IG9sZFN0YXJ0O1xuICAgIHJldHVybiBSO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxldmFudFN0YXRlbWVudHMoY2ZnKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoY2ZnWzJdLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5kaXJlY3RSZWxldmFudCA9PT0gdHJ1ZTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBnZXRSZWxldmFudEJyYW5jaFN0YXRlbWVudHMoY2ZnLCBTKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoY2ZnWzJdLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5pbmZsID8gU2V0LmludGVyc2VjdChub2RlLmluZmwsIFMpLnNpemUgOiBmYWxzZTtcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwKEEsIEIpIHtcbiAgICB2YXIga2V5cyA9IEIua2V5cygpO1xuICAgIGZvcih2YXIgaSBpbiBrZXlzKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZihBLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB2YXIgc2V0QSA9IEEuZ2V0KGtleSk7XG4gICAgICAgICAgICB2YXIgc2V0QiA9IEIuZ2V0KGtleSk7XG4gICAgICAgICAgICBBLnNldChrZXksIFNldC51bmlvbihzZXRBLCBzZXRCKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEE7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJbmZsdWVuY2Uobm9kZSwgaW52ZXJzZURvbWluYXRvcnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGlmIChub2RlLm5leHQubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGZpbmRTZXRPZk5vZGVzT25QYXRoKG5vZGUubmV4dCwgaW52ZXJzZURvbWluYXRvcnMsIHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kU2V0T2ZOb2Rlc09uUGF0aChmcm9tQXJyLCBlbmRTZXQsIHJlc3VsdCkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmcm9tQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gZnJvbUFycltpXTtcbiAgICAgICAgaWYoIShyZXN1bHQuaGFzKG5vZGUpIHx8IGVuZFNldC5oYXMobm9kZSkpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKG5vZGUpO1xuICAgICAgICAgICAgZmluZFNldE9mTm9kZXNPblBhdGgobm9kZS5uZXh0LCBlbmRTZXQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8vIGRlcGVuZGVuY2llc1xudmFyIHdhbGtlciA9IHJlcXVpcmUoJ3dhbGtlcycpO1xudmFyIHdvcmtsaXN0ID0gcmVxdWlyZSgnYW5hbHlzZXMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vYmFzZS9jb21tb24uanNcIik7XG52YXIgZXNncmFwaCA9IHJlcXVpcmUoJ2VzZ3JhcGgnKTtcbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XG52YXIgYXN0VG9vbHMgPSByZXF1aXJlKFwiLi91dGlscy9hc3RcIik7XG52YXIgU2hhZGUgPSByZXF1aXJlKFwiLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxuICAgIFNwYWNlVHlwZSA9IFNoYWRlLlNwYWNlVHlwZSxcbiAgICBWZWN0b3JUeXBlID0gU2hhZGUuVmVjdG9yVHlwZSxcbiAgICBTcGFjZVZlY3RvclR5cGUgPSBTaGFkZS5TcGFjZVZlY3RvclR5cGU7XG5cblxuLy8gc2hvcnRjdXRzXG52YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcbnZhciBTZXQgPSB3b3JrbGlzdC5TZXQsXG4gICAgVHlwZXMgPSBTaGFkZS5UWVBFUztcblxudmFyIEFOTk8gPSBjb21tb24uQU5OTztcbi8vIGRlZmluZXNcblxuXG52YXIgY19yZXN1bHRQb2ludE9rID0gdHJ1ZSwgY19yZXN1bHROb3JtYWxPayA9IHRydWUsXG4gICAgY19jdXN0b21GdW5jdGlvblByb3BhZ2F0aW9ucyA9IG51bGwsIGNfZGVidWcgPSBmYWxzZTtcblxuZnVuY3Rpb24gYW5hbHl6ZShmdW5jdGlvbkFhc3QsIGN1c3RvbUZ1bmN0aW9uUHJvcGFnYXRpb25zKSB7XG4gICAgdmFyIGNmZyA9IGVzZ3JhcGgoZnVuY3Rpb25BYXN0LmJvZHksIHtvbWl0RXhjZXB0aW9uczogdHJ1ZX0pO1xuICAgIGNfcmVzdWx0UG9pbnRPayA9IHRydWU7XG4gICAgY19yZXN1bHROb3JtYWxPayA9IHRydWU7XG4gICAgY19jdXN0b21GdW5jdGlvblByb3BhZ2F0aW9ucyA9IGN1c3RvbUZ1bmN0aW9uUHJvcGFnYXRpb25zIHx8IHt9O1xuICAgIHZhciBvdXRwdXQgPSB3b3JrbGlzdChjZmcsIHRyYW5zZmVyU3BhY2VJbmZvLCB7XG4gICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJyxcbiAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgIG1lcmdlOiB3b3JrbGlzdC5tZXJnZShtZXJnZVNwYWNlSW5mbylcbiAgICB9KTtcbiAgICB2YXIgc3RhcnROb2RlUmVzdWx0ID0gb3V0cHV0LmdldChjZmdbMF0pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgdHJhbmZlckVudHJ5ID0ge1xuICAgICAgICB0cmFuc2ZlclBvaW50T2s6IGNfcmVzdWx0UG9pbnRPayxcbiAgICAgICAgdHJhbnNmZXJOb3JtYWxPazogY19yZXN1bHROb3JtYWxPayxcbiAgICAgICAgdHJhbnNmZXJBcmdzOiBbXVxuICAgIH07XG4gICAgdmFyIHRyYW5zZmVyU3BhY2VzID0ge307XG4gICAgc3RhcnROb2RlUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gZWxlbS5zcGxpdChcIjtcIiksIG5hbWUgPSBzcGxpdFswXSwgc3BhY2UgPSBzcGxpdFsxXSAqIDE7XG4gICAgICAgIGlmIChTaGFkZS5nZXRTcGFjZUZyb21TcGFjZVZlY3RvcihzcGFjZSkgPT0gU3BhY2VUeXBlLlJFU1VMVCkge1xuICAgICAgICAgICAgdHJhbnNmZXJTcGFjZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0W25hbWVdKSByZXN1bHRbbmFtZV0gPSBbXTtcbiAgICAgICAgcmVzdWx0W25hbWVdLnB1c2goc3BhY2UpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25BYXN0LnBhcmFtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbmFtZSA9IGZ1bmN0aW9uQWFzdC5wYXJhbXNbaV0ubmFtZTtcbiAgICAgICAgdHJhbmZlckVudHJ5LnRyYW5zZmVyQXJncy5wdXNoKHRyYW5zZmVyU3BhY2VzW25hbWVdKTtcbiAgICB9XG4gICAgY19jdXN0b21GdW5jdGlvblByb3BhZ2F0aW9uc1tmdW5jdGlvbkFhc3QuaWQubmFtZV0gPSB0cmFuZmVyRW50cnk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBzZXRTcGFjZUluZm8oYXN0LCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFhc3Quc3BhY2VJbmZvKVxuICAgICAgICBhc3Quc3BhY2VJbmZvID0ge307XG4gICAgYXN0LnNwYWNlSW5mb1trZXldID0gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRTcGFjZUluZm9TcGFjZXMoYXN0LCBrZXksIHNwYWNlcykge1xuICAgIHZhciB2YWx1ZXMgPSBzcGFjZXMgJiYgc3BhY2VzLmZpbHRlcihmdW5jdGlvbiAoc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBTaGFkZS5nZXRTcGFjZUZyb21TcGFjZVZlY3RvcihzcGFjZSkgIT0gU3BhY2VUeXBlLlJFU1VMVFxuICAgICAgICB9KTtcbiAgICBzZXRTcGFjZUluZm8oYXN0LCBrZXksIHZhbHVlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZXR9IGlucHV0XG4gKiBAdGhpcyB7Rmxvd05vZGV9XG4gKiBAcmV0dXJucyB7U2V0fSBvdXRwdXQgd2l0aCByZXNwZWN0IHRvIGlucHV0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZmVyU3BhY2VJbmZvKGlucHV0KSB7XG4gICAgaWYgKHRoaXMudHlwZSB8fCAhdGhpcy5hc3ROb2RlKSAvLyBTdGFydCBhbmQgZW5kIG5vZGUgZG8gbm90IGluZmx1ZW5jZSB0aGUgcmVzdWx0XG4gICAgICAgIHJldHVybiBpbnB1dDtcblxuICAgIC8vIExvY2FsXG4gICAgdmFyIGtpbGwgPSB0aGlzLmtpbGwgPSB0aGlzLmtpbGwgfHwgYXN0VG9vbHMuZmluZFZhcmlhYmxlRGVmaW5pdGlvbnModGhpcy5hc3ROb2RlLCB0cnVlKTtcbiAgICB2YXIgZ2VuZXJhdGVkRGVwZW5kZW5jaWVzID0gdGhpcy5nZW5lcmF0ZSA9IHRoaXMuZ2VuZXJhdGUgfHwgZ2VuZXJhdGVTcGFjZURlcGVuZGVuY2llcyh0aGlzLmFzdE5vZGUsIGtpbGwpO1xuICAgIC8vZ2VuZXJhdGUgJiYgY29uc29sZS5sb2codGhpcy5sYWJlbCwgZ2VuZXJhdGUpO1xuXG4gICAgLy8gRGVwZW5kcyBvbiBpbnB1dFxuICAgIHZhciBkZXBTcGFjZUluZm8gPSBuZXcgU2V0KCksIGZpbmFsU3BhY2VzID0gbnVsbCwgc3BhY2VUeXBlcyA9IG51bGw7XG4gICAgc2V0U3BhY2VJbmZvKHRoaXMuYXN0Tm9kZSwgXCJ0cmFuc2ZlclNwYWNlc1wiLCBudWxsKTtcbiAgICBzZXRTcGFjZUluZm8odGhpcy5hc3ROb2RlLCBcImhhc1NwYWNlT3ZlcnJpZGVzXCIsIGdlbmVyYXRlZERlcGVuZGVuY2llcy5kZXBlbmRlbmNpZXMuc3BhY2VPdmVycmlkZXMubGVuZ3RoID4gMCk7XG4gICAgaWYgKGdlbmVyYXRlZERlcGVuZGVuY2llcy5kZWYpIHtcbiAgICAgICAgdmFyIGRlZiA9IGdlbmVyYXRlZERlcGVuZGVuY2llcy5kZWY7XG4gICAgICAgIHNldFNwYWNlSW5mbyh0aGlzLmFzdE5vZGUsIFwiZGVmXCIsIGRlZik7XG4gICAgICAgIHNwYWNlVHlwZXMgPSBnZXRTcGFjZVZlY3RvclR5cGVzRnJvbUluZm8oaW5wdXQsIGRlZik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzcGFjZVR5cGVzID0gbmV3IFNldChbU3BhY2VWZWN0b3JUeXBlLk9CSkVDVF0pXG4gICAgICAgIGlmICh0aGlzLmFzdE5vZGUudHlwZSA9PSBTeW50YXguUmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBzcGFjZVR5cGVzLmFkZChTcGFjZVZlY3RvclR5cGUuUkVTVUxUX05PUk1BTCk7XG4gICAgICAgICAgICBzcGFjZVR5cGVzLmFkZChTcGFjZVZlY3RvclR5cGUuUkVTVUxUX1BPSU5UKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTcGFjZUluZm9TcGFjZXModGhpcy5hc3ROb2RlLCBcInRyYW5zZmVyU3BhY2VzXCIsIHNwYWNlVHlwZXMpO1xuICAgIGZpbmFsU3BhY2VzID0gY3JlYXRlU3BhY2VJbmZvRnJvbURlcGVuZGVuY2llcyhkZXBTcGFjZUluZm8sIGdlbmVyYXRlZERlcGVuZGVuY2llcy5kZXBlbmRlbmNpZXMsIHNwYWNlVHlwZXMpO1xuICAgIHNldFNwYWNlSW5mb1NwYWNlcyh0aGlzLmFzdE5vZGUsIFwiZmluYWxTcGFjZXNcIiwgKGZpbmFsU3BhY2VzICYmIGZpbmFsU3BhY2VzLnNpemUgPiAwKSA/IGZpbmFsU3BhY2VzIDogbnVsbCk7XG5cbiAgICBpbnB1dCA9IG5ldyBTZXQoaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiAha2lsbC5oYXMoZWxlbS5zcGxpdChcIjtcIilbMF0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gbWVyZ2VTcGFjZUluZm8oaW5wdXQsIGRlcFNwYWNlSW5mbyk7XG59XG5cbmZ1bmN0aW9uIGdldFNwYWNlVmVjdG9yVHlwZXNGcm9tSW5mbyhzcGFjZUluZm8sIGlkZW50aWZpZXIpIHtcbiAgICB2YXIgc2V0ID0gbmV3IFNldChzcGFjZUluZm8uZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLnNwbGl0KFwiO1wiKVswXSA9PSBpZGVudGlmaWVyXG4gICAgfSkubWFwKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLnNwbGl0KFwiO1wiKVsxXSAqIDFcbiAgICB9KSk7XG4gICAgaWYgKHNldC5zaXplID09IDApXG4gICAgICAgIHNldC5hZGQoU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCk7XG4gICAgcmV0dXJuIHNldDtcbn1cbmZ1bmN0aW9uIGlzU3BhY2VUeXBlVmFsaWQoc3BhY2VUeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICB2YXIgdHlwZSA9IFNoYWRlLmdldFZlY3RvckZyb21TcGFjZVZlY3RvcihzcGFjZVR5cGUpO1xuICAgIHJldHVybiB0eXBlID09IFZlY3RvclR5cGUuTk9ORSB8fCAodHlwZSA9PSBWZWN0b3JUeXBlLk5PUk1BTCAmJiAhZGVwZW5kZW5jaWVzLm5vcm1hbFNwYWNlVmlvbGF0aW9uKVxuICAgICAgICB8fCAodHlwZSA9PSBWZWN0b3JUeXBlLlBPSU5UICYmICFkZXBlbmRlbmNpZXMucG9pbnRTcGFjZVZpb2xhdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNwYWNlSW5mb0Zyb21EZXBlbmRlbmNpZXMoZGVwU3BhY2VJbmZvLCBkZXBlbmRlbmNpZXMsIHNwYWNlcykge1xuICAgIHZhciBmaW5hbFNwYWNlcyA9IG5ldyBTZXQoKTtcbiAgICBkZXBlbmRlbmNpZXMudG9PYmplY3RTZXQuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBkZXBTcGFjZUluZm8uYWRkKG5hbWUgKyBcIjtcIiArIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QpO1xuICAgIH0pXG4gICAgc3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKHNwYWNlVmVjdG9yKSB7XG4gICAgICAgIHZhciBzcGFjZSA9IFNoYWRlLmdldFNwYWNlRnJvbVNwYWNlVmVjdG9yKHNwYWNlVmVjdG9yKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSBpc1NwYWNlVHlwZVZhbGlkKHNwYWNlVmVjdG9yLCBkZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIGlmIChzcGFjZSAhPSBTcGFjZVR5cGUuT0JKRUNUICYmIGRlcGVuZGVuY2llcy5oYXNEaXJlY3RWZWMzU3BhY2VPdmVycmlkZSgpKSB7XG4gICAgICAgICAgICBpZiAoc3BhY2UgPT0gU3BhY2VUeXBlLlJFU1VMVClcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGV0ZWN0aW9uIG9mIHJlcGVhdGVkIHNwYWNlIGNvbnZlcnNpb24uIE5vdCBzdXBwb3J0ZWQhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxTcGFjZXMuYWRkKHNwYWNlVmVjdG9yKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQgJiYgc3BhY2UgPT0gU3BhY2VUeXBlLlJFU1VMVCkge1xuICAgICAgICAgICAgaWYgKFNoYWRlLmdldFZlY3RvckZyb21TcGFjZVZlY3RvcihzcGFjZVZlY3RvcikgPT0gVmVjdG9yVHlwZS5OT1JNQUwpXG4gICAgICAgICAgICAgICAgY19yZXN1bHROb3JtYWxPayA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNfcmVzdWx0UG9pbnRPayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNwYWNlVmVjdG9yID0gaXNWYWxpZCA/IHNwYWNlVmVjdG9yIDogU3BhY2VWZWN0b3JUeXBlLk9CSkVDVDtcblxuICAgICAgICBkZXBlbmRlbmNpZXMucHJvcGFnYXRlU2V0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlcFNwYWNlSW5mby5hZGQobmFtZSArIFwiO1wiICsgc3BhY2VWZWN0b3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgb3ZlcnJpZGVzID0gZGVwZW5kZW5jaWVzLnNwYWNlT3ZlcnJpZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcnJpZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZVNwYWNlSW5mb0Zyb21EZXBlbmRlbmNpZXMoZGVwU3BhY2VJbmZvLCBvdmVycmlkZXNbaV0uZGVwZW5kZW5jaWVzLCBuZXcgU2V0KFtvdmVycmlkZXNbaV0uc3BhY2VdKSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFNwYWNlcztcbn1cblxuXG4vKipcbiAqIFNwZWNpYWwgbWVyZ2UgZnVuY3Rpb24gdGhhdCBtZXJnZXMgZW50cmllcyB3aXRoIHNhbWUgbmFtZXNcbiAqIHRvIGEgbmV3IGVudHJ5IHdpdGggdG9wIGVsZW1lbnQgU2VtYW50aWMuVU5LTk9XTlxuICogQHBhcmFtIHtTZXR9IGFcbiAqIEBwYXJhbSB7U2V0fSBiXG4gKiBAcmV0dXJucyB7U2V0fVxuICovXG5mdW5jdGlvbiBtZXJnZVNwYWNlSW5mbyhhLCBiKSB7XG4gICAgdmFyIHMgPSBhID8gbmV3IFNldChhKSA6IG5ldyBTZXQoKTtcbiAgICBpZiAoYilcbiAgICAgICAgYi5mb3JFYWNoKFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBzLmFkZChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gU3BhY2VEZXBlbmRlbmNpZXMoKSB7XG4gICAgdGhpcy5ub3JtYWxTcGFjZVZpb2xhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMucG9pbnRTcGFjZVZpb2xhdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMucHJvcGFnYXRlU2V0ID0gbmV3IFNldCgpO1xuICAgIHRoaXMudG9PYmplY3RTZXQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zcGFjZU92ZXJyaWRlcyA9IFtdO1xufVxuXG5TcGFjZURlcGVuZGVuY2llcy5wcm90b3R5cGUuYWRkU3BhY2VPdmVycmlkZSA9IGZ1bmN0aW9uIChzcGFjZSwgZnJvbU9iamVjdFNwYWNlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICB0aGlzLnNwYWNlT3ZlcnJpZGVzLnB1c2goe3NwYWNlOiBzcGFjZSwgZnJvbU9iamVjdFNwYWNlOiBmcm9tT2JqZWN0U3BhY2UsIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzfSlcbn1cblNwYWNlRGVwZW5kZW5jaWVzLnByb3RvdHlwZS5oYXNEaXJlY3RWZWMzU3BhY2VPdmVycmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuc3BhY2VPdmVycmlkZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKCF0aGlzLnNwYWNlT3ZlcnJpZGVzW2ldLmZyb21PYmplY3RTcGFjZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVTcGFjZURlcGVuZGVuY2llcyhhc3QsIGRlZnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge2RlZjogbnVsbCwgZGVwZW5kZW5jaWVzOiBuZXcgU3BhY2VEZXBlbmRlbmNpZXMoKX07XG4gICAgaWYgKCFhc3QgJiYgIWFzdC50eXBlKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIHZhciBkZWZDb3VudCA9IGRlZnMuc2l6ZTtcbiAgICBpZiAoZGVmQ291bnQgPiAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlIG5vdCBzYW5pdGl6ZWQsIGZvdW5kIG11bHRpcGxlIGRlZmluaXRpb25zIGluIG9uZSBzdGF0ZW1lbnRcIik7XG4gICAgaWYgKGRlZkNvdW50ID09IDEpXG4gICAgICAgIHJlc3VsdC5kZWYgPSBkZWZzLnZhbHVlcygpWzBdO1xuICAgIC8vIFRPRE86IFByb3Blcmx5IGRldGVybWluZSBGTE9BVDMgc3RhdGVtZW50c1xuICAgIHZhciBpc0Zsb2F0M1N0YXRlbWVudCA9IEFOTk8oYXN0KS5nZXRLaW5kKCkgPT0gXCJWZWMzXCI7XG5cbiAgICBpZiAoaXNGbG9hdDNTdGF0ZW1lbnQpIHtcbiAgICAgICAgZ2F0aGVyU3BhY2VEZXBlbmRlbmNpZXMoYXN0LCByZXN1bHQuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgc2V0U3BhY2VJbmZvKGFzdCwgXCJwcm9wYWdhdGVTZXRcIiwgcmVzdWx0LmRlcGVuZGVuY2llcy5wcm9wYWdhdGVTZXQudmFsdWVzKCkpO1xuICAgICAgICBzZXRTcGFjZUluZm8oYXN0LCBcIm5vcm1hbFNwYWNlVmlvbGF0aW9uXCIsIHJlc3VsdC5kZXBlbmRlbmNpZXMubm9ybWFsU3BhY2VWaW9sYXRpb24pO1xuICAgICAgICBzZXRTcGFjZUluZm8oYXN0LCBcInBvaW50U3BhY2VWaW9sYXRpb25cIiwgcmVzdWx0LmRlcGVuZGVuY2llcy5wb2ludFNwYWNlVmlvbGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBnYXRoZXJPYmplY3REZXBlbmRlbmNpZXMoYXN0LCByZXN1bHQuZGVwZW5kZW5jaWVzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldFNwYWNlQ29udmVyc2lvbihjYWxsQXN0KSB7XG4gICAgdmFyIGNhbGxlZSA9IGNhbGxBc3QuY2FsbGVlO1xuICAgIGlmIChjYWxsZWUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBjYWxsZWUub2JqZWN0LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXJcbiAgICAgICAgJiYgY2FsbGVlLm9iamVjdC5uYW1lID09IFwiU3BhY2VcIikge1xuICAgICAgICB2YXIgc3BhY2VUeXBlID0gMDtcbiAgICAgICAgc3dpdGNoIChjYWxsZWUucHJvcGVydHkubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcInRyYW5zZm9ybVBvaW50XCI6XG4gICAgICAgICAgICAgICAgc3BhY2VUeXBlID0gVmVjdG9yVHlwZS5QT0lOVDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2Zvcm1EaXJlY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBzcGFjZVR5cGUgPSBWZWN0b3JUeXBlLk5PUk1BTDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzcGFjZVR5cGUgPSBzcGFjZVR5cGUgPDwgMztcbiAgICAgICAgaWYgKHNwYWNlVHlwZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0QXJnID0gY2FsbEFzdC5hcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgIGlmIChmaXJzdEFyZy50eXBlICE9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uIHx8IGZpcnN0QXJnLm9iamVjdC50eXBlICE9IFN5bnRheC5JZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgfHwgZmlyc3RBcmcub2JqZWN0Lm5hbWUgIT0gXCJTcGFjZVwiIHx8IGZpcnN0QXJnLnByb3BlcnR5LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG9mICdcIiArIGNhbGxlZS5wcm9wZXJ0eSArIFwiJyBtdXN0IGJlIGEgU3BhY2UgZW51bSB2YWx1ZS5cIik7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpcnN0QXJnLnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiVklFV1wiIDpcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VUeXBlICs9IFNwYWNlVHlwZS5WSUVXO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiV09STERcIjpcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VUeXBlICs9IFNwYWNlVHlwZS5XT1JMRDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BhY2VUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTcGFjZU92ZXJyaWRlKGNhbGxBc3QsIHJlc3VsdCwgZnJvbU9iamVjdFNwYWNlKSB7XG4gICAgdmFyIHNwYWNlID0gZ2V0U3BhY2VDb252ZXJzaW9uKGNhbGxBc3QpO1xuICAgIGlmIChzcGFjZSkge1xuICAgICAgICB2YXIgc3ViUmVzdWx0ID0gbmV3IFNwYWNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgIGdhdGhlclNwYWNlRGVwZW5kZW5jaWVzKGNhbGxBc3QuYXJndW1lbnRzWzFdLCBzdWJSZXN1bHQpO1xuICAgICAgICByZXN1bHQuYWRkU3BhY2VPdmVycmlkZShzcGFjZSwgZnJvbU9iamVjdFNwYWNlLCBzdWJSZXN1bHQpO1xuICAgICAgICBzZXRTcGFjZUluZm8oY2FsbEFzdCwgXCJzcGFjZU92ZXJyaWRlXCIsIHNwYWNlKTtcbiAgICAgICAgc2V0U3BhY2VJbmZvKGNhbGxBc3QsIFwicHJvcGFnYXRlU2V0XCIsIHN1YlJlc3VsdC5wcm9wYWdhdGVTZXQudmFsdWVzKCkpO1xuICAgICAgICBzZXRTcGFjZUluZm8oY2FsbEFzdCwgXCJub3JtYWxTcGFjZVZpb2xhdGlvblwiLCBzdWJSZXN1bHQubm9ybWFsU3BhY2VWaW9sYXRpb24pO1xuICAgICAgICBzZXRTcGFjZUluZm8oY2FsbEFzdCwgXCJwb2ludFNwYWNlVmlvbGF0aW9uXCIsIHN1YlJlc3VsdC5wb2ludFNwYWNlVmlvbGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2F0aGVyT2JqZWN0RGVwZW5kZW5jaWVzKGFzdCwgcmVzdWx0KSB7XG4gICAgd2Fsa2VyKGFzdCwge1xuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0sXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4dHJhLmtpbmQgPT0gXCJWZWMzXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudG9PYmplY3RTZXQuYWRkKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4dHJhLmtpbmQgPT0gXCJWZWMzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmplY3QudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnByb3BlcnR5LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqZWN0LmV4dHJhLmdsb2JhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9wYWdhdGVTZXQuYWRkKFwiZW52LlwiICsgdGhpcy5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vYmplY3QubmFtZSAhPT0gXCJ1ZXhwXCIpIHsgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lbWJlciBBY2Nlc3Mgb2Ygbm9uICdlbnYnIG9iamVjdCBpbiBzcGFjZSBlcXVhdGlvbiAtIG5vdCBzdXBwb3J0ZWQ6IFwiICsgY29kZWdlbi5nZW5lcmF0ZSh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWN1cnNlKHRoaXMub2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZWN1cnNlKHRoaXMucHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVTcGFjZU92ZXJyaWRlKHRoaXMsIHJlc3VsdCwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmNhbGxlZSk7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5tYXAocmVjdXJzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNWZWN0b3IzKG5vZGUpIHtcbiAgICByZXR1cm4gQU5OTyhub2RlKS5pc09mS2luZChcIlZlYzNcIilcbn1cblxuXG5mdW5jdGlvbiBnYXRoZXJTcGFjZURlcGVuZGVuY2llcyhhc3QsIHJlc3VsdCkge1xuICAgIHdhbGtlcihhc3QsIHtcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB9LFxuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5yaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1ZlY3RvcjModGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHJvcGFnYXRlU2V0LmFkZCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIHNldFNwYWNlSW5mbyh0aGlzLCBcInByb3BhZ2F0ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZSA9PSBcIlZlYzNcIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZVZlYzNBcmdzKHRoaXMuYXJndW1lbnRzLCByZWN1cnNlLCByZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdDtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucHJvcGVydHk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZlY3RvcjModGhpcykpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgcHJvcGVydHkudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQU5OTyhvYmplY3QpLmlzR2xvYmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9wYWdhdGVTZXQuYWRkKFwiZW52LlwiICsgcHJvcGVydHkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0Lm5hbWUgIT09IFwidWV4cFwiKSB7IC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZW1iZXIgQWNjZXNzIG9mIG5vbiAnZW52JyBvYmplY3QgaW4gc3BhY2UgZXF1YXRpb24gLSBub3Qgc3VwcG9ydGVkLlwiKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFNwYWNlSW5mbyh0aGlzLCBcInByb3BhZ2F0ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWN1cnNlKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgcmVjdXJzZShwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuICAgICAgICAgICAgaWYgKGhhbmRsZVNwYWNlT3ZlcnJpZGUodGhpcywgcmVzdWx0LCBmYWxzZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVlLnR5cGUgPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucG9pbnRTcGFjZVZpb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxPYmplY3QgPSB0aGlzLmNhbGxlZS5vYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdEtpbmQgPSBBTk5PKGNhbGxPYmplY3QpLmdldEtpbmQoKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdGhpcy5jYWxsZWUucHJvcGVydHkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMuYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGlmIChQcm9wYWdhdGlvblJ1bGVzW29iamVjdEtpbmRdICYmIFByb3BhZ2F0aW9uUnVsZXNbb2JqZWN0S2luZF1bbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICBQcm9wYWdhdGlvblJ1bGVzW29iamVjdEtpbmRdW21ldGhvZF0oY2FsbE9iamVjdCwgYXJncywgcmVjdXJzZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuaGFuZGxlZDogXCIsIGNvZGVnZW4uZ2VuZXJhdGUodGhpcykpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsbGVlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmNhbGxlZS5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciBjdXN0b21FbnRyeSA9IGNfY3VzdG9tRnVuY3Rpb25Qcm9wYWdhdGlvbnMgJiYgY19jdXN0b21GdW5jdGlvblByb3BhZ2F0aW9uc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tRW50cnkudHJhbnNmZXJQb2ludE9rKSByZXN1bHQucG9pbnRTcGFjZVZpb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tRW50cnkudHJhbnNmZXJOb3JtYWxPaykgcmVzdWx0Lm5vcm1hbFNwYWNlVmlvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBjdXN0b21FbnRyeS50cmFuc2ZlckFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRW50cnkudHJhbnNmZXJBcmdzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5hcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhdGhlck9iamVjdERlcGVuZGVuY2llcyh0aGlzLmFyZ3VtZW50c1tpXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnBvaW50U3BhY2VWaW9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0Lm5vcm1hbFNwYWNlVmlvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGdhdGhlck9iamVjdERlcGVuZGVuY2llcyh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgICAgLy90aGlzLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGFyZyl7IGdhdGhlck9iamVjdERlcGVuZGVuY2llcyhhcmcsIHJlc3VsdCl9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY2FsZU9wZXJhdG9yKGNhbGxPYmplY3QsIGFyZ3MsIHJlY3Vyc2UsIHJlc3VsdCkge1xuICAgIGhhbmRsZVZlYzNBcmdzKGFyZ3MsIHJlY3Vyc2UsIHJlc3VsdCwgdHJ1ZSk7XG4gICAgcmVjdXJzZShjYWxsT2JqZWN0KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFkZFN1Yk9wZXJhdGlvbihjYWxsT2JqZWN0LCBhcmdzLCByZWN1cnNlLCByZXN1bHQpIHtcbiAgICBoYW5kbGVWZWMzQXJncyhhcmdzLCByZWN1cnNlLCByZXN1bHQsIGZhbHNlKTtcbiAgICByZWN1cnNlKGNhbGxPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVWZWMzQXJncyhhcmdzLCByZWN1cnNlLCByZXN1bHQsIHNjYWxpbmcpIHtcbiAgICBpZiAoIXNjYWxpbmcgJiYgYXJncy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXN1bHQubm9ybWFsU3BhY2VWaW9sYXRpb24gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0Lm5vcm1hbFNwYWNlVmlvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZiAoaXNWZWN0b3IzKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICByZWN1cnNlKGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjYWxpbmcgJiYgdHlwZUlzU2NhbGFyKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICBnYXRoZXJPYmplY3REZXBlbmRlbmNpZXMoYXJnc1swXSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub3JtYWxTcGFjZVZpb2xhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHR5cGVJc1NjYWxhcihub2RlKSB7XG4gICAgcmV0dXJuIEFOTk8obm9kZSkuaXNOdW1iZXIoKSB8fCBBTk5PKG5vZGUpLmlzSW50KCk7XG59XG5cblxudmFyIFByb3BhZ2F0aW9uUnVsZXMgPSB7XG4gICAgXCJWZWMzXCI6IHtcbiAgICAgICAgXCJhZGRcIjogaGFuZGxlQWRkU3ViT3BlcmF0aW9uLFxuICAgICAgICBcInN1YlwiOiBoYW5kbGVBZGRTdWJPcGVyYXRpb24sXG4gICAgICAgIFwiY3Jvc3NcIjogaGFuZGxlQWRkU3ViT3BlcmF0aW9uLFxuICAgICAgICBcIm11bFwiOiBoYW5kbGVTY2FsZU9wZXJhdG9yLFxuICAgICAgICBcImRpdlwiOiBoYW5kbGVTY2FsZU9wZXJhdG9yLFxuICAgICAgICBcIm5vcm1hbGl6ZVwiOiBoYW5kbGVTY2FsZU9wZXJhdG9yXG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYW5hbHl6ZTogYW5hbHl6ZVxufTtcblxuIiwiLy8gRGVwZW5kZW5jaWVzXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9jb21tb24uanNcIiksXG4gICAgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcbiAgICBldmFsdWF0b3IgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzL2V2YWx1YXRvci5qc1wiKSxcbiAgICBlc3RyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxuICAgIEVycm9ySGFuZGxlciA9IHJlcXVpcmUoXCIuLi8uLi90eXBlLXN5c3RlbS9lcnJvcnMuanNcIik7XG5cbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XG52YXIgVHlwZUluZm8gPSByZXF1aXJlKFwiLi4vLi4vdHlwZS1zeXN0ZW0vdHlwZWluZm9cIik7XG52YXIgVFlQRVMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlcy5qc1wiKS5UWVBFUztcblxuLy8gU2hvcnRjdXRzXG52YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcbnZhciBBTk5PID0gY29tbW9uLkFOTk87XG52YXIgZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uID0gRXJyb3JIYW5kbGVyLmdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbjtcbnZhciBFUlJPUl9UWVBFUyA9IEVycm9ySGFuZGxlci5FUlJPUl9UWVBFUztcblxudmFyIGRlYnVnID0gZmFsc2U7XG5cbnZhciBoYW5kbGVycyA9IHtcblxuICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpLCBlbGVtZW50cyA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5lbGVtZW50cyk7XG4gICAgICAgIHJlc3VsdC5pbmZvLmVsZW1lbnRzID0gcmVzdWx0LmluZm8uZWxlbWVudHMgfHwge307XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IEFOTk8ocmVzdWx0LmluZm8uZWxlbWVudHMpO1xuXG4gICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLkFSUkFZKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRUeXBlLmNvcHlGcm9tKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRUeXBlLnNldENvbW1vblR5cGUoZWxlbWVudFR5cGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBcInNoYWRlLmpzIGRvZXMgbm90IHN1cHBvcnQgaW5ob21vZ2VuZW91cyBhcnJheXM6IFtcIiwgZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRUeXBlU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpLCBcIl1cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5zZXRBcnJheVNpemUoZWxlbWVudHMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBMaXRlcmFsOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnJhdyAhPT0gdW5kZWZpbmVkID8gbm9kZS5yYXcgOiBub2RlLnZhbHVlLFxuICAgICAgICAgICAgcmVzdWx0ID0gQU5OTyhub2RlKTtcblxuICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZihcIi5cIikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5JTlQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5CT09MRUFOKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5OVUxMKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLlNUUklORyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRDb25zdGFudFZhbHVlKGV2YWx1YXRvci5nZXRDb25zdGFudFZhbHVlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHByZXNzaW9uU3RhdGVtZW50OiBKdXN0IGNvcHkgdGhlIHJlc3VsdCBmcm9tIHRoZSBhY3R1YWwgZXhwcmVzc2lvblxuICAgICAqL1xuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IEFOTk8obm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgcmVzdWx0LmNvcHlGcm9tKGV4cHJlc3Npb24pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVyblN0YXRlbWVudDogSWYgcmV0dXJuIGhhcyBhbiBhcmd1bWVudCwgY29weSB0aGUgVHlwZUluZm9cbiAgICAgKiBmb3JtIHRoZSBhcmd1bWVudCwgb3RoZXJ3aXNlIGl0J3MgdW5kZWZpbmVkLiBJbmZvcm0gdGhlIHNjb3BlIG9uXG4gICAgICogdGhlIHJldHVybiB0eXBlIG9mIHRoaXMgcmV0dXJuIGJyYW5jaC5cbiAgICAgKi9cbiAgICBSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFOTk8obm9kZSksXG4gICAgICAgICAgICBhcmd1bWVudCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5hcmd1bWVudCk7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXN1bHQuY29weUZyb20oYXJndW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuVU5ERUZJTkVEKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmdldFNjb3BlKCkucmV0dXJuSW5mbyA9IHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTmV3RXhwcmVzc2lvbjogRmluZCB0aGUgdHlwZSBvZiB0aGUgQ2FsbGVlIGZyb21cbiAgICAgKiB0aGUgc2NvcGUgYW5kIGV2YWx1YXRlIGJhc2VkIG9uIGFubm90YXRlZCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKSwgc2NvcGUgPSBjb250ZXh0LmdldFNjb3BlKCk7XG5cbiAgICAgICAgLy8gQmUgb24gdGhlIHNhZmUgc2lkZSwgYXNzdW1lIHJlc3VsdCBpcyBzdGF0aWMgaW5kZXBlbmRlbnRseSBvZiBmb3JtZXIgYW5ub3RhdGlvbnNcbiAgICAgICAgcmVzdWx0LnNldER5bmFtaWNWYWx1ZSgpO1xuXG4gICAgICAgIHZhciBmdW5jID0gc2NvcGUudHlwZShub2RlLmNhbGxlZSk7XG4gICAgICAgIGlmICghZnVuYy5pc0Z1bmN0aW9uKCkpIHsgIC8vIGUuZy4gdmFyIGEgPSB1bmRlZmluZWQ7IGEudW5rbm93bjtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5UWVBFX0VSUk9SLCBub2RlLmNhbGxlZS5uYW1lLCBcImlzIG5vdCBhIGZ1bmN0aW9uXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmMuY3RvcjtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBjb25zdHJ1Y3RvciA9PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICB2YXIgYXJncyA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5hcmd1bWVudHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV4dHJhID0gY29uc3RydWN0b3IocmVzdWx0LCBhcmdzLCBzY29wZSk7XG4gICAgICAgICAgICByZXN1bHQuc2V0RnJvbUV4dHJhKGV4dHJhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFVuYXJ5RXhwcmVzc2lvblxuICAgICAqL1xuICAgIFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKSxcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmFyZ3VtZW50KSxcbiAgICAgICAgICAgIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcblxuICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5CT09MRUFOKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnQuY2FuT2JqZWN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldENvbnN0YW50VmFsdWUoZmFsc2UpOyAvLyAhb2JqID09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnQuY2FuSW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuSU5UKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LmNhbk51bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLk5BTl9FUlJPUikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5TVFJJTkcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldENvbnN0YW50VmFsdWUoYXJndW1lbnQuZ2V0SmF2YVNjcmlwdFR5cGVTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY2FzZSBcIn5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2b2lkXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBvcGVyYXRvciwgXCJpcyBub3Qgc3VwcG9ydGVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50Lmhhc0NvbnN0YW50VmFsdWUoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldENvbnN0YW50VmFsdWUoZXZhbHVhdG9yLmdldENvbnN0YW50VmFsdWUobm9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnNldER5bmFtaWNWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICdVbmRlZmluZWQnIGlzIGFuIGlkZW50aWZpZXIuIFZhcmlhYmxlcywgbmFtZXMgb2YgZnVuY3Rpb25zIGFuZFxuICAgICAqIG1lbWJlciBwcm9wZXJ0aWVzIGFyZSBoYW5kbGVkIHdpdGhpbiBwYXJlbnQgZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICBJZGVudGlmaWVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIEFOTk8obm9kZSkuc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZSk7XG4gICAgICAgICAgICBBTk5PKG5vZGUpLmNvcHlGcm9tKGluZm8pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmFyeUV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2cobm9kZS5sZWZ0LCBub2RlLnJpZ2h0KTtcbiAgICAgICAgdmFyIGxlZnQgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUubGVmdCksXG4gICAgICAgICAgICByaWdodCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5yaWdodCksXG4gICAgICAgICAgICByZXN1bHQgPSBBTk5PKG5vZGUpLFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKCEobGVmdC5pc1ZhbGlkKCkgJiYgcmlnaHQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICAgICAgICAvLyBpbnQgJ29wJyBpbnQgPT4gaW50XG4gICAgICAgICAgICAgICAgLy8gaW50IC8gaW50ID0+IG51bWJlclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNhbkludCgpICYmIHJpZ2h0LmNhbkludCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLklOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludCAnb3AnIG51bWJlciA9PiBudW1iZXJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0LmNhbkludCgpICYmIHJpZ2h0LmlzTnVtYmVyKCkgfHwgcmlnaHQuY2FuSW50KCkgJiYgbGVmdC5pc051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG51bWJlciAnb3AnIG51bWJlciA9PiBudW1iZXJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0LmlzTnVtYmVyKCkgJiYgcmlnaHQuaXNOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5OVU1CRVIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnQgJ29wJyBudWxsID0+IGludFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0LmlzSW50KCkgJiYgcmlnaHQuaXNOdWxsKCkgfHwgcmlnaHQuaXNJbnQoKSAmJiBsZWZ0LmlzTnVsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLklOVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG51bWJlciAnb3AnIG51bGwgPT4gbnVtYmVyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGxlZnQuaXNOdW1iZXIoKSAmJiByaWdodC5pc051bGwoKSkgfHwgKHJpZ2h0LmlzTnVtYmVyKCkgJiYgbGVmdC5pc051bGwoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hTlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdW5kZWZpbmVkLCBhcyB0aGlzIGlzIHRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5pc051bGxPclVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gY29kZWdlbi5nZW5lcmF0ZShub2RlLmxlZnQpICsgXCIgaXMgdW5kZWZpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHQuaXNOdWxsT3JVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGNvZGVnZW4uZ2VuZXJhdGUobm9kZS5yaWdodCkgKyBcIiBpcyB1bmRlZmluZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuTkFOX0VSUk9SLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgICAgICAgY2FzZSBcIiE9PVwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLkJPT0xFQU4pO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmlzVW5kZWZpbmVkKCkgfHwgcmlnaHQuaXNVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnQuaXNVbmRlZmluZWQoKSAmJiByaWdodC5pc1VuZGVmaW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0Q29uc3RhbnRWYWx1ZShvcGVyYXRvciA9PSBcIj09PVwiID8gdmFsdWUgOiAhdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj09XCI6IC8vIGNvbXBhcmlzb25cbiAgICAgICAgICAgIGNhc2UgXCIhPVwiOlxuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLkJPT0xFQU4pO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmlzVW5kZWZpbmVkKCkgfHwgcmlnaHQuaXNVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnQuaXNVbmRlZmluZWQoKSAmJiByaWdodC5pc1VuZGVmaW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0Q29uc3RhbnRWYWx1ZShvcGVyYXRvciA9PSBcIiE9XCIgPyAhdmFsdWUgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBvcGVyYXRvciwgXCJpcyBub3Qgc3VwcG9ydGVkLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0Lmhhc0NvbnN0YW50VmFsdWUoKSAmJiByaWdodC5oYXNDb25zdGFudFZhbHVlKCkpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGVmdC5nZXRDb25zdGFudFZhbHVlKCksIG9wZXJhdG9yLCByaWdodC5nZXRDb25zdGFudFZhbHVlKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnNldENvbnN0YW50VmFsdWUoZXZhbHVhdG9yLmdldENvbnN0YW50VmFsdWUobm9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnNldER5bmFtaWNWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmFyZ3VtZW50KSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEFOTk8obm9kZSk7XG4gICAgICAgIGlmIChhcmd1bWVudC5jYW5OdW1iZXIoKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvcHlGcm9tKGFyZ3VtZW50KTtcbiAgICAgICAgICAgIGlmIChub2RlLnByZWZpeCAmJiBhcmd1bWVudC5oYXNDb25zdGFudFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PSBcIisrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldENvbnN0YW50VmFsdWUoYXJndW1lbnQuZ2V0Q29uc3RhbnRWYWx1ZSgpICsgMSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT0gXCItLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRDb25zdGFudFZhbHVlKGFyZ3VtZW50LmdldENvbnN0YW50VmFsdWUoKSAtIDEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BlcmF0b3Igbm90IHN1cHBvcnRlZDogXCIgKyBub2RlLm9wZXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlLmcuIHZhciBhID0ge307IGErKztcbiAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5OQU5fRVJST1IpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmlnaHQgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUucmlnaHQpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQU5OTyhub2RlKTtcblxuICAgICAgICByZXN1bHQuY29weUZyb20ocmlnaHQpO1xuICAgICAgICByZXN1bHQuc2V0RHluYW1pY1ZhbHVlKCk7XG4gICAgICAgIHJlc3VsdC5jbGVhclVuaWZvcm1EZXBlbmRlbmNpZXMoKTtcblxuICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gY29udGV4dC5nZXRTY29wZSgpLnR5cGUobm9kZS5sZWZ0Lm9iamVjdCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZUluZm8gPSBBTk5PKG9iamVjdC5nZXRBcnJheUVsZW1lbnRUeXBlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VHlwZUluZm8uZ2V0VHlwZSgpID09PSBUWVBFUy5BTlkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFR5cGVJbmZvLmNvcHlGcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzdWNrcywgbWFrZSBiZXR0ZXIgaGFuZGxpbmcgb2YgY2FzdCBvcHMhIVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFR5cGVJbmZvLmdldFR5cGUoKSAhPT0gcmVzdWx0LmdldFR5cGUoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFR5cGVJbmZvLmlzTnVtYmVyKCkgJiYgIXJlc3VsdC5jYW5OdW1iZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGhhcyB0byBiZSBob21vZ2VuZW91cyFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubGVmdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZXRQcm9wZXJ0eShuYW1lLCByZXN1bHQuaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2ssIGlmIGEgYXNzaWduZWQgdmFyaWFibGUgc3RpbGwgaGFzIHRoZSBzYW1lIHR5cGUgYXNcbiAgICAgICAgLy8gYmVmb3JlIGFuZCB1cGRhdGUgdHlwZSBvZiB1bmluaXRpYWxpemVkIHZhcmlhYmxlcy5cbiAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09IFN5bnRheC5JZGVudGlmaWVyICYmICFjb250ZXh0LmluRGVjbGFyYXRpb24oKSAmJiByaWdodC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5sZWZ0Lm5hbWU7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBjb250ZXh0LmdldFNjb3BlKCk7XG4gICAgICAgICAgICBzY29wZS51cGRhdGVUeXBlSW5mbyhuYW1lLCByaWdodCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVE9ETyBjYW4gd2UgbWVyZ2Ugc29tZSBvZiB0aGlzIHdpdGggY2FsbCBleHByIHNvbWVob3c/IG9yIHZpY2UgdmVyc2E/XG4gICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0VHlwZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZSk7XG4gICAgICAgIHZhciBvYmplY3RBbm5vdGF0aW9uID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLm9iamVjdCksXG4gICAgICAgICAgICBwcm9wZXJ0eUFubm90YXRpb24gPSBBTk5PKG5vZGUucHJvcGVydHkpLFxuICAgICAgICAgICAgc2NvcGUgPSBjb250ZXh0LmdldFNjb3BlKCk7XG5cbiAgICAgICAgaWYgKCFvYmplY3RBbm5vdGF0aW9uLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmVzdWx0VHlwZS5zZXRJbnZhbGlkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTWVtYmVyXCIsIG5vZGUub2JqZWN0Lm5hbWUsIG5vZGUucHJvcGVydHkubmFtZSwgbm9kZS5jb21wdXRlZCk7XG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0QW5ub3RhdGlvbi5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0eSBpcyBjb21wdXRlZCwgdGh1cyBpdCBjb3VsZCBiZSBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHByb3BlcnR5VHlwZS5jYW5OdW1iZXIoKSwgXCJFeHBlY3RlZCAnaW50JyBvciAnbnVtYmVyJyB0eXBlIGZvciBhcnJheSBhY2Nlc3NvclwiKTtcblxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50SW5mbyA9IG9iamVjdEFubm90YXRpb24uZ2V0QXJyYXlFbGVtZW50VHlwZSgpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0VHlwZS5zZXRUeXBlKGVsZW1lbnRJbmZvLmV4dHJhLnR5cGUsIGVsZW1lbnRJbmZvLmV4dHJhLmtpbmQpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SW5mby5leHRyYS50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHlwZS5pbmZvLnN0YXRpY1NpemUgPSBlbGVtZW50SW5mby5leHRyYS5zdGF0aWNTaXplO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRUeXBlLmluZm8uZWxlbWVudHMgPSBlbGVtZW50SW5mby5leHRyYS5lbGVtZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3RBbm5vdGF0aW9uLmlzVGV4dHVyZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VHlwZS5zZXRUeXBlKFRZUEVTLkFSUkFZKTtcbiAgICAgICAgICAgICAgICByZXN1bHRUeXBlLmluZm8uZWxlbWVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcIlZlYzRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFR5cGUuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuU0hBREVKU19FUlJPUiwgXCJubyBhcnJheSBhY2Nlc3MgdG8gb2JqZWN0IHlldFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBub2RlLnByb3BlcnR5Lm5hbWU7XG5cbiAgICAgICAgdmFyIG9iamVjdE9mSW50ZXJlc3QgPSBzY29wZS50eXBlKG5vZGUub2JqZWN0KTtcbiAgICAgICAgaWYgKCFvYmplY3RPZkludGVyZXN0KSB7XG4gICAgICAgICAgICByZXN1bHRUeXBlLnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlJFRkVSRU5DRV9FUlJPUiwgbm9kZS5vYmplY3QubmFtZSArIFwiIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqZWN0T2ZJbnRlcmVzdC5pc1ZhbGlkKCkgfHwgb2JqZWN0T2ZJbnRlcmVzdC5nZXRUeXBlKCkgPT0gVFlQRVMuVU5ERUZJTkVEKSB7ICAvLyBlLmcuIHZhciBhID0gdW5kZWZpbmVkOyBhLnVua25vd247XG4gICAgICAgICAgICByZXN1bHRUeXBlLnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlRZUEVfRVJST1IsIFwiQ2Fubm90IHJlYWQgcHJvcGVydHkgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInIG9mIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmplY3RPZkludGVyZXN0LmlzT2JqZWN0KCkpIHsgLy8gZS5nLiB2YXIgYSA9IDU7IGEudW5rbm93bjtcbiAgICAgICAgICAgIHJlc3VsdFR5cGUuc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0QW5ub3RhdGlvbi5jb3B5RnJvbShvYmplY3RPZkludGVyZXN0KTtcblxuICAgICAgICBpZiAoIW9iamVjdE9mSW50ZXJlc3QuaGFzUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0VHlwZS5zZXRUeXBlKFRZUEVTLlVOREVGSU5FRCk7XG4gICAgICAgICAgICBwcm9wZXJ0eUFubm90YXRpb24uc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BlcnR5VHlwZUluZm8gPSBvYmplY3RPZkludGVyZXN0LmdldFByb3BlcnR5SW5mbyhwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBwcm9wZXJ0eUFubm90YXRpb24uY29weUZyb20ocHJvcGVydHlUeXBlSW5mbyk7XG4gICAgICAgIHJlc3VsdFR5cGUuY29weUZyb20ocHJvcGVydHlBbm5vdGF0aW9uKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdHlwZSwgZXZhbHVhdGUgc3RhdGljIHZhbHVlXG4gICAgICAgIGlmICghcHJvcGVydHlUeXBlSW5mby5jYW5Db21wdXRlU3RhdGljVmFsdWUoKSB8fCBwcm9wZXJ0eVR5cGVJbmZvLmdldFR5cGUoKSA9PT0gVFlQRVMuRlVOQ1RJT04pIHtcbiAgICAgICAgICAgIGRlYnVnICYmIGNvbnNvbGUud2FybihcIk5vIHN0YXRpYyBldmFsdWF0aW9uIGV4aXN0cyBmb3IgZnVuY3Rpb25cIiwgY29kZWdlbi5nZW5lcmF0ZShub2RlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRpY1ZhbHVlID0gcHJvcGVydHlUeXBlSW5mby5jb21wdXRlU3RhdGljVmFsdWUocmVzdWx0VHlwZSwgc2NvcGUsIG9iamVjdE9mSW50ZXJlc3QpO1xuICAgICAgICBpZiAoc3RhdGljVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0VHlwZS5zZXRDb25zdGFudFZhbHVlKHN0YXRpY1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKSxcbiAgICAgICAgICAgIHNjb3BlID0gY29udGV4dC5nZXRTY29wZSgpLFxuICAgICAgICAgICAgdGhpc1R5cGUgPSBzY29wZS5nZXQoXCJ0aGlzXCIpO1xuICAgICAgICBhc3NlcnQodGhpc1R5cGUpO1xuICAgICAgICByZXN1bHQuY29weUZyb20odGhpc1R5cGUpO1xuICAgIH0sXG5cbiAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCwgYW5hbHl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFOTk8obm9kZSksXG4gICAgICAgICAgICBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKSxcbiAgICAgICAgICAgIGFyZ3MgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUuYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGV4dHJhLCBzdGF0aWNWYWx1ZTtcblxuICAgICAgICBpZiAocmVzdWx0LmdldFR5cGUoKSAhPT0gXCJhbnlcIilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAoIWFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcuaXNWYWxpZCgpXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwiTm90IGFsbCBhcmd1bWVudHMgdHlwZXMgb2YgY2FsbCBleHByZXNzaW9uIGNvdWxkIGJlIGV2YWx1YXRlZFwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmUgb24gdGhlIHNhZmUgc2lkZSwgYXNzdW1lIHJlc3VsdCBpcyBzdGF0aWMgaW5kZXBlbmRlbnRseSBvZiBmb3JtZXIgYW5ub3RhdGlvbnNcbiAgICAgICAgcmVzdWx0LnNldER5bmFtaWNWYWx1ZSgpO1xuXG4gICAgICAgIC8vIENhbGwgb24gYW4gb2JqZWN0LCBlLmcuIE1hdGguY29zKClcbiAgICAgICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcblxuICAgICAgICAgICAgdmFyIG1lbWJlckV4cHJlc3Npb24gPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUuY2FsbGVlKTtcbiAgICAgICAgICAgIGlmICghbWVtYmVyRXhwcmVzc2lvbi5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG5vZGUuY2FsbGVlLm9iamVjdCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBub2RlLmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0UmVmZXJlbmNlID0gc2NvcGUudHlwZShvYmplY3QpO1xuXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBoYW5kbGVkIGJ5IHBhcmVudCBNZW1iZXJFeHByZXNzaW9uXG4gICAgICAgICAgICBhc3NlcnQob2JqZWN0UmVmZXJlbmNlLmlzVmFsaWQoKSwgXCJObyBvYmplY3QgaW5mbyBmb3I6XCIgKyBvYmplY3QpO1xuXG4gICAgICAgICAgICBpZiAoIW1lbWJlckV4cHJlc3Npb24uaXNGdW5jdGlvbigpKSB7IC8vIGUuZy4gTWF0aC5QSSgpXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGNvZGVnZW4uZ2VuZXJhdGUobm9kZS5jYWxsZWUpICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIjtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuVFlQRV9FUlJPUiwgbXNnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlIYW5kbGVyID0gb2JqZWN0UmVmZXJlbmNlLmdldFByb3BlcnR5SW5mbyhwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAgICAgICAvL2Fzc2VydChwcm9wZXJ0eUhhbmRsZXIuY2FuRXZhbHVhdGUoKSwgXCJJbnRlcm5hbDogbm8gaGFuZGxlciByZWdpc3RlcmVkIGZvciBmdW5jdGlvbiAnXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIidcIik7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SGFuZGxlci5jYW5FdmFsdWF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IHByb3BlcnR5SGFuZGxlci5ldmFsdWF0ZShub2RlLCBhcmdzLCBzY29wZSwgb2JqZWN0UmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhID0gYW5hbHl6ZXIuc3BlY2lhbGl6ZUZ1bmN0aW9uKHByb3BlcnR5SGFuZGxlci5nZXRGdW5jdGlvbk5hbWUoKSwgYXJncyk7XG4gICAgICAgICAgICAgICAgZXh0cmEgJiYgcmVzdWx0LnNldEZyb21FeHRyYShleHRyYSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGV2YWx1YXRpb24gbWV0aG9kcyBhbHJlYWR5IGNvbXB1dGVkIGEgY29uc3RhbnQgdmFsdWUsIHdlIGNhbiBza2lwIHRoYXQgcGFydFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5oYXNDb25zdGFudFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSB0eXBlLCBldmFsdWF0ZSBzdGF0aWMgdmFsdWVcbiAgICAgICAgICAgIGlmICghcHJvcGVydHlIYW5kbGVyLmNhbkNvbXB1dGVTdGF0aWNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcgJiYgY29uc29sZS53YXJuKFwiTm8gc3RhdGljIGV2YWx1YXRpb24gZXhpc3RzIGZvciBmdW5jdGlvblwiLCBjb2RlZ2VuLmdlbmVyYXRlKG5vZGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0aWNWYWx1ZSA9IHByb3BlcnR5SGFuZGxlci5jb21wdXRlU3RhdGljVmFsdWUocmVzdWx0LCBhcmdzLCBzY29wZSwgb2JqZWN0UmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldENvbnN0YW50VmFsdWUoc3RhdGljVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvL3ZhciBmdW5jdGlvbk5hbWUgPSBub2RlLmNhbGxlZS5nZXRGdW5jdGlvbk5hbWUoKTsvL25vZGUuY2FsbGVlLm5hbWU7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHNjb3BlLmdldChub2RlLmNhbGxlZS5uYW1lKTtcbiAgICAgICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5SRUZFUkVOQ0VfRVJST1IsIG5vZGUuY2FsbGVlLm5hbWUsIFwiaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZnVuYy5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuVFlQRV9FUlJPUiwgZnVuYy5nZXRUeXBlU3RyaW5nKCksIFwiaXMgbm90IGEgZnVuY3Rpb25cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXh0cmEgPSBhbmFseXplci5zcGVjaWFsaXplRnVuY3Rpb24oZnVuYy5nZXRGdW5jdGlvbk5hbWUoKSwgYXJncyk7XG4gICAgICAgICAgICAgICAgZXh0cmEgJiYgcmVzdWx0LnNldEZyb21FeHRyYShleHRyYSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwiRmFpbHVyZSBpbiBmdW5jdGlvbiBjYWxsOiBcIiwgZS5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwiSW50ZXJuYWw6XCIsIFwiVW5oYW5kbGVkIENhbGxFeHByZXNzaW9uXCIsIG5vZGUuY2FsbGVlLnR5cGUpKTtcbiAgICB9LFxuXG4gICAgVmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbml0ID0gbm9kZS5pbml0ID8gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmluaXQpIDogbnVsbCxcbiAgICAgICAgICAgIHJlc3VsdCA9IEFOTk8obm9kZSk7XG4gICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICBBTk5PKG5vZGUuaW5pdCkuY29weUZyb20oaW5pdCk7XG4gICAgICAgICAgICByZXN1bHQuY29weUZyb20oaW5pdCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnNldEluRGVjbGFyYXRpb24oZmFsc2UpO1xuICAgIH0sXG5cbiAgICBMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgbGVmdCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5sZWZ0KSxcbiAgICAgICAgICAgIHJpZ2h0ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLnJpZ2h0KSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEFOTk8obm9kZSk7XG5cblxuICAgICAgICAvLyBzdGF0aWM6IHRydWUgfHwgZmFsc2UsIGR5bmFtaWM6IHVuZGVmaW5lZFxuICAgICAgICB2YXIgbGVmdEJvb2wgPSBsZWZ0LmdldFN0YXRpY1RydXRoVmFsdWUoKSxcbiAgICAgICAgICAgIHJpZ2h0Qm9vbCA9IHJpZ2h0LmdldFN0YXRpY1RydXRoVmFsdWUoKSxcbiAgICAgICAgICAgIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwifHxcIikge1xuICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5RnJvbShyaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHlGcm9tKGxlZnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExlZnQgaXMgZHluYW1pYywgbGV0J3MgY2hlY2sgcmlnaHRcbiAgICAgICAgICAgIGlmIChyaWdodEJvb2wgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm93IHRoZSByZXN1bHQgdHlwZSBpcyBhbHdheXMgdGhlIG9uZSBvZiB0aGUgbGVmdCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5RnJvbShsZWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09IFwiJiZcIikge1xuICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIFQoeCkgPT0gZmFsc2UgPT4geCAmJiB5ID09IHhcbiAgICAgICAgICAgICAgICByZXN1bHQuY29weUZyb20obGVmdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHlGcm9tKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZWZ0IGlzIGR5bmFtaWMsIGxldCdzIGNoZWNrIHJpZ2h0XG4gICAgICAgICAgICBpZiAocmlnaHRCb29sID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm93IHRoZSByZXN1bHQgdHlwZSBpcyBhbHdheXMgdGhlIG9uZSBvZiB0aGUgbGVmdCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5RnJvbShsZWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRCb29sID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdyB0aGUgcmVzdWx0IG11c3QgYmUgZmFsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5CT09MRUFOKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0Q29uc3RhbnRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgY2FuIGNhc3QgYm90aCBzaWRlcyB0byBhIGNvbW1vbiB0eXBlLCBpdCdzIGZpbmVcbiAgICAgICAgaWYgKHJlc3VsdC5zZXRDb21tb25UeXBlKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBcIkNhbid0IGV2YWx1YXRlIHBvbHltb3JwaGljIGxvZ2ljYWwgZXhwcmVzc2lvblwiKSk7XG4gICAgfSxcblxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgY29uc2VxdWVudCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5jb25zZXF1ZW50KSxcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5hbHRlcm5hdGUpLFxuICAgICAgICAgICAgdGVzdCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS50ZXN0KSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEFOTk8obm9kZSk7XG5cbiAgICAgICAgdmFyIHRlc3RSZXN1bHQgPSB0ZXN0LmdldFN0YXRpY1RydXRoVmFsdWUoKTtcbiAgICAgICAgaWYgKHRlc3RSZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb3B5RnJvbShjb25zZXF1ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0UmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvcHlGcm9tKGFsdGVybmF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNldENvbW1vblR5cGUoY29uc2VxdWVudCwgYWx0ZXJuYXRlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXREeW5hbWljVmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwiQ2FuJ3QgZXZhbHVhdGUgcG9seW1vcnBoaWMgY29uZGl0aW9uYWwgZXhwcmVzc2lvblwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcbiAgICBPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICBub2RlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBwID0gcHJvcGVydGllc1twcm9wZXJ0eS5rZXkubmFtZV0gPSBwcm9wZXJ0eS52YWx1ZS5leHRyYTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLk9CSkVDVCk7XG4gICAgICAgIHJlc3VsdC5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKTtcbiAgICAgICAgcmVzdWx0LmNvcHlGcm9tKGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS52YWx1ZSkpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGFzdCwgcHJvcGFnYXRlZENvbnN0YW50cywgYW5hbHl6ZXIpIHtcblxuICAgIGlmICghYXN0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIk5vIG5vZGUgdG8gYW5hbHl6ZVwiKTtcblxuICAgIHZhciBjb250cm9sbGVyID0gbmV3IGVzdHJhdmVyc2UuQ29udHJvbGxlcigpO1xuXG4gICAgY29udGV4dC5zZXRDb25zdGFudHMocHJvcGFnYXRlZENvbnN0YW50cyB8fCBudWxsKTtcblxuICAgIGNvbnRyb2xsZXIudHJhdmVyc2UoYXN0LCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0SW5EZWNsYXJhdGlvbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzW25vZGUudHlwZV0uY2FsbCh0aGlzLCBub2RlLCBwYXJlbnQsIGNvbnRleHQsIGFuYWx5emVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWRcIiwgbm9kZS50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29udGV4dC5zZXRDb25zdGFudHMobnVsbCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xudmFyIFRZUEVTID0gU2hhZGUuVFlQRVM7XG5cbmZ1bmN0aW9uIEFycmF5KHJlc3VsdCwgYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEgfHwgIWFyZ3NbMF0uY2FuTnVtYmVyKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGFyZyBvZiB0eXBlIG51bWJlciBhbGxvd2VkXCIpO1xuXG4gICAgdmFyIHNpemU7XG4gICAgaWYgKGFyZ3NbMF0uaGFzQ29uc3RhbnRWYWx1ZSgpKVxuICAgICAgICBzaXplID0gYXJnc1swXS5nZXRDb25zdGFudFZhbHVlKCk7XG5cbiAgICBpZiAoc2l6ZSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIHN0YXRpY1NpemU6IHNpemUsXG4gICAgICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYW55XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYW55XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbn1cblxuQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IHtcbiAgICB0eXBlOiBUWVBFUy5JTlQsXG4gICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBmdW5jdGlvbiAocmVzdWx0LCBzY29wZSwgb2JqZWN0T2ZJbnRlcmVzdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0T2ZJbnRlcmVzdC5nZXRBcnJheVNpemUoKTtcbiAgICB9XG59O1xuXG5BcnJheS5wcm90b3R5cGUuc2hhcGUgPSB7XG4gICAgdHlwZTogVFlQRVMuQVJSQVksXG4gICAgZWxlbWVudHM6IHtcbiAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLklOVFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgVHlwZVN5c3RlbSA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlLXN5c3RlbS90eXBlLXN5c3RlbS5qc1wiKTtcbnZhciBTY29wZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsc1wiKS5TY29wZTtcbnZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvaW5kZXguanNcIik7XG5cbnZhciBJbmZlcmVuY2VTY29wZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnRTY29wZSwgb3B0KSB7XG5cdFNjb3BlLmNhbGwodGhpcywgbm9kZSwgcGFyZW50U2NvcGUsIG9wdCk7XG59O1xuXG5CYXNlLmNyZWF0ZUNsYXNzKEluZmVyZW5jZVNjb3BlLCBTY29wZSwge1xuXHRyZWdpc3Rlckdsb2JhbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiTWF0aFwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJNYXRoXCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiVmVjMlwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJWZWMyXCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiVmVjM1wiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJWZWMzXCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiVmVjNFwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJWZWM0XCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiTWF0M1wiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJNYXQzXCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiTWF0NFwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJNYXQ0XCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwidGhpc1wiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJTeXN0ZW1cIikpO1xuXHRcdHRoaXMuZGVjbGFyZVByZWRlZmluZWQoXCJTcGFjZVwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJTcGFjZVwiKSk7XG5cdFx0dGhpcy5kZWNsYXJlUHJlZGVmaW5lZChcIk9iamVjdFwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJPYmplY3RcIikpO1xuXHRcdHRoaXMuZGVjbGFyZVByZWRlZmluZWQoXCJTaGFkZVwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJTaGFkZVwiKSk7XG5cdFx0dGhpcy5kZWNsYXJlUHJlZGVmaW5lZChcIkFycmF5XCIsIFR5cGVTeXN0ZW0uZ2V0UHJlZGVmaW5lZE9iamVjdChcIkFycmF5XCIpKTtcblx0XHR0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiVGV4dHVyZVwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJUZXh0dXJlXCIpKTtcblx0fVxufSk7XG5cbmV4cG9ydHMuSW5mZXJlbmNlU2NvcGUgPSBJbmZlcmVuY2VTY29wZTtcblxuIiwidmFyIHRvb2xzID0gcmVxdWlyZShcIi4vdmVjX3Rvb2xzXCIpO1xuXG52YXIgTWF0MyA9IGZ1bmN0aW9uIE1hdDMobm9kZSwgYXJndW1lbnRzKSB7XG4gICAgcmV0dXJuIHRvb2xzLmV2YWx1YXRlQ29uc3RydWN0b3IoXCIzeDNcIiwgbm9kZSwgYXJndW1lbnRzKTtcbn07XG5cbnRvb2xzLmF0dGFjaE1ldGhvZHMoTWF0My5wcm90b3R5cGUsIFtcImludmVydFwiLCBcInRyYW5zcG9zZVwiXSwgXCIzeDNcIiwgXCIzeDNcIik7XG50b29scy5hdHRhY2hFbGVtZW50QWNjZXNzb3IoTWF0My5wcm90b3R5cGUsIDMpO1xudG9vbHMuYXR0YWNoQ29sdW1uQWNjZXNzb3IoTWF0My5wcm90b3R5cGUsIDMpO1xudG9vbHMuYXR0YWNoTXVsTWV0aG9kKE1hdDMucHJvdG90eXBlLCBcIjN4M1wiLCAzKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWF0MztcbiIsInZhciB0b29scyA9IHJlcXVpcmUoXCIuL3ZlY190b29sc1wiKTtcblxudmFyIE1hdDQgPSBmdW5jdGlvbiBNYXQ0KG5vZGUsIGFyZ3VtZW50cykge1xuICAgIHJldHVybiB0b29scy5ldmFsdWF0ZUNvbnN0cnVjdG9yKFwiNHg0XCIsIG5vZGUsIGFyZ3VtZW50cyk7XG59O1xuXG50b29scy5hdHRhY2hNZXRob2RzKE1hdDQucHJvdG90eXBlLCBbXCJpbnZlcnRcIiwgXCJ0cmFuc3Bvc2VcIl0sIFwiNHg0XCIsIFwiNHg0XCIpO1xudG9vbHMuYXR0YWNoRWxlbWVudEFjY2Vzc29yKE1hdDQucHJvdG90eXBlLCA0KTtcbnRvb2xzLmF0dGFjaENvbHVtbkFjY2Vzc29yKE1hdDQucHJvdG90eXBlLCA0KTtcbnRvb2xzLmF0dGFjaE11bE1ldGhvZChNYXQ0LnByb3RvdHlwZSwgXCI0eDRcIiwgNCk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1hdDQ7XG4iLCJ2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcblx0VFlQRVMgPSBTaGFkZS5UWVBFUyxcblx0QmFzZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxuXHRUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xuXG5cblxudmFyIG5vdFN0YXRpYyA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbnZhciBldmFsdWF0ZVN0YXRpYyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHJldHVybiBmdW5jdGlvbiAocmVzdWx0LCBhcmdzKSB7XG5cdFx0aWYgKFRvb2xzLmFsbEFyZ3VtZW50c0FyZVN0YXRpYyhhcmdzKSkge1xuXHRcdFx0dmFyIGNhbGxBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcblx0XHRcdFx0cmV0dXJuIGEuZ2V0Q29uc3RhbnRWYWx1ZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gTWF0aFtuYW1lXS5hcHBseShudWxsLCBjYWxsQXJncyk7XG5cdFx0fVxuXHR9XG59XG5cbnZhciBldmFsdWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbUNvdW50LCByZXR1cm5UeXBlKSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0Fubm90YXRpb259IHJlc3VsdFxuXHQgKiBAcGFyYW0ge0FycmF5LjxBbm5vdGF0aW9uPn0gYXJnc1xuXHQgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxuXHQgKi9cblx0cmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MsIGN0eCkge1xuXHRcdGlmIChwYXJhbUNvdW50ICE9IC0xKSB7IC8vIEFyYml0cmFyeSBudW1iZXIgb2YgYXJndW1lbnRzXG5cdFx0XHRpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggIT0gcGFyYW1Db3VudCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzIGZvciBNYXRoLlwiICsgbmFtZSArIFwiLCBleHBlY3RlZCBcIiArIHBhcmFtQ291bnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtQ291bnQ7IGkrKykge1xuXHRcdFx0aWYgKCFhcmdzW2ldLmNhbk51bWJlcigpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBcIiArIChpICsgMSkgKyBcIiBoYXMgaW52YWxpZCB0eXBlIGZvciBNYXRoLlwiICsgbmFtZSArIFwiLCBleHBlY3RlZCAnbnVtYmVyJywgYnV0IGdvdCBcIiArIGFyZ3NbaV0uZ2V0VHlwZSgpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogcmV0dXJuVHlwZSB8fCBUWVBFUy5OVU1CRVJcblx0XHR9O1xuXHR9XG59O1xuXG52YXIgTWF0aE9iamVjdCA9IHtcblx0cmFuZG9tOiB7XG5cdFx0dHlwZTogVFlQRVMuRlVOQ1RJT04sXG5cdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uIChub2RlLCBhcmdzKSB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGgpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1hdGgucmFuZG9tIGhhcyBubyBwYXJhbWV0ZXJzLlwiKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6IFRZUEVTLk5VTUJFUlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29tcHV0ZVN0YXRpY1ZhbHVlOiBub3RTdGF0aWNcblx0fSxcblx0YWJzOiB7XG5cdFx0dHlwZTogVFlQRVMuRlVOQ1RJT04sXG5cdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MpIHtcblx0XHRcdFRvb2xzLmNoZWNrUGFyYW1Db3VudChyZXN1bHQubm9kZSwgXCJNYXRoLmFic1wiLCBbMV0sIGFyZ3MubGVuZ3RoKTtcblx0XHRcdHZhciB0eXBlSW5mbyA9IHt9O1xuXHRcdFx0aWYgKGFyZ3NbMF0uY2FuTnVtYmVyKCkpIHtcblx0XHRcdFx0dHlwZUluZm8udHlwZSA9IGFyZ3NbMF0uZ2V0VHlwZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdEVycm9yLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiSW52YWxpZFR5cGUgZm9yIE1hdGguYWJzXCIpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVE9ETzogU3RhdGljIHZhbHVlXG5cdFx0XHRyZXR1cm4gdHlwZUluZm87XG5cdFx0fSxcblx0XHRjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKFwiYWJzXCIpXG5cdH0sXG5cblxuXHQvLyBOb24tc3RhbmRhcmQgbWV0aG9kc1xuXHRjbGFtcDoge1xuXHRcdHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxuXHRcdGV2YWx1YXRlOiBmdW5jdGlvbiAocmVzdWx0LCBhcmdzKSB7XG5cdFx0XHRUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiTWF0aC5jbGFtcFwiLCBbM10sIGFyZ3MubGVuZ3RoKTtcblxuXHRcdFx0aWYgKGFyZ3NbMV0uY2FuTnVtYmVyKCkgJiYgYXJnc1syXS5jYW5OdW1iZXIoKSkge1xuXHRcdFx0XHR2YXIgdHlwZUluZm8gPSB7fTtcblx0XHRcdFx0aWYgKGFyZ3NbMF0uY2FuTnVtYmVyKCkpIHtcblx0XHRcdFx0XHR0eXBlSW5mby50eXBlID0gVFlQRVMuTlVNQkVSO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGFyZ3NbMF0uaXNWZWN0b3IoKSkge1xuXHRcdFx0XHRcdHR5cGVJbmZvLnR5cGUgPSBhcmdzWzBdLmdldFR5cGUoKTtcblx0XHRcdFx0XHR0eXBlSW5mby5raW5kID0gYXJnc1swXS5nZXRLaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHR5cGVJbmZvO1xuXHRcdFx0fVxuXHRcdFx0RXJyb3IudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJNYXRoLmNsYW1wIG5vdCBzdXBwb3J0ZWQgd2l0aCBhcmd1bWVudCB0eXBlczogXCIgKyBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG5cdFx0XHRcdHJldHVybiBhcmcuZ2V0VHlwZVN0cmluZygpO1xuXHRcdFx0fSkuam9pbihcIiwgXCIpKTtcblx0XHR9LFxuXHRcdGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMoXCJjbGFtcFwiKVxuXG5cdH0sXG5cdHNtb290aHN0ZXA6IHtcblx0XHR0eXBlOiBUWVBFUy5GVU5DVElPTixcblx0XHRldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4KSB7XG5cdFx0XHRUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiTWF0aC5zbW9vdGhzdGVwXCIsIFszXSwgYXJncy5sZW5ndGgpO1xuXG5cdFx0XHRpZiAoYXJncy5ldmVyeShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdHJldHVybiBlLmNhbk51bWJlcigpO1xuXHRcdFx0XHR9KSkge1xuXHRcdFx0XHRyZXR1cm4ge3R5cGU6IFRZUEVTLk5VTUJFUn07XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5ldmVyeShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdHJldHVybiBlLmlzVmVjdG9yKCk7XG5cdFx0XHRcdH0pKSB7XG5cdFx0XHRcdGlmICghKGFyZ3NbMF0uZXF1YWxzKGFyZ3NbMV0pICYmIGFyZ3NbMV0uZXF1YWxzKGFyZ3NbMl0pKSkge1xuXHRcdFx0XHRcdHRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiTWF0aC5zbW9vdGhzdGVwOiBBbGwgYXJndW1lbnRzIGhhdmUgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlOiBcIiArIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhcmcuZ2V0VHlwZVN0cmluZygpO1xuXHRcdFx0XHRcdH0pLmpvaW4oXCIsIFwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFRZUEVTLk9CSkVDVCxcblx0XHRcdFx0XHRraW5kOiBhcmdzWzBdLmdldEtpbmQoKVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdDtcblx0XHRcdEVycm9yLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiTWF0aC5zbW9vdGhzdGVwIG5vdCBzdXBwb3J0ZWQgd2l0aCBhcmd1bWVudCB0eXBlczogXCIgKyBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG5cdFx0XHRcdHJldHVybiBhcmcuZ2V0VHlwZVN0cmluZygpO1xuXHRcdFx0fSkuam9pbihcIiwgXCIpKTtcblx0XHR9LFxuXHRcdGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMoXCJzbW9vdGhzdGVwXCIpXG5cdH0sXG5cdHN0ZXA6IHtcblx0XHR0eXBlOiBUWVBFUy5GVU5DVElPTixcblx0XHRldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4KSB7XG5cdFx0XHRUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiU2hhZGUuc3RlcFwiLCBbMl0sIGFyZ3MubGVuZ3RoKTtcblxuXHRcdFx0aWYgKFRvb2xzLmFsbEFyZ3VtZW50c0Nhbk51bWJlcihhcmdzKSkge1xuXHRcdFx0XHRyZXR1cm4ge3R5cGU6IFRZUEVTLk5VTUJFUn1cblx0XHRcdH1cblx0XHRcdEVycm9yLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiU2hhZGUuc3RlcCBub3Qgc3VwcG9ydGVkIHdpdGggYXJndW1lbnQgdHlwZXM6IFwiICsgYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuXHRcdFx0XHRyZXR1cm4gYXJnLmdldFR5cGVTdHJpbmcoKTtcblx0XHRcdH0pLmpvaW4oXCIsIFwiKSk7XG5cdFx0fSxcblx0XHRjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKFwic3RlcFwiKVxuXHR9LFxuXHRmcmFjdDogIHtcblx0XHRcdHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxuXHRcdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MsIGN0eCkge1xuXHRcdFx0XHRUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiU2hhZGUuZnJhY3RcIiwgWzFdLCBhcmdzLmxlbmd0aCk7XG5cblx0XHRcdFx0aWYgKFRvb2xzLmFsbEFyZ3VtZW50c0Nhbk51bWJlcihhcmdzKSkge1xuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogVFlQRVMuTlVNQkVSfVxuXHRcdFx0XHR9XG5cdFx0XHRcdEVycm9yLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiU2hhZGUuc3RlcCBub3Qgc3VwcG9ydGVkIHdpdGggYXJndW1lbnQgdHlwZXM6IFwiICsgYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuXHRcdFx0XHRcdHJldHVybiBhcmcuZ2V0VHlwZVN0cmluZygpO1xuXHRcdFx0XHR9KS5qb2luKFwiLCBcIikpO1xuXHRcdH0sXG5cdFx0Y29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhcImZyYWN0XCIpXG5cdH0sXG5cblx0bWl4OiB7XG5cdFx0dHlwZTogVFlQRVMuRlVOQ1RJT04sXG5cdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MsIGN0eCkge1xuXHRcdFx0VG9vbHMuY2hlY2tQYXJhbUNvdW50KHJlc3VsdC5ub2RlLCBcIk1hdGgubWl4XCIsIFszXSwgYXJncy5sZW5ndGgpO1xuXG5cdFx0XHR2YXIgY250ID0gVG9vbHMuVmVjLmNoZWNrQW55VmVjQXJndW1lbnQocmVzdWx0Lm5vZGUsIFwiTWF0aC5taXhcIiwgYXJnc1swXSk7XG5cblx0XHRcdHZhciB0eXBlSW5mbyA9IHt9O1xuXHRcdFx0QmFzZS5leHRlbmQodHlwZUluZm8sIFRvb2xzLlZlYy5nZXRUeXBlKGNudCkpO1xuXG5cdFx0XHRpZiAoIWFyZ3NbMV0uZXF1YWxzKGFyZ3NbMF0pKVxuXHRcdFx0XHRFcnJvci50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIk1hdGgubWl4IHR5cGVzIG9mIGZpcnN0IHR3byBhcmd1bWVudHMgZG8gbm8gbWF0Y2g6IGdvdCBcIiArIGFyZ3NbMF0uZ2V0VHlwZVN0cmluZygpICtcblx0XHRcdFx0XCIgYW5kIFwiICsgYXJnc1sxXS5nZXRUeXBlU3RyaW5nKCkpO1xuXHRcdFx0aWYgKCFhcmdzWzJdLmNhbk51bWJlcigpKVxuXHRcdFx0XHRFcnJvci50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIk1hdGgubWl4IHRoaXJkIGFyZ3VtZW50IGlzIG5vdCBhIG51bWJlci5cIik7XG5cblx0XHRcdHJldHVybiB0eXBlSW5mbztcblx0XHR9LFxuXHRcdGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMoXCJtaXhcIilcblx0fSxcblx0c2F0dXJhdGU6IHtcblx0XHR0eXBlOiBUWVBFUy5GVU5DVElPTixcblx0XHRldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4KSB7XG5cdFx0XHRUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiU2hhZGUuc2F0dXJhdGVcIiwgWzFdLCBhcmdzLmxlbmd0aCk7XG5cblx0XHRcdHZhciB0eXBlSW5mbyA9IHtcblx0XHRcdFx0dHlwZTogVFlQRVMuTlVNQkVSXG5cdFx0XHR9XG5cdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdGlmICghYXJnLmNhbk51bWJlcigpKSB7XG5cdFx0XHRcdEVycm9yLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiTWF0aC5zYXR1cmF0ZSBub3Qgc3VwcG9ydGVkIHdpdGggYXJndW1lbnQgdHlwZTogXCIgKyBhcmcuZ2V0VHlwZVN0cmluZygpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0eXBlSW5mbztcblx0XHR9LFxuXHRcdGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMoXCJzYXR1cmF0ZVwiKVxuXHR9XG59O1xuXG52YXIgTWF0aENvbnN0YW50cyA9IFtcIkVcIiwgXCJQSVwiLCBcIkxOMlwiLCBcIkxPRzJFXCIsIFwiTE9HMTBFXCIsIFwiUElcIiwgXCJTUVJUMV8yXCIsIFwiU1FSVDJcIl07XG52YXIgT25lUGFyYW1ldGVyTnVtYmVyTWV0aG9kcyA9IFtcImFjb3NcIiwgXCJhc2luXCIsIFwiYXRhblwiLCBcImNvc1wiLCBcImV4cFwiLCBcImxvZ1wiLCBcInJvdW5kXCIsIFwic2luXCIsIFwic3FydFwiLCBcInRhblwiLCBcImNlaWxcIiwgXCJmbG9vclwiXTtcbnZhciBPbmVQYXJhbWV0ZXJJbnRNZXRob2RzID0gW107XG52YXIgVHdvUGFyYW1ldGVyTnVtYmVyTWV0aG9kcyA9IFtcImF0YW4yXCIsIFwicG93XCJdO1xudmFyIEFyYml0cmFyeVBhcmFtZXRlck51bWJlck1ldGhvZHMgPSBbXCJtYXhcIiwgXCJtaW5cIl07XG5cbk1hdGhDb25zdGFudHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RhbnQpIHtcblx0TWF0aE9iamVjdFtjb25zdGFudF0gPSB7dHlwZTogVFlQRVMuTlVNQkVSLCBjb25zdGFudFZhbHVlOiBNYXRoW2NvbnN0YW50XX07XG59KTtcblxuT25lUGFyYW1ldGVyTnVtYmVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcblx0TWF0aE9iamVjdFttZXRob2RdID0ge1xuXHRcdHR5cGU6IFRZUEVTLkZVTkNUSU9OLCBldmFsdWF0ZTogZXZhbHVhdGVNZXRob2QobWV0aG9kLCAxKSwgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhtZXRob2QpXG5cdH07XG59KTtcblxuVHdvUGFyYW1ldGVyTnVtYmVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcblx0TWF0aE9iamVjdFttZXRob2RdID0ge1xuXHRcdHR5cGU6IFRZUEVTLkZVTkNUSU9OLCBldmFsdWF0ZTogZXZhbHVhdGVNZXRob2QobWV0aG9kLCAyKSwgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhtZXRob2QpXG5cdH07XG59KTtcblxuT25lUGFyYW1ldGVySW50TWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcblx0TWF0aE9iamVjdFttZXRob2RdID0ge1xuXHRcdHR5cGU6IFRZUEVTLkZVTkNUSU9OLCBldmFsdWF0ZTogZXZhbHVhdGVNZXRob2QobWV0aG9kLCAxLCBUWVBFUy5JTlQpLCBjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKG1ldGhvZClcblx0fTtcbn0pO1xuXG5BcmJpdHJhcnlQYXJhbWV0ZXJOdW1iZXJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRNYXRoT2JqZWN0W21ldGhvZF0gPSB7XG5cdFx0dHlwZTogVFlQRVMuRlVOQ1RJT04sIGV2YWx1YXRlOiBldmFsdWF0ZU1ldGhvZChtZXRob2QsIC0xKSwgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhtZXRob2QpXG5cdH07XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogXCJNYXRoXCIsXG5cdHByb3BlcnRpZXM6IE1hdGhPYmplY3Rcbn07XG5cblxuXG5cbiIsInZhciBPYmogPSBmdW5jdGlvbiBPYmplY3QoKSB7XG5cdHJldHVybiB7dHlwZTogXCJvYmplY3RcIn07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iajtcbiIsInZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLCBUWVBFUyA9IFNoYWRlLlRZUEVTLFxuXHRLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EU1xuXG52YXIgU2hhZGVPYmplY3QgPSB7fTtcblxuT2JqZWN0LmtleXMoU2hhZGUuQ29sb3JDbG9zdXJlcylcblx0LmZvckVhY2goZnVuY3Rpb24oY2xvc3VyZU5hbWUpIHtcblx0XHR2YXIgcGFyYW1zID0gU2hhZGUuQ29sb3JDbG9zdXJlc1tjbG9zdXJlTmFtZV0uaW5wdXQ7XG5cdFx0U2hhZGVPYmplY3RbY2xvc3VyZU5hbWVdID0ge1xuXHRcdFx0dHlwZTogVFlQRVMuRlVOQ1RJT04sXG5cdFx0XHRuYW1lOiBjbG9zdXJlTmFtZSxcblx0XHRcdGV2YWx1YXRlOiBmdW5jdGlvbihub2RlLFxuXHRcdFx0XHRcdFx0XHQgICBhcmdzIC8qLCBjb250ZXh0LCBvYmplY3RSZWZlcmVuY2UsIHJvb3QgKi8pIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaSA+PSBhcmdzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtc1tpXS5kZWZhdWx0VmFsdWUgIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0U2hhZGUudGhyb3dFcnJvcihub2RlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgXCJBcmd1bWVudCBcIiArIChpICsgMSkgKyBcIiBvZiBTaGFkZS5cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCArIGNsb3N1cmVOYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICsgXCIgaXMgcmVxdWlyZWQgYnV0IG5vdCBnaXZlbi5cIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFRPRE8oa3NvbnMpOiBOZWVkIGEgbW9yZSBnZW5lcmljIGNhbkNhc3RUbyBtZXRob2QgaW5cblx0XHRcdFx0XHRcdC8vIHR5cGUgc3lzdGVtXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHBhcmFtc1tpXS5zZW1hbnRpYykge1xuXHRcdFx0XHRcdFx0Y2FzZSBTaGFkZS5TRU1BTlRJQ1MuQ09MT1I6XG5cdFx0XHRcdFx0XHRcdGlmICghYXJnc1tpXS5jYW5Db2xvcigpKSB7XG5cdFx0XHRcdFx0XHRcdFx0U2hhZGUudGhyb3dFcnJvcihcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcIkFyZ3VtZW50IFwiICsgKGkgKyAxKSArIFwiIG9mIFNoYWRlLlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsgY2xvc3VyZU5hbWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KyBcIiBtdXN0IGV2YWx1YXRlIHRvIGEgY29sb3IsIGZvdW5kIFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsgYXJnc1tpXS5nZXRUeXBlU3RyaW5nKCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBTaGFkZS5TRU1BTlRJQ1MuTk9STUFMOlxuXHRcdFx0XHRcdFx0XHRpZiAoIWFyZ3NbaV0uY2FuTm9ybWFsKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRTaGFkZS50aHJvd0Vycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHRcdFx0XHRcdFwiQXJndW1lbnQgXCIgKyAoaSArIDEpICsgXCIgb2YgU2hhZGUuXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0KyBjbG9zdXJlTmFtZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrIFwiIG11c3QgZXZhbHVhdGUgdG8gYSBub3JtYWwsIGZvdW5kIFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsgYXJnc1tpXS5nZXRUeXBlU3RyaW5nKCkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETyhrc29ucyk6IE1vcmUgdHlwZSBjaGVja3Ncblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHt0eXBlOiBUWVBFUy5PQkpFQ1QsIGtpbmQ6IEtJTkRTLkNPTE9SX0NMT1NVUkV9O1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuU2hhZGVPYmplY3QubWl4ID0ge1xuXHR0eXBlOiBUWVBFUy5GVU5DVElPTixcblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7dHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBLSU5EUy5DT0xPUl9DTE9TVVJFfTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6IFwiU2hhZGVcIixcblx0cHJvcGVydGllczogU2hhZGVPYmplY3Rcbn07IiwidmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XG52YXIgVFlQRVMgPSBTaGFkZS5UWVBFUztcblxudmFyIFNwYWNlT2JqZWN0ID0ge1xuICAgIHRyYW5zZm9ybURpcmVjdGlvbjoge1xuICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPSAyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zZm9ybURpcmVjdGlvbiBleHBlY3RzIDIgcGFyYW1ldGVycy5cIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBraW5kOiBcIlZlYzNcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJhbnNmb3JtUG9pbnQ6IHtcbiAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAocmVzdWx0LCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT0gMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2Zvcm1Qb2ludCBleHBlY3RzIDIgcGFyYW1ldGVycy5cIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBraW5kOiBcIlZlYzNcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgVklFVzoge3R5cGU6IFRZUEVTLk5VTUJFUn0sXG4gICAgV09STEQ6IHt0eXBlOiBUWVBFUy5OVU1CRVJ9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBuYW1lOiBcIlNwYWNlXCIsXG4gICAgcHJvcGVydGllczogU3BhY2VPYmplY3Rcbn07XG4iLCJ2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcbiAgICBCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvaW5kZXguanNcIiksXG4gICAgVG9vbHMgPSByZXF1aXJlKFwiLi90b29scy5qc1wiKTtcbnZhciBUeXBlSW5mbyA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlLXN5c3RlbS90eXBlaW5mby5qc1wiKTtcblxuXG52YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcbiAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcblxuXG5cbmZ1bmN0aW9uIGFsbG93TnVtYmVyT3JWZWN0b3IobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgYXJncykge1xuICAgICAgICBUb29scy5jaGVja1BhcmFtQ291bnQobm9kZSwgbmFtZSwgWzFdLCBhcmdzLmxlbmd0aCk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoYXJnLmNhbk51bWJlcigpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGFyZy5nZXRUeXBlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnLmlzVmVjdG9yKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuT0JKRUNULFxuICAgICAgICAgICAgICAgIGtpbmQ6IGFyZy5nZXRLaW5kKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSWxsZWdhbEFyZ3VtZW50RXJyb3I6IGZpcnN0IGFyZ3VtZW50IG9mIHRoaXMuXCIgKyBuYW1lICsgXCIgaXMgb2YgdHlwZTogXCIgKyBhcmcuZ2V0VHlwZVN0cmluZygpKTtcbiAgICB9XG59XG5cblxudmFyIERlcml2YXRpdmVzTWV0aG9kcyA9IHtcbiAgICBmd2lkdGg6IHtcbiAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXG4gICAgICAgIGV2YWx1YXRlOiBhbGxvd051bWJlck9yVmVjdG9yKFwiZndpZHRoXCIpXG4gICAgfSxcbiAgICBkeDoge1xuICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcbiAgICAgICAgZXZhbHVhdGU6IGFsbG93TnVtYmVyT3JWZWN0b3IoXCJkeFwiKVxuICAgIH0sXG4gICAgZHk6IHtcbiAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXG4gICAgICAgIGV2YWx1YXRlOiBhbGxvd051bWJlck9yVmVjdG9yKFwiZHlcIilcbiAgICB9XG59O1xuXG52YXIgU3lzdGVtID0ge1xuICAgIG5hbWU6IFwiU3lzdGVtXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBub3JtYWxpemVkQ29vcmRzOiB7XG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXG4gICAgICAgICAgICBraW5kOiBcIlZlYzNcIixcbiAgICAgICAgICAgIGRlcml2ZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY29vcmRzOiB7XG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXG4gICAgICAgICAgICBraW5kOiBcIlZlYzNcIixcbiAgICAgICAgICAgIGRlcml2ZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5JTlQsXG4gICAgICAgICAgICBkZXJpdmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5JTlQsXG4gICAgICAgICAgICBkZXJpdmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldERlcml2YXRpdmVzOiBmdW5jdGlvbiAoYXZhaWxhYmxlKSB7XG4gICAgICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgICAgICAgIEJhc2UuZXh0ZW5kKFN5c3RlbS5wcm9wZXJ0aWVzLCBEZXJpdmF0aXZlc01ldGhvZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBEZXJpdmF0aXZlc01ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgU3lzdGVtLnByb3BlcnRpZXNbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcbnZhciBUWVBFUyA9IFNoYWRlLlRZUEVTO1xudmFyIHRvb2xzID0gcmVxdWlyZShcIi4vdmVjX3Rvb2xzXCIpO1xuXG5mdW5jdGlvbiBUZXh0dXJlKHJlc3VsdCwgYXJncywgY3R4KSB7XG4gICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKGFyZ3NbMF0uaGFzQ29uc3RhbnRWYWx1ZSgpKVxuICAgICAgICB3aWR0aCA9IGFyZ3NbMF0uZ2V0Q29uc3RhbnRWYWx1ZSgpO1xuICAgIGlmIChhcmdzWzFdLmhhc0NvbnN0YW50VmFsdWUoKSlcbiAgICAgICAgaGVpZ2h0ID0gYXJnc1swXS5nZXRDb25zdGFudFZhbHVlKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBraW5kOiBcIlRleHR1cmVcIixcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gICAgLy8gU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJDb25zdHJ1Y3Rpb24gb2YgVGV4dHVyZXMgaXMgbm90IHN1cHBvcnRlZC5cIiApO1xufVxuXG50b29scy5hdHRhY2hNZXRob2RzKFRleHR1cmUucHJvdG90eXBlLCBbJ3NhbXBsZTJEJ10sIDQsIDIpO1xuXG5UZXh0dXJlLnByb3RvdHlwZS53aWR0aCA9IHtcbiAgICB0eXBlOiBUWVBFUy5JTlRcbn07XG5UZXh0dXJlLnByb3RvdHlwZS5oZWlnaHQgPSB7XG4gICAgdHlwZTogVFlQRVMuSU5UXG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuIiwiKGZ1bmN0aW9uKG5zKXtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlL3V0aWxzXCIpO1xuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvaW5kZXguanNcIik7XG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXG4gICAgICAgIFRZUEVTID0gU2hhZGUuVFlQRVMsXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTLFxuICAgICAgICBWZWNCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvdmVjLmpzXCIpO1xuXG4gICAgdmFyIGFsbEFyZ3VtZW50c0FyZUNvbnN0YW50ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZy5oYXNDb25zdGFudFZhbHVlKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbnMuYWxsQXJndW1lbnRzQ2FuTnVtYmVyID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnLmNhbk51bWJlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBucy5jaGVja1BhcmFtQ291bnQgPSBmdW5jdGlvbihub2RlLCBuYW1lLCBhbGxvd2VkLCBpcykge1xuICAgICAgICBpZiAoYWxsb3dlZC5pbmRleE9mKGlzKSA9PSAtMSkge1xuICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkludmFsaWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgZm9yIFwiICsgbmFtZSArIFwiLCBleHBlY3RlZCBcIiArIGFsbG93ZWQuam9pbihcIiBvciBcIikgKyBcIiwgZm91bmQ6IFwiICsgaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbnMuc2luZ2xlQWNjZXNzb3IgPSBmdW5jdGlvbiAobmFtZSwgb2JqLCB2YWxpZEFyZ0NvdW50cywgc3RhdGljVmFsdWVGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgbnMuY2hlY2tQYXJhbUNvdW50KHJlc3VsdC5ub2RlLCBuYW1lLCB2YWxpZEFyZ0NvdW50cywgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9ICBhcmdzLmxlbmd0aCA/IG9iaiA6IHsgdHlwZTogVFlQRVMuTlVNQkVSIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljVmFsdWVGdW5jdGlvbiAmJiBjYWxsT2JqZWN0Lmhhc0NvbnN0YW50VmFsdWUoKSAmJiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uKGEpIHtyZXR1cm4gYS5oYXNDb25zdGFudFZhbHVlKCk7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLnN0YXRpY1ZhbHVlID0gc3RhdGljVmFsdWVGdW5jdGlvbihjYWxsT2JqZWN0LmdldENvbnN0YW50VmFsdWUoKSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBucy5leHRlbmQgPSBCYXNlLmV4dGVuZDtcblxuICAgIHZhciBWZWMgPSB7XG4gICAgICAgIFRZUEVTOiB7XG4gICAgICAgICAgICAxOiB7IHR5cGU6IFRZUEVTLk5VTUJFUiB9LFxuICAgICAgICAgICAgMjogeyB0eXBlOiBUWVBFUy5PQkpFQ1QsIGtpbmQ6IFwiVmVjMlwiIH0sXG4gICAgICAgICAgICAzOiB7IHR5cGU6IFRZUEVTLk9CSkVDVCwga2luZDogXCJWZWMzXCIgfSxcbiAgICAgICAgICAgIDQ6IHsgdHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBcIlZlYzRcIiB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uIChkZXN0VmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjLlRZUEVTW2Rlc3RWZWN0b3JdO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb25zdGFudFZhbHVlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSwgcmVzdWx0LCBjdHgsIGNhbGxPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChjYWxsT2JqZWN0Lmhhc0NvbnN0YW50VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBjYWxsT2JqZWN0LmdldENvbnN0YW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0W21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjaGVja0FueVZlY0FyZ3VtZW50OiBmdW5jdGlvbihhc3ROb2RlLCBtZXRob2ROYW1lLCBhcmcpe1xuICAgICAgICAgICAgdmFyIGNudDtcblxuICAgICAgICAgICAgaWYoYXJnLmNhbk51bWJlcigpKSBjbnQgPSAxO1xuICAgICAgICAgICAgZWxzZSBpZihhcmcuaXNPZktpbmQoXCJWZWMyXCIpKSBjbnQgPSAyO1xuICAgICAgICAgICAgZWxzZSBpZihhcmcuaXNPZktpbmQoXCJWZWMzXCIpKSBjbnQgPSAzO1xuICAgICAgICAgICAgZWxzZSBpZihhcmcuaXNPZktpbmQoXCJWZWM0XCIpKSBjbnQgPSA0O1xuICAgICAgICAgICAgZWxzZSBTaGFkZS50aHJvd0Vycm9yKGFzdE5vZGUsIFwiSW52YWxpZCBwYXJhbWV0ZXIgZm9yIFwiICsgbWV0aG9kTmFtZSArIFwiLCB0eXBlICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGFyZy5nZXRUeXBlU3RyaW5nKCkgKyBcIicgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrVmVjQXJndW1lbnRzOiBmdW5jdGlvbihtZXRob2ROYW1lLCB2ZWNTaXplLCB3aXRoRW1wdHksIGFyZ1N0YXJ0LCByZXN1bHQsIGFyZ3Mpe1xuICAgICAgICAgICAgd2l0aEVtcHR5ID0gKHdpdGhFbXB0eSB8fCB2ZWNTaXplID09IDApO1xuICAgICAgICAgICAgdmFyIGFsbG93ZWQgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IHdpdGhFbXB0eSA/IDAgOiAxOyBpIDw9IHZlY1NpemU7ICsraSkgYWxsb3dlZC5wdXNoKGkgKyBhcmdTdGFydCk7XG4gICAgICAgICAgICBucy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIG1ldGhvZE5hbWUsIGFsbG93ZWQsIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYod2l0aEVtcHR5ICYmIGFyZ3MubGVuZ3RoIC0gYXJnU3RhcnQgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoIC0gYXJnU3RhcnQ9PSAxICYmIGFyZ3NbMF0uY2FuTnVtYmVyKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IGFyZ1N0YXJ0OyBpZHggPCB2ZWNTaXplICYmIGkgPCBhcmdzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgYXJnPSBhcmdzW2ldLCBjbnQ7XG4gICAgICAgICAgICAgICAgaWYoYXJnLmNhbk51bWJlcigpKSBjbnQgPSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYoYXJnLmlzT2ZLaW5kKFwiVmVjMlwiKSkgY250ID0gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFyZy5pc09mS2luZChcIlZlYzNcIikpIGNudCA9IDM7XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhcmcuaXNPZktpbmQoXCJWZWM0XCIpKSBjbnQgPSA0O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYoYXJnLmlzT2ZLaW5kKFwiTWF0M1wiKSkgY250ID0gOTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFyZy5pc09mS2luZChcIk1hdDRcIikpIGNudCA9IDE2O1xuICAgICAgICAgICAgICAgIGVsc2UgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlciBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIsIHR5cGUgJ1wiICsgYXJnLmdldFR5cGVTdHJpbmcoKSArIFwiJyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgIGlkeCArPSBjbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlkeCA8IHZlY1NpemUpXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlcnMgZm9yIFwiICsgbWV0aG9kTmFtZSArIFwiLCBleHBlY3RlZCBcIiArIHZlY1NpemUgKyBcIiBzY2FsYXIgdmFsdWVzLCBnb3QgXCIgKyBpZHgpO1xuICAgICAgICAgICAgZWxzZSBpZihpIDwgYXJncy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiSW52YWxpZCBwYXJhbWV0ZXJzIGZvciBcIiArIG1ldGhvZE5hbWUgKyBcIiwgdG9vIG1hbnkgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB2ZWNFdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgbWV0aG9kTmFtZSwgZGVzdFZlY1NpemUsIHNyY1ZlY1NpemUsIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ2ZWNFdmFsdWF0ZVwiLCBvYmplY3ROYW1lLCBtZXRob2ROYW1lLCBkZXN0VmVjU2l6ZSwgc3JjVmVjU2l6ZSwgYXJncylcbiAgICAgICAgICAgIFZlYy5jaGVja1ZlY0FyZ3VtZW50cyhvYmplY3ROYW1lICsgXCIuXCIgKyBtZXRob2ROYW1lLCBzcmNWZWNTaXplLCBmYWxzZSwgMCwgcmVzdWx0LCBhcmdzKTtcblxuICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0ge307XG4gICAgICAgICAgICBCYXNlLmV4dGVuZCh0eXBlSW5mbywgVmVjLmdldFR5cGUoZGVzdFZlY1NpemUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xuICAgICAgICB9LFxuICAgICAgICBhbnlWZWNBcmd1bWVudEV2YWx1YXRlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpIHtcbiAgICAgICAgICAgIG5zLmNoZWNrUGFyYW1Db3VudChyZXN1bHQubm9kZSwgbWV0aG9kTmFtZSwgWzFdLCBhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1swXTtcblxuICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0ge307XG4gICAgICAgICAgICB2YXIgY250ID0gVmVjLmNoZWNrQW55VmVjQXJndW1lbnQocmVzdWx0Lm5vZGUsIG1ldGhvZE5hbWUsIGFyZyk7XG4gICAgICAgICAgICBCYXNlLmV4dGVuZCh0eXBlSW5mbywgVmVjLmdldFR5cGUoY250KSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlSW5mbztcbiAgICAgICAgfSxcblxuICAgICAgICBvcHRpb25hbFplcm9FdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgbWV0aG9kTmFtZSwgZGVzdFZlY1NpemUsIHplcm9EZXN0VmVjU2l6ZSwgc3JjVmVjU2l6ZSwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBxdWFsaWZpZWROYW1lID0gb2JqZWN0TmFtZSArIFwiLlwiICsgbWV0aG9kTmFtZTtcbiAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IHt9O1xuXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgICAgICBCYXNlLmV4dGVuZCh0eXBlSW5mbywgVmVjLmdldFR5cGUoemVyb0Rlc3RWZWNTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIFZlYy5jaGVja1ZlY0FyZ3VtZW50cyhxdWFsaWZpZWROYW1lLCBzcmNWZWNTaXplLCB0cnVlLCAwLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBWZWMuZ2V0VHlwZShkZXN0VmVjU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN3aXp6bGVFdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgdmVjU2l6ZSwgc3dpenpsZSwgd2l0aFNldHRlciwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpIHtcbiAgICAgICAgICAgIGlmKHdpdGhTZXR0ZXIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMub3B0aW9uYWxaZXJvRXZhbHVhdGUob2JqZWN0TmFtZSwgc3dpenpsZSwgdmVjU2l6ZSwgc3dpenpsZS5sZW5ndGgsIHN3aXp6bGUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWMudmVjRXZhbHVhdGUob2JqZWN0TmFtZSwgc3dpenpsZSwgc3dpenpsZS5sZW5ndGgsIDAsIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3dpenpsZU9wZXJhdG9yRXZhbHVhdGU6IGZ1bmN0aW9uKG9iamVjdE5hbWUsIHZlY1NpemUsIHN3aXp6bGUsIG9wZXJhdG9yLCByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIFZlYy52ZWNFdmFsdWF0ZShvYmplY3ROYW1lLCBzd2l6emxlICsgb3BlcmF0b3IsIHZlY1NpemUsIHN3aXp6bGUubGVuZ3RoLCByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN3aXp6bGVFdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgdmVjU2l6ZSwgc3dpenpsZSwgd2l0aFNldHRlcil7XG4gICAgICAgICAgICByZXR1cm4gIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5OVU1CRVIsXG4gICAgICAgICAgICAgICAgZXZhbHVhdGU6IFZlYy5zd2l6emxlRXZhbHVhdGUuYmluZChudWxsLCBvYmplY3ROYW1lLCB2ZWNTaXplLCBzd2l6emxlLCB3aXRoU2V0dGVyKSxcbiAgICAgICAgICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IFZlYy5nZXRDb25zdGFudFZhbHVlLmJpbmQobnVsbCwgc3dpenpsZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U3dpenpsZU9wZXJhdG9yRXZhbHVhdGU6IGZ1bmN0aW9uKG9iamVjdE5hbWUsIHZlY1NpemUsIHN3aXp6bGUsIG9wZXJhdG9yKXtcbiAgICAgICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxuICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBWZWMuc3dpenpsZU9wZXJhdG9yRXZhbHVhdGUuYmluZChudWxsLCBvYmplY3ROYW1lLCB2ZWNTaXplLCBzd2l6emxlLCBvcGVyYXRvciksXG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBWZWMuZ2V0Q29uc3RhbnRWYWx1ZS5iaW5kKG51bGwsIHN3aXp6bGUgKyBvcGVyYXRvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNoU3dpenpsZXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb2JqZWN0TmFtZSwgdmVjTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlL3V0aWxzXCIpO1xuXG4gICAgICAgICAgICB1dGlscy5hdHRhY2hTd2l6emxlcygyLCBmdW5jdGlvbiAoc3dpenpsZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgc3dpenpsZS5qb2luKFwiXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKGZ1bmN0aW9uIChzd2l6emxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5OVU1CRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTdGF0aWNWYWx1ZTogVmVjLmdldENvbnN0YW50VmFsdWUuYmluZChudWxsLCBzd2l6emxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoc3dpenpsZSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5OVU1CRVIsXG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBWZWMuc3dpenpsZUV2YWx1YXRlLmJpbmQobnVsbCwgb2JqZWN0TmFtZSwgdmVjTGVuZ3RoLCBzd2l6emxlKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBWZWMuZ2V0Q29uc3RhbnRWYWx1ZS5iaW5kKG51bGwsIHN3aXp6bGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaFZlY01ldGhvZHM6IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmplY3ROYW1lLCBkZXN0VmVjU2l6ZSwgc3JjVmVjU2l6ZSwgbWV0aG9kTmFtZXMpe1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBtZXRob2ROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VbbWV0aG9kTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBWZWMudmVjRXZhbHVhdGUuYmluZChudWxsLCBvYmplY3ROYW1lLCBtZXRob2ROYW1lLCBkZXN0VmVjU2l6ZSwgc3JjVmVjU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbnN0YW50VmFsdWVGcm9tQ29uc3RydWN0b3I6IGZ1bmN0aW9uKG9iamVjdE5hbWUsIGFyZ3Mpe1xuICAgICAgICAgICAgdmFyIGFyZ0FycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gaXNTdGF0aWMgJiYgcGFyYW0uaGFzQ29uc3RhbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgICAgICAgICAgICAgYXJnQXJyYXkucHVzaChwYXJhbS5nZXRDb25zdGFudFZhbHVlKCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gbmV3IFNoYWRlW29iamVjdE5hbWVdKCk7XG4gICAgICAgICAgICAgICAgU2hhZGVbb2JqZWN0TmFtZV0uYXBwbHkodiwgYXJnQXJyYXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcblxuICAgICAgICBjb25zdHJ1Y3RvckV2YWx1YXRlOiBmdW5jdGlvbihvYmplY3ROYW1lLCB2ZWNTaXplKSB7XG5cdFx0XHR2YXIgY29uc3RydWN0b3IgPSBmdW5jdGlvbiAocmVzdWx0LCBhcmdzKSB7XG5cdFx0XHRcdFZlYy5jaGVja1ZlY0FyZ3VtZW50cyhvYmplY3ROYW1lLCB2ZWNTaXplLCB0cnVlLCAwLCByZXN1bHQsIGFyZ3MpO1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gQmFzZS5leHRlbmQoe30sIFZlYy5nZXRUeXBlKHZlY1NpemUpKTtcblx0XHRcdFx0cmVzdWx0LmNvbnN0YW50VmFsdWUgPSBWZWMuZ2V0Q29uc3RhbnRWYWx1ZUZyb21Db25zdHJ1Y3RvcihvYmplY3ROYW1lLCBhcmdzKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHRcdGNvbnN0cnVjdG9yLnByb3RvID0ge307XG5cdFx0XHRyZXR1cm4gY29uc3RydWN0b3I7XG5cdFx0fVxuXG5cbiAgICB9O1xuXG4gICAgdmFyIE1hdCA9IHtcbiAgICAgICAgVFlQRVM6IHtcbiAgICAgICAgICAgIFwiTWF0M1wiOiB7IHR5cGU6IHsgdHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBLSU5EUy5NQVRSSVgzIH0sIGNvbHM6IDMsIHJvd3M6IDMgfSxcbiAgICAgICAgICAgIFwiTWF0NFwiOiB7IHR5cGU6IHsgdHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBLSU5EUy5NQVRSSVg0IH0sIGNvbHM6IDQsIHJvd3M6IDQgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbihtYXROYW1lKXtcbiAgICAgICAgICAgIHJldHVybiBNYXQuVFlQRVNbbWF0TmFtZV0udHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VmVjU2l6ZTogZnVuY3Rpb24obWF0TmFtZSl7XG4gICAgICAgICAgICByZXR1cm4gTWF0LlRZUEVTW21hdE5hbWVdLmNvbHMgKiBNYXQuVFlQRVNbbWF0TmFtZV0ucm93cztcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tNYXRBcmd1bWVudHM6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIG1hdE5hbWUsIHdpdGhFbXB0eSwgcmVzdWx0LCBhcmdzKXtcbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoID09IDEgJiYgKGFyZ3NbMF0uaXNPZktpbmQoS0lORFMuTUFUUklYMykgfHwgYXJnc1swXS5pc09mS2luZChLSU5EUy5NQVRSSVg0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgaWYoYXJnc1tpXS5pc09mS2luZChLSU5EUy5NQVRSSVgzKSB8fCBhcmdzW2ldLmlzT2ZLaW5kKEtJTkRTLk1BVFJJWDQpKVxuICAgICAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIkludmFsaWQgcGFyYW1ldGVyIGZvciBcIiArIG1ldGhvZE5hbWUgKyBcIjogQ29uc3RydWN0aW5nIE1hdHJpeCBmcm9tIE1hdHJpeCBjYW4gb25seSB0YWtlIG9uZSBhcmd1bWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZlYy5jaGVja1ZlY0FyZ3VtZW50cyhtZXRob2ROYW1lLCBNYXQuZ2V0VmVjU2l6ZShtYXROYW1lKSwgd2l0aEVtcHR5LCAwLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1hdEV2YWx1YXRlOiBmdW5jdGlvbihtYXROYW1lLCBtZXRob2ROYW1lLCByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCl7XG4gICAgICAgICAgICBNYXQuY2hlY2tNYXRBcmd1bWVudHMobWF0TmFtZSArIFwiLlwiICsgbWV0aG9kTmFtZSwgbWF0TmFtZSwgZmFsc2UsIHJlc3VsdCwgYXJncyk7XG5cbiAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IHt9O1xuICAgICAgICAgICAgQmFzZS5leHRlbmQodHlwZUluZm8sIE1hdC5nZXRUeXBlKG1hdE5hbWUpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1hdENvbnN0cnVjdG9yRXZhbHVhdGU6IGZ1bmN0aW9uKG1hdE5hbWUsIHJlc3VsdCwgYXJncywgY3R4KXtcbiAgICAgICAgICAgIE1hdC5jaGVja01hdEFyZ3VtZW50cyhtYXROYW1lLCBtYXROYW1lLCB0cnVlLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIFZlYy5nZXRDb25zdHJ1Y3RvclR5cGVJbmZvKG1hdE5hbWUsIE1hdC5nZXRWZWNTaXplKG1hdE5hbWUpLCBNYXQuZ2V0VHlwZShtYXROYW1lKSwgcmVzdWx0LCBhcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hNYXRNZXRob2RzOiBmdW5jdGlvbihpbnN0YW5jZSwgbWF0TmFtZSwgbWV0aG9kTmFtZXMpe1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlW21ldGhvZE5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IE1hdC5tYXRFdmFsdWF0ZS5iaW5kKG51bGwsIG1hdE5hbWUsIG1ldGhvZE5hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xFdmFsdWF0ZTogZnVuY3Rpb24obWF0TmFtZSwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBxdWFsaWZpZWROYW1lID0gbWF0TmFtZSArIFwiLmNvbFwiO1xuICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0ge307XG5cbiAgICAgICAgICAgIHZhciBjb2xzID0gTWF0LlRZUEVTW21hdE5hbWVdLmNvbHMsIHJvd3MgPSBNYXQuVFlQRVNbbWF0TmFtZV0ucm93cztcblxuICAgICAgICAgICAgaWYoYXJncy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICBWZWMuY2hlY2tWZWNBcmd1bWVudHMocXVhbGlmaWVkTmFtZSwgcm93cywgdHJ1ZSwgMSwgcmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBCYXNlLmV4dGVuZCh0eXBlSW5mbywgTWF0LmdldFR5cGUobWF0TmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBucy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIHF1YWxpZmllZE5hbWUsIFsxXSwgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBWZWMuZ2V0VHlwZShyb3dzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighYXJnc1swXS5jYW5OdW1iZXIoKSl7XG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlciBmb3IgXCIgKyBxdWFsaWZpZWROYW1lICsgXCIsIGZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogVmVjLmdldENvbnN0YW50VmFsdWUodHlwZUluZm8sIFwiY29sXCIsIGFyZ3MsIGNhbGxPYmplY3QpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHlwZUluZm87XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG5zLlZlYyA9IFZlYztcbiAgICBucy5NYXQgPSBNYXQ7XG4gICAgbnMuYWxsQXJndW1lbnRzQXJlU3RhdGljID0gYWxsQXJndW1lbnRzQXJlQ29uc3RhbnQ7XG5cblxufShleHBvcnRzKSk7XG4iLCJ2YXIgdG9vbHMgPSByZXF1aXJlKFwiLi92ZWNfdG9vbHNcIik7XG5cbnZhciBWZWMyID0gZnVuY3Rpb24gVmVjMihyZXN1bHQsIGFyZ3MpIHtcblx0cmV0dXJuIHRvb2xzLmV2YWx1YXRlQ29uc3RydWN0b3IoMiwgcmVzdWx0LCBhcmdzKTtcbn07XG5cbnRvb2xzLmF0dGFjaFN3aXp6bGVzKFZlYzIucHJvdG90eXBlLCAyKTtcbnRvb2xzLmF0dGFjaE1ldGhvZHMoVmVjMi5wcm90b3R5cGUsIFtcImFkZFwiLCBcInN1YlwiLCBcIm11bFwiLCBcImRpdlwiLCBcIm1vZFwiXSwgMiwgMik7XG50b29scy5hdHRhY2hNZXRob2RzKFZlYzIucHJvdG90eXBlLCBbXCJkb3RcIl0sIDEsIDIpO1xudG9vbHMuYXR0YWNoTWV0aG9kcyhWZWMyLnByb3RvdHlwZSwgW1wibm9ybWFsaXplXCIsIFwiZmxpcFwiXSwgMiwgMCk7XG50b29scy5hdHRhY2hNZXRob2RzKFZlYzIucHJvdG90eXBlLCBbXCJsZW5ndGhcIl0sIDEsIDApO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xuIiwidmFyIHRvb2xzID0gcmVxdWlyZShcIi4vdmVjX3Rvb2xzXCIpO1xuXG52YXIgVmVjMyA9IGZ1bmN0aW9uIFZlYzMocmVzdWx0LCBhcmdzKSB7XG5cdHJldHVybiB0b29scy5ldmFsdWF0ZUNvbnN0cnVjdG9yKDMsIHJlc3VsdCwgYXJncyk7XG59O1xuXG50b29scy5hdHRhY2hTd2l6emxlcyhWZWMzLnByb3RvdHlwZSwgMyk7XG50b29scy5hdHRhY2hNZXRob2RzKFZlYzMucHJvdG90eXBlLCBbXCJhZGRcIiwgXCJzdWJcIiwgXCJtdWxcIiwgXCJkaXZcIiwgXCJtb2RcIiwgXCJyZWZsZWN0XCIsIFwiY3Jvc3NcIl0sIDMsIDMpO1xudG9vbHMuYXR0YWNoTWV0aG9kcyhWZWMzLnByb3RvdHlwZSwgW1wiZG90XCJdLCAxLCAzKTtcbnRvb2xzLmF0dGFjaE1ldGhvZHMoVmVjMy5wcm90b3R5cGUsIFtcIm5vcm1hbGl6ZVwiLCBcImZsaXBcIl0sIDMsIDApO1xudG9vbHMuYXR0YWNoTWV0aG9kcyhWZWMzLnByb3RvdHlwZSwgW1wibGVuZ3RoXCJdLCAxLCAwKTtcblxuVmVjMy5wcm90b3R5cGUucmVmcmFjdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MpIHtcblx0aWYgKGFyZ3MubGVuZ3RoIDwgMilcblx0XHRTaGFkZS50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIk5vdCBlbm91Z2ggcGFyYW1ldGVycyBmb3IgcmVmcmFjdC5cIik7XG5cblx0dmFyIGV0YSA9IGFyZ3MucG9wKCk7XG5cdGlmICghZXRhIHx8ICFldGEuY2FuTnVtYmVyKCkpXG5cdFx0U2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlciBmb3IgcmVmcmFjdCwgZXhwZWN0ZWQgYSBudW1iZXIgZ290IFwiICsgZXRhLmdldFR5cGVTdHJpbmcoKSk7XG5cblx0Ly9Ub29scy5WZWMuY2hlY2tWZWNBcmd1bWVudHMoXCJWZWMzLnJlZnJhY3RcIiwgMywgZmFsc2UsIDAsIHJlc3VsdCwgYXJncyk7XG5cblx0cmV0dXJuIHtcblx0XHR0eXBlOiBcIm9iamVjdFwiLFxuXHRcdGtpbmQ6IFwiVmVjM1wiXG5cdH07XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBWZWMzO1xuIiwidmFyIHRvb2xzID0gcmVxdWlyZShcIi4vdmVjX3Rvb2xzXCIpO1xuXG52YXIgVmVjNCA9IGZ1bmN0aW9uIFZlYzQocmVzdWx0LCBhcmdzKSB7XG5cdHJldHVybiB0b29scy5ldmFsdWF0ZUNvbnN0cnVjdG9yKDQsIHJlc3VsdCwgYXJncyk7XG59O1xuXG50b29scy5hdHRhY2hTd2l6emxlcyhWZWM0LnByb3RvdHlwZSwgNCk7XG50b29scy5hdHRhY2hNZXRob2RzKFZlYzQucHJvdG90eXBlLCBbXCJhZGRcIiwgXCJzdWJcIiwgXCJtdWxcIiwgXCJkaXZcIiwgXCJtb2RcIl0sIDQsIDQpO1xudG9vbHMuYXR0YWNoTWV0aG9kcyhWZWM0LnByb3RvdHlwZSwgW1wiZG90XCJdLCAxLCA0KTtcbnRvb2xzLmF0dGFjaE1ldGhvZHMoVmVjNC5wcm90b3R5cGUsIFtcIm5vcm1hbGl6ZVwiLCBcImZsaXBcIl0sIDQsIDApO1xudG9vbHMuYXR0YWNoTWV0aG9kcyhWZWM0LnByb3RvdHlwZSwgW1wibGVuZ3RoXCJdLCAxLCAwKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVmVjNDtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2UvdXRpbHNcIik7XG52YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2luZGV4LmpzXCIpO1xudmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XG52YXIgVFlQRVMgPSBTaGFkZS5UWVBFUztcbnZhciBWZWMyID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXNcIikuVmVjMjtcbnZhciBWZWMzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXNcIikuVmVjMztcbnZhciBWZWM0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXNcIikuVmVjNDtcbnZhciBNYXQyID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXNcIikuTWF0MjtcbnZhciBNYXQzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXNcIikuTWF0MztcbnZhciBNYXQ0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXNcIikuTWF0NDtcblxudmFyIHNpemVUeXBlTWFwID0ge1xuXHQxOiB7dHlwZTogVFlQRVMuTlVNQkVSfSxcblx0Mjoge3R5cGU6IFRZUEVTLk9CSkVDVCwga2luZDogXCJWZWMyXCJ9LFxuXHQzOiB7dHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBcIlZlYzNcIn0sXG5cdDQ6IHt0eXBlOiBUWVBFUy5PQkpFQ1QsIGtpbmQ6IFwiVmVjNFwifSxcbiAgICBcIjJ4MlwiOiB7dHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBcIk1hdDJcIn0sXG4gICAgXCIzeDNcIjoge3R5cGU6IFRZUEVTLk9CSkVDVCwga2luZDogXCJNYXQzXCJ9LFxuICAgIFwiNHg0XCI6IHt0eXBlOiBUWVBFUy5PQkpFQ1QsIGtpbmQ6IFwiTWF0NFwifVxufTtcblxudmFyIHNpemVDb25zdHJ1Y3Rvck1hcCA9IHtcbiAgICAyOiBWZWMyLFxuICAgIDM6IFZlYzMsXG4gICAgNDogVmVjNCxcbiAgICBcIjJ4MlwiOiBNYXQyLFxuICAgIFwiM3gzXCI6IE1hdDMsXG4gICAgXCI0eDRcIjogTWF0NFxufTtcblxudmFyIGtpbmRTaXplTWFwID0ge1xuICAgIFwiVmVjMlwiOiAyLFxuICAgIFwiVmVjM1wiOiAzLFxuICAgIFwiVmVjNFwiOiA0XG59O1xuXG5mdW5jdGlvbiBhdHRhY2hTd2l6emxlcyhwcm90b3R5cGUsIHZlY1NpemUpIHtcblx0dXRpbHMuYXR0YWNoU3dpenpsZXModmVjU2l6ZSwgZnVuY3Rpb24oc3dpenpsZSwgaWR4KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHN3aXp6bGUuam9pbihcIlwiKSwge1xuICAgICAgICAgICAgZ2V0OiAoZnVuY3Rpb24oc3dpenpsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhc2UuZXh0ZW5kKHNpemVUeXBlTWFwW3N3aXp6bGUubGVuZ3RoXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBnZXRDb25zdGFudFZhbHVlLmJpbmQobnVsbCwgc3dpenpsZS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShzd2l6emxlKVxuICAgICAgICB9KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnN0YW50VmFsdWUobWV0aG9kTmFtZSwgcmVzdWx0LCBjdHgsIGNhbGxPYmplY3QpIHtcblx0aWYgKGNhbGxPYmplY3QuaGFzQ29uc3RhbnRWYWx1ZSgpKVxuXHRcdHJldHVybiBjYWxsT2JqZWN0LmdldENvbnN0YW50VmFsdWUoKVttZXRob2ROYW1lXTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTWV0aG9kcyhwcm90b3R5cGUsIG1ldGhvZE5hbWVzLCByZXN1bHRTaXplLCBhcmdTaXplKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBtZXRob2ROYW1lc1tpXTtcbiAgICAgICAgcHJvdG90eXBlW21ldGhvZE5hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXG4gICAgICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUuYmluZChudWxsLCBtZXRob2ROYW1lLCByZXN1bHRTaXplLCBhcmdTaXplKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZShtZXRob2ROYW1lLCByZXN1bHRWZWNTaXplLCBhcmdWZWNTaXplLCByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzKCk7XG4gICAgcmV0dXJuIEJhc2UuZXh0ZW5kKHt9LCBzaXplVHlwZU1hcFtyZXN1bHRWZWNTaXplXSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJndW1lbnRzKGFyZ1ZlY1NpemUsIHJlc3VsVmVjU2l6ZSkge1xuXG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlQ29uc3RydWN0b3Ioc2l6ZSwgcmVzdWx0LCBhcmdzKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHMoKTtcbiAgICByZXN1bHQgPSBCYXNlLmV4dGVuZCh7fSwgc2l6ZVR5cGVNYXBbc2l6ZV0pO1xuXG4gICAgaWYgKGFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnLmhhc0NvbnN0YW50VmFsdWUoKSB9KSlcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50VmFsdWUgPSBuZXcgc2l6ZUNvbnN0cnVjdG9yTWFwW3NpemVdKGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZy5nZXRDb25zdGFudFZhbHVlKCl9KSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBvbmx5IHNxdWFyZSBtYXRyaWNlc1xuZnVuY3Rpb24gYXR0YWNoRWxlbWVudEFjY2Vzc29yKHByb3RvdHlwZSwgY29sdW1uU2l6ZSkge1xuICAgIGZvciAodmFyIHJvd0lkeCA9IDE7IHJvd0lkeCA8PSBjb2x1bW5TaXplOyArK3Jvd0lkeClcbiAgICAgICAgZm9yICh2YXIgY29sdW1uSWR4ID0gMTsgY29sdW1uSWR4IDw9IGNvbHVtblNpemU7ICsrY29sdW1uSWR4KVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIHByb3RvdHlwZSwgXCJtXCIgKyByb3dJZHggKyBcIlwiICsgY29sdW1uSWR4LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKGZ1bmN0aW9uKHJvd0lkeCwgY29sdW1uSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCYXNlLmV4dGVuZCh7dHlwZTogVFlQRVMuTlVNQkVSfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IGdldENvbnN0YW50VmFsdWUuYmluZChudWxsLCBcIm1cIiArIHJvd0lkeCArIFwiXCIgKyBjb2x1bW5JZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKHJvd0lkeCAtIDEsIGNvbHVtbklkeCAtIDEpXG4gICAgICAgICAgICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaENvbHVtbkFjY2Vzc29yKHByb3RvdHlwZSwgY29sdW1uU2l6ZSkge1xuICAgIGZvciAodmFyIGNvbHVtbklkeCA9IDE7IGNvbHVtbklkeCA8PSBjb2x1bW5TaXplOyArK2NvbHVtbklkeCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBcImNcIiArIGNvbHVtbklkeCwge1xuICAgICAgICAgICAgZ2V0OiAoZnVuY3Rpb24oY29sdW1uSWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFzZS5leHRlbmQoc2l6ZVR5cGVNYXBbY29sdW1uU2l6ZV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTdGF0aWNWYWx1ZTogZ2V0Q29uc3RhbnRWYWx1ZS5iaW5kKG51bGwsIFwiY1wiICsgY29sdW1uSWR4KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShjb2x1bW5JZHggLSAxKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE11bE1ldGhvZChwcm90b3R5cGUsIHNpemUsIGNvbHVtblNpemUpIHtcbiAgICBwcm90b3R5cGUubXVsID0ge1xuICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdLmdldFR5cGUoKSAhPT0gVFlQRVMuT0JKRUNUKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm5vcGVcIjtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1swXS5nZXRLaW5kKCkgPT09IHNpemVUeXBlTWFwW3NpemVdLmtpbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplVHlwZU1hcFtzaXplXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvdW50ID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBhcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmdldFR5cGUoKSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsga2luZFNpemVNYXBbYXJnLmdldEtpbmQoKV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnLmNhbk51bWJlcigpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgKyAxO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3RcIjtcbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgICAgICBpZiAoY291bnQgIT09IGNvbHVtblNpemUpXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJOb3BlXCI7XG5cbiAgICAgICAgICAgIHJldHVybiBzaXplVHlwZU1hcFtjb3VudF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuYXR0YWNoU3dpenpsZXMgPSBhdHRhY2hTd2l6emxlcztcbmV4cG9ydHMuYXR0YWNoTWV0aG9kcyA9IGF0dGFjaE1ldGhvZHM7XG5leHBvcnRzLmV2YWx1YXRlQ29uc3RydWN0b3IgPSBldmFsdWF0ZUNvbnN0cnVjdG9yO1xuZXhwb3J0cy5hdHRhY2hFbGVtZW50QWNjZXNzb3IgPSBhdHRhY2hFbGVtZW50QWNjZXNzb3I7XG5leHBvcnRzLmF0dGFjaENvbHVtbkFjY2Vzc29yID0gYXR0YWNoQ29sdW1uQWNjZXNzb3I7XG5leHBvcnRzLmF0dGFjaE11bE1ldGhvZCA9IGF0dGFjaE11bE1ldGhvZDsiLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICAvLyBkZXBlbmRlbmNpZXNcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG4gICAgdmFyIGVzZ3JhcGggPSByZXF1aXJlKCdlc2dyYXBoJyk7XG4gICAgdmFyIHdvcmtsaXN0ID0gcmVxdWlyZSgnYW5hbHlzZXMnKTtcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpO1xuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvaW5kZXguanNcIik7XG4gICAgdmFyIGNvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKTtcbiAgICB2YXIgYW5ub3RhdGVSaWdodCA9IHJlcXVpcmUoXCIuL2luZmVyX2V4cHJlc3Npb24uanNcIik7XG4gICAgdmFyIEluZmVyZW5jZVNjb3BlID0gcmVxdWlyZShcIi4vcmVnaXN0cnkvXCIpLkluZmVyZW5jZVNjb3BlO1xuICAgIHZhciBTeXN0ZW0gPSByZXF1aXJlKFwiLi9yZWdpc3RyeS9zeXN0ZW0uanNcIik7XG4gICAgdmFyIGFubm90YXRlID0gcmVxdWlyZShcIi4vLi4vLi4vdXRpbHNcIikuYW5ub3RhdGU7XG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG4gICAgdmFyIGFzdFRvb2xzID0gcmVxdWlyZShcIi4uL3V0aWxzL2FzdFwiKTtcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcbiAgICB2YXIgd2Fsa2VzID0gcmVxdWlyZSgnd2Fsa2VzJyk7XG4gICAgdmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRpb24nKTtcbiAgICB2YXIgVHlwZUluZm8gPSByZXF1aXJlKFwiLi4vLi4vdHlwZS1zeXN0ZW0vdHlwZWluZm8uanNcIik7XG5cbiAgICAvLyBzaG9ydGN1dHNcbiAgICB2YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcbiAgICB2YXIgU2V0ID0gd29ya2xpc3QuU2V0O1xuXG5cblxuXG5cblxuXG5cbiAgICBmdW5jdGlvbiBmaW5kQ29uc3RhbnRzRm9yKGFzdCwgbmFtZXMsIGNvbnN0YW50VmFyaWFibGVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU2V0KCksIGFubm90YXRpb24sIG5hbWUsIGZvcm1lclZhbHVlO1xuICAgICAgICBjb25zdGFudFZhcmlhYmxlcyA9IGNvbnN0YW50VmFyaWFibGVzID8gY29uc3RhbnRWYXJpYWJsZXMudmFsdWVzKCkgOiBbXTtcblxuICAgICAgICB3YWxrZXMoYXN0LCB7XG4gICAgICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24ocmVjdXJzZSkge1xuXG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihhc3QsIFwiQ2FuJ3QgZmluZCBjb25zdGFudCBmb3IgY29tcHV0ZWQgbGVmdCBleHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5sZWZ0Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYobmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb24gPSBhbm5vdGF0ZSh0aGlzLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoYW5ub3RhdGlvbi5oYXNDb25zdGFudFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZCh7IG5hbWU6IG5hbWUsIGNvbnN0YW50OiBUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUoYW5ub3RhdGlvbil9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi09XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIis9XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIio9XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi89XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1lclZhbHVlID0gY29uc3RhbnRWYXJpYWJsZXMuZmlsdGVyKGZ1bmN0aW9uKHYpeyByZXR1cm4gdi5uYW1lID09IG5hbWU7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmb3JtZXJWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZm9ybWVyVmFsdWVbMF0uY29uc3RhbnQsIHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2godGhpcy5vcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIrPVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gYyArIFR5cGVJbmZvLmNvcHlTdGF0aWNWYWx1ZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi09XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBjIC0gVHlwZUluZm8uY29weVN0YXRpY1ZhbHVlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGMgKiBUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIvPVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gYyAvIFR5cGVJbmZvLmNvcHlTdGF0aWNWYWx1ZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHsgbmFtZTogbmFtZSwgY29uc3RhbnQ6IHZ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIXRoaXMub3BlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLnJpZ2h0KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24ocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmlkLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdCAmJiBuYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRlKHRoaXMuaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFubm90YXRpb24uaGFzQ29uc3RhbnRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHsgbmFtZTogbmFtZSwgY29uc3RhbnQ6IFR5cGVJbmZvLmNvcHlTdGF0aWNWYWx1ZShhbm5vdGF0aW9uKX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5pbml0KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmFyZ3VtZW50LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuYXJndW1lbnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZihhbm5vdGF0aW9uLmhhc0NvbnN0YW50VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gVHlwZUluZm8uY29weVN0YXRpY1ZhbHVlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcGVyYXRvciA9PSBcIi0tXCIgPyAtLXZhbHVlIDogKyt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoeyBuYW1lOiBuYW1lLCBjb25zdGFudDogdmFsdWV9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXN0XG4gICAgICogQHBhcmFtIHtBbmFseXNpc0NvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0geyp9IG9wdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUeXBlSW5mZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCwgb3B0LCBhbmFseXplcikge1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHRoaXMuYW5hbHl6ZXIgPSBhbmFseXplcjtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNvbnN0YW50cyA9IG9wdC5wcm9wYWdhdGVDb25zdGFudHMgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIEJhc2UuZXh0ZW5kKFR5cGVJbmZlcmVuY2UucHJvdG90eXBlLCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gYXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gb3B0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5mZXJCb2R5OiBmdW5jdGlvbiAoYXN0LCBvcHQpIHtcbiAgICAgICAgICAgICB2YXIgY2ZnID0gZXNncmFwaChhc3QsIHsgb21pdEV4Y2VwdGlvbnM6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnN0YW50cyA9IHRoaXMucHJvcGFnYXRlQ29uc3RhbnRzO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJpbmZlciBib2R5XCIsIGNmZylcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgIHZhciByZXN1bHQgPSB3b3JrbGlzdChjZmcsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U2V0fSBpbnB1dFxuICAgICAgICAgICAgICogQHRoaXMge0Zsb3dOb2RlfVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hc3ROb2RlIHx8IHRoaXMudHlwZSkgLy8gU3RhcnQgYW5kIGVuZCBub2RlIGRvIG5vdCBpbmZsdWVuY2UgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQW5hbHl6ZVwiLCBjb2RlZ2VuLmdlbmVyYXRlKHRoaXMuYXN0Tm9kZSksIHRoaXMuYXN0Tm9kZS50eXBlKTtcblxuICAgICAgICAgICAgICAgIC8vIExvY2FsXG4gICAgICAgICAgICAgICAgaWYocHJvcGFnYXRlQ29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2lsbCA9IHRoaXMua2lsbCB8fCBhc3RUb29scy5maW5kVmFyaWFibGVEZWZpbml0aW9ucyh0aGlzLmFzdE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFubm90YXRlUmlnaHQoY29udGV4dCwgdGhpcy5hc3ROb2RlLCBwcm9wYWdhdGVDb25zdGFudHMgPyBpbnB1dCA6IG51bGwsIHNlbGYuYW5hbHl6ZXIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNsID0gdGhpcy5kZWNsIHx8IGNvbnRleHQuZGVjbGFyZSh0aGlzLmFzdE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgLy9jb250ZXh0LmNvbXB1dGVDb25zdGFudHModGhpcy5hc3ROb2RlLCBpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICBpZighcHJvcGFnYXRlQ29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkSW5wdXQgPSBudWxsLCBnZW5lcmF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2lsbC5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgaWYgdGhlcmUncyBhbiBhc3NpZ25tZW50LCB3ZSBuZWVkIHRvIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlID0gZmluZENvbnN0YW50c0Zvcih0aGlzLmFzdE5vZGUsIHRoaXMua2lsbCwgcHJvcGFnYXRlQ29uc3RhbnRzID8gaW5wdXQgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZElucHV0ID0gbmV3IFNldChpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoYXQua2lsbC5zb21lKGZ1bmN0aW9uKHRva2lsbCkgeyByZXR1cm4gZWxlbS5uYW1lID09IHRva2lsbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBTZXQudW5pb24oZmlsdGVyZWRJbnB1dCB8fCBpbnB1dCwgZ2VuZXJhdGUpO1xuICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpbnB1dDpcIiwgaW5wdXQpO1xuICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJraWxsOlwiLCB0aGlzLmtpbGwpO1xuICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJnZW5lcmF0ZTpcIiwgZ2VuZXJhdGUpO1xuICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJmaWx0ZXJlZElucHV0OlwiLCBmaWx0ZXJlZElucHV0KTtcbiAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJyxcbiAgICAgICAgICAgICAgICBtZXJnZTogd29ya2xpc3QubWVyZ2UoZnVuY3Rpb24oYSxiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYSAmJiAhYilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTWVyZ2VcIiwgYSAmJiBhLnZhbHVlcygpLCBiICYmIGIudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBTZXQuaW50ZXJzZWN0KGEsIGIpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVzdWx0XCIsIHJlc3VsdCAmJiByZXN1bHQudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ2YWx1ZXMgPSBiLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZXMoKS5ldmVyeShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ2YWx1ZXMuc29tZShmdW5jdGlvbiAoYnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnYubmFtZSA9PT0gdi5uYW1lICYmIGJ2LmNvbnN0YW50ID09PSB2LmNvbnN0YW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vVG9vbHMucHJpbnRNYXAocmVzdWx0LCBjZmcpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzdFxuICAgICAqIEBwYXJhbSB7QW5hbHlzaXNDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIG9wdFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHZhciBpbmZlclByb2dyYW0gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0LCBvcHQsIGFuYWx5emVyKSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgLy92YXIgZ2xvYmFsU2NvcGUgPSBjcmVhdGVHbG9iYWxTY29wZShhc3QpO1xuICAgICAgICAvL3JlZ2lzdGVyU3lzdGVtSW5mb3JtYXRpb24oZ2xvYmFsU2NvcGUsIG9wdCk7XG5cbiAgICAgICAgdmFyIHR5cGVJbmZlcmVuY2UgPSBuZXcgVHlwZUluZmVyZW5jZShhc3QsIGNvbnRleHQsIG9wdCwgYW5hbHl6ZXIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZUluZmVyZW5jZS5pbmZlckJvZHkoYXN0LCBvcHQpO1xuXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgbnMuaW5mZXIgPSBpbmZlclByb2dyYW07XG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgLy8gRGVwZW5kZW5jaWVzXG4gICAgdmFyIHRyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxuICAgICAgICBjb21tb24gPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcbiAgICAgICAgY29kZWdlbiA9IHJlcXVpcmUoJ2VzY29kZWdlbicpLFxuICAgICAgICBTZXQgPSByZXF1aXJlKCdhbmFseXNlcycpLlNldCxcbiAgICAgICAgYXN0VG9vbHMgPSByZXF1aXJlKCcuLi91dGlscy9hc3QuanMnKTtcblxuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdmFyIFN5bnRheCA9IHRyYXZlcnNlLlN5bnRheCwgQU5OTyA9IGNvbW1vbi5BTk5PO1xuXG4gICAgZnVuY3Rpb24gdG9NYXAodW5pZm9ybVNldCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHVuaWZvcm1TZXQgJiYgdW5pZm9ybVNldC5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICByZXN1bHRbZW50cnkubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBlbnRyeS5kZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAgICAgY29zdHM6IGVudHJ5LmNvc3RzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgYWxsb3dlZE1lbWJlckNhbGxzID0gW1wiTWF0aFwiLCBcIlNoYWRlXCJdO1xuXG4gICAgbnMuZ2VuZXJhdGVVbmlmb3JtRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoYXN0LCBpbnB1dCkge1xuXG4gICAgICAgIHZhciB1bmlmb3JtVmFyaWFibGVzID0gdG9NYXAoaW5wdXQpO1xuXG4gICAgICAgIHRyYXZlcnNlLnRyYXZlcnNlKGFzdCwge1xuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2xlYXJVbmlmb3JtRGVwZW5kZW5jaWVzKCk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyB1bmlmb3JtcyBjYW4gY29tZSB2aWEgdGhlIGVudiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eUFubm90YXRpb24gPSBBTk5PKG5vZGUucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QW5ub3RhdGlvbi5nZXRTb3VyY2UoKSA9PSBTaGFkZS5TT1VSQ0VTLlVOSUZPUk0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybURlcGVuZGVuY2llcyhub2RlLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQU5OTyhub2RlLm9iamVjdCkuaXNVbmlmb3JtRXhwcmVzc2lvbigpICYmIHByb3BlcnR5QW5ub3RhdGlvbi5nZXRUeXBlKCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtRGVwZW5kZW5jaWVzKEFOTk8obm9kZS5vYmplY3QpLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1Db3N0cygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYXN0VG9vbHMuaXNWYXJpYWJsZVJlZmVyZW5jZShub2RlLCBwYXJlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFyaWFibGUgb24gdGhlIHJpZ2h0IHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudC50eXBlID09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBwYXJlbnQubGVmdCA9PSBub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodW5pZm9ybVZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BhZ2F0ZWRVbmlmb3JtID0gdW5pZm9ybVZhcmlhYmxlc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtRGVwZW5kZW5jaWVzKHByb3BhZ2F0ZWRVbmlmb3JtLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1Db3N0cyhwcm9wYWdhdGVkVW5pZm9ybS5jb3N0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5CaW5hcnlFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gQU5OTyhub2RlLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IEFOTk8obm9kZS5yaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNhblVuaWZvcm1FeHByZXNzaW9uKCkgJiYgcmlnaHQuY2FuVW5pZm9ybUV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtRGVwZW5kZW5jaWVzKGxlZnQuZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpLCByaWdodC5nZXRVbmlmb3JtRGVwZW5kZW5jaWVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMobGVmdC5nZXRVbmlmb3JtQ29zdHMoKSArIHJpZ2h0LmdldFVuaWZvcm1Db3N0cygpICsgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVW5hcnlFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50ID0gQU5OTyhub2RlLmFyZ3VtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXJndW1lbnQuaXNVbmlmb3JtRXhwcmVzc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1EZXBlbmRlbmNpZXMoYXJndW1lbnQuZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybUNvc3RzKGFyZ3VtZW50LmdldFVuaWZvcm1Db3N0cygpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ2FsbEV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IG5vZGUuY2FsbGVlLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzLm1hcChmdW5jdGlvbihhcmcpIHsgcmV0dXJuIEFOTk8oYXJnKTt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iamVjdC5uYW1lICYmIH5hbGxvd2VkTWVtYmVyQ2FsbHMuaW5kZXhPZihvYmplY3QubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IG1lcmdlVW5pZm9ybURlcGVuZGVuY2llcyhhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvc3RzID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkgeyByZXR1cm4gcHJldiArIG5leHQuZ2V0VW5pZm9ybUNvc3RzKCk7IH0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1Db3N0cyhjb3N0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENsZWFuQ29kZTogTWVyZ2Ugd2l0aCBhYm92ZSBhcyBzb29uIGFzIGFsbCBkaWZmZXJlbmNlcyBhcmUgY2xlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdEFubm8gPSBBTk5PKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iamVjdEFubm8uaXNVbmlmb3JtRXhwcmVzc2lvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gbWVyZ2VVbmlmb3JtRGVwZW5kZW5jaWVzKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY2llcyB8fCBhcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1EZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBvYmplY3RBbm5vLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvc3RzID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkgeyByZXR1cm4gcHJldiArIG5leHQuZ2V0VW5pZm9ybUNvc3RzKCk7IH0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMoY29zdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJObyBleHA6XCIsIFNoYWRlLnRvSmF2YVNjcmlwdChub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5OZXdFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5jYWxsZWUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiBub2RlLmNhbGxlZS5uYW1lICE9PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzLm1hcChmdW5jdGlvbihhcmcpIHsgcmV0dXJuIEFOTk8oYXJnKTt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gbWVyZ2VVbmlmb3JtRGVwZW5kZW5jaWVzKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29zdHMgPSBhcmdzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7IHJldHVybiBwcmV2ICsgbmV4dC5nZXRVbmlmb3JtQ29zdHMoKTsgfSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMoY29zdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBBTk5PKGFzdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmlzVW5pZm9ybUV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHsgbmFtZTogYXN0LmxlZnQubmFtZSwgZGVwZW5kZW5jaWVzOiByaWdodC5nZXRVbmlmb3JtRGVwZW5kZW5jaWVzKCksIGNvc3RzOiByaWdodC5nZXRVbmlmb3JtQ29zdHMoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uOlxuICAgICAgICAgICAgICAgIGFzdC5kZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gQU5OTyhkZWNsYXJhdGlvbi5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0LmlzVW5pZm9ybUV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoeyBuYW1lOiBkZWNsYXJhdGlvbi5pZC5uYW1lLCBkZXBlbmRlbmNpZXM6IGluaXQuZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpLCBjb3N0czogaW5pdC5nZXRVbmlmb3JtQ29zdHMoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGZ1bmN0aW9uIGF0TGVhc3RPbmVBcmd1bWVudElzVW5pZm9ybShhcmdzKSB7XG4gICAgICAgIHZhciBhbGxVbmlmb3JtT3JTdGF0aWMgPSB0cnVlLFxuICAgICAgICAgICAgb25lVW5pZm9ybSA9IGZhbHNlO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aCAmJiBhbGxVbmlmb3JtT3JTdGF0aWM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRoaXNVbmlmb3JtID0gYXJnc1tpXS5pc1VuaWZvcm1FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBhbGxVbmlmb3JtT3JTdGF0aWMgPSBhbGxVbmlmb3JtT3JTdGF0aWMgJiYgKHRoaXNVbmlmb3JtIHx8IGFyZ3NbaV0uaGFzQ29uc3RhbnRWYWx1ZSgpKTtcbiAgICAgICAgICAgIG9uZVVuaWZvcm0gPSBvbmVVbmlmb3JtIHx8IHRoaXNVbmlmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxVbmlmb3JtT3JTdGF0aWMgJiYgb25lVW5pZm9ybTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWVyZ2VVbmlmb3JtRGVwZW5kZW5jaWVzKGFyZ3MpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1EZXBlbmRlbmNpZXMgPSBudWxsO1xuXG4gICAgICAgIGlmKGF0TGVhc3RPbmVBcmd1bWVudElzVW5pZm9ybShhcmdzKSkge1xuICAgICAgICAgICAgdW5pZm9ybURlcGVuZGVuY2llcyA9IFtdXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPCBhcmdzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tpXS5pc1VuaWZvcm1FeHByZXNzaW9uKCkpICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1EZXBlbmRlbmNpZXMgPSB1bmlmb3JtRGVwZW5kZW5jaWVzLmNvbmNhdChhcmdzW2ldLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlmb3JtRGVwZW5kZW5jaWVzO1xuICAgIH07XG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgLy8gRGVwZW5kZW5jaWVzXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbW1vbi5qc1wiKTtcbiAgICB2YXIgZXNncmFwaCA9IHJlcXVpcmUoJ2VzZ3JhcGgnKTtcbiAgICB2YXIgd29ya2xpc3QgPSByZXF1aXJlKCdhbmFseXNlcycpO1xuICAgIHZhciBldmFsdWF0b3IgPSByZXF1aXJlKCcuL2V2YWx1YXRvci5qcycpO1xuICAgIHZhciB0cmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vdW5pZm9ybVRyYW5zZm9ybWVyLmpzJyk7XG4gICAgdmFyIGFzdFRvb2xzID0gcmVxdWlyZShcIi4uL3V0aWxzL2FzdFwiKTtcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIHZhciBTZXQgPSB3b3JrbGlzdC5TZXQsXG4gICAgICAgIFN5bnRheCA9IGNvbW1vbi5TeW50YXg7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcm9vdFxuICAgICAqIEBwYXJhbSBvcHRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbmlmb3JtQW5hbHlzaXMocm9vdCwgb3B0KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMub3B0ID0gb3B0IHx8IHt9O1xuICAgIH1cblxuXG4gICAgVW5pZm9ybUFuYWx5c2lzLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYW5hbHl6ZUJvZHk6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB2YXIgY2ZnID0gZXNncmFwaChib2R5LCB7IG9taXRFeGNlcHRpb25zOiB0cnVlIH0pO1xuXG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB3b3JrbGlzdChjZmcsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U2V0fSBpbnB1dFxuICAgICAgICAgICAgICogQHRoaXMge0Zsb3dOb2RlfVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hc3ROb2RlIHx8IHRoaXMudHlwZSkgLy8gU3RhcnQgYW5kIGVuZCBub2RlIGRvIG5vdCBpbmZsdWVuY2UgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGUgPSBldmFsdWF0b3IuZ2VuZXJhdGVVbmlmb3JtRXhwcmVzc2lvbnModGhpcy5hc3ROb2RlLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5raWxsID0gdGhpcy5raWxsIHx8IGFzdFRvb2xzLmZpbmRWYXJpYWJsZURlZmluaXRpb25zKHRoaXMuYXN0Tm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtpbGwuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSW5wdXQgPSBuZXcgU2V0KGlucHV0LmZpbHRlcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhhdC5raWxsLnNvbWUoZnVuY3Rpb24odG9raWxsKSB7IHJldHVybiBlbGVtLm5hbWUgPT0gdG9raWxsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNldC51bmlvbihmaWx0ZXJlZElucHV0LCBnZW5lcmF0ZSk7XG5cbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5wdXQ6XCIsIGlucHV0KTtcbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwia2lsbDpcIiwgdGhpcy5raWxsKTtcbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2VuZXJhdGU6XCIsIGdlbmVyYXRlKTtcbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmlsdGVyZWRJbnB1dDpcIiwgZmlsdGVyZWRJbnB1dCk7XG4vLyAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnLFxuICAgICAgICAgICAgICAgIG1lcmdlOiB3b3JrbGlzdC5tZXJnZShmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhICYmICFiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXQuaW50ZXJzZWN0KGEsIGIpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vVG9vbHMucHJpbnRNYXAocmVzdWx0LCBjZmcpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIudHJhbnNmb3JtKHRoaXMucm9vdCwgdGhpcy5vcHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIG5zLmV4dHJhY3QgPSBmdW5jdGlvbiAoYXN0LCBvcHQpIHtcblxuICAgICAgICBhc3NlcnQoYXN0LnR5cGUgPT0gU3ludGF4LlByb2dyYW0gfHwgYXN0LnR5cGUgPT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KTtcblxuICAgICAgICB2YXIgYW5hbHlzaXMgPSBuZXcgVW5pZm9ybUFuYWx5c2lzKGFzdCwgb3B0KTtcblxuICAgICAgICAvLyBQcm9wYWdhdGUgYW5kIGFuYWx5emVcbiAgICAgICAgYW5hbHlzaXMuYW5hbHl6ZUJvZHkoYXN0LnR5cGUgPT0gU3ludGF4LlByb2dyYW0gPyBhc3QuYm9keSA6IGFzdCk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtXG4gICAgICAgIHJldHVybiBhbmFseXNpcy50cmFuc2Zvcm0oKTtcbiAgICB9O1xuXG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG4gICAgdmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xuICAgIHZhciBhbm5vdGF0ZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKS5hbm5vdGF0ZTtcblxuICAgIGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yKGtpbmQpe1xuICAgICAgICBzd2l0Y2goa2luZCl7XG4gICAgICAgICAgICBjYXNlIFwiVmVjMlwiOiByZXR1cm4gXCJTaGFkZS5WZWMyXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlZlYzNcIjogcmV0dXJuIFwiU2hhZGUuVmVjM1wiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWZWM0XCI6IHJldHVybiBcIlNoYWRlLlZlYzRcIjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTWF0M1wiOiByZXR1cm4gXCJTaGFkZS5NYXQzXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1hdDRcIjogcmV0dXJuIFwiU2hhZGUuTWF0NFwiOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IFwiVW5zdXBwb3J0ZWQgb2JqZWN0IGtpbmQgaW4gdW5pZm9ybSBleHByZXNzaW9uIGFyZ3VtZW50OiBcIiArIGtpbmQ7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGlzTWF0aENhbGwobm9kZSkge1xuICAgICAgICByZXR1cm4gKG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIG5vZGUuY2FsbGVlLm9iamVjdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gXCJNYXRoXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmVjTWF0aENhbGwobm9kZSkge1xuICAgICAgICBpZighaXNNYXRoQ2FsbChub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGZpcnN0QXJndW1lbnQgPSBhbm5vdGF0ZShub2RlLmFyZ3VtZW50c1swXSk7XG4gICAgICAgIHJldHVybiBmaXJzdEFyZ3VtZW50LmlzVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgdmFyIGxlYXZlVmlzaXRvciA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHZhcmlhYmxlcywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gYW5ub3RhdGUobm9kZS5vYmplY3QpO1xuICAgICAgICAgICAgaWYgKG5vZGUub2JqZWN0LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgb2JqZWN0LmlzVW5pZm9ybUV4cHJlc3Npb24oKSkge1xuICAgICAgICAgICAgICAgIGlmKHZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShub2RlLm9iamVjdC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGb3VuZDogXCIgKyBub2RlLm9iamVjdC5uYW1lLCB2YXJpYWJsZXNbbm9kZS5vYmplY3QubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBub2RlLm9iamVjdCA9IHZhcmlhYmxlc1tub2RlLm9iamVjdC5uYW1lXS5jb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuaXNHbG9iYWwoKSAmJiBub2RlLnByb3BlcnR5LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBhbm5vdGF0ZShub2RlLnByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmKHByb3BlcnR5LmlzT2JqZWN0KCkpe1xuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgYWNjZXNzZWQgcGFyYW1ldGVyIGlzIGEgdmVjdG9yIG9yIG1hdHJpeCAsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gd3JhcCB0aGUgdHlwZWQgYXJyYXkgaW4gdGhlIHJlc3BlY3RpdmUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IocHJvcGVydHkuZ2V0S2luZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBjb25zdHJ1Y3Rvcn0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6ICBbbm9kZV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKChwYXJlbnQgPT0gbm9kZSkgfHwgcGFyZW50LnR5cGUgIT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pe1xuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgYWNjZXNzZWQgcGFyYW1ldGVyIGlzIGEgc2NhbGFyIHZhbHVlLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGlucHV0IGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguQ2FsbEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChpc1ZlY01hdGhDYWxsKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPSBcIk1hdGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKH5bU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uLCBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yXS5pbmRleE9mKHBhcmVudC50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PSBTeW50YXguTmV3RXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBOb3QgYSB2YXJpYWJsZSBvbiB0aGUgcmlnaHQgc2lkZVxuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBwYXJlbnQubGVmdCA9PSBub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYodmFyaWFibGVzLmhhc093blByb3BlcnR5KG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRm91bmQ6IFwiICsgbm9kZS5uYW1lLCB0aGlzW25vZGUubmFtZV0pO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gdmFyaWFibGVzW25vZGUubmFtZV0uY29kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLmNhbGxlZS5uYW1lO1xuICAgICAgICAgICAgICAgIHN3aXRjaChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWZWMyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWZWMzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWZWM0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNhbGxlZS5uYW1lID0gXCJTaGFkZS5cIiArIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LlJldHVyblN0YXRlbWVudCkge1xuICAgICAgICAgICAgdmFyIGFubm8gPSBhbm5vdGF0ZShub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGlmKGFubm8uaXNPYmplY3QoKSl7XG4gICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudCA9IHsgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBub2RlLmFyZ3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIl90b0Zsb2F0QXJyYXlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICBucy50cmFuc2Zvcm1Vbmlmb3JtU2V0dGVyID0gZnVuY3Rpb24gKGFzdCwgdmFyaWFibGVzKSB7XG4gICAgICAgIHJldHVybiB3YWxrLnJlcGxhY2UoYXN0LCB7IGxlYXZlOiBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWF2ZVZpc2l0b3Iobm9kZSwgcGFyZW50LCB2YXJpYWJsZXMsIHRoaXMpO1xuICAgICAgICB9fSk7XG4gICAgfTtcblxuXG59KGV4cG9ydHMpKTtcbiIsIihmdW5jdGlvbihucyl7XG5cbiAgICAvLyBEZXBlbmRlbmNpZXNcbiAgICB2YXIgdHJhdmVyc2UgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyksXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxuICAgICAgICBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyksXG4gICAgICAgIHNldHRlckdlbmVyYXRvciA9IHJlcXVpcmUoJy4vdW5pZm9ybVNldHRlclRyYW5zZm9ybWF0aW9uLmpzJyk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICB2YXIgQU5OTyA9IGNvbW1vbi5BTk5PLFxuICAgICAgICBTeW50YXggPSB0cmF2ZXJzZS5TeW50YXg7XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIGZ1bmN0aW9uIGdldENvdW50ZXIoKSB7XG4gICAgICAgIHJldHVybiBjb3VudGVyKys7XG4gICAgfVxuICAgIHZhciBVbmlmb3JtVHJhbnNmb3JtZXIgPSBmdW5jdGlvbihvcHQpe1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdGhpcy51bmlmb3JtRXhwcmVzc2lvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5hY3RpdmVVbmlmb3JtVmFyaWFibGVzID0ge307XG4gICAgfTtcblxuICAgIFVuaWZvcm1UcmFuc2Zvcm1lci5wcm90b3R5cGUgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oYXN0KSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2UucmVwbGFjZShhc3QsIHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ubyA9IEFOTk8obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFubm8uaXNVbmlmb3JtRXhwcmVzc2lvbigpICYmIHNob3VsZEdlbmVyYXRlVW5pZm9ybUV4cHJlc3Npb24obm9kZSwgYW5ubykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmdlbmVyYXRlVW5pZm9ybUV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gfHwgKG5vZGUudHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yICYmIG5vZGUuaW5pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IEFOTk8obm9kZS5yaWdodCB8fCBub2RlLmluaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnROb2RlID0gbm9kZS5sZWZ0IHx8IG5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQuaXNVbmlmb3JtRXhwcmVzc2lvbigpICYmIGxlZnROb2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFjdGl2ZVVuaWZvcm1WYXJpYWJsZXNbbGVmdE5vZGUubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHNldHRlckdlbmVyYXRvci50cmFuc2Zvcm1Vbmlmb3JtU2V0dGVyKG5vZGUucmlnaHQgfHwgbm9kZS5pbml0LCB0aGF0LmFjdGl2ZVVuaWZvcm1WYXJpYWJsZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHJpZ2h0LmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVbmlmb3JtRXhwcmVzc2lvbjogZnVuY3Rpb24odWV4cCkge1xuICAgICAgICAgICAgZm9yKHZhciBuYW1lIGluIHRoaXMudW5pZm9ybUV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy51bmlmb3JtRXhwcmVzc2lvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYodWV4cC5jb2RlID09IG90aGVyLmNvZGUgJiYgZXF1YWxEZXBlbmRlbmNpZXModWV4cC5kZXBlbmRlbmNpZXMsIG90aGVyLmRlcGVuZGVuY2llcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbmVyYXRlVW5pZm9ybUV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBhbm5vID0gQU5OTyhub2RlKTtcbiAgICAgICAgICAgIHZhciB1ZXhwID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVnZW4uZ2VuZXJhdGUoc2V0dGVyR2VuZXJhdG9yLnRyYW5zZm9ybVVuaWZvcm1TZXR0ZXIobm9kZSwgdGhpcy5hY3RpdmVVbmlmb3JtVmFyaWFibGVzKSksXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBhbm5vLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0VW5pZm9ybUV4cHJlc3Npb24odWV4cCk7XG4gICAgICAgICAgICBpZighbmFtZSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcInVcIiArIGdldENvdW50ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1FeHByZXNzaW9uc1tuYW1lXSA9IHVleHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ1ZXhwXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBTk5PKHJlc3VsdCkuY29weUZyb20oYW5ubyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVxdWFsRGVwZW5kZW5jaWVzKGEsIGIpIHtcbiAgICAgICAgaWYoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICBpZihiLmluZGV4T2YoZWxlbSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkR2VuZXJhdGVVbmlmb3JtRXhwcmVzc2lvbihub2RlLCBhbm5vKSB7XG4gICAgICAgIHZhciBjb3N0cyA9IGFubm8uZ2V0VW5pZm9ybUNvc3RzKCk7XG4gICAgICAgIHJldHVybiBjb3N0cyA+IDA7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSBucy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXN0LCBvcHQpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IFVuaWZvcm1UcmFuc2Zvcm1lcihvcHQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGFzdCk7XG4gICAgICAgIG9wdC51bmlmb3JtRXhwcmVzc2lvbnMgPSB0cmFuc2Zvcm1lci51bmlmb3JtRXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxufShleHBvcnRzKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcbnZhciBTZXQgPSByZXF1aXJlKFwiYW5hbHlzZXNcIikuU2V0O1xuXG5mdW5jdGlvbiBmaW5kVmFyaWFibGVEZWZpbml0aW9ucyhhc3QsIGlnbm9yZVVuaW5pdGlhbGl6ZWREZWNsYXJhdGlvbnMpIHtcblx0dmFyIGRlZmluaXRpb25zID0gbmV3IFNldCgpO1xuXHRlc3RyYXZlcnNlLnRyYXZlcnNlKGFzdCwge1xuXHRcdGxlYXZlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRzd2l0Y2ggKG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XG5cdFx0XHRcdGlmIChub2RlLmxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnMuYWRkKG5vZGUubGVmdC5uYW1lKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I6XG5cdFx0XHRcdGlmIChub2RlLmlkLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyXG5cdFx0XHRcdFx0JiYgKCFpZ25vcmVVbmluaXRpYWxpemVkRGVjbGFyYXRpb25zIHx8IG5vZGUuaW5pdCkpXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnMuYWRkKG5vZGUuaWQubmFtZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcblx0XHRcdFx0aWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnMuYWRkKG5vZGUuYXJndW1lbnQubmFtZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZWZpbml0aW9ucztcbn1cblxuZnVuY3Rpb24gZmluZFZhcmlhYmxlUmVmZXJlbmNlcyhhc3QpIHtcblx0dmFyIHJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG5cdGVzdHJhdmVyc2UudHJhdmVyc2UoYXN0LCB7XG5cdFx0bGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuXHRcdFx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0XHRcdGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuXHRcdFx0XHRyZWZlcmVuY2VzID0gU2V0LnVuaW9uKHJlZmVyZW5jZXMsIGZpbmRWYXJpYWJsZVJlZmVyZW5jZXMobm9kZS5yaWdodCkpO1xuXHRcdFx0XHR0aGlzLmJyZWFrKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTeW50YXguSWRlbnRpZmllcjpcblx0XHRcdFx0aWYgKGlzVmFyaWFibGVSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSlcblx0XHRcdFx0XHRyZWZlcmVuY2VzLmFkZChub2RlLm5hbWUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG5cdFx0XHRcdGlmIChpc01lbWJlclJlZmVyZW5jZShub2RlLCBwYXJlbnQpKSB7XG5cdFx0XHRcdFx0aWYgKGlzVmFyaWFibGVSZWZlcmVuY2Uobm9kZS5vYmplY3QsIG5vZGUpKVxuXHRcdFx0XHRcdFx0cmVmZXJlbmNlcy5hZGQobm9kZS5uYW1lKTtcblx0XHRcdFx0XHRyZWZlcmVuY2VzLmFkZChub2RlLm9iamVjdC5uYW1lICsgXCIuXCIgKyBub2RlLnByb3BlcnR5Lm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBTeW50YXguQ2FsbEV4cHJlc3Npb246XG5cdFx0XHRcdGlmIChub2RlLmNhbGxlZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBwYXJlbnRcblx0XHRcdFx0XHQmJiBwYXJlbnQudHlwZSAhPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gbm9kZS5jYWxsZWUub2JqZWN0O1xuXHRcdFx0XHRcdGlmIChvYmplY3QudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcilcblx0XHRcdFx0XHRcdHJlZmVyZW5jZXMuYWRkKG9iamVjdC5uYW1lKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHJlZmVyZW5jZXM7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSB7XG4gICAgcmV0dXJuIGlzVmFyaWFibGVOYW1lKG5vZGUsIHBhcmVudCkgJiYgcGFyZW50LnR5cGUgIT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVOYW1lKG5vZGUsIHBhcmVudCkge1xuXHRpZiAobm9kZS50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguTmV3RXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc01lbWJlclJlZmVyZW5jZShub2RlLCBwYXJlbnQpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RlLm9iamVjdC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RlLnByb3BlcnR5LnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG59XG5cblxuZXhwb3J0cy5maW5kVmFyaWFibGVEZWZpbml0aW9ucyA9IGZpbmRWYXJpYWJsZURlZmluaXRpb25zO1xuZXhwb3J0cy5maW5kVmFyaWFibGVSZWZlcmVuY2VzID0gZmluZFZhcmlhYmxlUmVmZXJlbmNlcztcbmV4cG9ydHMuaXNWYXJpYWJsZVJlZmVyZW5jZSA9IGlzVmFyaWFibGVSZWZlcmVuY2U7XG5leHBvcnRzLmlzVmFyaWFibGVOYW1lID0gaXNWYXJpYWJsZU5hbWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHdvcmtsaXN0ID0gcmVxdWlyZShcImFuYWx5c2VzXCIpO1xudmFyIFNldCA9IHdvcmtsaXN0LlNldDtcblxuZnVuY3Rpb24gY29tcHV0ZVBvc3REb21pbmF0b3JzKGNmZykge1xuICAgIHJldHVybiB3b3JrbGlzdChjZmcsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy50eXBlIHx8ICF0aGlzLmFzdE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAgICAgcmV0dXJuIFNldC51bmlvbihpbnB1dCwgbmV3IFNldChbdGhpc10pKTtcbiAgICB9LCB7ZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIsIHN0YXJ0OiBuZXcgU2V0KCksIG1lcmdlOiAgd29ya2xpc3QubWVyZ2UoU2V0LmludGVyc2VjdCl9KTtcbn1cblxuZXhwb3J0cy5jb21wdXRlUG9zdERvbWluYXRvcnMgPSBjb21wdXRlUG9zdERvbWluYXRvcnM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vdmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLy4uL2Jhc2UvY29tbW9uLmpzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG52YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG52YXIgVFlQRVMgPSByZXF1aXJlKFwiLi4vLi4vdHlwZS1zeXN0ZW0vY29uc3RhbnRzXCIpLlRZUEVTO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgcmV0dXJuIGVzdHJhdmVyc2UudHJhdmVyc2UoYXN0LCB7XG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gdXRpbHMuYW5ub3RhdGUobm9kZSksIHJpZ2h0O1xuICAgICAgICAgICAgaWYoIWFubm90YXRpb24uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGFubm90YXRpb24uZ2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JJbmZvLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGVycm9yLmxvYyA9IGVycm9ySW5mby5sb2M7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG5vZGUudHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdXRpbHMuYW5ub3RhdGUobm9kZS5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5jb3B5RnJvbShyaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24uaXNOdWxsT3JVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlscy50aHJvd0Vycm9yKG5vZGUsIFwiTm8gdHlwZSBjb3VsZCBiZSBjYWxjdWxhdGVkIGZvciBcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihub2RlLnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB1dGlscy5hbm5vdGF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmNvcHlGcm9tKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmNsZWFyVW5pZm9ybURlcGVuZGVuY2llcygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24uaXNOdWxsT3JVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlscy50aHJvd0Vycm9yKG5vZGUsIFwiTm8gdHlwZSBjb3VsZCBiZSBjYWxjdWxhdGVkIGZvciBcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYobm9kZS50eXBlID09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cCA9IHV0aWxzLmFubm90YXRlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5jb3B5RnJvbShleHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgdmFyIGFubm90YXRlID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpLmFubm90YXRlLFxuICAgICAgICBlc3RyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxuICAgICAgICBFcnJvckhhbmRsZXIgPSByZXF1aXJlKFwiLi4vdHlwZS1zeXN0ZW0vZXJyb3JzLmpzXCIpO1xuXG5cbiAgICB2YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5LjxvYmplY3Q+fSBub2RlXG4gICAgICogQHBhcmFtIHNjb3BlXG4gICAgICogQHJldHVybnMge1R5cGVJbmZvfEFycmF5LjxUeXBlSW5mbz59XG4gICAgICovXG4gICAgbnMuY3JlYXRlVHlwZUluZm8gPSBmdW5jdGlvbiAobm9kZSwgc2NvcGUpIHtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuY3JlYXRlVHlwZUluZm8oYXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBhbm5vdGF0ZShub2RlKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciB8fCBub2RlLnR5cGUgPT0gU3ludGF4LlRoaXNFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciA/IG5vZGUubmFtZSA6ICd0aGlzJztcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZ0J5TmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHlGcm9tKGJpbmRpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8QXJyYXkuPG9iamVjdD59IG5vZGVcbiAgICAgKiBAcGFyYW0gc2NvcGVcbiAgICAgKiBAcGFyYW0ge0FycmF5P30gY29uc3RhbnRzIEFkZGl0aW9uYWwgYXJyYXkgb2YgY29uc3RhbnRzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGVja1xuICAgICAqIEByZXR1cm5zIHtUeXBlSW5mb3xBcnJheS48VHlwZUluZm8+fVxuICAgICAqL1xuICAgIG5zLmdldFR5cGVJbmZvID0gZnVuY3Rpb24gZ2V0VHlwZUluZm8obm9kZSwgc2NvcGUsIGNvbnN0YW50cywgY2hlY2spIHtcbiAgICAgICAgaWYoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBjaGVjayA9IGNoZWNrID09IHVuZGVmaW5lZCA/IGZhbHNlIDogY2hlY2s7XG5cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHlwZUluZm8oYXJnLCBzY29wZSwgY29uc3RhbnRzLCBjaGVjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmluZGluZztcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG5cbiAgICAgICAgICAgIGlmKG5hbWUgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRlKG5vZGUpO1xuXG4gICAgICAgICAgICBiaW5kaW5nID0gc2NvcGUuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYoYmluZGluZyA9PSB1bmRlZmluZWQgJiYgY2hlY2spIHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZShub2RlKS5zZXRJbnZhbGlkKEVycm9ySGFuZGxlci5nZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRXJyb3JIYW5kbGVyLkVSUk9SX1RZUEVTLlJFRkVSRU5DRV9FUlJPUiwgbmFtZSwgXCJpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoYmluZGluZykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbm5vdGF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29weUZyb20oYmluZGluZyk7XG4gICAgICAgICAgICAgICAgLy8gQSB2YXJpYWJsZSBpcyBkeW5hbWljIHBlciBkZWZhdWx0LiBPbmx5IGlmIGl0J3MgbGlzdGVkIGluIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGFzc3VtZSBhIHN0YXRpYyB2YWx1ZVxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXREeW5hbWljVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLnNldER5bmFtaWNWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudHMgJiYgIWJpbmRpbmcuaXNOdWxsT3JVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGFnYXRlZENvbnN0YW50ID0gY29uc3RhbnRzLmZpbHRlcihmdW5jdGlvbiAoY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudC5uYW1lID09IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wYWdhdGVkQ29uc3RhbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nLnNldENvbnN0YW50VmFsdWUocHJvcGFnYXRlZENvbnN0YW50WzBdLmNvbnN0YW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRDb25zdGFudFZhbHVlKHByb3BhZ2F0ZWRDb25zdGFudFswXS5jb25zdGFudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LlRoaXNFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBiaW5kaW5nID0gc2NvcGUuZ2V0KFwidGhpc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZyB8fCBhbm5vdGF0ZShub2RlKTtcbiAgICB9O1xuXG5cblxuICAgIG5zLlN5bnRheCA9IFN5bnRheDtcbiAgICBucy5WaXNpdG9yT3B0aW9uID0gZXN0cmF2ZXJzZS5WaXNpdG9yT3B0aW9uO1xuXG4gICAgbnMuQU5OTyA9IGFubm90YXRlO1xuICAgIG5zLmdldE9iamVjdFJlZmVyZW5jZUZyb21Ob2RlID0gbnMuZ2V0VHlwZUluZm87XG5cblxufShleHBvcnRzKSk7XG4iLCJ2YXIgQ29udGV4dCA9IGZ1bmN0aW9uIChyb290LCBvcHQpIHtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdCB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG9mIHRoZSBwcm9ncmFtIHRvIGFuYWx5emVcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgLyoqXG4gICAgICogVG8gaWRlbnRpZnkgdGhlIG1haW4gbWV0aG9kIG9mIHRoZSBzaGFkZXJcbiAgICAgKiBAdHlwZSB7KnxzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tYWluRnVuY3Rpb24gPSBvcHQubWFpbkZ1bmN0aW9uIHx8IFwic2hhZGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48U2NvcGU+fVxuICAgICAqL1xuICAgIHRoaXMuc2NvcGVTdGFjayA9IG9wdC5zY29wZSA/IFtvcHQuc2NvcGVdIDogW107XG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCBrZXl3b3Jkc1xuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmJsb2NrZWROYW1lcyA9IG9wdC5ibG9ja2VkTmFtZXMgfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIG5hbWVzXG4gICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMudXNlZE5hbWVzID0gW107XG5cblxuICAgIHRoaXMuZGVjbGFyYXRpb24gPSBmYWxzZTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGdldFNjb3BlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH0sXG4gICAgcHVzaFNjb3BlOiBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFjay5wdXNoKHNjb3BlKTtcbiAgICB9LFxuICAgIHBvcFNjb3BlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gICAgfSxcbiAgICBpbk1haW5GdW5jdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY29wZSgpLnRvU3RyaW5nKCkgPT0gXCJnbG9iYWwuXCIgKyB0aGlzLm1haW5GdW5jdGlvbjtcbiAgICB9LFxuICAgIHNldEluRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBpbkRlY2xhcmF0aW9uO1xuICAgIH0sXG4gICAgaW5EZWNsYXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbjtcbiAgICB9LFxuICAgIGdldFNhZmVOYW1lOiBmdW5jdGlvbiAoYmFzZU5hbWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgc2VhcmNoTmFtZSA9IGJhc2VOYW1lO1xuICAgICAgICB3aGlsZSAodGhpcy5ibG9ja2VkTmFtZXMuaW5kZXhPZihzZWFyY2hOYW1lKSAhPSAtMSkge1xuICAgICAgICAgICAgc2VhcmNoTmFtZSA9IGJhc2VOYW1lICsgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoTmFtZTtcbiAgICB9LFxuICAgIGdldFNhZmVVbmlxdWVOYW1lOiBmdW5jdGlvbiAoYmFzZU5hbWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMSwgc2VhcmNoTmFtZSA9IGJhc2VOYW1lO1xuICAgICAgICB3aGlsZSAoISh0aGlzLnVzZWROYW1lcy5pbmRleE9mKHNlYXJjaE5hbWUpID09IC0xICYmIHRoaXMuYmxvY2tlZE5hbWVzLmluZGV4T2Yoc2VhcmNoTmFtZSkgPT0gLTEpKSB7XG4gICAgICAgICAgICBzZWFyY2hOYW1lID0gYmFzZU5hbWUgKyBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlZE5hbWVzLnB1c2goc2VhcmNoTmFtZSk7XG4gICAgICAgIHJldHVybiBzZWFyY2hOYW1lO1xuICAgIH1cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG5cbiIsIihmdW5jdGlvbihucyl7XG5cbiAgICBucy5leHRlbmQgPSByZXF1aXJlKFwibG9kYXNoLmFzc2lnblwiKTtcblxuXG5cbiAgICBucy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBzcmNWYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgZHN0VmFsdWUgPSBkZXN0aW5hdGlvbltwcm9wZXJ0eV07XG4gICAgICAgICAgICB2YXIgY29weTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvcHkgPSBkc3RWYWx1ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICBucy5kZWVwRXh0ZW5kKGNvcHksIHNyY1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNyY1ZhbHVlID09PSBcIm9iamVjdFwiICYmIHNyY1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29weSA9IGRzdFZhbHVlIHx8IHt9O1xuICAgICAgICAgICAgICAgIG5zLmRlZXBFeHRlbmQoY29weSwgc3JjVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5ID0gc3JjVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9O1xuXG4gICAgbnMuc2hhbGxvd0V4dGVuZCA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3RvciBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGNsYXNzXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBtZXRob2RzIE1ldGhvZHMgdG8gYWRkIHRvIHRoZSBjbGFzc1xuICAgICAqIEByZXR1cm4ge09iamVjdCF9XG4gICAgICovXG4gICAgbnMuY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbihjdG9yLCBwYXJlbnQsIG1ldGhvZHMpIHtcbiAgICAgICAgbWV0aG9kcyA9IG1ldGhvZHMgfHwge307XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgRigpO1xuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgICAgICAgICAgY3Rvci5zdXBlcmNsYXNzID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKCB2YXIgbSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVttXSA9IG1ldGhvZHNbbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3I7XG4gICAgfTtcblxuXG59KGV4cG9ydHMpKVxuIiwiKGZ1bmN0aW9uKG5zKXtcblxuICAgIG5zLnN3aXp6bGVUb0luZGV4ID0gZnVuY3Rpb24oc3dpenpsZUtleSl7XG4gICAgICAgIHN3aXRjaChzd2l6emxlS2V5KXtcbiAgICAgICAgICAgIGNhc2UgJ3gnOmNhc2UgJ3InIDpjYXNlICdzJzogcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlICd5JzpjYXNlICdnJyA6Y2FzZSAndCc6IHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAneic6Y2FzZSAnYicgOmNhc2UgJ3AnOiByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgJ3cnOmNhc2UgJ2EnIDpjYXNlICdxJzogcmV0dXJuIDM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzd2l6emxlIGtleTogJ1wiICsgc3dpenpsZUtleSArIFwiJ1wiKTtcbiAgICB9O1xuICAgIG5zLmluZGV4VG9Td2l6emxlID0gZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICBzd2l0Y2goaW5kZXgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gJ3gnO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gJ3knO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gJ3onO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gJ3cnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3dpenpsZSBpbmRleDogJ1wiICsgaW5kZXggKyBcIidcIik7XG4gICAgfTtcbiAgICBucy5zd2l6emxlU2V0cyA9IFtcbiAgICAgICAgWyd4JywgJ3knLCAneicsICd3J10sXG4gICAgICAgIFsncicsICdnJywgJ2InLCAnYSddLFxuICAgICAgICBbJ3MnLCAndCcsICdwJywgJ3EnXVxuICAgIF07XG4gICAgbnMuc3dpenpsZU9wZXJhdG9ycyA9IHtcbiAgICAgICAgJ0FkZCcgOiAnKycsXG4gICAgICAgICdTdWInIDogJy0nLFxuICAgICAgICAnTXVsJyA6ICcqJyxcbiAgICAgICAgJ0RpdicgOiAnLydcbiAgICB9XG5cblxufShleHBvcnRzKSlcbiIsIihmdW5jdGlvbihucyl7XG5cbiAgICB2YXIgT25lUGFyYW1ldGVyTnVtYmVyTWV0aG9kcyA9IFtcImFjb3NcIiwgXCJhc2luXCIsIFwiYXRhblwiLCBcImNvc1wiLCBcImV4cFwiLCBcImxvZ1wiLCBcInJvdW5kXCIsIFwic2luXCIsIFwic3FydFwiLCBcInRhblwiLCBcImNlaWxcIiwgXCJmbG9vclwiXTtcblxuICAgIGZ1bmN0aW9uIG9uZVBhcmFtZXRlckZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICB2YXIgZnVuYyA9IE1hdGhbbmFtZV07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZlYykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHZlYy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZ1bmModmVjW2xlbmd0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBWZWNNYXRoID0ge1xuICAgICAgICBtaXggOiBmdW5jdGlvbih4LHksYSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHgubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBvbmVNaW51c0E7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIGEubGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdoaWxlKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gYVtsZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IHhbbGVuZ3RoXSAqICgxIC0gYSkgKyB5W2xlbmd0aF0gKiBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25lTWludXNBID0gMSAtIGE7XG4gICAgICAgICAgICAgICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSB4W2xlbmd0aF0gKiBvbmVNaW51c0EgKyB5W2xlbmd0aF0gKiBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSxcbiAgICAgICAgc3RlcCA6IGZ1bmN0aW9uKGVkZ2UsIHgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBlZGdlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgICAgIHdoaWxlKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlZGdlW2xlbmd0aF07XG4gICAgICAgICAgICAgICAgdmFyIHgwID0geFtsZW5ndGhdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtsZW5ndGhdID0gKHgwIDw9IGUpID8gMCA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBzbW9vdGhzdGVwIDogZnVuY3Rpb24oZWRnZTAsIGVkZ2UxLCB4KSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZWRnZTAubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICAgICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZTAgPSBlZGdlMFtsZW5ndGhdO1xuICAgICAgICAgICAgICAgIHZhciBlMSA9IGVkZ2UxW2xlbmd0aF07XG4gICAgICAgICAgICAgICAgdmFyIHgwID0geFtsZW5ndGhdO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gTWF0aC5jbGFtcCgoeDAgLSBlMCkgLyAoZTEgLSBlMCksIDAuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IHQgKiB0ICogKDMuMCAtIDIuMCAqIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBPbmVQYXJhbWV0ZXJOdW1iZXJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBWZWNNYXRoW25hbWVdID0gb25lUGFyYW1ldGVyRnVuY3Rpb24obmFtZSk7XG4gICAgfSk7XG5cbiAgICBucy5WZWNNYXRoID0gVmVjTWF0aDtcblxuXG59KGV4cG9ydHMpKTtcbiIsIihmdW5jdGlvbiAobnMpIHtcblxuICAgIC8vIERlcGVuZGVuY2llc1xuICAgIHZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9jb21tb24uanNcIik7XG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIik7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICB2YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRmxvYXQodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW50ZXJuYWw6IEV4cHJlc3Npb24gZ2VuZXJhdGVkIE5hTiFcIik7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyArIHZhbHVlO1xuICAgICAgICBpZiAocmVzdWx0LmluZGV4T2YoXCIuXCIpID09IC0xICYmIHJlc3VsdC5pbmRleE9mKFwiZVwiKSA9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiLjBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdD99IG9wdGlvbnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRXhwcmVzc2lvbkhhbmRsZXIgPSBmdW5jdGlvbiAoY29udHJvbGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZ2VuZXJhdGVGbG9hdCA9IHRoaXMuY29udHJvbGxlci5nZW5lcmF0ZUZsb2F0IHx8IGdlbmVyYXRlRmxvYXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfTtcblxuICAgIEV4cHJlc3Npb25IYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYmluYXJ5OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZXhwcmVzc2lvbihub2RlKTtcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5CaW5hcnlFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCIoIFwiICsgcmVzdWx0ICsgXCIgKVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3VtZW50czogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiKFwiO1xuICAgICAgICAgICAgY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uKGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgY29udGFpbmVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLCBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyBcIilcIjtcbiAgICAgICAgfSxcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24gKGV4dHJhLCBhbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGV4dHJhID0gZXh0cmEgfHwge30sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBleHRyYS5zdGF0aWNWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZXh0cmEuc3RhdGljVmFsdWUgOiBhbHRlcm5hdGl2ZTtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLnR5cGUgPT0gU2hhZGUuVFlQRVMuTlVNQkVSKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIuZ2VuZXJhdGVGbG9hdCh2YWx1ZSk7IGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBcIlwiO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcblxuICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk5ld0V4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udHJvbGxlci50eXBlKG5vZGUuZXh0cmEsIHsgY29uc3RydWN0b3I6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFyZ3VtZW50cyhub2RlLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTGl0ZXJhbDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5saXRlcmFsKG5vZGUuZXh0cmEsIG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5CaW5hcnlFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5iaW5hcnkobm9kZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgbm9kZS5vcGVyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5iaW5hcnkobm9kZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmluYXJ5KG5vZGUuYXJndW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmV4cHJlc3Npb24obm9kZS5jYWxsZWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcmd1bWVudHMobm9kZS5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYmluYXJ5KG5vZGUub2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5vZGUuY29tcHV0ZWQgPyBcIltcIiA6IFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uKG5vZGUucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbXB1dGVkICYmIChyZXN1bHQgKz0gXCJdXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5leHByZXNzaW9uKG5vZGUudGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiA/IFwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uKG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiA6IFwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5VcGRhdGVFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1ByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5vZGUub3BlcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwcmVzc2lvbihub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCI8dW5oYW5kbGVkOiBcIiArIG5vZGUudHlwZSArIFwiPlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZW1lbnQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJ1bmhhbmRsZWQgc3RhdGVtZW50XCI7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlJldHVyblN0YXRlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0FyZ3VtZW50cyA9IG5vZGUuYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwicmV0dXJuXCIgKyAoaGFzQXJndW1lbnRzID8gKFwiIFwiICsgdGhpcy5leHByZXNzaW9uKG5vZGUuYXJndW1lbnQpKSA6IFwiXCIpICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFeHBvcnRzXG4gICAgbnMuRXhwcmVzc2lvbkhhbmRsZXIgPSBFeHByZXNzaW9uSGFuZGxlcjtcblxuXG59KGV4cG9ydHMpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpO1xudmFyIFN5bnRheCA9IGVzdHJhdmVyc2UuU3ludGF4O1xuXG5mdW5jdGlvbiBjcmVhdGVEZWNsYXJhdGlvbihuYW1lLCBpbml0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IGluaXQgIT09IHVuZGVmaW5lZCA/IGNyZWF0ZUlkZW50aWZpZXJMaXRlcmFsT3JTdHJpcEV4cHJlc3Npb24oaW5pdCkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAga2luZDogXCJ2YXJcIlxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihsaHMsIHJocywgb3BlcmF0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgdHlwZTogb3BlcmF0b3IgPT09IFwiPVwiID8gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uIDogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgICAgICAgICBsZWZ0OiBjcmVhdGVJZGVudGlmaWVyTGl0ZXJhbE9yU3RyaXBFeHByZXNzaW9uKGxocyksXG4gICAgICAgICAgICByaWdodDogY3JlYXRlSWRlbnRpZmllckxpdGVyYWxPclN0cmlwRXhwcmVzc2lvbihyaHMpLFxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHksIGluZm8pIHtcbiAgICByZXR1cm4gYW5ub3RhdGUoe1xuICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgb2JqZWN0OiBjcmVhdGVJZGVudGlmaWVyTGl0ZXJhbE9yU3RyaXBFeHByZXNzaW9uKG9iamVjdCksXG4gICAgICAgIHByb3BlcnR5OiBjcmVhdGVJZGVudGlmaWVyTGl0ZXJhbE9yU3RyaXBFeHByZXNzaW9uKHByb3BlcnR5KSxcbiAgICB9LCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSWRlbnRpZmllckxpdGVyYWxPclN0cmlwRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICBuYW1lOiBub2RlXG4gICAgICAgIH07XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogbm9kZVxuICAgICAgICB9O1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG5cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgb3BlcmF0b3I6IFwiLVwiLFxuICAgICAgICAgICAgYXJndW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogLXZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJZGVudGlmaWVyKG5hbWUsIGluZm8pIHtcbiAgICByZXR1cm4gYW5ub3RhdGUoe1xuICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgbmFtZTogbmFtZVxuICAgIH0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGwoZm4sIGFyZ3MsIGluZm8pIHtcbiAgICBhcmdzID0gYXJncyA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmdzO1xuICAgIGFyZ3MgPSBBcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXTtcbiAgICByZXR1cm4gYW5ub3RhdGUoe1xuICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgIGNhbGxlZTogY3JlYXRlSWRlbnRpZmllckxpdGVyYWxPclN0cmlwRXhwcmVzc2lvbihmbiksXG4gICAgICAgIGFyZ3VtZW50czogYXJncy5tYXAoY3JlYXRlSWRlbnRpZmllckxpdGVyYWxPclN0cmlwRXhwcmVzc2lvbilcbiAgICB9LCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlBY2Nlc3Mob2JqZWN0LCBpbmRleCwgaW5mbykge1xuICAgIHJldHVybiBhbm5vdGF0ZSh7XG4gICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgb2JqZWN0OiBjcmVhdGVJZGVudGlmaWVyTGl0ZXJhbE9yU3RyaXBFeHByZXNzaW9uKG9iamVjdCksXG4gICAgICAgIHByb3BlcnR5OiBjcmVhdGVJZGVudGlmaWVyTGl0ZXJhbE9yU3RyaXBFeHByZXNzaW9uKGluZGV4KVxuICAgIH0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheUV4cHJlc3Npb24oYXJncywgaW5mbykge1xuICAgIHJldHVybiBhbm5vdGF0ZSh7XG4gICAgICAgIHR5cGU6IFN5bnRheC5BcnJheUV4cHJlc3Npb24sXG4gICAgICAgIGVsZW1lbnRzOiBhcmdzLFxuICAgIH0sIGluZm8pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0V4cHJlc3Npb24obmFtZSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICBjYWxsZWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9LFxuICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAga2luZDogbmFtZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhbm5vdGF0ZShub2RlLCBpbmZvKSB7XG4gICAgbm9kZS5leHRyYSA9IGluZm87XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRGVjbGFyYXRpb24gPSBjcmVhdGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbiA9IGNyZWF0ZUJpbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLmNyZWF0ZUlkZW50aWZpZXIgPSBjcmVhdGVJZGVudGlmaWVyO1xuZXhwb3J0cy5jcmVhdGVNZW1iZXJFeHByZXNzaW9uID0gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuY3JlYXRlTGl0ZXJhbCA9IGNyZWF0ZUxpdGVyYWw7XG5leHBvcnRzLmNyZWF0ZUZ1bmN0aW9uQ2FsbCA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbDtcbmV4cG9ydHMuY3JlYXRlQXJyYXlBY2Nlc3MgPSBjcmVhdGVBcnJheUFjY2VzcztcbmV4cG9ydHMuY3JlYXRlQXJyYXlFeHByZXNzaW9uID0gY3JlYXRlQXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5jcmVhdGVOZXdFeHByZXNzaW9uID0gY3JlYXRlTmV3RXhwcmVzc2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBzaW1kTWFya2VyID0gcmVxdWlyZShcIi4vc2ltZF9tYXJrZXJcIik7XG52YXIgdmVjdG9yaXplciA9IHJlcXVpcmUoXCIuL3ZlY3Rvcml6ZXJcIik7XG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKFwiLi9zaW1wbGlmeVwiKTtcbnZhciBwcm9wYWdhdGVDb25zdGFudHMgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXIvY29uc3RhbnRfcHJvcGFnYXRpb25cIik7XG52YXIgaW5saW5lSW50ZXJuYWxGdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXIvaW5saW5lX2ludGVybmFsX2Z1bmN0aW9uc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBhc3RVdGlscyA9IHJlcXVpcmUoXCIuL2FzdF91dGlsc1wiKTtcbnZhciBtYXRoID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcblNoYWRlLm1hdGggPSBtYXRoO1xuU2hhZGUudGV4dHVyZSA9IHJlcXVpcmUoXCIuL3RleHR1cmVcIik7XG5cbnZhciBzdXBwb3J0ZWRUeXBlcyA9IGNvbnN0YW50cy5zdXBwb3J0ZWRUeXBlcztcbnZhciB0eXBlU2l6ZU1hcCA9IGNvbnN0YW50cy50eXBlU2l6ZU1hcDtcbnZhciBzd2l6emxlVG9JbmRleE1hcCA9IGNvbnN0YW50cy5zd2l6emxlVG9JbmRleE1hcDtcbnZhciBjb2x1bW5Ub1NpbmdsZVN3aXp6bGUgPSBjb25zdGFudHMuY29sdW1uVG9TaW5nbGVTd2l6emxlO1xudmFyIHZlY3RvckluZGV4VG9Td2l6emxlTWFwID0gY29uc3RhbnRzLnZlY3RvckluZGV4VG9Td2l6emxlTWFwO1xudmFyIG1hdHJpeEluZGV4VG9Td2l6emxlTWFwID0gY29uc3RhbnRzLm1hdHJpeEluZGV4VG9Td2l6emxlTWFwO1xudmFyIGluZGV4VG9Td2l6emxlTWFwID0gY29uc3RhbnRzLmluZGV4VG9Td2l6emxlTWFwO1xuXG5mdW5jdGlvbiBGYXN0bGFuZUNvbXBpbGVyKG9wdCkge1xuXHRvcHQgPSBPYmplY3QuYXNzaWduKHt1c2VTSU1EOiBmYWxzZX0sIG9wdCk7XG5cblx0dGhpcy5fdXNlU0lNRCA9IG9wdC51c2VTSU1EO1xuXHR0aGlzLl9jb3VudGVyID0gMDtcblx0dGhpcy5faXNTSU1EVHlwZSA9IG5ldyBTZXQoKTtcbn1cblxuRmFzdGxhbmVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKGFhc3QsIG9wdCkge1xuXHR2YXIgbm9ybWFsaXplciA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZXJcIik7XG5cdG5vcm1hbGl6ZXIubm9ybWFsaXplKGFhc3QpO1xuXHRpZiAodGhpcy5fdXNlU0lNRCkge1xuXHRcdHZlY3Rvcml6ZXIudmVjdG9yaXplKGFhc3QuYm9keVswXS5ib2R5KTtcblx0XHRzaW1kTWFya2VyLm1hcmsoYWFzdC5ib2R5WzBdLmJvZHkpO1xuXHR9XG5cblx0YWFzdCA9IHRoaXMudHJhdmVyc2UoYWFzdCk7XG5cblx0dmFyIERlY2xhcmF0aW9uU2ltcGxpZmllciA9IHJlcXVpcmUoXCIuLi8uLi9hbmFseXplL3Nhbml0aXplci9kZWNsYXJhdGlvbl9zaW1wbGlmaWVyXCIpO1xuXHR2YXIgUmVkdW5kYW50QmxvY2tzUmVtb3ZlclxuXHRcdD0gcmVxdWlyZShcIi4uLy4uL2FuYWx5emUvc2FuaXRpemVyL3JlZHVuZGFudF9ibG9ja3NfcmVtb3ZlclwiKTtcblxuXHR2YXIgZGVjbGFyYXRpb25TaW1wbGlmaWVyID0gbmV3IERlY2xhcmF0aW9uU2ltcGxpZmllcigpO1xuXHRkZWNsYXJhdGlvblNpbXBsaWZpZXIuZXhlY3V0ZShhYXN0KTtcblxuXHRpbmxpbmVJbnRlcm5hbEZ1bmN0aW9ucyhhYXN0KTtcblxuXHRlc3RyYXZlcnNlLnJlcGxhY2UoYWFzdCwge1xuXHRcdGVudGVyOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRpZiAobm9kZS50eXBlID09PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCkge1xuXHRcdFx0XHRpZiAobm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudClcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuXHRcdFx0XHRpZiAobm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBub2RlLmV4cHJlc3Npb24ucmlnaHQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KVxuXHRcdFx0XHRcdHJldHVybiBub2RlLmV4cHJlc3Npb24ucmlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHR2YXIgcmVkdW5kYW50QmxvY2tzUmVtb3ZlciA9IG5ldyBSZWR1bmRhbnRCbG9ja3NSZW1vdmVyKCk7XG5cdGRlY2xhcmF0aW9uU2ltcGxpZmllci5leGVjdXRlKGFhc3QpO1xuXHRyZWR1bmRhbnRCbG9ja3NSZW1vdmVyLmV4ZWN1dGUoYWFzdCk7XG5cblx0cHJvcGFnYXRlQ29uc3RhbnRzKGFhc3QpO1xuXG5cdGVzdHJhdmVyc2UucmVwbGFjZShhYXN0LCB7XG5cdFx0ZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRpZiAobm9kZS50eXBlID09PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gU3ludGF4LkVtcHR5U3RhdGVtZW50KVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoKTtcblx0XHRcdGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5FbXB0eVN0YXRlbWVudClcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlKCk7XG5cdFx0fVxuXHR9KTtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIGlmIChvcHQubmFtZSlcblx0XHRhYXN0LmJvZHlbMF0uaWQubmFtZSA9IG9wdC5uYW1lO1xuXG5cdGlmIChvcHQuYmVuY2htYXJrKSB7XG5cdFx0aW5zZXJ0QmVuY2htYXJraW5nKGFhc3QpO1xuXHR9XG5cblx0cmV0dXJuIHV0aWxzLnRvSmF2YVNjcmlwdChhYXN0KTtcbn07XG5cbmZ1bmN0aW9uIGluc2VydEJlbmNobWFya2luZyhhYXN0KSB7XG5cdHZhciB0ME5hbWUgPSBcIl9fYmVuY2htYXJrX3QwXCI7XG5cdGFhc3QuYm9keVswXS5ib2R5LmJvZHkudW5zaGlmdChhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbih0ME5hbWUsIGFzdFV0aWxzLmNyZWF0ZUZ1bmN0aW9uQ2FsbChcInBlcmZvcm1hbmNlLm5vd1wiKSkpO1xuXHRlc3RyYXZlcnNlLnRyYXZlcnNlKGFhc3QuYm9keVswXS5ib2R5LCB7XG5cdFx0ZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRpZiAobm9kZS50eXBlID09PSBTeW50YXguUmV0dXJuU3RhdGVtZW50KSB7XG5cdFx0XHRcdG5vZGUuYXJndW1lbnQucHJvcGVydGllcy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiBTeW50YXguUHJvcGVydHksXG5cdFx0XHRcdFx0a2V5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IFwiX190aW1lXCJ9LFxuXHRcdFx0XHRcdHZhbHVlOiBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGFzdFV0aWxzLmNyZWF0ZUZ1bmN0aW9uQ2FsbChcInBlcmZvcm1hbmNlLm5vd1wiKSwgdDBOYW1lLCBcIi1cIikuZXhwcmVzc2lvblxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbkZhc3RsYW5lQ29tcGlsZXIucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24oYmxvY2spIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHZhciBjdXJyZW50QmxvY2sgPSBudWxsO1xuXHR2YXIgb2xkQmxvY2sgPSBudWxsO1xuXHR2YXIgcGFyZW50ID0gLTE7XG5cdGJsb2NrID0gZXN0cmF2ZXJzZS5yZXBsYWNlKGJsb2NrLCB7XG5cdFx0ZW50ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuXHRcdFx0XHRvbGRCbG9jayA9IGN1cnJlbnRCbG9jaztcblx0XHRcdFx0Y3VycmVudEJsb2NrID0gbm9kZTtcblx0XHRcdH1cblx0XHRcdGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50KSB7XG5cdFx0XHRcdHBhcmVudCA9IG5vZGU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsZWF2ZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KVxuXHRcdFx0XHRjdXJyZW50QmxvY2sgPSBvbGRCbG9jaztcblx0XHRcdGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbilcblx0XHRcdFx0bm9kZS5hcmd1bWVudHMgPSBub2RlLmFyZ3VtZW50cy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICF1dGlscy5hbm5vdGF0ZShhcmcpLmlzVW5kZWZpbmVkKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pXG5cdFx0XHRcdHJldHVybiBzZWxmLmhhbmRsZU5ld0V4cHJlc3Npb24oXG5cdFx0XHRcdFx0bm9kZSwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2suYm9keS5pbmRleE9mKHBhcmVudCkpO1xuXHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pXG5cdFx0XHRcdHJldHVybiBzZWxmLmhhbmRsZU1lbWJlckV4cHJlc3Npb24oXG5cdFx0XHRcdFx0bm9kZSwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2suYm9keS5pbmRleE9mKHBhcmVudCkpO1xuXHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkNhbGxFeHByZXNzaW9uXG5cdFx0XHRcdCYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKVxuXHRcdFx0XHRyZXR1cm4gc2VsZi5oYW5kbGVNZW1iZXJDYWxsRXhwcmVzc2lvbihcblx0XHRcdFx0XHRub2RlLCBjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9jay5ib2R5LmluZGV4T2YocGFyZW50KSk7XG5cdFx0XHRpZiAobm9kZS50eXBlID09PSBTeW50YXguUmV0dXJuU3RhdGVtZW50KVxuXHRcdFx0XHRyZXR1cm4gc2VsZi5oYW5kbGVSZXR1cm5TdGF0ZW1lbnQoXG5cdFx0XHRcdFx0bm9kZSwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2suYm9keS5pbmRleE9mKHBhcmVudCkpO1xuXHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLmhhbmRsZUFzc2lnbm1lbnRFeHByZXNzaW9uKFxuXHRcdFx0XHRcdG5vZGUsIGN1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrLmJvZHkuaW5kZXhPZihwYXJlbnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBibG9jaztcbn07XG5cbkZhc3RsYW5lQ29tcGlsZXIucHJvdG90eXBlLmhhbmRsZU5ld0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBjdXJyZW50QmxvY2ssXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBpbmRleCkge1xuXHR2YXIgYW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUpO1xuXHR2YXIga2luZCA9IGFubm90YXRpb24uZ2V0S2luZCgpO1xuXHRpZiAoc3VwcG9ydGVkVHlwZXMuaGFzKGtpbmQpKSB7XG5cdFx0dmFyIGFyZ3MgPSBub2RlLmFyZ3VtZW50cztcblx0XHR2YXIgc2l6ZSA9IHR5cGVTaXplTWFwW2tpbmRdO1xuXHRcdHZhciB0bXAgPSB0aGlzLmNyZWF0ZVRtcFZhcmlhYmxlTmFtZSgpO1xuXHRcdHZhciBpbml0ID0gbnVsbDtcblx0XHRpZiAobm9kZS5fX3NpbWQpIHtcblx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpbml0ID0gYXN0VXRpbHMuY3JlYXRlRnVuY3Rpb25DYWxsKFxuXHRcdFx0XHRcdFwiU0lNRC5GbG9hdDMyeDQuc3BsYXRcIixcblx0XHRcdFx0XHRub2RlLmFyZ3VtZW50c1swXSxcblx0XHRcdFx0XHRub2RlLmV4dHJhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluaXQgPSBhc3RVdGlscy5jcmVhdGVGdW5jdGlvbkNhbGwoXG5cdFx0XHRcdFx0XCJTSU1ELkZsb2F0MzJ4NFwiLFxuXHRcdFx0XHRcdHRoaXMuY29udmVydEFyZ3VtZW50cyhub2RlLmFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bm9kZS5leHRyYSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pc1NJTURUeXBlLmFkZCh0bXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBzaXplOyArK2kpXG5cdFx0XHRcdFx0YXJnc1tpXSA9IGFyZ3NbMF07XG5cdFx0XHR9XG5cdFx0XHRpbml0ID0gYXN0VXRpbHMuY3JlYXRlQXJyYXlFeHByZXNzaW9uKFxuXHRcdFx0XHR0aGlzLmNvbnZlcnRBcmd1bWVudHMobm9kZS5hcmd1bWVudHMpLFxuXHRcdFx0XHRub2RlLmV4dHJhKTtcblx0XHR9XG5cblx0XHRjdXJyZW50QmxvY2suYm9keS5zcGxpY2UoXG5cdFx0XHRpbmRleCwgMCxcblx0XHRcdGFzdFV0aWxzLmNyZWF0ZURlY2xhcmF0aW9uKGNyZWF0ZU9mZnNldFZhcmlhYmxlTmFtZSh0bXApLCAwKSxcblx0XHRcdGFzdFV0aWxzLmNyZWF0ZURlY2xhcmF0aW9uKHRtcCwgaW5pdClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIodG1wLCBub2RlLmV4dHJhKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn07XG5cbkZhc3RsYW5lQ29tcGlsZXIucHJvdG90eXBlLmNyZWF0ZVRtcFZhcmlhYmxlTmFtZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCJfX3RtcFwiICsgdGhpcy5fY291bnRlcisrO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKG5hbWUpIHtcblx0cmV0dXJuIFwiX19vZmZzZXRcIiArIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGlzVG1wVmFyaWFibGUobmFtZSkge1xuXHRyZXR1cm4gbmFtZSA/IG5hbWUuaW5kZXhPZihcIl9fXCIpID09PSAwIDogZmFsc2U7XG59XG5cbkZhc3RsYW5lQ29tcGlsZXIucHJvdG90eXBlLmNvbnZlcnRBcmd1bWVudHMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0dmFyIHNjYWxhckxpc3QgPSBbXTtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB2YWx1ZUFubm90YXRpb24gPSB1dGlscy5hbm5vdGF0ZSh2YWx1ZSk7XG5cdFx0aWYgKHZhbHVlQW5ub3RhdGlvbi5jYW5OdW1iZXIoKSkge1xuXHRcdFx0c2NhbGFyTGlzdC5wdXNoKHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlQW5ub3RhdGlvbi5pc1ZlY3RvcigpKSB7XG5cdFx0XHR2YXIga2luZCA9IHZhbHVlQW5ub3RhdGlvbi5nZXRLaW5kKCk7XG5cdFx0XHR2YXIgc2l6ZSA9IHR5cGVTaXplTWFwW2tpbmRdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXG5cdFx0XHRcdHNjYWxhckxpc3QucHVzaChcblx0XHRcdFx0XHRzZWxmLnN3aXp6bGVUb0V4dHJhY3QoYXN0VXRpbHMuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbihcblx0XHRcdFx0XHRcdHZhbHVlLCBpbmRleFRvU3dpenpsZU1hcFtraW5kXVtpXSwge3R5cGU6IFwibnVtYmVyXCJ9KSkpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHNjYWxhckxpc3QucHVzaCh2YWx1ZSlcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBzY2FsYXJMaXN0O1xufTtcblxuRmFzdGxhbmVDb21waWxlci5wcm90b3R5cGUuY3JlYXRlRnJvbVZhbHVlc0NhbGwgPSBmdW5jdGlvbihraW5kLCBhcmdzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgIHR5cGVTaXplKSB7XG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdHlwZVNpemU7ICsraSlcblx0XHRcdGFyZ3NbaV0gPSBhcmdzWzBdO1xuXHR9XG5cblx0cmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUFycmF5RXhwcmVzc2lvbihhcmdzLCB7dHlwZTogXCJvYmplY3RcIiwga2luZDoga2luZH0pO1xufTtcblxuRmFzdGxhbmVDb21waWxlci5wcm90b3R5cGUuaGFuZGxlTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIGN1cnJlbnRCbG9jayxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBpbmRleCkge1xuXHR2YXIgcmVzdWx0QW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUpO1xuXHR2YXIgb2JqZWN0QW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUub2JqZWN0KTtcblxuXHRpZiAocmVzdWx0QW5ub3RhdGlvbi5nZXRUeXBlKCkgPT09IFwiYW55XCIpXG5cdFx0cmV0dXJuO1xuXG5cdGlmIChvYmplY3RBbm5vdGF0aW9uLmlzVGV4dHVyZSgpKSB7XG5cdFx0aWYgKG5vZGUucHJvcGVydHkubmFtZSA9PT0gXCJ3aWR0aFwiKVxuXHRcdFx0bm9kZS5wcm9wZXJ0eS5uYW1lID0gXCJzaGFwZVswXVwiO1xuXHRcdGlmIChub2RlLnByb3BlcnR5Lm5hbWUgPT09IFwiaGVpZ2h0XCIpXG5cdFx0XHRub2RlLnByb3BlcnR5Lm5hbWUgPSBcInNoYXBlWzFdXCI7XG5cdH1cblxuXHRpZiAobm9kZS5jb21wdXRlZCkge1xuXHRcdGlmIChvYmplY3RBbm5vdGF0aW9uLmlzQXJyYXkoKSkge1xuXHRcdFx0dmFyIGVsZW1lbnRTaXplID0gZGV0ZXJtaW5lTG9naWNhbEVsZW1lbnRTaXplKG5vZGUub2JqZWN0KTtcblx0XHRcdHZhciBvZmZzZXQgPSBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUucHJvcGVydHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGVsZW1lbnRTaXplLCBcIipcIilcblx0XHRcdFx0XHRcdFx0IC5leHByZXNzaW9uO1xuXHRcdFx0aWYgKGlzVG1wVmFyaWFibGUobm9kZS5vYmplY3QubmFtZSkpIHtcblx0XHRcdFx0b2Zmc2V0ID0gYXN0VXRpbHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihcblx0XHRcdFx0XHRcdFx0XHRcdCBvZmZzZXQsXG5cdFx0XHRcdFx0XHRcdFx0XHQgY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKG5vZGUub2JqZWN0Lm5hbWUpLFxuXHRcdFx0XHRcdFx0XHRcdFx0IFwiK1wiKVxuXHRcdFx0XHRcdFx0XHQgLmV4cHJlc3Npb247XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZXN1bHRBbm5vdGF0aW9uLmNhbk51bWJlcigpKSB7XG5cdFx0XHRcdHJldHVybiBhc3RVdGlscy5jcmVhdGVBcnJheUFjY2Vzcyhub2RlLm9iamVjdCwgb2Zmc2V0KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRtcCA9IHRoaXMuY3JlYXRlVG1wVmFyaWFibGVOYW1lKCk7XG5cdFx0XHRcdGN1cnJlbnRCbG9jay5ib2R5LnNwbGljZShcblx0XHRcdFx0XHRpbmRleCwgMCwgYXN0VXRpbHMuY3JlYXRlRGVjbGFyYXRpb24odG1wLCBub2RlLm9iamVjdCksXG5cdFx0XHRcdFx0YXN0VXRpbHMuY3JlYXRlRGVjbGFyYXRpb24oY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKHRtcCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgb2Zmc2V0KSk7XG5cdFx0XHRcdHJldHVybiBhc3RVdGlscy5jcmVhdGVJZGVudGlmaWVyKHRtcCwgcmVzdWx0QW5ub3RhdGlvbi5pbmZvKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9iamVjdEFubm90YXRpb24uaXNUZXh0dXJlKCkpIHtcblx0XHRcdHZhciBlbGVtZW50U2l6ZSA9IG9iamVjdEFubm90YXRpb24uaW5mby53aWR0aCAqIDQ7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gYXN0VXRpbHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihub2RlLnByb3BlcnR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBlbGVtZW50U2l6ZSwgXCIqXCIpXG5cdFx0XHRcdFx0XHRcdCAuZXhwcmVzc2lvbjtcblx0XHRcdGlmIChub2RlLm9iamVjdC5uYW1lICYmIG5vZGUub2JqZWN0Lm5hbWUuaW5kZXhPZihcIl9fXCIpID09PSAwKSB7XG5cdFx0XHRcdG9mZnNldCA9IGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oXG5cdFx0XHRcdFx0XHRcdFx0XHQgb2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHRcdFx0IGNyZWF0ZU9mZnNldFZhcmlhYmxlTmFtZShub2RlLm9iamVjdC5uYW1lKSxcblx0XHRcdFx0XHRcdFx0XHRcdCBcIitcIilcblx0XHRcdFx0XHRcdFx0IC5leHByZXNzaW9uO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuY3JlYXRlVG1wVmFyaWFibGVOYW1lKCk7XG5cdFx0XHRjdXJyZW50QmxvY2suYm9keS5zcGxpY2UoXG5cdFx0XHRcdGluZGV4LCAwLCBhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbih0bXAsIG5vZGUub2JqZWN0KSxcblx0XHRcdFx0YXN0VXRpbHMuY3JlYXRlRGVjbGFyYXRpb24oY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKHRtcCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgIG9mZnNldCkpO1xuXHRcdFx0cmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIodG1wLCByZXN1bHRBbm5vdGF0aW9uLmluZm8pO1xuXHRcdH1cblx0fVxuXG5cdGlmICghbm9kZS5jb21wdXRlZCAmJiBzdXBwb3J0ZWRUeXBlcy5oYXMob2JqZWN0QW5ub3RhdGlvbi5nZXRLaW5kKCkpXG5cdFx0JiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcilcblx0XHRyZXR1cm4gdGhpcy5zd2l6emxlVG9FeHRyYWN0KG5vZGUpO1xufTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lTG9naWNhbEVsZW1lbnRTaXplKG9iamVjdCkge1xuXHR2YXIgYW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG9iamVjdCk7XG5cdHZhciBlbGVtZW50VHlwZSA9IGFubm90YXRpb24uZ2V0QXJyYXlFbGVtZW50VHlwZSgpO1xuXHR2YXIgc2l6ZSA9IDE7XG5cblx0d2hpbGUgKGVsZW1lbnRUeXBlLmV4dHJhLnR5cGUgPT09IFwiYXJyYXlcIikge1xuXHRcdHNpemUgKj0gZWxlbWVudFR5cGUuZXh0cmEuc3RhdGljU2l6ZTtcblx0XHRlbGVtZW50VHlwZSA9IGVsZW1lbnRUeXBlLmV4dHJhLmVsZW1lbnRzO1xuXHR9XG5cblx0cmV0dXJuIHNpemUgKiB0eXBlU2l6ZU1hcFtlbGVtZW50VHlwZS5leHRyYS5raW5kIHx8IGVsZW1lbnRUeXBlLmV4dHJhLnR5cGVdO1xufVxuXG5GYXN0bGFuZUNvbXBpbGVyLnByb3RvdHlwZS5zd2l6emxlVG9FeHRyYWN0ID0gZnVuY3Rpb24obm9kZSkge1xuXHR2YXIgcmVzdWx0QW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUpO1xuXHR2YXIgb2JqZWN0QW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUub2JqZWN0KTtcblxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGZ1bmN0aW9uIHN3aXp6bGVUb0FjY2Vzcyhzd2l6emxlKSB7XG5cdFx0dmFyIGluZGV4ID0gc3dpenpsZVRvSW5kZXhNYXBbb2JqZWN0QW5ub3RhdGlvbi5nZXRLaW5kKCldW3N3aXp6bGVdO1xuXHRcdGlmIChub2RlLm9iamVjdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuXHRcdFx0aWYgKHNlbGYuX2lzU0lNRFR5cGUuaGFzKG5vZGUub2JqZWN0Lm5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBhc3RVdGlscy5jcmVhdGVGdW5jdGlvbkNhbGwoXCJTSU1ELkZsb2F0MzJ4NC5leHRyYWN0TGFuZVwiLCBbbm9kZS5vYmplY3QsIGluZGV4XSwge3R5cGU6IFwibnVtYmVyXCJ9KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUFycmF5QWNjZXNzKFxuXHRcdFx0XHRcdG5vZGUub2JqZWN0LFxuXHRcdFx0XHRcdGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oXG5cdFx0XHRcdFx0XHRjcmVhdGVPZmZzZXRWYXJpYWJsZU5hbWUobm9kZS5vYmplY3QubmFtZSksIGluZGV4LCBcIitcIiksXG5cdFx0XHRcdFx0e3R5cGU6IFwibnVtYmVyXCJ9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gYXN0VXRpbHMuY3JlYXRlQXJyYXlBY2Nlc3Mobm9kZS5vYmplY3QsIGluZGV4LCB7dHlwZTogXCJudW1iZXJcIn0pO1xuXHRcdH1cblx0fVxuXG5cdGlmIChyZXN1bHRBbm5vdGF0aW9uLmlzTnVtYmVyKCkpIHtcblx0XHRyZXR1cm4gc3dpenpsZVRvQWNjZXNzKG5vZGUucHJvcGVydHkubmFtZSk7XG5cdH1cblxuXHRpZiAocmVzdWx0QW5ub3RhdGlvbi5pc1ZlY3RvcigpKSB7XG5cdFx0aWYgKG9iamVjdEFubm90YXRpb24uaXNWZWN0b3IoKSkge1xuXHRcdFx0dmFyIGVsZW1lbnRzXG5cdFx0XHRcdD0gbm9kZS5wcm9wZXJ0eS5uYW1lLnNwbGl0KFwiXCIpLm1hcChzd2l6emxlVG9BY2Nlc3MpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0QW5ub3RhdGlvbi5pc01hdHJpeCgpKSB7XG5cdFx0XHR2YXIgZWxlbWVudHNcblx0XHRcdFx0PSBjb2x1bW5Ub1NpbmdsZVN3aXp6bGVbbm9kZS5wcm9wZXJ0eS5uYW1lXVxuXHRcdFx0XHRcdCAgLnNwbGl0KFwiLFwiKVxuXHRcdFx0XHRcdCAgLnNsaWNlKDAsIHR5cGVTaXplTWFwW3Jlc3VsdEFubm90YXRpb24uZ2V0S2luZCgpXSlcblx0XHRcdFx0XHQgIC5tYXAoc3dpenpsZVRvQWNjZXNzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRnJvbVZhbHVlc0NhbGwocmVzdWx0QW5ub3RhdGlvbi5nZXRLaW5kKCksIGVsZW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgZWxlbWVudHMubGVuZ3RoKTtcblx0fVxufTtcblxuRmFzdGxhbmVDb21waWxlci5wcm90b3R5cGUuaGFuZGxlQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbihcblx0bm9kZSwgY3VycmVudEJsb2NrLCBpbmRleCkge1xuXHR2YXIgbGhzID0gbm9kZS5sZWZ0O1xuXHR2YXIgcmhzID0gbm9kZS5yaWdodDtcblx0dmFyIHJoc0Fubm90YXRpb24gPSB1dGlscy5hbm5vdGF0ZShyaHMpO1xuXG5cdGlmIChsaHMudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgcmhzLl9fc2ltZCB8fCB0aGlzLl9pc1NJTURUeXBlLmhhcyhyaHMubmFtZSkpXG5cdFx0dGhpcy5faXNTSU1EVHlwZS5hZGQobGhzLm5hbWUpO1xuXG5cdGlmIChsaHMudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNUbXBWYXJpYWJsZShsaHMubmFtZSlcblx0XHQmJiByaHMudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXJcblx0XHQmJiByaHMubmFtZS5pbmRleE9mKFwiX2NhbGxcIikgIT09IC0xKSB7XG5cblx0XHR2YXIgZm5Ob2RlID0gbnVsbDtcblx0XHRlc3RyYXZlcnNlLnJlcGxhY2UoY3VycmVudEJsb2NrLCB7XG5cdFx0XHRlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIG5vZGUubGVmdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBub2RlLmxlZnQubmFtZSA9PT0gcmhzLm5hbWUpIHtcblx0XHRcdFx0XHRub2RlLnJpZ2h0LmNhbGxlZS5uYW1lICs9IFwiU3RvcmVcIjtcblx0XHRcdFx0XHRub2RlLnJpZ2h0LmFyZ3VtZW50cy51bnNoaWZ0KGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIoY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKGxocy5uYW1lKSkpO1xuXHRcdFx0XHRcdG5vZGUucmlnaHQuYXJndW1lbnRzLnVuc2hpZnQobGhzKTtcblx0XHRcdFx0XHRmbk5vZGUgPSBub2RlO1xuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogU3ludGF4LkVtcHR5U3RhdGVtZW50fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZuTm9kZTtcblx0fVxuXG5cdGlmIChsaHMudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1RtcFZhcmlhYmxlKGxocy5uYW1lKSkge1xuXHRcdHZhciByaHNLaW5kID0gcmhzQW5ub3RhdGlvbi5nZXRLaW5kKCk7XG5cdFx0dmFyIG9iamVjdCA9IGxocztcblx0XHR2YXIgb2JqZWN0QW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG9iamVjdCk7XG5cdFx0dmFyIGJvZHkgPSBbXTtcblx0XHRpZiAob2JqZWN0QW5ub3RhdGlvbi5pc1ZlY3RvcigpIHx8IG9iamVjdEFubm90YXRpb24uaXNNYXRyaXgoKSkge1xuXHRcdFx0dmFyIHZhck5hbWUgPSByaHMubmFtZTtcblx0XHRcdGlmIChyaHMudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpIHtcblx0XHRcdFx0dmFyIHRtcCA9IHRoaXMuY3JlYXRlVG1wVmFyaWFibGVOYW1lKCk7XG5cdFx0XHRcdGJvZHkucHVzaChhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbih0bXAsIHJocykpO1xuXHRcdFx0XHRpZiAocmhzLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzVG1wVmFyaWFibGUocmhzLm5hbWUpKVxuXHRcdFx0XHRcdGJvZHkucHVzaChhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbihcblx0XHRcdFx0XHRcdGNyZWF0ZU9mZnNldFZhcmlhYmxlTmFtZSh0bXApLFxuXHRcdFx0XHRcdFx0YXN0VXRpbHMuY3JlYXRlSWRlbnRpZmllcihcblx0XHRcdFx0XHRcdFx0Y3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKHJocy5uYW1lKSkpKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGJvZHkucHVzaChhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbihcblx0XHRcdFx0XHRcdGNyZWF0ZU9mZnNldFZhcmlhYmxlTmFtZSh0bXApLCBhc3RVdGlscy5jcmVhdGVMaXRlcmFsKDApKSk7XG5cdFx0XHRcdHZhck5hbWUgPSB0bXA7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZVNpemVNYXBbcmhzS2luZF07ICsraSkge1xuXHRcdFx0XHRib2R5LnB1c2goYXN0VXRpbHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihcblx0XHRcdFx0XHRhc3RVdGlscy5jcmVhdGVBcnJheUFjY2Vzcyhcblx0XHRcdFx0XHRcdG9iamVjdCxcblx0XHRcdFx0XHRcdGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZU9mZnNldFZhcmlhYmxlTmFtZShvYmplY3QubmFtZSksIGksIFwiK1wiKSksXG5cdFx0XHRcdFx0dGhpcy5zd2l6emxlVG9FeHRyYWN0KGFzdFV0aWxzLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24oXG5cdFx0XHRcdFx0XHRhc3RVdGlscy5jcmVhdGVJZGVudGlmaWVyKFxuXHRcdFx0XHRcdFx0XHR2YXJOYW1lLCB7dHlwZTogXCJvYmplY3RcIiwga2luZDogcmhzS2luZH0pLFxuXHRcdFx0XHRcdFx0cmhzQW5ub3RhdGlvbi5pc01hdHJpeCgpXG5cdFx0XHRcdFx0XHRcdD8gbWF0cml4SW5kZXhUb1N3aXp6bGVNYXBbcmhzS2luZF1baV1cblx0XHRcdFx0XHRcdFx0OiB2ZWN0b3JJbmRleFRvU3dpenpsZU1hcFtpXSxcblx0XHRcdFx0XHRcdHt0eXBlOiBcIm51bWJlclwifSkpLFxuXHRcdFx0XHRcdFwiPVwiKSlcblx0XHRcdH1cblx0XHRcdHJldHVybiB7dHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LCBib2R5OiBib2R5fTtcblx0XHR9XG5cdH1cblxuXHRpZiAobGhzLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG5cdFx0aWYgKHJoc0Fubm90YXRpb24uaXNBcnJheSgpIHx8IHJocy50eXBlID09PSBTeW50YXguQXJyYXlFeHByZXNzaW9uIHx8IChyaHMudHlwZSA9PT0gU3ludGF4LkNhbGxFeHByZXNzaW9uICYmIHJocy5jYWxsZWUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgcmhzLmNhbGxlZS5uYW1lLmluZGV4T2YoXCJTaGFkZS5cIikgIT09IC0xKSkge1xuXHRcdFx0dmFyIG9mZnNldCA9IGFzdFV0aWxzLmNyZWF0ZUxpdGVyYWwoMCk7XG5cdFx0XHRpZiAocmhzLm5hbWUgJiYgcmhzLm5hbWUuaW5kZXhPZihcIl9fXCIpID09PSAwKSB7XG5cdFx0XHRcdG9mZnNldCA9IGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIoXCJfX29mZnNldFwiICsgcmhzLm5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHZhck5hbWUgPSBsaHMubmFtZTtcblx0XHRcdGN1cnJlbnRCbG9jay5ib2R5LnNwbGljZShcblx0XHRcdFx0aW5kZXgsIDAsXG5cdFx0XHRcdGFzdFV0aWxzLmNyZWF0ZURlY2xhcmF0aW9uKFwiX19vZmZzZXRcIiArIHZhck5hbWUsIG9mZnNldCkpO1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fSBlbHNlIGlmIChyaHNBbm5vdGF0aW9uLmlzTWF0cml4KCkgfHwgcmhzQW5ub3RhdGlvbi5pc1ZlY3RvcigpKSB7XG5cdFx0XHRpZiAocmhzLm5hbWUgJiYgcmhzLm5hbWUuaW5kZXhPZihcIl9fXCIpID09PSAwKSB7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBhc3RVdGlscy5jcmVhdGVJZGVudGlmaWVyKFwiX19vZmZzZXRcIiArIHJocy5uYW1lKTtcblx0XHRcdFx0dmFyIHZhck5hbWUgPSBsaHMubmFtZTtcblx0XHRcdFx0Y3VycmVudEJsb2NrLmJvZHkuc3BsaWNlKFxuXHRcdFx0XHRcdGluZGV4LCAwLFxuXHRcdFx0XHRcdGFzdFV0aWxzLmNyZWF0ZURlY2xhcmF0aW9uKFwiX19vZmZzZXRcIiArIHZhck5hbWUsIG9mZnNldCkpO1xuXHRcdFx0XHRpZiAodGhpcy5faXNTSU1EVHlwZS5oYXMocmhzLm5hbWUpKVxuXHRcdFx0XHRcdHRoaXMuX2lzU0lNRFR5cGUuYWRkKGxocy5uYW1lKTtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5GYXN0bGFuZUNvbXBpbGVyLnByb3RvdHlwZS5oYW5kbGVNZW1iZXJDYWxsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0dmFyIGxocyA9IG5vZGUuY2FsbGVlLm9iamVjdDtcblx0dmFyIGxoc0Fubm90YXRpb24gPSB1dGlscy5hbm5vdGF0ZShsaHMpO1xuXHR2YXIgcmVzdWx0QW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUpO1xuXG5cdGlmIChsaHNBbm5vdGF0aW9uLmlzVGV4dHVyZSgpKSB7XG5cdFx0dmFyIGZuTmFtZSA9IFwiU2hhZGUudGV4dHVyZS5zYW1wbGVcIjtcblx0XHRpZiAobm9kZS5fX3NpbWQpIHtcblx0XHRcdGZuTmFtZSArPSBcIlNJTURcIjtcblx0XHRcdGlmIChsaHMuZXh0cmEuaXNCeXRlVGV4dHVyZSlcblx0XHRcdFx0Zm5OYW1lICs9IFwiQnl0ZVwiO1xuXHRcdH1cblx0XHR2YXIgdXYgPSBub2RlLmFyZ3VtZW50c1swXTtcblx0XHRpZiAodXYudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNUbXBWYXJpYWJsZSh1di5uYW1lKSkge1xuXHRcdFx0dmFyIG5ld05vZGUgPSBhc3RVdGlscy5jcmVhdGVGdW5jdGlvbkNhbGwoXG5cdFx0XHRcdGZuTmFtZSxcblx0XHRcdFx0W2xocywgdXYsIGNyZWF0ZU9mZnNldFZhcmlhYmxlTmFtZSh1di5uYW1lKV0sXG5cdFx0XHRcdHJlc3VsdEFubm90YXRpb24uaW5mbyk7XG5cdFx0XHRuZXdOb2RlLl9fc2ltZCA9IG5vZGUuX19zaW1kO1xuXHRcdFx0cmV0dXJuIG5ld05vZGU7XG5cdFx0fVxuXG5cdFx0dmFyIG5ld05vZGUgPSBhc3RVdGlscy5jcmVhdGVGdW5jdGlvbkNhbGwoZm5OYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgICBbbGhzLCB1diwgYXN0VXRpbHMuY3JlYXRlTGl0ZXJhbCgwKV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgIHJlc3VsdEFubm90YXRpb24uaW5mbyk7XG5cdFx0bmV3Tm9kZS5fX3NpbWQgPSBub2RlLl9fc2ltZDtcblx0XHRyZXR1cm4gbmV3Tm9kZTtcblx0fVxuXG5cdGlmICghbGhzQW5ub3RhdGlvbi5pc1ZlY3RvcigpICYmICFsaHNBbm5vdGF0aW9uLmlzTWF0cml4KCkpXG5cdFx0cmV0dXJuIG5vZGU7XG5cblx0dmFyIGxoc1R5cGUgPSBsaHNBbm5vdGF0aW9uLmdldEtpbmQoKTtcblx0dmFyIGZ1biA9IG5vZGUuY2FsbGVlLnByb3BlcnR5Lm5hbWU7XG5cblx0aWYgKGZ1biA9PT0gXCJtdWxcIiAmJiBsaHNBbm5vdGF0aW9uLmlzTWF0cml4KClcblx0XHQmJiByZXN1bHRBbm5vdGF0aW9uLmlzVmVjdG9yKCkpXG5cdFx0ZnVuID0gXCJtdWxWZWNcIjtcblxuXHR2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuXG5cdGlmIChub2RlLl9fc2ltZCAmJiBtYXRoW2xoc0Fubm90YXRpb24uZ2V0S2luZCgpLnRvTG93ZXJDYXNlKCldW2Z1biArIFwiU0lNRFwiXSkge1xuXHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB1dGlscy5hbm5vdGF0ZShhcmdzWzBdKS5jYW5OdW1iZXIoKVxuXHRcdFx0JiYgZnVuID09PSBcIm11bFwiKSB7XG5cdFx0XHRmdW4gPSBcInNjYWxlXCI7XG5cdFx0fVxuXHRcdGZ1biA9IGZ1biArIFwiU0lNRFwiO1xuXHRcdHZhciBsb2FkRnVuY3Rpb25OYW1lID0gXCJTSU1ELkZsb2F0MzJ4NC5sb2FkXCIgKyAodHlwZVNpemVNYXBbbGhzVHlwZV0gIT09IDQgPyB0eXBlU2l6ZU1hcFtsaHNUeXBlXSA6IFwiXCIpO1xuXHRcdHZhciBuZXdBcmdzID0gW107XG5cdFx0aWYgKHRoaXMuX2lzU0lNRFR5cGUuaGFzKGxocy5uYW1lKSkge1xuXHRcdFx0bmV3QXJncy5wdXNoKGxocy5uYW1lKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAobGhzLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG5cdFx0XHRcdGlmIChsaHNBbm5vdGF0aW9uLmlzVmVjdG9yKCkpIHtcblx0XHRcdFx0XHRuZXdBcmdzLnB1c2goYXN0VXRpbHMuY3JlYXRlRnVuY3Rpb25DYWxsKFxuXHRcdFx0XHRcdFx0bG9hZEZ1bmN0aW9uTmFtZSxcblx0XHRcdFx0XHRcdFtsaHMubmFtZSwgY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKGxocy5uYW1lKV0pKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRuZXdBcmdzLnB1c2gobGhzLm5hbWUpO1xuXHRcdFx0XHRcdG5ld0FyZ3MucHVzaChjcmVhdGVPZmZzZXRWYXJpYWJsZU5hbWUobGhzLm5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3QXJncy5wdXNoKGxocyk7XG5cdFx0XHRcdG5ld0FyZ3MucHVzaCgwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoYXJncy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAodGhpcy5faXNTSU1EVHlwZS5oYXMoYXJnc1swXS5uYW1lKSkge1xuXHRcdFx0XHRuZXdBcmdzLnB1c2goYXJnc1swXS5uYW1lKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAoYXJnc1swXS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGlmICh1dGlscy5hbm5vdGF0ZShhcmdzWzBdKS5pc1ZlY3RvcigpKSB7XG5cdFx0XHRcdFx0XHRuZXdBcmdzLnB1c2goYXN0VXRpbHMuY3JlYXRlRnVuY3Rpb25DYWxsKFxuXHRcdFx0XHRcdFx0XHRcIlNJTUQuRmxvYXQzMng0LmxvYWRcIiArICh0eXBlU2l6ZU1hcFt1dGlscy5hbm5vdGF0ZShhcmdzWzBdKS5nZXRLaW5kKCldICE9PSA0ID8gdHlwZVNpemVNYXBbdXRpbHMuYW5ub3RhdGUoYXJnc1swXSkuZ2V0S2luZCgpXSA6IFwiXCIpLFxuXHRcdFx0XHRcdFx0XHRbYXJnc1swXSwgY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKGFyZ3NbMF0ubmFtZSldKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3QXJncy5wdXNoKGFyZ3NbMF0ubmFtZSk7XG5cdFx0XHRcdFx0XHRuZXdBcmdzLnB1c2goY3JlYXRlT2Zmc2V0VmFyaWFibGVOYW1lKGFyZ3NbMF0ubmFtZSkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld0FyZ3MucHVzaChhcmdzWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFyZ3MgPSBuZXdBcmdzO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHV0aWxzLmFubm90YXRlKGFyZ3NbMF0pLmNhbk51bWJlcigpXG5cdFx0XHRcdCYmIGZ1biA9PT0gXCJtdWxcIikge1xuXHRcdFx0XHRmdW4gPSBcInNjYWxlXCI7XG5cdFx0XHRcdHZhciByaHMgPSBhcmdzWzBdO1xuXHRcdFx0XHRhcmdzLnB1c2gocmhzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhcmcgPSB0aGlzLmNvbnZlcnRGdW5jdGlvbkFyZ3VtZW50cyhcblx0XHRcdFx0XHRhcmdzLCBsaHNBbm5vdGF0aW9uLmdldEtpbmQoKSk7XG5cdFx0XHRcdGlmIChhcmcudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcblx0XHRcdFx0XHRhcmdzID0gW2FyZywgXCJfX29mZnNldFwiICsgYXJnLm5hbWVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFyZ3MgPSBbYXJnLCAwXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChsaHMudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcblx0XHRcdGFyZ3MudW5zaGlmdChcIl9fb2Zmc2V0XCIgKyBsaHMubmFtZSk7XG5cdFx0XHRhcmdzLnVuc2hpZnQobGhzLm5hbWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnVuc2hpZnQoMCk7XG5cdFx0XHRhcmdzLnVuc2hpZnQobGhzKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgbmV3Tm9kZSA9IGFzdFV0aWxzLmNyZWF0ZUZ1bmN0aW9uQ2FsbChcIlNoYWRlLm1hdGguXCIgKyBsaHNUeXBlLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgKyBcIi5cIiArIGZ1bixcblx0XHRcdFx0XHRcdFx0XHRcdCAgIGFyZ3MsIHJlc3VsdEFubm90YXRpb24uaW5mbyk7XG5cdG5ld05vZGUuX19zaW1kID0gbm9kZS5fX3NpbWQ7XG5cdHJldHVybiBuZXdOb2RlO1xufTtcblxuRmFzdGxhbmVDb21waWxlci5wcm90b3R5cGUuY29udmVydEZ1bmN0aW9uQXJndW1lbnRzID0gZnVuY3Rpb24oYXJncywgdmVjVHlwZSkge1xuXHRpZiAoYXJncy5sZW5ndGggPT09IDApXG5cdFx0cmV0dXJuO1xuXG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHRcdGlmICh1dGlscy5hbm5vdGF0ZShhcmdzWzBdKS5jYW5OdW1iZXIoKSkge1xuXHRcdFx0dmFyIHNjYWxhciA9IGFyZ3NbMF07XG5cdFx0XHR2YXIgbmV3QXJncyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlU2l6ZU1hcFt2ZWNUeXBlXTsgKytpKVxuXHRcdFx0XHRuZXdBcmdzLnB1c2goc2NhbGFyKTtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUZyb21WYWx1ZXNDYWxsKHZlY1R5cGUsIG5ld0FyZ3MsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHR5cGVTaXplTWFwW3ZlY1R5cGVdKTtcblx0XHR9IGVsc2Vcblx0XHRcdHJldHVybiBhcmdzWzBdXG5cdH1cblxuXHRyZXR1cm4gdGhpcy5jcmVhdGVGcm9tVmFsdWVzQ2FsbCh2ZWNUeXBlLCB0aGlzLmNvbnZlcnRBcmd1bWVudHMoYXJncyksXG5cdFx0XHRcdFx0XHRcdFx0XHQgdHlwZVNpemVNYXBbdmVjVHlwZV0pO1xufTtcblxuRmFzdGxhbmVDb21waWxlci5wcm90b3R5cGUuaGFuZGxlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuXHQvLyB0b2RvOiBoYW5kbGUgYXJyYXkgcmV0dXJuXG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGYXN0bGFuZUNvbXBpbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuc3VwcG9ydGVkVHlwZXMgPSBuZXcgU2V0KFtcIlZlYzJcIiwgXCJWZWMzXCIsIFwiVmVjNFwiLCBcIk1hdDJcIiwgXCJNYXQzXCIsIFwiTWF0NFwiXSk7XG5leHBvcnRzLnR5cGVTaXplTWFwID0ge1xuICAgIFwiaW50XCI6IDEsXG4gICAgXCJudW1iZXJcIjogMSxcbiAgICBcIlZlYzJcIjogMixcbiAgICBcIlZlYzNcIjogMyxcbiAgICBcIlZlYzRcIjogNCxcbiAgICBcIk1hdDJcIjogNCxcbiAgICBcIk1hdDNcIjogOSxcbiAgICBcIk1hdDRcIjogMTZcbn07XG5cbnZhciBzd2l6emxlVG9JbmRleE1hcCA9IHtcbiAgICBcIk1hdDJcIjoge1xuICAgICAgICBcIm0xMVwiOiAwLFxuICAgICAgICBcIm0yMVwiOiAxLFxuICAgICAgICBcIm0xMlwiOiAyLFxuICAgICAgICBcIm0yMlwiOiAzXG4gICAgfSxcbiAgICBcIk1hdDNcIjoge1xuICAgICAgICBcIm0xMVwiOiAwLFxuICAgICAgICBcIm0yMVwiOiAxLFxuICAgICAgICBcIm0zMVwiOiAyLFxuICAgICAgICBcIm0xMlwiOiAzLFxuICAgICAgICBcIm0yMlwiOiA0LFxuICAgICAgICBcIm0zMlwiOiA1LFxuICAgICAgICBcIm0xM1wiOiA2LFxuICAgICAgICBcIm0yM1wiOiA3LFxuICAgICAgICBcIm0zM1wiOiA4XG4gICAgfSxcbiAgICBcIk1hdDRcIjoge1xuICAgICAgICBcIm0xMVwiOiAwLFxuICAgICAgICBcIm0yMVwiOiAxLFxuICAgICAgICBcIm0zMVwiOiAyLFxuICAgICAgICBcIm00MVwiOiAzLFxuICAgICAgICBcIm0xMlwiOiA0LFxuICAgICAgICBcIm0yMlwiOiA1LFxuICAgICAgICBcIm0zMlwiOiA2LFxuICAgICAgICBcIm00MlwiOiA3LFxuICAgICAgICBcIm0xM1wiOiA4LFxuICAgICAgICBcIm0yM1wiOiA5LFxuICAgICAgICBcIm0zM1wiOiAxMCxcbiAgICAgICAgXCJtNDNcIjogMTEsXG4gICAgICAgIFwibTE0XCI6IDEyLFxuICAgICAgICBcIm0yNFwiOiAxMyxcbiAgICAgICAgXCJtMzRcIjogMTQsXG4gICAgICAgIFwibTQ0XCI6IDE1XG4gICAgfVxufTtcblxuc3dpenpsZVRvSW5kZXhNYXAuVmVjMiA9IHN3aXp6bGVUb0luZGV4TWFwLlZlYzMgPSBzd2l6emxlVG9JbmRleE1hcC5WZWM0ID0ge1xuICAgIFwieFwiOiAwLFxuICAgIFwieVwiOiAxLFxuICAgIFwielwiOiAyLFxuICAgIFwid1wiOiAzLFxuICAgIFwiclwiOiAwLFxuICAgIFwiZ1wiOiAxLFxuICAgIFwiYlwiOiAyLFxuICAgIFwiYVwiOiAzLFxuICAgIFwic1wiOiAwLFxuICAgIFwidFwiOiAxLFxuICAgIFwicFwiOiAyLFxuICAgIFwicVwiOiAzXG59O1xuXG5leHBvcnRzLnN3aXp6bGVUb0luZGV4TWFwID0gc3dpenpsZVRvSW5kZXhNYXA7XG5cbmV4cG9ydHMuY29sdW1uVG9TaW5nbGVTd2l6emxlID0ge1xuICAgIGMxOiBcIm0xMSxtMjEsbTMxLG00MVwiLFxuICAgIGMyOiBcIm0xMixtMjIsbTMyLG00MlwiLFxuICAgIGMzOiBcIm0xMyxtMjMsbTMzLG00M1wiLFxuICAgIGM0OiBcIm0xNCxtMjQsbTM0LG00NFwiXG59O1xuXG5leHBvcnRzLnZlY3RvckluZGV4VG9Td2l6emxlTWFwID0gezA6IFwieFwiLCAxOiBcInlcIiwgMjogXCJ6XCIsIDM6IFwid1wifTtcblxuZXhwb3J0cy5tYXRyaXhJbmRleFRvU3dpenpsZU1hcCA9IHtcbiAgICBcIk1hdDJcIjoge1xuICAgICAgICAwOiBcIm0xMVwiLFxuICAgICAgICAxOiBcIm0yMVwiLFxuICAgICAgICAyOiBcIm0xMlwiLFxuICAgICAgICAzOiBcIm0yMlwiXG4gICAgfSxcbiAgICBcIk1hdDNcIjoge1xuICAgICAgICAwOiBcIm0xMVwiLFxuICAgICAgICAxOiBcIm0yMVwiLFxuICAgICAgICAyOiBcIm0zMVwiLFxuICAgICAgICAzOiBcIm0xMlwiLFxuICAgICAgICA0OiBcIm0yMlwiLFxuICAgICAgICA1OiBcIm0zMlwiLFxuICAgICAgICA2OiBcIm0xM1wiLFxuICAgICAgICA3OiBcIm0yM1wiLFxuICAgICAgICA4OiBcIm0zM1wiXG4gICAgfSxcbiAgICBcIk1hdDRcIjoge1xuICAgICAgICAwOiBcIm0xMVwiLFxuICAgICAgICAxOiBcIm0yMVwiLFxuICAgICAgICAyOiBcIm0zMVwiLFxuICAgICAgICAzOiBcIm00MVwiLFxuICAgICAgICA0OiBcIm0xMlwiLFxuICAgICAgICA1OiBcIm0yMlwiLFxuICAgICAgICA2OiBcIm0zMlwiLFxuICAgICAgICA3OiBcIm00MlwiLFxuICAgICAgICA4OiBcIm0xM1wiLFxuICAgICAgICA5OiBcIm0yM1wiLFxuICAgICAgICAxMDogXCJtMzNcIixcbiAgICAgICAgMTE6IFwibTQzXCIsXG4gICAgICAgIDEyOiBcIm0xNFwiLFxuICAgICAgICAxMzogXCJtMjRcIixcbiAgICAgICAgMTQ6IFwibTM0XCIsXG4gICAgICAgIDE1OiBcIm00NFwiXG4gICAgfVxufTtcblxudmFyIGluZGV4VG9Td2l6emxlTWFwID0ge1xuICAgIFwiTWF0MlwiOiB7XG4gICAgICAgIDA6IFwibTExXCIsXG4gICAgICAgIDE6IFwibTIxXCIsXG4gICAgICAgIDI6IFwibTEyXCIsXG4gICAgICAgIDM6IFwibTIyXCJcbiAgICB9LFxuICAgIFwiTWF0M1wiOiB7XG4gICAgICAgIDA6IFwibTExXCIsXG4gICAgICAgIDE6IFwibTIxXCIsXG4gICAgICAgIDI6IFwibTMxXCIsXG4gICAgICAgIDM6IFwibTEyXCIsXG4gICAgICAgIDQ6IFwibTIyXCIsXG4gICAgICAgIDU6IFwibTMyXCIsXG4gICAgICAgIDY6IFwibTEzXCIsXG4gICAgICAgIDc6IFwibTIzXCIsXG4gICAgICAgIDg6IFwibTMzXCJcbiAgICB9LFxuICAgIFwiTWF0NFwiOiB7XG4gICAgICAgIDA6IFwibTExXCIsXG4gICAgICAgIDE6IFwibTIxXCIsXG4gICAgICAgIDI6IFwibTMxXCIsXG4gICAgICAgIDM6IFwibTQxXCIsXG4gICAgICAgIDQ6IFwibTEyXCIsXG4gICAgICAgIDU6IFwibTIyXCIsXG4gICAgICAgIDY6IFwibTMyXCIsXG4gICAgICAgIDc6IFwibTQyXCIsXG4gICAgICAgIDg6IFwibTEzXCIsXG4gICAgICAgIDk6IFwibTIzXCIsXG4gICAgICAgIDEwOiBcIm0zM1wiLFxuICAgICAgICAxMTogXCJtNDNcIixcbiAgICAgICAgMTI6IFwibTE0XCIsXG4gICAgICAgIDEzOiBcIm0yNFwiLFxuICAgICAgICAxNDogXCJtMzRcIixcbiAgICAgICAgMTU6IFwibTQ0XCJcbiAgICB9XG59O1xuaW5kZXhUb1N3aXp6bGVNYXAuVmVjMiA9IGluZGV4VG9Td2l6emxlTWFwLlZlYzMgPSBpbmRleFRvU3dpenpsZU1hcC5WZWM0ID0ge1xuICAgIDA6IFwieFwiLFxuICAgIDE6IFwieVwiLFxuICAgIDI6IFwielwiLFxuICAgIDM6IFwid1wiXG59O1xuZXhwb3J0cy5pbmRleFRvU3dpenpsZU1hcCA9IGluZGV4VG9Td2l6emxlTWFwOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYW5ub3RhdGUgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvYW5ub3RhdGVcIik7XG52YXIgdHlwZVNpemVNYXAgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIikudHlwZVNpemVNYXA7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0ZShub2RlKTtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBhbm5vdGF0aW9uLmdldEFycmF5RWxlbWVudFR5cGUoKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG5cbiAgICB3aGlsZSAoZWxlbWVudFR5cGUuZXh0cmEudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIHNpemUgKj0gZWxlbWVudFR5cGUuZXh0cmEuc3RhdGljU2l6ZTtcbiAgICAgICAgZWxlbWVudFR5cGUgPSBlbGVtZW50VHlwZS5leHRyYS5lbGVtZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZSAqIHR5cGVTaXplTWFwW2VsZW1lbnRUeXBlLmV4dHJhLmtpbmQgfHwgZWxlbWVudFR5cGUuZXh0cmEudHlwZV07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHZlYzIgPSB7fTtcbnZlYzIuYWRkID0gZnVuY3Rpb24gYWRkKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldF0sIHkxID0gdmVjW3ZlY09mZnNldCArIDFdO1xuICAgIHZhciB4MiA9IHZlYzJbdmVjT2Zmc2V0Ml0sIHkyID0gdmVjMlt2ZWNPZmZzZXQyICsgMV07XG4gICAgcmV0dXJuIFt4MSArIHgyLCB5MSArIHkyXTtcbn07XG5cbnZlYzIuYWRkU3RvcmUgPSBmdW5jdGlvbiBhZGRTdG9yZShyZXN1bHQsIHJlc3VsdE9mZnNldCwgdmVjLCB2ZWNPZmZzZXQsIHZlYzIsIHZlY09mZnNldDIpIHtcbiAgICB2YXIgeDEgPSB2ZWNbdmVjT2Zmc2V0XSwgeTEgPSB2ZWNbdmVjT2Zmc2V0ICsgMV07XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyXSwgeTIgPSB2ZWMyW3ZlY09mZnNldDIgKyAxXTtgYFxuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXRdID0geDEgKyB4MjtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMV0gPSB5MSArIHkyO1xufTtcblxudmFyIHZlYzMgPSB7fTtcbnZlYzMuYWRkID0gZnVuY3Rpb24gYWRkKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldCArIDBdLCB5MSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgejEgPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyICsgMF0sIHkyID0gdmVjMlt2ZWNPZmZzZXQyICsgMV0sIHoyID0gdmVjMlt2ZWNPZmZzZXQyICsgMl07XG4gICAgcmV0dXJuIFt4MSArIHgyLCB5MSArIHkyLCB6MSArIHoyXTtcbn07XG5cbi8vIHZlYzMuYWRkU0lNRCA9IGZ1bmN0aW9uIGFkZCh2ZWMsIHZlYzIpIHtcbi8vICAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQuYWRkKHZlYywgdmVjMik7XG4vLyB9O1xuXG52ZWMzLmFkZFN0b3JlID0gZnVuY3Rpb24gYWRkU3RvcmUocmVzdWx0LCByZXN1bHRPZmZzZXQsIHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldCArIDBdLCB5MSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgejEgPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyICsgMF0sIHkyID0gdmVjMlt2ZWNPZmZzZXQyICsgMV0sIHoyID0gdmVjMlt2ZWNPZmZzZXQyICsgMl07XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldF0gPSB4MSArIHgyO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAxXSA9IHkxICsgeTI7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDJdID0gejEgKyB6Mjtcbn07XG5cbi8vIHZlYzMuYWRkU0lNRFN0b3JlID0gZnVuY3Rpb24gYWRkKHJlc3VsdCwgcmVzdWx0T2Zmc2V0LCB2ZWMsIHZlYzIpIHtcbi8vICAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZTMocmVzdWx0LCByZXN1bHRPZmZzZXQsIFNJTUQuRmxvYXQzMng0LmFkZCh2ZWMsIHZlYzIpKTtcbi8vIH07XG5cbnZlYzMuc3ViID0gZnVuY3Rpb24gc3ViKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldCArIDBdLCB5MSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgejEgPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyICsgMF0sIHkyID0gdmVjMlt2ZWNPZmZzZXQyICsgMV0sIHoyID0gdmVjMlt2ZWNPZmZzZXQyICsgMl07XG4gICAgcmV0dXJuIFt4MSAtIHgyLCB5MSAtIHkyLCB6MSAtIHoyXTtcbn07XG5cbnZlYzMuc3ViU3RvcmUgPSBmdW5jdGlvbiBzdWJTdG9yZShyZXN1bHQsIHJlc3VsdE9mZnNldCwgdmVjLCB2ZWNPZmZzZXQsIHZlYzIsIHZlY09mZnNldDIpIHtcbiAgICB2YXIgeDEgPSB2ZWNbdmVjT2Zmc2V0ICsgMF0sIHkxID0gdmVjW3ZlY09mZnNldCArIDFdLCB6MSA9IHZlY1t2ZWNPZmZzZXQgKyAyXTtcbiAgICB2YXIgeDIgPSB2ZWMyW3ZlY09mZnNldDIgKyAwXSwgeTIgPSB2ZWMyW3ZlY09mZnNldDIgKyAxXSwgejIgPSB2ZWMyW3ZlY09mZnNldDIgKyAyXTtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0XSA9IHgxIC0geDI7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDFdID0geTEgLSB5MjtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMl0gPSB6MSAtIHoyO1xufTtcblxuLy8gdmVjMy5zdWJTSU1EID0gZnVuY3Rpb24gc3ViKHZlYywgdmVjMikge1xuLy8gICAgIHJldHVybiBTSU1ELkZsb2F0MzJ4NC5zdWIodmVjLCB2ZWMyKTtcbi8vIH07XG5cbnZlYzMubXVsID0gZnVuY3Rpb24gbXVsKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldCArIDBdLCB5MSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgejEgPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyICsgMF0sIHkyID0gdmVjMlt2ZWNPZmZzZXQyICsgMV0sIHoyID0gdmVjMlt2ZWNPZmZzZXQyICsgMl07XG4gICAgcmV0dXJuIFt4MSAqIHgyLCB5MSAqIHkyLCB6MSAqIHoyXTtcbn07XG5cbi8vIHZlYzMubXVsU0lNRCA9IGZ1bmN0aW9uIG11bCh2ZWMsIHZlYzIpIHtcbi8vICAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQubXVsKHZlYywgdmVjMik7XG4vLyB9O1xuXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2ZWMsIHZlY09mZnNldCkge1xuICAgIHZhciB4MSA9IHZlY1t2ZWNPZmZzZXQgKyAwXSwgeTEgPSB2ZWNbdmVjT2Zmc2V0ICsgMV0sIHoxID0gdmVjW3ZlY09mZnNldCArIDJdO1xuICAgIHZhciBub3JtID0gMSAvIE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSArIHoxICogejEpO1xuICAgIHJldHVybiBbeDEgKiBub3JtLCB5MSAqIG5vcm0sIHoxICogbm9ybV07XG59O1xuXG52ZWMzLm5vcm1hbGl6ZVN0b3JlID0gZnVuY3Rpb24gbm9ybWFsaXplU3RvcmUocmVzdWx0LCByZXN1bHRPZmZzZXQsIHZlYywgdmVjT2Zmc2V0KSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldCArIDBdLCB5MSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgejEgPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XG4gICAgdmFyIG5vcm0gPSAxIC8gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxICsgejEgKiB6MSk7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldF0gPSB4MSAqIG5vcm07XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDFdID0geTEgKiBub3JtO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAyXSA9IHoxICogbm9ybTtcbn07XG5cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2ZWMsIHZlY09mZnNldCwgc2NhbGFyKSB7XG4gICAgcmV0dXJuIFt2ZWNbdmVjT2Zmc2V0XSAqIHNjYWxhciwgdmVjW3ZlY09mZnNldCArIDFdICogc2NhbGFyLCB2ZWNbdmVjT2Zmc2V0ICsgMl0gKiBzY2FsYXJdO1xufTtcblxudmVjMy5zY2FsZVN0b3JlID0gZnVuY3Rpb24gc2NhbGUocmVzdWx0LCByZXN1bHRPZmZzZXQsIHZlYywgdmVjT2Zmc2V0LCBzY2FsYXIpIHtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0XSA9IHZlY1t2ZWNPZmZzZXRdICogc2NhbGFyO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAxXSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSAqIHNjYWxhcjtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMl0gPSB2ZWNbdmVjT2Zmc2V0ICsgMl0gKiBzY2FsYXI7XG59O1xuXG4vLyB2ZWMzLnNjYWxlU0lNRCA9IGZ1bmN0aW9uIHNjYWxlKHZlYywgc2NhbGFyKSB7XG4vLyAgICAgcmV0dXJuIFNJTUQuRmxvYXQzMng0Lm11bCh2ZWMsIFNJTUQuRmxvYXQzMng0LnNwbGF0KHNjYWxhcikpO1xuLy8gfTtcblxuLy8gdmVjMy5zY2FsZVNJTURTdG9yZSA9IGZ1bmN0aW9uIHNjYWxlKHJlc3VsdCwgb2Zmc2V0LCB2ZWMsIHNjYWxhcikge1xuLy8gICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlMyhyZXN1bHQsIG9mZnNldCwgU0lNRC5GbG9hdDMyeDQubXVsKHZlYywgU0lNRC5GbG9hdDMyeDQuc3BsYXQoc2NhbGFyKSkpO1xuLy8gfTtcblxudmFyIHZlYzQgPSB7fTtcbnZlYzQuYWRkID0gZnVuY3Rpb24gYWRkKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldF0sIHkxID0gdmVjW3ZlY09mZnNldCArIDFdLCB6MSA9IHZlY1t2ZWNPZmZzZXQgKyAyXSwgdzEgPSB2ZWNbdmVjT2Zmc2V0ICsgM107XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyXSwgeTIgPSB2ZWMyW3ZlY09mZnNldDIgKyAxXSwgejIgPSB2ZWMyW3ZlY09mZnNldDIgKyAyXSwgdzIgPSB2ZWMyW3ZlY09mZnNldDIgKyAzXTtcbiAgICByZXR1cm4gW3gxICsgeDIsIHkxICsgeTIsIHoxICsgejIsIHcxICsgdzJdO1xufTtcblxudmVjNC5hZGRTSU1EID0gZnVuY3Rpb24gYWRkKHZlYywgdmVjMikge1xuICAgIHJldHVybiBTSU1ELkZsb2F0MzJ4NC5hZGQodmVjLCB2ZWMyKTtcbn07XG5cbnZlYzQuYWRkU3RvcmUgPSBmdW5jdGlvbiBhZGRTdG9yZShyZXN1bHQsIHJlc3VsdE9mZnNldCwgdmVjLCB2ZWNPZmZzZXQsIHZlYzIsIHZlY09mZnNldDIpIHtcbiAgICB2YXIgeDEgPSB2ZWNbdmVjT2Zmc2V0XSwgeTEgPSB2ZWNbdmVjT2Zmc2V0ICsgMV0sIHoxID0gdmVjW3ZlY09mZnNldCArIDJdLCB3MSA9IHZlY1t2ZWNPZmZzZXQgKyAzXTtcbiAgICB2YXIgeDIgPSB2ZWMyW3ZlY09mZnNldDJdLCB5MiA9IHZlYzJbdmVjT2Zmc2V0MiArIDFdLCB6MiA9IHZlYzJbdmVjT2Zmc2V0MiArIDJdLCB3MiA9IHZlYzJbdmVjT2Zmc2V0MiArIDNdO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXRdID0geDEgKyB4MjtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMV0gPSB5MSArIHkyO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAyXSA9IHoxICsgejI7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDNdID0gdzEgKyB3Mjtcbn07XG5cbnZlYzQuc3ViID0gZnVuY3Rpb24gc3ViKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgdmFyIHgxID0gdmVjW3ZlY09mZnNldF0sIHkxID0gdmVjW3ZlY09mZnNldCArIDFdLCB6MSA9IHZlY1t2ZWNPZmZzZXQgKyAyXSwgdzEgPSB2ZWNbdmVjT2Zmc2V0ICsgM107XG4gICAgdmFyIHgyID0gdmVjMlt2ZWNPZmZzZXQyXSwgeTIgPSB2ZWMyW3ZlY09mZnNldDIgKyAxXSwgejIgPSB2ZWMyW3ZlY09mZnNldDIgKyAyXSwgdzIgPSB2ZWMyW3ZlY09mZnNldDIgKyAzXTtcbiAgICByZXR1cm4gW3gxIC0geDIsIHkxIC0geTIsIHoxIC0gejIsIHcxIC0gdzJdO1xufTtcblxudmVjNC5zdWJTSU1EID0gZnVuY3Rpb24gc3ViKHZlYywgdmVjMikge1xuICAgIHJldHVybiBTSU1ELkZsb2F0MzJ4NC5zdWIodmVjLCB2ZWMyKTtcbn07XG5cbnZlYzQuc3ViU3RvcmUgPSBmdW5jdGlvbiBzdWJTdG9yZShyZXN1bHQsIHJlc3VsdE9mZnNldCwgdmVjLCB2ZWNPZmZzZXQsIHZlYzIsIHZlY09mZnNldDIpIHtcbiAgICB2YXIgeDEgPSB2ZWNbdmVjT2Zmc2V0XSwgeTEgPSB2ZWNbdmVjT2Zmc2V0ICsgMV0sIHoxID0gdmVjW3ZlY09mZnNldCArIDJdLCB3MSA9IHZlY1t2ZWNPZmZzZXQgKyAzXTtcbiAgICB2YXIgeDIgPSB2ZWMyW3ZlY09mZnNldDJdLCB5MiA9IHZlYzJbdmVjT2Zmc2V0MiArIDFdLCB6MiA9IHZlYzJbdmVjT2Zmc2V0MiArIDJdLCB3MiA9IHZlYzJbdmVjT2Zmc2V0MiArIDNdO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXRdID0geDEgLSB4MjtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMV0gPSB5MSAtIHkyO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAyXSA9IHoxIC0gejI7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDNdID0gdzEgLSB3Mjtcbn07XG5cbnZlYzQubXVsID0gZnVuY3Rpb24gbXVsKHZlYywgdmVjT2Zmc2V0LCB2ZWMyLCB2ZWNPZmZzZXQyKSB7XG4gICAgcmV0dXJuIFt2ZWNbdmVjT2Zmc2V0ICsgMF0gKiB2ZWMyW3ZlY09mZnNldDIgKyAwXSwgdmVjW3ZlY09mZnNldCArIDFdICogdmVjMlt2ZWNPZmZzZXQyICsgMV0sIHZlY1t2ZWNPZmZzZXQgKyAyXSAqIHZlYzJbdmVjT2Zmc2V0MiArIDJdLCB2ZWNbdmVjT2Zmc2V0ICsgM10gKiB2ZWMyW3ZlY09mZnNldDIgKyAzXV07XG59O1xuXG52ZWM0Lm11bFNJTUQgPSBmdW5jdGlvbiBtdWwodmVjLCB2ZWMyKSB7XG4gICAgcmV0dXJuIFNJTUQuRmxvYXQzMng0Lm11bCh2ZWMsIHZlYzIpO1xufTtcblxudmVjNC5kaXYgPSBmdW5jdGlvbiBtdWwodmVjLCB2ZWNPZmZzZXQsIHZlYzIsIHZlY09mZnNldDIpIHtcbiAgICByZXR1cm4gW3ZlY1t2ZWNPZmZzZXQgKyAwXSAvIHZlYzJbdmVjT2Zmc2V0MiArIDBdLCB2ZWNbdmVjT2Zmc2V0ICsgMV0gLyB2ZWMyW3ZlY09mZnNldDIgKyAxXSwgdmVjW3ZlY09mZnNldCArIDJdIC8gdmVjMlt2ZWNPZmZzZXQyICsgMl0sIHZlY1t2ZWNPZmZzZXQgKyAzXSAvIHZlYzJbdmVjT2Zmc2V0MiArIDNdXTtcbn07XG5cbnZlYzQuZGl2U0lNRCA9IGZ1bmN0aW9uIG11bCh2ZWMsIHZlYzIpIHtcbiAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQuZGl2KHZlYywgdmVjMik7XG59O1xuXG52ZWM0LnNjYWxlID0gZnVuY3Rpb24gc2NhbGUodmVjLCB2ZWNPZmZzZXQsIHNjYWxhcikge1xuICAgIHJldHVybiBbdmVjW3ZlY09mZnNldF0gKiBzY2FsYXIsIHZlY1t2ZWNPZmZzZXQgKyAxXSAqIHNjYWxhciwgdmVjW3ZlY09mZnNldCArIDJdICogc2NhbGFyLCB2ZWNbdmVjT2Zmc2V0ICsgM10gKiBzY2FsYXJdO1xufTtcblxudmVjNC5zY2FsZVNJTUQgPSBmdW5jdGlvbiBzY2FsZSh2ZWMsIHNjYWxhcikge1xuICAgIHJldHVybiBTSU1ELkZsb2F0MzJ4NC5tdWwodmVjLCBTSU1ELkZsb2F0MzJ4NC5zcGxhdChzY2FsYXIpKTtcbn07XG5cbnZlYzQuc3FydFNJTUQgPSBmdW5jdGlvbiBzY2FsZSh2ZWMpIHtcbiAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQuc3FydCh2ZWMpO1xufTtcblxudmVjNC5zaW5TSU1EID0gZnVuY3Rpb24gc2NhbGUodmVjKSB7XG4gICAgdmFyIFBJID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoMy4xNDE1OTI2NTM2KTtcbiAgICB2YXIgUEkyID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoMiAqIDMuMTQxNTkyNjUzNik7XG4gICAgdmVjID0gU0lNRC5GbG9hdDMyeDQuYWRkKHZlYywgUEkpO1xuICAgIHZhciB4ID0gU0lNRC5GbG9hdDMyeDQuc3ViKHZlYywgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LmZyb21JbnQzMng0KFNJTUQuSW50MzJ4NC5mcm9tRmxvYXQzMng0KFNJTUQuRmxvYXQzMng0LmRpdih2ZWMsIFBJMikpKSwgUEkyKSk7XG4gICAgdmFyIGx0emVybyA9IFNJTUQuRmxvYXQzMng0Lmxlc3NUaGFuKHgsIFNJTUQuRmxvYXQzMng0LnNwbGF0KDApKTtcbiAgICB2YXIgbm9ybWVkID0gU0lNRC5GbG9hdDMyeDQuc2VsZWN0KGx0emVybywgU0lNRC5GbG9hdDMyeDQuYWRkKHgsIFBJKSwgU0lNRC5GbG9hdDMyeDQuc3ViKHgsIFBJKSk7XG5cbiAgICB2YXIgc3F1YXJlICA9IFNJTUQuRmxvYXQzMng0Lm11bChub3JtZWQsIG5vcm1lZCk7XG5cbiAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQubXVsKG5vcm1lZCwgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnNwbGF0KDAuOTk5OTc5Mzc2NzkyOTA3NzE0ODQzNzUpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoc3F1YXJlLCBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3BsYXQoLTAuMTY2NjI0MzY3MjM3MDkxMDY0NDUzMTI1KSwgU0lNRC5GbG9hdDMyeDQubXVsKHNxdWFyZSwgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnNwbGF0KDguMzA4OTc4NzUxMzAxNzY1NDQxODk0NTMxMjVlLTMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoc3F1YXJlLCBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3BsYXQoLTEuOTI2NDkxODIyODE0NTY4ODc3MjIwMTUzODA4NTkzNzVlLTQpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3BsYXQoMi4xNDc4NDAxNzc3MTMwNzg0NDY2ODYyNjc4NTI3ODMyMDMxMjVlLTYpLCBzcXVhcmUpKSkpKSkpKSk7XG59O1xuXG52ZWM0LmNvc1NJTUQgPSBmdW5jdGlvbiBzY2FsZSh2ZWMpIHtcbiAgICB2YXIgUEkgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdCgzLjE0MTU5MjY1MzYpO1xuICAgIHZhciBQSTIgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdCgyICogMy4xNDE1OTI2NTM2KTtcbiAgICB2ZWMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQodmVjLCBQSSk7XG4gICAgdmFyIHggPSBTSU1ELkZsb2F0MzJ4NC5zdWIodmVjLCBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuZnJvbUludDMyeDQoU0lNRC5JbnQzMng0LmZyb21GbG9hdDMyeDQoU0lNRC5GbG9hdDMyeDQuZGl2KHZlYywgUEkyKSkpLCBQSTIpKTtcbiAgICB2YXIgbHR6ZXJvID0gU0lNRC5GbG9hdDMyeDQubGVzc1RoYW4oeCwgU0lNRC5GbG9hdDMyeDQuc3BsYXQoMCkpO1xuICAgIHZhciBub3JtZWQgPSBTSU1ELkZsb2F0MzJ4NC5zZWxlY3QobHR6ZXJvLCBTSU1ELkZsb2F0MzJ4NC5hZGQoeCwgUEkpLCBTSU1ELkZsb2F0MzJ4NC5zdWIoeCwgUEkpKTtcbiAgICB2YXIgc3F1YXJlICA9IFNJTUQuRmxvYXQzMng0Lm11bChub3JtZWQsIG5vcm1lZCk7XG5cbiAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnNwbGF0KDAuOTk5OTU5NzY2ODY0Nzc2NjExMzI4MTI1KSwgU0lNRC5GbG9hdDMyeDQubXVsKHNxdWFyZSwgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnNwbGF0KC0wLjQ5OTc5MzA4MjQ3NTY2MjIzMTQ0NTMxMjUpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoc3F1YXJlLCBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3BsYXQoNC4xNDk2MDAxMTgzOTg2NjYzODE4MzU5Mzc1ZS0yKSwgU0lNRC5GbG9hdDMyeDQubXVsKHNxdWFyZSwgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnNwbGF0KC0xLjMzOTI2MzA0OTg4NTYzMDYwNzYwNDk4MDQ2ODc1ZS0zKSwgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnNwbGF0KDEuODc5MTcwODQ5ODYxMTExNDkxOTE4NTYzODQyNzczNDM3NWUtNSksIHNxdWFyZSkpKSkpKSkpO1xufTtcblxudmFyIG1hdDMgPSB7fTtcblxudmFyIG1hdDQgPSB7fTtcbm1hdDQubXVsVmVjID0gZnVuY3Rpb24gbXVsVmVjKG1hdCwgbWF0T2Zmc2V0LCB2ZWMsIHZlY09mZnNldCkge1xuICAgIHZhciB4ID0gdmVjW3ZlY09mZnNldCArIDBdLCB5ID0gdmVjW3ZlY09mZnNldCArIDFdLCB6ID0gdmVjW3ZlY09mZnNldCArIDJdLCB3ID0gdmVjW3ZlY09mZnNldCArIDNdO1xuICAgIHJldHVybiBbXG4gICAgbWF0W21hdE9mZnNldCArIDBdICogeCArIG1hdFttYXRPZmZzZXQgKyA0XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgOF0gKiB6ICsgbWF0W21hdE9mZnNldCArIDEyXSAqIHcsXG4gICAgbWF0W21hdE9mZnNldCArIDFdICogeCArIG1hdFttYXRPZmZzZXQgKyA1XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgOV0gKiB6ICsgbWF0W21hdE9mZnNldCArIDEzXSAqIHcsXG4gICAgbWF0W21hdE9mZnNldCArIDJdICogeCArIG1hdFttYXRPZmZzZXQgKyA2XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgMTBdICogeiArIG1hdFttYXRPZmZzZXQgKyAxNF0gKiB3LFxuICAgIG1hdFttYXRPZmZzZXQgKyAzXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgN10gKiB5ICsgbWF0W21hdE9mZnNldCArIDExXSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTVdICogdyxcbiAgICBdXG59O1xuXG5tYXQ0Lm11bFZlY1N0b3JlID0gZnVuY3Rpb24gbXVsVmVjKHJlc3VsdCwgcmVzdWx0T2Zmc2V0LCBtYXQsIG1hdE9mZnNldCwgdmVjLCB2ZWNPZmZzZXQpIHtcbiAgICB2YXIgeCA9IHZlY1t2ZWNPZmZzZXQgKyAwXSwgeSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgeiA9IHZlY1t2ZWNPZmZzZXQgKyAyXSwgdyA9IHZlY1t2ZWNPZmZzZXQgKyAzXTtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0XSA9IG1hdFttYXRPZmZzZXQgKyAwXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgNF0gKiB5ICsgbWF0W21hdE9mZnNldCArIDhdICogeiArIG1hdFttYXRPZmZzZXQgKyAxMl0gKiB3O1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAxXSA9IG1hdFttYXRPZmZzZXQgKyAxXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgNV0gKiB5ICsgbWF0W21hdE9mZnNldCArIDldICogeiArIG1hdFttYXRPZmZzZXQgKyAxM10gKiB3O1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAyXSA9IG1hdFttYXRPZmZzZXQgKyAyXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgNl0gKiB5ICsgbWF0W21hdE9mZnNldCArIDEwXSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTRdICogdztcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgM10gPSBtYXRbbWF0T2Zmc2V0ICsgM10gKiB4ICsgbWF0W21hdE9mZnNldCArIDddICogeSArIG1hdFttYXRPZmZzZXQgKyAxMV0gKiB6ICsgbWF0W21hdE9mZnNldCArIDE1XSAqIHc7XG59O1xuXG5tYXQ0Lm11bFZlY1NJTUQgPSBmdW5jdGlvbiBtdWxWZWMobWF0LCBvZmZzZXQsIHZlYykge1xuICAgIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0LCBvZmZzZXQpO1xuICAgIHZhciBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0LCBvZmZzZXQgKyA0KTtcbiAgICB2YXIgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0ICsgOCk7XG4gICAgdmFyIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQsIG9mZnNldCArIDEyKTtcbiAgICByZXR1cm4gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xufTtcblxubWF0NC5tdWxWZWNTSU1EU3RvcmUgPSBmdW5jdGlvbiBtdWxWZWMocmVzdWx0LCByZXN1bHRPZmZzZXQsIG1hdCwgb2Zmc2V0LCB2ZWMpIHtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0KTtcbiAgICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0ICsgNCk7XG4gICAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQsIG9mZnNldCArIDgpO1xuICAgIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0LCBvZmZzZXQgKyAxMik7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUocmVzdWx0LCByZXN1bHRPZmZzZXQsIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMywgMywgMywgMyksIGEzKSkpKSk7XG59O1xuXG5tYXQ0Lm11bCA9IGZ1bmN0aW9uIG11bChtYXQsIG9mZnNldDEsIG1hdDIsIG9mZnNldDIpIHtcbiAgICB2YXIgYTExID0gbWF0W29mZnNldDFdO1xuICAgIHZhciBhMjEgPSBtYXRbb2Zmc2V0MSArIDFdO1xuICAgIHZhciBhMzEgPSBtYXRbb2Zmc2V0MSArIDJdO1xuICAgIHZhciBhNDEgPSBtYXRbb2Zmc2V0MSArIDNdO1xuICAgIHZhciBhMTIgPSBtYXRbb2Zmc2V0MSArIDRdO1xuICAgIHZhciBhMjIgPSBtYXRbb2Zmc2V0MSArIDVdO1xuICAgIHZhciBhMzIgPSBtYXRbb2Zmc2V0MSArIDZdO1xuICAgIHZhciBhNDIgPSBtYXRbb2Zmc2V0MSArIDddO1xuICAgIHZhciBhMTMgPSBtYXRbb2Zmc2V0MSArIDhdO1xuICAgIHZhciBhMjMgPSBtYXRbb2Zmc2V0MSArIDldO1xuICAgIHZhciBhMzMgPSBtYXRbb2Zmc2V0MSArIDEwXTtcbiAgICB2YXIgYTQzID0gbWF0W29mZnNldDEgKyAxMV07XG4gICAgdmFyIGExNCA9IG1hdFtvZmZzZXQxICsgMTJdO1xuICAgIHZhciBhMjQgPSBtYXRbb2Zmc2V0MSArIDEzXTtcbiAgICB2YXIgYTM0ID0gbWF0W29mZnNldDEgKyAxNF07XG4gICAgdmFyIGE0NCA9IG1hdFtvZmZzZXQxICsgMTVdO1xuXG4gICAgdmFyIGIxMSA9IG1hdDJbb2Zmc2V0Ml07XG4gICAgdmFyIGIyMSA9IG1hdDJbb2Zmc2V0MiArIDFdO1xuICAgIHZhciBiMzEgPSBtYXQyW29mZnNldDIgKyAyXTtcbiAgICB2YXIgYjQxID0gbWF0MltvZmZzZXQyICsgM107XG4gICAgdmFyIGIxMiA9IG1hdDJbb2Zmc2V0MiArIDRdO1xuICAgIHZhciBiMjIgPSBtYXQyW29mZnNldDIgKyA1XTtcbiAgICB2YXIgYjMyID0gbWF0MltvZmZzZXQyICsgNl07XG4gICAgdmFyIGI0MiA9IG1hdDJbb2Zmc2V0MiArIDddO1xuICAgIHZhciBiMTMgPSBtYXQyW29mZnNldDIgKyA4XTtcbiAgICB2YXIgYjIzID0gbWF0MltvZmZzZXQyICsgOV07XG4gICAgdmFyIGIzMyA9IG1hdDJbb2Zmc2V0MiArIDEwXTtcbiAgICB2YXIgYjQzID0gbWF0MltvZmZzZXQyICsgMTFdO1xuICAgIHZhciBiMTQgPSBtYXQyW29mZnNldDIgKyAxMl07XG4gICAgdmFyIGIyNCA9IG1hdDJbb2Zmc2V0MiArIDEzXTtcbiAgICB2YXIgYjM0ID0gbWF0MltvZmZzZXQyICsgMTRdO1xuICAgIHZhciBiNDQgPSBtYXQyW29mZnNldDIgKyAxNV07XG5cbiAgICB2YXIgZGVzdCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICBkZXN0WzBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuICAgIGRlc3RbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG4gICAgZGVzdFsyXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcbiAgICBkZXN0WzNdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXG4gICAgZGVzdFs0XSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcbiAgICBkZXN0WzVdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuICAgIGRlc3RbNl0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG4gICAgZGVzdFs3XSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcblxuICAgIGRlc3RbOF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG4gICAgZGVzdFs5XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcbiAgICBkZXN0WzEwXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcbiAgICBkZXN0WzExXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcblxuICAgIGRlc3RbMTJdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuICAgIGRlc3RbMTNdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuICAgIGRlc3RbMTRdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuICAgIGRlc3RbMTVdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG4gICAgcmV0dXJuIGRlc3Q7XG59O1xuXG5tYXQ0Lm11bFN0b3JlID0gZnVuY3Rpb24gbXVsU3RvcmUocmVzdWx0LCByZXN1bHRPZmZzZXQsIG1hdCwgb2Zmc2V0LCBtYXQyLCBvZmZzZXQyKSB7XG4gICAgdmFyIGExMSA9IG1hdFtvZmZzZXRdO1xuICAgIHZhciBhMjEgPSBtYXRbb2Zmc2V0ICsgMV07XG4gICAgdmFyIGEzMSA9IG1hdFtvZmZzZXQgKyAyXTtcbiAgICB2YXIgYTQxID0gbWF0W29mZnNldCArIDNdO1xuICAgIHZhciBhMTIgPSBtYXRbb2Zmc2V0ICsgNF07XG4gICAgdmFyIGEyMiA9IG1hdFtvZmZzZXQgKyA1XTtcbiAgICB2YXIgYTMyID0gbWF0W29mZnNldCArIDZdO1xuICAgIHZhciBhNDIgPSBtYXRbb2Zmc2V0ICsgN107XG4gICAgdmFyIGExMyA9IG1hdFtvZmZzZXQgKyA4XTtcbiAgICB2YXIgYTIzID0gbWF0W29mZnNldCArIDldO1xuICAgIHZhciBhMzMgPSBtYXRbb2Zmc2V0ICsgMTBdO1xuICAgIHZhciBhNDMgPSBtYXRbb2Zmc2V0ICsgMTFdO1xuICAgIHZhciBhMTQgPSBtYXRbb2Zmc2V0ICsgMTJdO1xuICAgIHZhciBhMjQgPSBtYXRbb2Zmc2V0ICsgMTNdO1xuICAgIHZhciBhMzQgPSBtYXRbb2Zmc2V0ICsgMTRdO1xuICAgIHZhciBhNDQgPSBtYXRbb2Zmc2V0ICsgMTVdO1xuXG4gICAgdmFyIGIxMSA9IG1hdDJbb2Zmc2V0Ml07XG4gICAgdmFyIGIyMSA9IG1hdDJbb2Zmc2V0MiArIDFdO1xuICAgIHZhciBiMzEgPSBtYXQyW29mZnNldDIgKyAyXTtcbiAgICB2YXIgYjQxID0gbWF0MltvZmZzZXQyICsgM107XG4gICAgdmFyIGIxMiA9IG1hdDJbb2Zmc2V0MiArIDRdO1xuICAgIHZhciBiMjIgPSBtYXQyW29mZnNldDIgKyA1XTtcbiAgICB2YXIgYjMyID0gbWF0MltvZmZzZXQyICsgNl07XG4gICAgdmFyIGI0MiA9IG1hdDJbb2Zmc2V0MiArIDddO1xuICAgIHZhciBiMTMgPSBtYXQyW29mZnNldDIgKyA4XTtcbiAgICB2YXIgYjIzID0gbWF0MltvZmZzZXQyICsgOV07XG4gICAgdmFyIGIzMyA9IG1hdDJbb2Zmc2V0MiArIDEwXTtcbiAgICB2YXIgYjQzID0gbWF0MltvZmZzZXQyICsgMTFdO1xuICAgIHZhciBiMTQgPSBtYXQyW29mZnNldDIgKyAxMl07XG4gICAgdmFyIGIyNCA9IG1hdDJbb2Zmc2V0MiArIDEzXTtcbiAgICB2YXIgYjM0ID0gbWF0MltvZmZzZXQyICsgMTRdO1xuICAgIHZhciBiNDQgPSBtYXQyW29mZnNldDIgKyAxNV07XG5cbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0XSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDJdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAzXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblxuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyA0XSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgNV0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDZdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyA3XSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcblxuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyA4XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgOV0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDEwXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMTFdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDEyXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcbiAgICByZXN1bHRbcmVzdWx0T2Zmc2V0ICsgMTNdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQgKyAxNF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG4gICAgcmVzdWx0W3Jlc3VsdE9mZnNldCArIDE1XSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcbn07XG5cbm1hdDQubXVsU0lNRCA9IGZ1bmN0aW9uIG11bFN0b3JlU0lNRChtYXQsIG9mZnNldCwgbWF0Miwgb2Zmc2V0Mikge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICB2YXIgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0KTtcbiAgICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0ICsgNCk7XG4gICAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQsIG9mZnNldCArIDgpO1xuICAgIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0LCBvZmZzZXQgKyAxMik7XG5cbiAgICB2YXIgYjAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdDIsIG9mZnNldDIpO1xuICAgIHZhciBvdXQwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCByZXN1bHRPZmZzZXQsIG91dDApO1xuXG4gICAgdmFyIGIxID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQyLCBvZmZzZXQyICsgNCk7XG4gICAgdmFyIG91dDEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIHJlc3VsdE9mZnNldCArIDQsIG91dDEpO1xuXG4gICAgdmFyIGIyID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQyLCBvZmZzZXQyICsgOCk7XG4gICAgdmFyIG91dDIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIHJlc3VsdE9mZnNldCArIDgsIG91dDIpO1xuXG4gICAgdmFyIGIzID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQyLCBvZmZzZXQyICsgMTIpO1xuICAgIHZhciBvdXQzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCByZXN1bHRPZmZzZXQgKyAxMiwgb3V0Myk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubWF0NC5tdWxTSU1EU3RvcmUgPSBmdW5jdGlvbiBtdWxTdG9yZVNJTUQocmVzdWx0LCByZXN1bHRPZmZzZXQsIG1hdCwgb2Zmc2V0LCBtYXQyLCBvZmZzZXQyKSB7XG4gICAgdmFyIG91dCA9IHJlc3VsdDtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0KTtcbiAgICB2YXIgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdCwgb2Zmc2V0ICsgNCk7XG4gICAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChtYXQsIG9mZnNldCArIDgpO1xuICAgIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0LCBvZmZzZXQgKyAxMik7XG5cbiAgICB2YXIgYjAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKG1hdDIsIG9mZnNldDIpO1xuICAgIHZhciBiMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0Miwgb2Zmc2V0MiArIDQpO1xuICAgIHZhciBiMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0Miwgb2Zmc2V0MiArIDgpO1xuICAgIHZhciBiMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQobWF0Miwgb2Zmc2V0MiArIDEyKTtcblxuICAgIHZhciBvdXQwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG5cbiAgICB2YXIgb3V0MSA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuXG4gICAgdmFyIG91dDIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMywgMywgMywgMyksIGEzKSkpKTtcblxuICAgIHZhciBvdXQzID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG5cbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIHJlc3VsdE9mZnNldCwgb3V0MCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCByZXN1bHRPZmZzZXQgKyA0LCBvdXQxKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIHJlc3VsdE9mZnNldCArIDgsIG91dDIpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgcmVzdWx0T2Zmc2V0ICsgMTIsIG91dDMpO1xufTtcblxuZXhwb3J0cy52ZWMyID0gdmVjMjtcbmV4cG9ydHMudmVjMyA9IHZlYzM7XG5leHBvcnRzLnZlYzQgPSB2ZWM0O1xuZXhwb3J0cy5tYXQzID0gbWF0MztcbmV4cG9ydHMubWF0NCA9IG1hdDQ7IiwiZXhwb3J0cy5ub3JtYWxpemUgPSByZXF1aXJlKFwiLi9zYW5pdGl6ZXJcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcbnZhciBlc2dyYXBoID0gcmVxdWlyZShcImVzZ3JhcGhcIik7XG52YXIgd29ya2xpc3QgPSByZXF1aXJlKFwiLi93b3JrbGlzdFwiKTtcbnZhciBhc3RVdGlscyA9IHJlcXVpcmUoXCIuLi9hc3RfdXRpbHNcIik7XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnN0YW50cyhhYXN0KSB7XG4gICAgdmFyIGNmZyA9IGVzZ3JhcGgoYWFzdC5ib2R5WzBdLmJvZHkpO1xuXG4gICAgd29ya2xpc3QoY2ZnLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHZhciByZXN1bHQgPSBmaW5kVmFsdWUodGhpcy5hc3ROb2RlKTtcbiAgICAgICAgdmFyIHJ2YWx1ZXMgPSBbLi4ucmVzdWx0XTtcbiAgICAgICAgdmFyIGRpZiA9IFsuLi5pbnB1dF0uZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXJ2YWx1ZXMuc29tZShmdW5jdGlvbiAocnYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sZWZ0Lm5hbWUgPT09IHJ2LmxlZnQubmFtZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNldChbLi4uZGlmLCAuLi5yZXN1bHRdKTtcbiAgICB9KTtcblxuICAgIHdvcmtsaXN0KGNmZywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuc2l6ZSA+IDApXG4gICAgICAgICAgICBwcm9wYWdhdGVWYWx1ZXModGhpcy5hc3ROb2RlLCB0aGlzLmlucHV0KTtcblxuICAgICAgICB0aGlzLmdlbiA9IHRoaXMuZ2VuIHx8IGZpbmRWYXJpYWJsZVJlZmVyZW5jZXModGhpcy5hc3ROb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoWy4uLmlucHV0LCAuLi50aGlzLmdlbl0pO1xuICAgIH0pO1xuXG4gICAgY2ZnWzJdLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5nZW4gPSBub2RlLmtpbGwgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgdmFyIGNoYW5nZWQgPSB0cnVlO1xuICAgIHdoaWxlIChjaGFuZ2VkKSB7XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHdvcmtsaXN0KGNmZywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcblxuICAgICAgICAgICAgdmFyIGdlbiA9IHRoaXMuZ2VuID0gZmluZFZhcmlhYmxlUmVmZXJlbmNlcyh0aGlzLmFzdE5vZGUpO1xuICAgICAgICAgICAgdmFyIGtpbGwgPSB0aGlzLmtpbGwgPSBmaW5kVmFyaWFibGVEZWZpbml0aW9ucyh0aGlzLmFzdE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoWy4uLmdlbiwgLi4uWy4uLmlucHV0XS5maWx0ZXIoeCA9PiAha2lsbC5oYXMoeCkpXSk7XG4gICAgICAgIH0sIHtkaXJlY3Rpb246IFwiYmFja3dhcmRcIn0pO1xuXG4gICAgICAgIGNmZ1syXS5mb3JFYWNoKGZ1bmN0aW9uIChjZmdOb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2ZnTm9kZS50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSBjZmdOb2RlLmFzdE5vZGU7XG4gICAgICAgICAgICBpZiAoY2ZnTm9kZS5raWxsLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2ZnTm9kZS5raWxsLmZvckVhY2goZnVuY3Rpb24gKGtpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNmZ05vZGUubmV4dC5zb21lKGZ1bmN0aW9uIChjZmdOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5nZXQoY2ZnTm9kZSkuaGFzKGtpbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBub2RlLmxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgbm9kZS5sZWZ0Lm5hbWUgPT09IGtpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFN5bnRheC5FbXB0eVN0YXRlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFhc3Q7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHByb3BhZ2F0ZUNvbnN0YW50cztcblxuZnVuY3Rpb24gcHJvcGFnYXRlVmFsdWVzKGFzdCwgaW5wdXQpIHtcbiAgICB2YXIgbXVsdGlwbGVWYWx1ZXMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gWy4uLmlucHV0XS5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgdikge1xuICAgICAgICB2YXIgbmFtZSA9IHYubGVmdC5uYW1lO1xuICAgICAgICBpZiAobWFwLmhhcyhuYW1lKSlcbiAgICAgICAgICAgIG11bHRpcGxlVmFsdWVzLnB1c2gobmFtZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgdi5yaWdodCk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgbmV3IE1hcCgpKTtcblxuICAgIG11bHRpcGxlVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFsdWVzLmRlbGV0ZShuYW1lKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKG5hbWUsIGlkeCkge1xuICAgICAgICB2YXIgdiA9IHZhbHVlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghdilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gU3ludGF4LkFycmF5RXhwcmVzc2lvbiAmJiBpZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdi5lbGVtZW50c1tpZHhdO1xuICAgICAgICAgICAgLy8gaWYgKHZhbHVlLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKVxuICAgICAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodi50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUodi5uYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVzdHJhdmVyc2UucmVwbGFjZShhc3QsIHtcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguUHJvcGVydHkgJiYgcGFyZW50LmtleSA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgcGFyZW50LnByb3BlcnR5ID09PSBub2RlICYmICFwYXJlbnQuY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZShub2RlLm5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiBub2RlLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0VXRpbHMuY3JlYXRlTGl0ZXJhbChldmFsKG5vZGUubGVmdC52YWx1ZSArIFwiXCIgKyBub2RlLm9wZXJhdG9yICsgXCJcIiArIG5vZGUucmlnaHQudmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub2JqZWN0LnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyIHx8IG5vZGUucHJvcGVydHkudHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUobm9kZS5vYmplY3QubmFtZSwgbm9kZS5wcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZFZhcmlhYmxlRGVmaW5pdGlvbnMoYXN0KSB7XG4gICAgdmFyIGRlZmluaXRpb25zID0gbmV3IFNldCgpO1xuICAgIGVzdHJhdmVyc2UudHJhdmVyc2UoYXN0LCB7XG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnMuYWRkKG5vZGUubGVmdC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9ucy5hZGQobm9kZS5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGZpbmRWYXJpYWJsZVJlZmVyZW5jZXMoYXN0KSB7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgZXN0cmF2ZXJzZS50cmF2ZXJzZShhc3QsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzVmFyaWFibGVSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSlcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzLmFkZChub2RlLm5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguTmV3RXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5Qcm9wZXJ0eSAmJiBwYXJlbnQua2V5ID09PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBwYXJlbnQubGVmdCA9PT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBpc01lbWJlclJlZmVyZW5jZShub2RlLCBwYXJlbnQpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RlLm9iamVjdC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RlLnByb3BlcnR5LnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmluZFZhbHVlKGFzdCkge1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgZXN0cmF2ZXJzZS50cmF2ZXJzZShhc3QsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5VcGRhdGVFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSBub2RlLmFyZ3VtZW50O1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmFkZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzcHJpbWEgPSByZXF1aXJlKFwiZXNwcmltYVwiKTtcbnZhciBlc3RyYXZlcnNlID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbnZhciBpbnRlcm5hbEZ1bmN0aW9ucyA9IHJlcXVpcmUoXCIuLi9tYXRoXCIpO1xuaW50ZXJuYWxGdW5jdGlvbnMudGV4dHVyZSA9IHJlcXVpcmUoXCIuLi90ZXh0dXJlXCIpO1xudmFyIGFzdFV0aWxzID0gcmVxdWlyZShcIi4uL2FzdF91dGlsc1wiKTtcblxudmFyIGlubGluZUNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBpbmxpbmVJbnRlcm5hbEZ1bmN0aW9ucyhhYXN0KSB7XG4gICAgZXN0cmF2ZXJzZS5yZXBsYWNlKGFhc3QsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBub2RlLmNhbGxlZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0LnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlICE9PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgcGFyZW50LnR5cGUgIT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxocyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgIGxocyA9IHBhcmVudC5sZWZ0Lm5hbWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUuY2FsbGVlLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZm5OYW1lID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFsRnVuY3Rpb25zW3R5cGVOYW1lXSB8fCAhaW50ZXJuYWxGdW5jdGlvbnNbdHlwZU5hbWVdW2ZuTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgZm5Bc3QgPSBlc3ByaW1hLnBhcnNlKGludGVybmFsRnVuY3Rpb25zW3R5cGVOYW1lXVtmbk5hbWVdLnRvU3RyaW5nKCkpLmJvZHlbMF07XG4gICAgICAgICAgICAgICAgdmFyIGZuUGFyYW1ldGVyTmFtZXMgPSBmbkFzdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ubmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0TmFtZSA9IFwiX19pbmxpbmVfXCIgKyB0eXBlTmFtZSArIGZuTmFtZSArIFwicmVzdWx0XCIgKyBpbmxpbmVDb3VudGVyO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvblZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBmblBhcmFtZXRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVmFyaWFibGVzLmFkZChwYXJhbWV0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmbkFzdC5ib2R5LmJvZHkudW5zaGlmdChhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbihwYXJhbWV0ZXIsIG5vZGUuYXJndW1lbnRzW2lkeF0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlc3RyYXZlcnNlLnJlcGxhY2UoZm5Bc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVmFyaWFibGVzLmFkZChkZWNsYXJhdGlvbi5pZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25WYXJpYWJsZXMuaGFzKG5vZGUubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiX19pbmxpbmVfXCIgKyB0eXBlTmFtZSArIGZuTmFtZSArIG5vZGUubmFtZSArIGlubGluZUNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0VXRpbHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihyZXN1bHROYW1lLCBub2RlLmFyZ3VtZW50LCBcIj1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobGhzKVxuICAgICAgICAgICAgICAgICAgICBmbkFzdC5ib2R5LmJvZHkucHVzaChhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGxocywgcmVzdWx0TmFtZSwgXCI9XCIpKTtcbiAgICAgICAgICAgICAgICBmbkFzdC5ib2R5LmJvZHkudW5zaGlmdChhc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbihyZXN1bHROYW1lKSk7XG5cbiAgICAgICAgICAgICAgICBpbmxpbmVDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuQXN0LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQgJiYgbm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBub2RlLmV4cHJlc3Npb24ucmlnaHQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmV4cHJlc3Npb24ucmlnaHQ7XG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbmxpbmVJbnRlcm5hbEZ1bmN0aW9uczsiLCJcbnZhciBRdWV1ZSA9IHJlcXVpcmUoJ2FuYWx5c2VzL2xpYi9xdWV1ZScpO1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gd29ya2xpc3Q7XG5cbi8vIGV4cG9zZSB0aGUgdXRpbGl0aWVzIHRvIGhhdmUgdGhlbSB0ZXN0ZWQgc2VwYXJhdGVseVxuZXhwb3J0cy5RdWV1ZSA9IFF1ZXVlO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgZ2VuZXJhbCB3b3JrbGlzdCBhbGdvcml0aG1cbiAqIGBjZmdgIGlzIGEgY29udHJvbCBmbG93IGdyYXBoIGNyZWF0ZWQgYnkgYGVzZ3JhcGhgLFxuICogYHRyYW5zZmVyRnVuY3Rpb25gIGdldHMgY2FsbGVkIHdpdGggKHRoaXMgPSBub2RlLCBpbnB1dCwgd29ya2xpc3QpXG4gKiBpdCBvcGVyYXRlcyBvbiB0aGUgaW5wdXQgYFNldGAgYW5kIGNhbiByZXR1cm4gYW4gb3V0cHV0IHNldCwgaW4gd2hpY2ggY2FzZVxuICogdGhlIHdvcmtsaXN0IGFsZ29yaXRobSBhdXRvbWF0aWNhbGx5IGVucXVldWVzIGFsbCB0aGUgc3VjY2Vzc29yIG5vZGVzLCBvciBpdFxuICogbWlnaHQgcmV0dXJuIGFuIHtvdXRwdXQ6IG91dHB1dCwgZW5xdWV1ZTogZmFsc2V9IG9iamVjdCBpbiB3aGljaCBjYXNlIGl0IGlzXG4gKiBpdHNlbGYgcmVzcG9uc2libGUgdG8gZW5xdWV1ZSB0aGUgc3VjY2Vzc29yIG5vZGVzLlxuICogYG9wdGlvbnNgIGRlZmluZXMgdGhlIGBkaXJlY3Rpb25gLCBhIGBtZXJnZWAgZnVuY3Rpb24gYW5kIGFuIGBlcXVhbHNgXG4gKiBmdW5jdGlvbiB3aGljaCBtZXJnZSB0aGUgaW5wdXRzIHRvIGEgbm9kZSBhbmQgZGV0ZXJtaW5lIGlmIGEgbm9kZSBoYXMgY2hhbmdlZFxuICogaXRzIG91dHB1dCByZXNwZWN0aXZlbHkuXG4gKiBSZXR1cm5zIGEgYE1hcGAgZnJvbSBub2RlIC0+IG91dHB1dFxuICovXG5mdW5jdGlvbiB3b3JrbGlzdChjZmcsIHRyYW5zZmVyRnVuY3Rpb24sIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCAnZm9yd2FyZCc7XG5cdHZhciBtZXJnZSA9IG9wdGlvbnMubWVyZ2UgfHwgd29ya2xpc3QubWVyZ2UoU2V0LnVuaW9uKTtcblx0dmFyIGVxdWFscyA9IG9wdGlvbnMuZXF1YWxzIHx8IFNldC5lcXVhbHM7XG5cdHZhciBsaXN0ID0gbmV3IFF1ZXVlKCk7XG5cdGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuXHRcdGxpc3QucHVzaChjZmdbMF0pO1xuXHRcdHZhciBwcmVkZWNlc3NvcnMgPSB3b3JrbGlzdC5wcmVkZWNlc3NvcnM7XG5cdFx0dmFyIHN1Y2Nlc3NvcnMgPSB3b3JrbGlzdC5zdWNjZXNzb3JzO1xuXHR9IGVsc2Uge1xuXHRcdGxpc3QucHVzaChjZmdbMV0pO1xuXHRcdHZhciBwcmVkZWNlc3NvcnMgPSB3b3JrbGlzdC5zdWNjZXNzb3JzO1xuXHRcdHZhciBzdWNjZXNzb3JzID0gd29ya2xpc3QucHJlZGVjZXNzb3JzO1xuXHR9XG5cdHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgbmV3IFNldCgpO1xuXG5cdHZhciBvdXRwdXQgPSBuZXcgTWFwKCk7XG5cdHdoaWxlIChsaXN0Lmxlbmd0aCkge1xuXHRcdHZhciBub2RlID0gbGlzdC5zaGlmdCgpO1xuXHRcdHZhciBwcmUgPSBwcmVkZWNlc3NvcnMobm9kZSlcblx0XHRcdC5tYXAoZnVuY3Rpb24gKG4pIHtyZXR1cm4gb3V0cHV0LmdldChuKTt9KVxuXHRcdHZhciBpbnB1dCA9IHByZS5sZW5ndGggPyBtZXJnZShwcmUpIDogc3RhcnQ7XG5cdFx0dmFyIG9sZE91dHB1dCA9IG91dHB1dC5nZXQobm9kZSk7XG5cdFx0dmFyIG91dCA9IHRyYW5zZmVyRnVuY3Rpb24uY2FsbChub2RlLCBpbnB1dCwgbGlzdCwgb2xkT3V0cHV0KTtcblx0XHRpZiAoIW91dCB8fCBvdXQgaW5zdGFuY2VvZiBTZXQpXG5cdFx0XHRvdXQgPSB7b3V0cHV0OiBvdXQsIGVucXVldWU6IHRydWV9O1xuXHRcdG91dHB1dC5zZXQobm9kZSwgb3V0Lm91dHB1dCk7XG5cdFx0aWYgKG91dC5lbnF1ZXVlICYmICghb2xkT3V0cHV0IHx8ICFlcXVhbHMob3V0Lm91dHB1dCwgb2xkT3V0cHV0KSkpXG5cdFx0XHRzdWNjZXNzb3JzKG5vZGUpLmZvckVhY2goZnVuY3Rpb24gKGFTdWNjZXNzb3IpIHtcdGxpc3QucHVzaChhU3VjY2Vzc29yKTtcdH0pO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59O1xuXG53b3JrbGlzdC5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5wcmV2O1xufTtcblxud29ya2xpc3Quc3VjY2Vzc29ycyA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdHJldHVybiBub2RlLm5leHQ7XG59O1xuXG53b3JrbGlzdC5tZXJnZSA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGlucHV0cykge1xuXHRcdGlmIChpbnB1dHMubGVuZ3RoID09IDEpXG5cdFx0XHRyZXR1cm4gbmV3IFNldChpbnB1dHNbMF0pO1xuXHRcdHJldHVybiBpbnB1dHMucmVkdWNlKGZuKTtcblx0fTtcbn07XG5cbmlmICghU2V0LmVxdWFscylcblx0U2V0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0aWYgKGEuc2l6ZSAhPSBiLnNpemUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIFsuLi5hXS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRyZXR1cm4gYi5oYXModmFsKTtcblx0XHR9KTtcblx0fTtcblxuaWYgKCFTZXQudW5pb24pXG5cdFNldC51bmlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0aWYgKCFhKVxuXHRcdFx0cmV0dXJuIGI7XG5cdFx0aWYgKCFiKVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0cmV0dXJuIG5ldyBTZXQoWy4uLmEsIC4uLmJdKTtcblx0fTtcblxuaWYgKCFTZXQubWludXMpXG5cdFNldC5taW51cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0aWYgKCFiKVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0aWYgKCFhKVxuXHRcdFx0cmV0dXJuIG5ldyBTZXQoKTtcblx0XHRyZXR1cm4gbmV3IFNldChbLi4uYV0uZmlsdGVyKHggPT4gIWIuaGFzKHgpKSk7XG5cdH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlc3RyYXZlcnNlID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsc1wiKTtcbnZhciBhc3RVdGlscyA9IHJlcXVpcmUoXCIuLi9hc3RfdXRpbHNcIik7XG52YXIgc3dpenpsZVRvSW5kZXhNYXAgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpLnN3aXp6bGVUb0luZGV4TWFwO1xudmFyIGRldGVybWluZUxvZ2ljYWxFbGVtZW50U2l6ZSA9IHJlcXVpcmUoXCIuLi9kZXRlcm1pbmVfbG9naWNhbF9lbGVtZW50X3NpemVcIik7XG5cbmV4cG9ydHMubm9kZVR5cGVzID0gW1N5bnRheC5NZW1iZXJFeHByZXNzaW9uXTtcbmV4cG9ydHMuZW50ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICghbm9kZS5vYmplY3QuY29tcHV0ZWQgfHwgbm9kZS5jb21wdXRlZClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGFubm90YXRpb24gPSB1dGlscy5hbm5vdGF0ZShub2RlKTtcbiAgICBpZiAoIWFubm90YXRpb24uY2FuTnVtYmVyKCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBzd2l6emxlSW5kZXggPSBzd2l6emxlVG9JbmRleE1hcFt1dGlscy5hbm5vdGF0ZShub2RlLm9iamVjdCkuZ2V0S2luZCgpXVtub2RlLnByb3BlcnR5Lm5hbWVdO1xuICAgIHZhciBzdHJpZGUgPSBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUub2JqZWN0LnByb3BlcnR5LCBkZXRlcm1pbmVMb2dpY2FsRWxlbWVudFNpemUobm9kZS5vYmplY3Qub2JqZWN0KSwgXCIqXCIpO1xuICAgIG5vZGUub2JqZWN0LnByb3BlcnR5ID0gYXN0VXRpbHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihzdHJpZGUsIHN3aXp6bGVJbmRleCwgXCIrXCIpLmV4cHJlc3Npb247XG4gICAgbm9kZS5vYmplY3QuZXh0cmEgPSB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9O1xuXG4gICAgbm9kZS5vYmplY3Qub2JqZWN0LmV4dHJhID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gW25vZGUub2JqZWN0XTtcbn07XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpO1xudmFyIFN5bnRheCA9IGVzdHJhdmVyc2UuU3ludGF4O1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHNcIik7XG5cbnZhciBkZXRlcm1pbmVMb2dpY2FsRWxlbWVudFNpemUgPSByZXF1aXJlKFwiLi4vZGV0ZXJtaW5lX2xvZ2ljYWxfZWxlbWVudF9zaXplXCIpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG52YXIgYXN0VXRpbHMgPSByZXF1aXJlKFwiLi4vYXN0X3V0aWxzXCIpO1xuXG5leHBvcnRzLm5vZGVUeXBlcyA9IFtTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb25dO1xuZXhwb3J0cy5lbnRlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUubGVmdC50eXBlICE9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiB8fCAhbm9kZS5sZWZ0LmNvbXB1dGVkIHx8IG5vZGUucmlnaHQudHlwZSAhPT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBkZXN0aW5hdGlvbkFubm90YXRpb24gPSB1dGlscy5hbm5vdGF0ZShub2RlLmxlZnQpO1xuICAgIHZhciB0eXBlID0gZGVzdGluYXRpb25Bbm5vdGF0aW9uLmdldEtpbmQoKTtcbiAgICB2YXIgaW5kZXggPSBub2RlLmxlZnQucHJvcGVydHk7XG5cbiAgICB2YXIgYXNzaWdubWVudHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RhbnRzLnR5cGVTaXplTWFwW3R5cGVdOyArK2kpIHtcbiAgICAgICAgYXNzaWdubWVudHMucHVzaChhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKFxuICAgICAgICAgICAgYXN0VXRpbHMuY3JlYXRlQXJyYXlBY2Nlc3MoXG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0Lm9iamVjdCxcbiAgICAgICAgICAgICAgICBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oaW5kZXgsIGRldGVybWluZUxvZ2ljYWxFbGVtZW50U2l6ZShub2RlLmxlZnQub2JqZWN0KSwgXCIqXCIpLCBpLCBcIitcIiksIHt0eXBlOiBcIm51bWJlclwifSksXG4gICAgICAgICAgICBub2RlLnJpZ2h0LmFyZ3VtZW50c1tpXSxcbiAgICAgICAgICAgIFwiPVwiLFxuICAgICAgICAgICAge3R5cGU6IFwibnVtYmVyXCJ9KSk7XG4gICAgfVxuICAgIG5vZGUubGVmdC5vYmplY3QuZXh0cmEuZWxlbWVudHMgPSB7XG4gICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzc2lnbm1lbnRzW2Fzc2lnbm1lbnRzLmxlbmd0aCAtIDFdID0gYXNzaWdubWVudHNbYXNzaWdubWVudHMubGVuZ3RoIC0gMV0uZXhwcmVzc2lvbjtcblxuICAgIHJldHVybiBhc3NpZ25tZW50cztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcblxudmFyIGFzdFV0aWxzID0gcmVxdWlyZShcIi4uL2FzdF91dGlsc1wiKTtcblxudmFyIHZhbGlkT3BlcmF0b3JzID0gW1wiK1wiLCBcIi1cIiwgXCIqXCIsIFwiL1wiLCBcIiVcIl07XG52YXIgY291bnRlciA9IDA7XG5cbmV4cG9ydHMubm9kZVR5cGVzID0gW1N5bnRheC5CaW5hcnlFeHByZXNzaW9uXTtcbmV4cG9ydHMuZW50ZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xuICAgICAgICBub2RlLl9faWdub3JlX2JpbmFyeV9leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuX19pZ25vcmVfYmluYXJ5X2V4cHJlc3Npb24gPSBwYXJlbnQuX19pZ25vcmVfYmluYXJ5X2V4cHJlc3Npb247XG59O1xuZXhwb3J0cy5sZWF2ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKHZhbGlkT3BlcmF0b3JzLmluZGV4T2Yobm9kZS5vcGVyYXRvcikgPT09IC0xIHx8IG5vZGUuX19pZ25vcmVfYmluYXJ5X2V4cHJlc3Npb24pXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciB0bXAgPSBcIl9ib3BcIiArIGNvdW50ZXIrKztcbiAgICBub2RlLl9fdG1wID0gdG1wO1xuICAgIHJldHVybiBbYXN0VXRpbHMuY3JlYXRlRGVjbGFyYXRpb24odG1wLCBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGdldFZhck5hbWVPckxpdGVyYWwobm9kZS5sZWZ0KSwgZ2V0VmFyTmFtZU9yTGl0ZXJhbChub2RlLnJpZ2h0KSwgbm9kZS5vcGVyYXRvcikuZXhwcmVzc2lvbiwgbm9kZS5leHRyYSksIGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIobm9kZS5fX3RtcCwgbm9kZS5leHRyYSldXG59O1xuXG5mdW5jdGlvbiBnZXRWYXJOYW1lT3JMaXRlcmFsKG5vZGUpIHtcbiAgICBpZiAobm9kZS5fX3RtcClcbiAgICAgICAgcmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIobm9kZS5fX3RtcCwgbm9kZS5leHRyYSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcblxuZXhwb3J0cy5ub2RlVHlwZXMgPSBbU3ludGF4LklmU3RhdGVtZW50LCBTeW50YXguV2hpbGVTdGF0ZW1lbnQsIFN5bnRheC5Gb3JTdGF0ZW1lbnRdO1xuZXhwb3J0cy5lbnRlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LklmU3RhdGVtZW50KSB7XG4gICAgICAgIG5vZGUuY29uc2VxdWVudCA9IHdyYXBJbkJsb2NrU3RhdGVtZW50KG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgIG5vZGUuYWx0ZXJuYXRlID0gd3JhcEluQmxvY2tTdGF0ZW1lbnQobm9kZS5hbHRlcm5hdGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguV2hpbGVTdGF0ZW1lbnRcbiAgICAgICAgfHwgbm9kZS50eXBlID09PSBTeW50YXguRm9yU3RhdGVtZW50KSB7XG4gICAgICAgIG5vZGUuYm9keSA9IHdyYXBJbkJsb2NrU3RhdGVtZW50KG5vZGUuYm9keSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JhcEluQmxvY2tTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUudHlwZSAhPT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KVxuICAgICAgICByZXR1cm4ge3R5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCwgYm9keTogW25vZGVdfTtcbiAgICByZXR1cm4gbm9kZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcblxudmFyIGFzdFV0aWxzID0gcmVxdWlyZShcIi4uL2FzdF91dGlsc1wiKTtcblxudmFyIGNvdW50ZXIgPSAwO1xuXG5leHBvcnRzLm5vZGVUeXBlcyA9IFtTeW50YXguQ2FsbEV4cHJlc3Npb25dO1xuZXhwb3J0cy5sZWF2ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUuX190bXApXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgdG1wID0gXCJfY2FsbFwiICsgY291bnRlcisrO1xuICAgIG5vZGUuYXJndW1lbnRzID0gbm9kZS5hcmd1bWVudHMubWFwKGdldFZhck5hbWVPckxpdGVyYWwpO1xuICAgIG5vZGUuX190bXAgPSB0bXA7XG4gICAgcmV0dXJuIFthc3RVdGlscy5jcmVhdGVEZWNsYXJhdGlvbih0bXAsIG5vZGUsIG5vZGUuZXh0cmEpLCBhc3RVdGlscy5jcmVhdGVJZGVudGlmaWVyKG5vZGUuX190bXAsIG5vZGUuZXh0cmEpXTtcbn07XG5cbmZ1bmN0aW9uIGdldFZhck5hbWVPckxpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLl9fdG1wKVxuICAgICAgICByZXR1cm4gYXN0VXRpbHMuY3JlYXRlSWRlbnRpZmllcihub2RlLl9fdG1wLCBub2RlLmV4dHJhKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpO1xudmFyIFN5bnRheCA9IGVzdHJhdmVyc2UuU3ludGF4O1xuXG52YXIgRGVjbGFyYXRpb25TaW1wbGlmaWVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2FuYWx5emUvc2FuaXRpemVyL2RlY2xhcmF0aW9uX3NpbXBsaWZpZXJcIik7XG52YXIgUmVkdW5kYW50QmxvY2tzUmVtb3ZlclxuICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL2FuYWx5emUvc2FuaXRpemVyL3JlZHVuZGFudF9ibG9ja3NfcmVtb3ZlclwiKTtcblxudmFyIHRyYW5zZm9ybWVycyA9IFtyZXF1aXJlKFwiLi9ibG9ja193cmFwcGVyXCIpLCByZXF1aXJlKFwiLi9iaW5hcnlfZXhwcmVzc2lvblwiKSwgcmVxdWlyZShcIi4vYXNzaWdubWVudF9leHByZXNzaW9uXCIpLCByZXF1aXJlKFwiLi9hcnJheV9hY2Nlc3Nfc3dpenpsZVwiKSwgcmVxdWlyZShcIi4vY2FsbF9leHByZXNzaW9uXCIpXTtcblxuZnVuY3Rpb24gc2FuaXRpemUoYXN0KSB7XG4gICAgdHJhbnNmb3JtZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHZhciBjdXJyZW50QmxvY2sgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdEJsb2NrID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRFeHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgZXN0cmF2ZXJzZS5yZXBsYWNlKGFzdCwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrID0gY3VycmVudEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2sgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50IHx8IG5vZGUudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24gfHwgbm9kZS50eXBlID09IFN5bnRheC5JZlN0YXRlbWVudCB8fCBub2RlLnR5cGUgPT09IFN5bnRheC5XaGlsZVN0YXRlbWVudCB8fCBub2RlLnR5cGUgPT09IFN5bnRheC5Gb3JTdGF0ZW1lbnQgfHwgbm9kZS50eXBlID09PSBTeW50YXguUmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFeHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGN1cnJlbnRCbG9jay5ib2R5LmluZGV4T2YoY3VycmVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIubm9kZVR5cGVzLmluZGV4T2Yobm9kZS50eXBlKSA9PT0gLTEgfHwgIXRyYW5zZm9ybWVyLmVudGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIuZW50ZXIobm9kZSwgcGFyZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnROb2RlID0gcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIGluc2VydE5ld05vZGVzKHJlc3VsdCwgY3VycmVudEJsb2NrLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudE5vZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrID0gbGFzdEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGN1cnJlbnRCbG9jay5ib2R5LmluZGV4T2YoY3VycmVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIubm9kZVR5cGVzLmluZGV4T2Yobm9kZS50eXBlKSA9PT0gLTEgfHwgIXRyYW5zZm9ybWVyLmxlYXZlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIubGVhdmUobm9kZSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50Tm9kZSA9IHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgICAgICBpbnNlcnROZXdOb2RlcyhyZXN1bHQsIGN1cnJlbnRCbG9jaywgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBkZWNsYXJhdGlvblNpbXBsaWZpZXIgPSBuZXcgRGVjbGFyYXRpb25TaW1wbGlmaWVyKCk7XG4gICAgZGVjbGFyYXRpb25TaW1wbGlmaWVyLmV4ZWN1dGUoYXN0KTtcbiAgICB2YXIgcmVkdW5kYW50QmxvY2tzUmVtb3ZlciA9IG5ldyBSZWR1bmRhbnRCbG9ja3NSZW1vdmVyKCk7XG4gICAgcmVkdW5kYW50QmxvY2tzUmVtb3Zlci5leGVjdXRlKGFzdCk7XG5cbiAgICByZXR1cm4gYXN0O1xufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzYW5pdGl6ZTtcblxuZnVuY3Rpb24gaW5zZXJ0TmV3Tm9kZXMobm9kZXMsIGJsb2NrLCBleHByZXNzaW9uSWR4KSB7XG4gICAgaWYgKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJlcGxhY2VtZW50Tm9kZSwgaWR4KSB7XG4gICAgICAgICBibG9jay5ib2R5LnNwbGljZShleHByZXNzaW9uSWR4ICsgaWR4LCAwICwgcmVwbGFjZW1lbnROb2RlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlc3RyYXZlcnNlID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIik7XG52YXIgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG52YXIgZXNncmFwaCA9IHJlcXVpcmUoXCJlc2dyYXBoXCIpO1xudmFyIGFuYWx5c2VzID0gcmVxdWlyZShcImFuYWx5c2VzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xudmFyIG1hdGggPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xuXG5leHBvcnRzLm1hcmsgPSBmdW5jdGlvbihhc3QpIHtcbiAgICB2YXIgY2ZnID0gZXNncmFwaChhc3QsIHtvbWl0RXhjZXB0aW9uczogdHJ1ZX0pO1xuXG4gICAgdmFyIHZhcmlhYmxlc1Zpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHNob3VsZFNJTUQgPSBhbmFseXNlcyhjZmcsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuXG4gICAgICAgIHZhciBzaG91bGRTSU1EID0gbmV3IGFuYWx5c2VzLlNldCgpO1xuICAgICAgICB2YXIgc2hvdWxkTm90U0lNRCA9IG5ldyBhbmFseXNlcy5TZXQoKTtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYXN0Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLmxlZnQubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVzVmlzaXRlZC5oYXMobmFtZSkgJiYgIWlucHV0LmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5oYXMobm9kZS5sZWZ0Lm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU0lNRC5hZGQobm9kZS5yaWdodC5uYW1lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBub2RlLnJpZ2h0LmNhbGxlZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHZhciBsaHNBbm5vdGF0aW9uID0gdXRpbHMuYW5ub3RhdGUobm9kZS5yaWdodC5jYWxsZWUub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWxoc0Fubm90YXRpb24uaXNWZWN0b3IoKSAmJiAhbGhzQW5ub3RhdGlvbi5pc01hdHJpeCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm5OYW1lID0gbm9kZS5yaWdodC5jYWxsZWUucHJvcGVydHkubmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChmbk5hbWUgPT09IFwibXVsXCIgJiYgbGhzQW5ub3RhdGlvbi5pc01hdHJpeCgpICYmIHV0aWxzLmFubm90YXRlKG5vZGUucmlnaHQuYXJndW1lbnRzWzBdKS5pc1ZlY3RvcigpKVxuICAgICAgICAgICAgICAgICAgICBmbk5hbWUgKz0gXCJWZWNcIjtcblxuICAgICAgICAgICAgICAgIGlmIChmbk5hbWUgPT09IFwibXVsXCIgJiYgbGhzQW5ub3RhdGlvbi5pc1ZlY3RvcigpICYmIHV0aWxzLmFubm90YXRlKG5vZGUucmlnaHQuYXJndW1lbnRzWzBdKS5jYW5OdW1iZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgZm5OYW1lID0gXCJzY2FsZVwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGhbbGhzQW5ub3RhdGlvbi5nZXRLaW5kKCkudG9Mb3dlckNhc2UoKV1bZm5OYW1lICsgXCJTSU1EXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNJTUQuYWRkKG5vZGUubGVmdC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc1Zpc2l0ZWQuYWRkKG5vZGUubGVmdC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNJTUQuYWRkKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQuY2FsbGVlLm9iamVjdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU0lNRC5hZGQobm9kZS5yaWdodC5jYWxsZWUub2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzVmlzaXRlZC5hZGQobm9kZS5yaWdodC5jYWxsZWUub2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yaWdodC5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU0lNRC5hZGQoYXJnLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc1Zpc2l0ZWQuYWRkKGFyZy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiAhc2hvdWxkU0lNRC5oYXMobm9kZS5sZWZ0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGROb3RTSU1ELmFkZChub2RlLmxlZnQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNWaXNpdGVkLmFkZChub2RlLmxlZnQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQuY2FsbGVlLm9iamVjdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTm90U0lNRC5hZGQobm9kZS5yaWdodC5jYWxsZWUub2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yaWdodC5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTm90U0lNRC5hZGQoYXJnLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc1Zpc2l0ZWQuYWRkKGFyZy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgYW5hbHlzZXMuU2V0LnVuaW9uKHNob3VsZFNJTUQsIGFuYWx5c2VzLlNldC5taW51cyhpbnB1dCwgc2hvdWxkTm90U0lNRCkpO1xuICAgIH0sIHtkaXJlY3Rpb246IFwiYmFja3dhcmRcIn0pLmdldChjZmdbMF0pO1xuXG4gICAgLy8gZG8ge1xuICAgIC8vICAgICB2YXIgbGFzdFNob3VsZFNJTUQgPSBuZXcgYW5hbHlzZXMuU2V0KHNob3VsZFNJTUQpXG4gICAgLy8gICAgIGFuYWx5c2VzKGNmZywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgLy8gICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgIC8vICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAvL1xuICAgIC8vICAgICAgICAgdmFyIHNob3VsZE5vdFNJTUQgPSBuZXcgYW5hbHlzZXMuU2V0KCk7XG4gICAgLy8gICAgICAgICBpZiAodGhpcy5hc3ROb2RlLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgIC8vICAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAvLyAgICAgICAgICAgICBpZiAodGhpcy5hc3ROb2RlLmxlZnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpXG4gICAgLy8gICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmFzdE5vZGUubGVmdC5uYW1lO1xuICAgIC8vICAgICAgICAgICAgIGVzdHJhdmVyc2UudHJhdmVyc2UodGhpcy5hc3ROb2RlLnJpZ2h0LCB7XG4gICAgLy8gICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguTmV3RXhwcmVzc2lvbilcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQ2FsbEV4cHJlc3Npb24gJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgIT09IFwiTWF0aFwiKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEFyZ3NTSU1EID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5uYW1lICYmIGFyZy5leHRyYS50eXBlID09PSBcIm9iamVjdFwiICYmICFsYXN0U2hvdWxkU0lNRC5oYXMoYXJnLm5hbWUpKVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQXJnc1NJTUQgPSBmYWxzZTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEFyZ3NTSU1EICYmIG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lKVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGROb3RTSU1ELmFkZChub2RlLmNhbGxlZS5vYmplY3QubmFtZSlcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIG5vZGUuY29tcHV0ZWQpXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiAhbGFzdFNob3VsZFNJTUQuaGFzKG5vZGUubmFtZSkpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIChwYXJlbnQucHJvcGVydHkgPT09IG5vZGUgfHwgcGFyZW50Lm9iamVjdCA9PT0gbm9kZSkpXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSlcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTm90U0lNRC5hZGQobmFtZSlcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgICAgIH0pO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vXG4gICAgLy8gICAgICAgICBzaG91bGRTSU1EID0gYW5hbHlzZXMuU2V0Lm1pbnVzKHNob3VsZFNJTUQsIHNob3VsZE5vdFNJTUQpO1xuICAgIC8vICAgICAgICAgcmV0dXJuIHNob3VsZE5vdFNJTUQ7XG4gICAgLy8gICAgIH0sIHtkaXJlY3Rpb246IFwiYmFja3dhcmRcIn0pLmdldChjZmdbMF0pO1xuICAgIC8vIH0gd2hpbGUgKHNob3VsZFNJTUQuc2l6ZSAhPT0gMCAmJiAhYW5hbHlzZXMuU2V0LmVxdWFscyhsYXN0U2hvdWxkU0lNRCwgc2hvdWxkU0lNRCkpO1xuXG4gICAgdmFyIGNhblNJTUQgPSBhbmFseXNlcyhjZmcsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuXG4gICAgICAgIHZhciBjYW5TSU1EID0gaW5wdXQ7XG4gICAgICAgIGVzdHJhdmVyc2UudHJhdmVyc2UodGhpcy5hc3ROb2RlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgbm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGNhblNJTUQuaGFzKG5vZGUubGVmdC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKG5vZGUucmlnaHQgPyBub2RlLnJpZ2h0IDogbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgc2hvdWxkU0lNRC5oYXMobm9kZS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NpbWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBub2RlLmNhbGxlZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBub2RlLmNhbGxlZS5vYmplY3QubmFtZSAhPT0gXCJNYXRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3NpbWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBub2RlLmNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9fc2ltZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk5ld0V4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX19zaW1kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQgJiYgbm9kZS5yaWdodC5fX3NpbWQgJiYgbm9kZS5sZWZ0Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGNhblNJTUQuYWRkKG5vZGUubGVmdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhblNJTUQ7XG4gICAgfSwge2RpcmVjdGlvbjogXCJmb3J3YXJkXCIsIHN0YXJ0OiBzaG91bGRTSU1EfSkuZ2V0KGNmZ1sxXSk7XG5cbiAgICByZXR1cm4gY2FuU0lNRDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcbnZhciBlc2dyYXBoID0gcmVxdWlyZShcImVzZ3JhcGhcIik7XG52YXIgYW5hbHlzZXMgPSByZXF1aXJlKFwiYW5hbHlzZXNcIik7XG52YXIgYXN0VXRpbHMgPSByZXF1aXJlKFwiLi9hc3RfdXRpbHNcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xuZXh0ZXJuYWwudGV4dHVyZSA9IHJlcXVpcmUoXCIuL3RleHR1cmVcIik7XG52YXIgZXNwcmltYSA9IHJlcXVpcmUoXCJlc3ByaW1hXCIpO1xuXG52YXIgUmVkdW5kYW50QmxvY2tzUmVtb3ZlclxuICAgID0gcmVxdWlyZShcIi4uLy4uL2FuYWx5emUvc2FuaXRpemVyL3JlZHVuZGFudF9ibG9ja3NfcmVtb3ZlclwiKTtcbnZhciBEZWNsYXJhdGlvblNpbXBsaWZpZXIgPSByZXF1aXJlKFwiLi4vLi4vYW5hbHl6ZS9zYW5pdGl6ZXIvZGVjbGFyYXRpb25fc2ltcGxpZmllclwiKTtcblxuZnVuY3Rpb24gc2ltcGxpZnkoYWFzdCkge1xuICAgIGlubGluZUZ1bmN0aW9ucyhhYXN0KTtcblxuICAgIGVzdHJhdmVyc2UucmVwbGFjZShhYXN0LCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIG5vZGUuZXhwcmVzc2lvbi5yaWdodC50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmV4cHJlc3Npb24ucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBkZWNsYXJhdGlvblNpbXBsaWZpZXIgPSBuZXcgRGVjbGFyYXRpb25TaW1wbGlmaWVyKCk7XG4gICAgZGVjbGFyYXRpb25TaW1wbGlmaWVyLmV4ZWN1dGUoYWFzdCk7XG5cbiAgICB2YXIgcmVkdW5kYW50QmxvY2tzUmVtb3ZlciA9IG5ldyBSZWR1bmRhbnRCbG9ja3NSZW1vdmVyKCk7XG4gICAgcmVkdW5kYW50QmxvY2tzUmVtb3Zlci5leGVjdXRlKGFhc3QpO1xuXG4gICAgcHJvcGFnYXRlQ29waWVzKGFhc3QpO1xuICAgIHByb3BhZ2F0ZUNvbnN0YW50cyhhYXN0KTtcbiAgICBkZWFkQ29kZUVsaW1pbmF0aW9uKGFhc3QpO1xuICAgIHJlbW92ZUVtcHR5U3RhdGVtZW50cyhhYXN0KTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnk7XG5cbmZ1bmN0aW9uIGlubGluZUZ1bmN0aW9ucyhhYXN0KSB7XG4gICAgdmFyIGlubGluZUNvdW50ZXIgPSAwO1xuICAgIGVzdHJhdmVyc2UucmVwbGFjZShhYXN0LCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBwYXJlbnQubGVmdC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgIT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBwYXJlbnQudHlwZSAhPT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkNhbGxFeHByZXNzaW9uICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxocyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgIGxocyA9IHBhcmVudC5sZWZ0Lm5hbWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUuY2FsbGVlLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZm5OYW1lID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4dGVybmFsW3R5cGVOYW1lXVtmbk5hbWVdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGZuQXN0ID0gZXNwcmltYS5wYXJzZShleHRlcm5hbFt0eXBlTmFtZV1bZm5OYW1lXS50b1N0cmluZygpKS5ib2R5WzBdO1xuICAgICAgICAgICAgICAgIHZhciBmblBhcmFtZXRlck5hbWVzID0gZm5Bc3QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLm5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdE5hbWUgPSBcIl9faW5saW5lX1wiICsgdHlwZU5hbWUgKyBmbk5hbWUgKyBcInJlc3VsdFwiICsgaW5saW5lQ291bnRlcjtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25WYXJpYWJsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZm5QYXJhbWV0ZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbWV0ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblZhcmlhYmxlcy5hZGQocGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm5Bc3QuYm9keS5ib2R5LnVuc2hpZnQoYXN0VXRpbHMuY3JlYXRlRGVjbGFyYXRpb24ocGFyYW1ldGVyLCBub2RlLmFyZ3VtZW50c1tpZHhdKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXN0cmF2ZXJzZS5yZXBsYWNlKGZuQXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblZhcmlhYmxlcy5hZGQoZGVjbGFyYXRpb24uaWQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uVmFyaWFibGVzLmhhcyhub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIl9faW5saW5lX1wiICsgdHlwZU5hbWUgKyBmbk5hbWUgKyBub2RlLm5hbWUgKyBpbmxpbmVDb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguUmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24ocmVzdWx0TmFtZSwgbm9kZS5hcmd1bWVudCwgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxocylcbiAgICAgICAgICAgICAgICAgICAgZm5Bc3QuYm9keS5ib2R5LnB1c2goYXN0VXRpbHMuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihsaHMsIHJlc3VsdE5hbWUsIFwiPVwiKSk7XG4gICAgICAgICAgICAgICAgZm5Bc3QuYm9keS5ib2R5LnVuc2hpZnQoYXN0VXRpbHMuY3JlYXRlRGVjbGFyYXRpb24ocmVzdWx0TmFtZSkpO1xuXG4gICAgICAgICAgICAgICAgaW5saW5lQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbkFzdC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29waWVzKGFhc3QpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgd2hpbGUgKGNoYW5nZWQpIHtcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY2ZnID0gZXNncmFwaChhYXN0LmJvZHlbMF0uYm9keSk7XG4gICAgICAgIHZhciByZXN1bHQgPSAgcmVhY2hpbmdEZWZpbml0aW9ucyhjZmcsIGZpbmRBc3NpZ25lZFZhcmlhYmxlc0FuZENvcHlWYWx1ZXMpO1xuICAgICAgICBjZmdbMl0uZm9yRWFjaChmdW5jdGlvbiAoY2ZnTm9kZSwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoY2ZnTm9kZS50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGlucHV0ID0gcmVzdWx0LmdldChjZmdOb2RlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmREZWZpbnRpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZzID0gaW5wdXQudmFsdWVzKCkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZnNbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBkZWZzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChkZWZzLmV2ZXJ5KGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYubmFtZSAhPT0gZmlyc3QubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWxWYWx1ZShkZWYudmFsdWUsIGZpcnN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXN0cmF2ZXJzZS5yZXBsYWNlKGNmZ05vZGUuYXN0Tm9kZSwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmICFwYXJlbnQuY29tcHV0ZWQgJiYgcGFyZW50LnByb3BlcnR5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIHBhcmVudC5wcm9wZXJ0eS5uYW1lID09PSBub2RlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguUHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBmaW5kRGVmaW50aW9uKG5vZGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uICYmIGRlZmluaXRpb24udmFsdWUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbiA9PT0gcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgcGFyZW50LnJpZ2h0ID09PSBkZWZpbml0aW9uLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29uc3RhbnRzKGFhc3QpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgd2hpbGUgKGNoYW5nZWQpIHtcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY2ZnID0gZXNncmFwaChhYXN0LmJvZHlbMF0uYm9keSk7XG4gICAgICAgIHZhciByZXN1bHQgPSAgcmVhY2hpbmdEZWZpbml0aW9ucyhjZmcsIGZpbmRBc3NpZ25lZFZhcmlhYmxlc0FuZExpdGVyYWxWYWx1ZXMpO1xuICAgICAgICBjZmdbMl0uZm9yRWFjaChmdW5jdGlvbiAoY2ZnTm9kZSwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoY2ZnTm9kZS50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGlucHV0ID0gcmVzdWx0LmdldChjZmdOb2RlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmREZWZpbml0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmcyA9IGlucHV0LnZhbHVlcygpLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm5hbWUgPT09IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVmcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZzWzBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gZGVmc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmcy5ldmVyeShmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLm5hbWUgIT09IGZpcnN0Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsVmFsdWUoZGVmLnZhbHVlLCBmaXJzdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVzdHJhdmVyc2UucmVwbGFjZShjZmdOb2RlLmFzdE5vZGUsIHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiAhcGFyZW50LmNvbXB1dGVkICYmIHBhcmVudC5wcm9wZXJ0eS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBwYXJlbnQucHJvcGVydHkubmFtZSA9PT0gbm9kZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LlByb3BlcnR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gZmluZERlZmluaXRpb24obm9kZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi52YWx1ZSAmJiBkZWZpbml0aW9uLnZhbHVlLnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24gPT09IHBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5yaWdodCA9PT0gZGVmaW5pdGlvbi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09PSBub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZXN0cmF2ZXJzZS5yZXBsYWNlKGNmZ05vZGUuYXN0Tm9kZSwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09PSBub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jb21wdXRlZCAmJiBub2RlLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIG5vZGUub2JqZWN0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUucHJvcGVydHkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5vYmplY3QubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBub2RlLnByb3BlcnR5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBmaW5kRGVmaW5pdGlvbihuYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi52YWx1ZSAmJiBkZWZpbml0aW9uLnZhbHVlLnR5cGUgPT09IFN5bnRheC5BcnJheUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbi52YWx1ZS5lbGVtZW50c1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvbGRDb25zdGFudHMoYWFzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVhY2hpbmdEZWZpbml0aW9ucyhjZmcsIGdhdGhlclZhcmlhYmxlRGVmaW5pdGlvbnMpIHtcbiAgICByZXR1cm4gYW5hbHlzZXMoY2ZnLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcblxuICAgICAgICB2YXIgZ2VuID0gdGhpcy5nZW4gPSB0aGlzLmdlbiB8fCBnYXRoZXJWYXJpYWJsZURlZmluaXRpb25zKHRoaXMpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBpbnB1dC52YWx1ZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAhZ2VuLnZhbHVlcygpLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSB2Lm5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFuYWx5c2VzLlNldC51bmlvbihnZW4sIG5ldyBhbmFseXNlcy5TZXQocmVzdWx0KSk7XG4gICAgfSwge1xuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICByZXR1cm4gYS52YWx1ZXMoKS5ldmVyeShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gYi52YWx1ZXMoKS5maW5kKGZ1bmN0aW9uIChidikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnYubmFtZSA9PT0gdi5uYW1lICYmIGJ2LnZhbHVlID09PSB2LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kQXNzaWduZWRWYXJpYWJsZXNBbmRDb3B5VmFsdWVzKGNmZ05vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IGFuYWx5c2VzLlNldCgpO1xuICAgIGlmIChjZmdOb2RlLnBhcmVudC50eXBlICE9PSBTeW50YXguRm9yU3RhdGVtZW50ICYmXG4gICAgICAgIGNmZ05vZGUucGFyZW50LnR5cGUgIT09IFN5bnRheC5XaGlsZVN0YXRlbWVudCAmJlxuICAgICAgICBjZmdOb2RlLmFzdE5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmXG4gICAgICAgIGNmZ05vZGUuYXN0Tm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC5hZGQoe25hbWU6IGNmZ05vZGUuYXN0Tm9kZS5sZWZ0Lm5hbWUsIHZhbHVlOiBjZmdOb2RlLmFzdE5vZGUucmlnaHR9KTtcbiAgICB9XG5cbiAgICBpZiAoY2ZnTm9kZS5hc3ROb2RlLnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBjZmdOb2RlLmFzdE5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGNmZ05vZGUuYXN0Tm9kZS5jYWxsZWUubmFtZS5pbmRleE9mKFwiU3RvcmVcIikgIT09IC0xKVxuICAgICAgICByZXN1bHQuYWRkKHtuYW1lOiBjZmdOb2RlLmFzdE5vZGUuYXJndW1lbnRzWzBdLm5hbWUsIHZhbHVlOiBjZmdOb2RlLmFzdE5vZGUuY2FsbGVlLm5hbWV9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gZmluZEFzc2lnbmVkVmFyaWFibGVzQW5kTGl0ZXJhbFZhbHVlcyhjZmdOb2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBhbmFseXNlcy5TZXQoKTtcbiAgICBpZiAoY2ZnTm9kZS5wYXJlbnQudHlwZSAhPT0gU3ludGF4LkZvclN0YXRlbWVudCAmJlxuICAgICAgICBjZmdOb2RlLnBhcmVudC50eXBlICE9PSBTeW50YXguV2hpbGVTdGF0ZW1lbnQgJiZcbiAgICAgICAgY2ZnTm9kZS5hc3ROb2RlLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJlxuICAgICAgICBjZmdOb2RlLmFzdE5vZGUubGVmdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICByZXN1bHQuYWRkKHtuYW1lOiBjZmdOb2RlLmFzdE5vZGUubGVmdC5uYW1lLCB2YWx1ZTogY2ZnTm9kZS5hc3ROb2RlLnJpZ2h0fSk7XG4gICAgfVxuICAgIGlmIChjZmdOb2RlLmFzdE5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmXG4gICAgICAgIGNmZ05vZGUuYXN0Tm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmXG4gICAgICAgIGNmZ05vZGUuYXN0Tm9kZS5sZWZ0Lm9iamVjdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgcmVzdWx0LmFkZCh7bmFtZTogY2ZnTm9kZS5hc3ROb2RlLmxlZnQub2JqZWN0Lm5hbWUsIHZhbHVlOiBudWxsfSk7XG5cbiAgICBpZiAoY2ZnTm9kZS5hc3ROb2RlLnR5cGUgPT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbiAmJiBjZmdOb2RlLmFzdE5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGNmZ05vZGUuYXN0Tm9kZS5jYWxsZWUubmFtZS5pbmRleE9mKFwiU3RvcmVcIikgIT09IC0xKVxuICAgICAgICByZXN1bHQuYWRkKHtuYW1lOiBjZmdOb2RlLmFzdE5vZGUuYXJndW1lbnRzWzBdLm5hbWUsIHZhbHVlOiBjZmdOb2RlLmFzdE5vZGUuY2FsbGVlLm5hbWV9KTtcblxuICAgIHJldHVybiByZXN1bHQ7fVxuXG5mdW5jdGlvbiBlcXVhbFZhbHVlKG5vZGUxLCBub2RlMikge1xuICAgIGlmICghbm9kZTEgfHwgIW5vZGUyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vZGUxLnR5cGUgIT09IG5vZGUyLnR5cGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHN3aXRjaCAobm9kZTEudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5MaXRlcmFsOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUxLnZhbHVlID09PSBub2RlMi52YWx1ZTtcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgIHJldHVybiBub2RlMS5uYW1lID09PSBub2RlMi5uYW1lO1xuICAgICAgICBjYXNlIFN5bnRheC5BcnJheUV4cHJlc3Npb246XG4gICAgICAgICAgICByZXR1cm4gbm9kZTEuZWxlbWVudHMuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQsIGlkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5lbGVtZW50c1tpZHhdID09PSBlbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb2xkQ29uc3RhbnRzKG5vZGUpIHtcbiAgICBlc3RyYXZlcnNlLnJlcGxhY2Uobm9kZSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5CaW5hcnlFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBub2RlLnJpZ2h0LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGhzID0gbm9kZS5sZWZ0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJocyA9IG5vZGUucmlnaHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0VXRpbHMuY3JlYXRlTGl0ZXJhbChldmFsKGxocyArIFwiXCIgKyBub2RlLm9wZXJhdG9yICsgXCJcIiArIHJocykpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlc3RyYXZlcnNlLnJlcGxhY2Uobm9kZSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlYWRDb2RlRWxpbWluYXRpb24oYWFzdCkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB3aGlsZSAoY2hhbmdlZCkge1xuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBjZmcgPSBlc2dyYXBoKGFhc3QuYm9keVswXS5ib2R5KTtcbiAgICAgICAgLy8gdmFyIHJlc3VsdCA9IGxpdmVWYXJpYWJsZXMoY2ZnKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFuYWx5c2VzKGNmZywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcblxuICAgICAgICAgICAgdmFyIGdlbiA9IHRoaXMuZ2VuID0gdGhpcy5nZW4gfHwgZmluZFVzZWRWYXJpYWJsZXModGhpcy5hc3ROb2RlKTtcbiAgICAgICAgICAgIHZhciBraWxsID0gdGhpcy5raWxsID0gdGhpcy5raWxsIHx8IGZpbmRBc3NpZ25lZFZhcmlhYmxlcyh0aGlzLmFzdE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhbmFseXNlcy5TZXQudW5pb24oZ2VuLCBhbmFseXNlcy5TZXQubWludXMoaW5wdXQsIGtpbGwpKTtcbiAgICAgICAgfSwge2RpcmVjdGlvbjogXCJiYWNrd2FyZFwifSk7XG5cbiAgICAgICAgY2ZnWzJdLmZvckVhY2goZnVuY3Rpb24gKGNmZ05vZGUpIHtcbiAgICAgICAgICAgIGlmIChjZmdOb2RlLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNmZ05vZGUuYXN0Tm9kZTtcbiAgICAgICAgICAgIGlmIChjZmdOb2RlLmtpbGwuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjZmdOb2RlLmtpbGwuZm9yRWFjaChmdW5jdGlvbiAoa2lsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ZnTm9kZS5uZXh0LnNvbWUoZnVuY3Rpb24gKGNmZ05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmdldChjZmdOb2RlKS5oYXMoa2lsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIG5vZGUubGVmdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBub2RlLmxlZnQubmFtZSA9PT0ga2lsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gU3ludGF4LkVtcHR5U3RhdGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRVc2VkVmFyaWFibGVzKG5vZGUpIHtcbiAgICB2YXIgdmFycyA9IG5ldyBhbmFseXNlcy5TZXQoKTtcbiAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKG5vZGUsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBwYXJlbnQubGVmdCA9PT0gbm9kZSAmJiBbXCIrPVwiLCBcIi09XCIsIFwiKj1cIiwgXCIvPVwiLCBcIiY9XCIsIFwifD1cIl0uaW5kZXhPZihwYXJlbnQub3BlcmF0b3IpID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBwYXJlbnQucHJvcGVydHkgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhcnMuYWRkKG5vZGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2YXJzO1xufVxuXG5mdW5jdGlvbiBmaW5kQXNzaWduZWRWYXJpYWJsZXMobm9kZSkge1xuICAgIHZhciB2YXJzID0gbmV3IGFuYWx5c2VzLlNldCgpO1xuICAgIGVzdHJhdmVyc2UudHJhdmVyc2Uobm9kZSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIG5vZGUubGVmdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICB2YXJzLmFkZChub2RlLmxlZnQubmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFycztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlTdGF0ZW1lbnRzKGFhc3QpIHtcbiAgICBlc3RyYXZlcnNlLnJlcGxhY2UoYWFzdCwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50ICYmIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguRW1wdHlTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9KVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuc2FtcGxlID0gZnVuY3Rpb24gc2FtcGxlVGV4dHVyZShhcnJheSwgdXYsIHV2T2Zmc2V0KSB7XG4gICAgdmFyIHUgPSB1dlt1dk9mZnNldF0sIHYgPSB1dlt1dk9mZnNldCArIDFdO1xuICAgIHZhciB4ID0gTWF0aC5mbG9vcih1ICogKGFycmF5LnNoYXBlWzBdIC0gMSkpICUgKGFycmF5LnNoYXBlWzBdIC0gMSk7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKCgxIC0gdikgKiAoYXJyYXkuc2hhcGVbMV0gLSAxKSkgJSAoYXJyYXkuc2hhcGVbMV0gLSAxKTtcblxuICAgIHZhciBvZmZzZXQgPSAoeCArIHkgKiBhcnJheS5zaGFwZVswXSkgKiA0O1xuICAgIHJldHVybiBbYXJyYXlbb2Zmc2V0XSwgYXJyYXlbb2Zmc2V0ICsgMV0sIGFycmF5W29mZnNldCArIDJdICwgYXJyYXlbb2Zmc2V0ICsgM11dO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbnZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcbnZhciBlc2dyYXBoID0gcmVxdWlyZShcImVzZ3JhcGhcIik7XG52YXIgYW5hbHlzZXMgPSByZXF1aXJlKFwiYW5hbHlzZXNcIik7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbnZhciBtYXRoID0gcmVxdWlyZShcIi4vbWF0aFwiKTtcbnZhciBhc3RVdGlscyA9IHJlcXVpcmUoXCIuL2FzdF91dGlsc1wiKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbmV4cG9ydHMudmVjdG9yaXplID0gZnVuY3Rpb24gKGFzdCkge1xuICAgIGVzdHJhdmVyc2UucmVwbGFjZShhc3QsIHtcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5Gb3JTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVWZWN0b3JpemVkKG5vZGUpICYmICFub2RlLl9faWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvcml6ZShub2RlLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXN0O1xufTtcblxuZnVuY3Rpb24gY2FuQmVWZWN0b3JpemVkKG5vZGUpIHtcbiAgICB2YXIgbG9vcFZhciA9IG5vZGUuaW5pdC5sZWZ0Lm5hbWU7XG5cbiAgICB2YXIgY2Fubm90QmVWZWN0b3JpemVkID0gZmFsc2U7XG4gICAgdmFyIHVuc3VwcG9ydGVkT3BlcmF0b3JzID0gW1wiJVwiXTtcbiAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKG5vZGUsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gdXRpbHMuYW5ub3RhdGUobm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5pc1ZlY3RvcigpIHx8IGFubm90YXRpb24uaXNNYXRyaXgoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5ub3RCZVZlY3Rvcml6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkJpbmFyeUV4cHJlc3Npb24gJiYgdW5zdXBwb3J0ZWRPcGVyYXRvcnMuaW5kZXhPZihub2RlLm9wZXJhdG9yKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjYW5ub3RCZVZlY3Rvcml6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJlYWsoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY2Fubm90QmVWZWN0b3JpemVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgY29udGFpbnNBbHJlYWR5VmVjdG9yaXplZExvb3AgPSBmYWxzZTtcbiAgICB2YXIgbm9kZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuICAgIGVzdHJhdmVyc2UucmVwbGFjZShub2RlLCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgaWYgKG4gIT09IG5vZGUgJiYgbi50eXBlID09PSBTeW50YXguRm9yU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG4uX192ZWN0b3JpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zQWxyZWFkeVZlY3Rvcml6ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVhaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNvbnRhaW5zQWxyZWFkeVZlY3Rvcml6ZWRMb29wKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgY2ZnID0gZXNncmFwaChub2RlLCB7b21pdEV4Y2VwdGlvbnM6IHRydWV9KTtcbiAgICBhbmFseXNlcyhjZmcsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuXG4gICAgICAgIHZhciBnZW4gPSB0aGlzLmdlbiA9IHRoaXMuZ2VuIHx8IGZpbmRVc2VkVmFyaWFibGVzKHRoaXMuYXN0Tm9kZSk7XG4gICAgICAgIHRoaXMuZ2VuLmRlbGV0ZShsb29wVmFyKTtcbiAgICAgICAgdmFyIGtpbGwgPSB0aGlzLmtpbGwgPSB0aGlzLmtpbGwgfHwgZmluZEFzc2lnbmVkVmFyaWFibGVzKHRoaXMuYXN0Tm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcgYW5hbHlzZXMuU2V0LnVuaW9uKGdlbiwgYW5hbHlzZXMuU2V0Lm1pbnVzKGlucHV0LCBraWxsKSk7XG4gICAgfSwge2RpcmVjdGlvbjogXCJiYWNrd2FyZFwifSk7XG5cbiAgICB2YXIgbG9vcERlcGVuZGVuY3kgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNmZ1syXS5sZW5ndGggJiYgIWxvb3BEZXBlbmRlbmN5OyArK2kpIHtcbiAgICAgICAgdmFyIGNmZ05vZGUgPSBjZmdbMl1baV07XG5cbiAgICAgICAgaWYgKCFjZmdOb2RlLmdlbilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBkZWZpbmVkQWZ0ZXIgPSBjZmdOb2RlLmdlbi5maWx0ZXIoZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWRBZnRlcihjZmdOb2RlLCB2YXJOYW1lLCBjZmdbMV0ucHJldlswXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxvb3BEZXBlbmRlbmN5ID0gZGVmaW5lZEFmdGVyLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuICFsb29wRGVwZW5kZW5jeTtcbn1cblxuZnVuY3Rpb24gZmluZFVzZWRWYXJpYWJsZXMobm9kZSkge1xuICAgIHZhciB2YXJzID0gbmV3IGFuYWx5c2VzLlNldCgpO1xuICAgIGVzdHJhdmVyc2UudHJhdmVyc2Uobm9kZSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09PSBub2RlICYmIFtcIis9XCIsIFwiLT1cIiwgXCIqPVwiLCBcIi89XCIsIFwiJj1cIiwgXCJ8PVwiXS5pbmRleE9mKHBhcmVudC5vcGVyYXRvcikgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFycy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZhcnM7XG59XG5cbmZ1bmN0aW9uIGZpbmRBc3NpZ25lZFZhcmlhYmxlcyhub2RlKSB7XG4gICAgdmFyIHZhcnMgPSBuZXcgYW5hbHlzZXMuU2V0KCk7XG4gICAgZXN0cmF2ZXJzZS50cmF2ZXJzZShub2RlLCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gJiYgbm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgIHZhcnMuYWRkKG5vZGUubGVmdC5uYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YXJzO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWRBZnRlcihjZmdOb2RlLCB2YXJOYW1lLCBsb29wVGFpbCwgYWxyZWFkeVZpc2l0ZWQpIHtcbiAgICBhbHJlYWR5VmlzaXRlZCA9IGFscmVhZHlWaXNpdGVkIHx8IG5ldyBTZXQoKTtcbiAgICBhbHJlYWR5VmlzaXRlZC5hZGQoY2ZnTm9kZSk7XG4gICAgaWYgKCFjZmdOb2RlLmtpbGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBjZmdOb2RlLm5leHQucmVkdWNlKGZ1bmN0aW9uIChpc0RlZmluZWQsIG5leHROb2RlKSB7XG4gICAgICAgIGlmICghbmV4dE5vZGUua2lsbClcbiAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQ7XG4gICAgICAgIGlmIChuZXh0Tm9kZS5wYXJlbnQudHlwZSA9PT0gU3ludGF4LkZvclN0YXRlbWVudClcbiAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQ7XG4gICAgICAgIGlmIChhbHJlYWR5VmlzaXRlZC5oYXMobmV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGlzRGVmaW5lZDtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSBsb29wVGFpbClcbiAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc0RlZmluZWQgfHwgbmV4dE5vZGUua2lsbC5oYXModmFyTmFtZSkgfHwgaXNEZWZpbmVkQWZ0ZXIobmV4dE5vZGUsIHZhck5hbWUsIGxvb3BUYWlsLCBhbHJlYWR5VmlzaXRlZCk7XG4gICAgfSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiB2ZWN0b3JpemUoYXN0LCBwYXJlbnQpIHtcbiAgICBhc3QuX192ZWN0b3JpemVkID0gdHJ1ZTtcbiAgICB2YXIgbG9vcFZhcmlhYmxlID0gYXN0LmluaXQubGVmdC5uYW1lO1xuXG4gICAgLy8gY2xlYW4gdXBcbiAgICBwYXJlbnQuYm9keS5zcGxpY2UocGFyZW50LmJvZHkuaW5kZXhPZihhc3QpICsgMSwgMCwge1xuICAgICAgICB0eXBlOiBTeW50YXguRm9yU3RhdGVtZW50LFxuICAgICAgICB0ZXN0OiBhc3QudGVzdCxcbiAgICAgICAgdXBkYXRlOiBhc3QudXBkYXRlLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXG4gICAgICAgICAgICBib2R5OiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFzdC5ib2R5LmJvZHkpKVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgYXN0LnVwZGF0ZSA9IGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24obG9vcFZhcmlhYmxlLCBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGxvb3BWYXJpYWJsZSwgNCwgXCIrXCIpLCBcIj1cIikuZXhwcmVzc2lvbjtcbiAgICBhc3QudGVzdCA9IGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24obG9vcFZhcmlhYmxlLCBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGFzdC50ZXN0LnJpZ2h0LCBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKGFzdC50ZXN0LnJpZ2h0LCA0LCBcIiVcIiksIFwiLVwiKSwgYXN0LnRlc3Qub3BlcmF0b3IpLmV4cHJlc3Npb247XG5cbiAgICB2YXIgdmVjdG9yaXplZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICBlc3RyYXZlcnNlLnJlcGxhY2UoYXN0LmJvZHksIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBwYXJlbnQudHlwZSA9PT0gU3ludGF4LkZvclN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFN5bnRheC5Gb3JTdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IHV0aWxzLmFubm90YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5pc1ZlY3RvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdmVjdG9yaXplTm9kZShub2RlLnJpZ2h0LCB2ZWN0b3JpemVkVmFyaWFibGVzLCBsb29wVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JpemVkVmFyaWFibGVzLmFkZChub2RlLmxlZnQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGVmdC5leHRyYSA9IG5vZGUubGVmdC5leHRyYSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWZ0LmV4dHJhLnR5cGUgPSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxlZnQuZXh0cmEua2luZCA9IFwiVmVjNFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluc0xvb3BWYXJpYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlc3RyYXZlcnNlLnRyYXZlcnNlKG5vZGUubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgbi5uYW1lID09PSBsb29wVmFyaWFibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zTG9vcFZhcmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zTG9vcFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXNzaWdubWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBlc3RyYXZlcnNlLnJlcGxhY2UoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShub2RlKSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChuLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG4ubmFtZSA9PT0gbG9vcFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24obiwgaSwgXCIrXCIpLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnJpZ2h0ID0gZXh0cmFjdENvbXAobmV3Tm9kZS5yaWdodCwgaSwgbG9vcFZhcmlhYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuX19pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbklkeCA9IGFzdC5ib2R5LmJvZHkuaW5kZXhPZihwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXNzaWdubWVudCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN0LmJvZHkuYm9keS5zcGxpY2UoZXhwcmVzc2lvbklkeCArIGlkeCwgMCwge3R5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LCBleHByZXNzaW9uOiBhc3NpZ25tZW50fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRW1wdHlTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkJpbmFyeUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwic3ViXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwibXVsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwiZGl2XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSB2ZWN0b3JpemVOb2RlKG5vZGUubGVmdCwgdmVjdG9yaXplZFZhcmlhYmxlcywgbG9vcFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdmVjdG9yaXplTm9kZShub2RlLnJpZ2h0LCB2ZWN0b3JpemVkVmFyaWFibGVzLCBsb29wVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIG5vZGUubGVmdC5leHRyYSA9IG5vZGUubGVmdC5leHRyYSB8fCB7fTtcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQuZXh0cmEudHlwZSA9IFwib2JqZWN0XCI7XG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0LmV4dHJhLmtpbmQgPSBcIlZlYzRcIjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhc3RVdGlscy5jcmVhdGVGdW5jdGlvbkNhbGwoYXN0VXRpbHMuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbihub2RlLmxlZnQsIG1ldGhvZCksIFtub2RlLnJpZ2h0XSwge3R5cGU6IFwib2JqZWN0XCIsIGtpbmQ6IFwiVmVjNFwifSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmVjdG9yaXplTm9kZShub2RlLCB2ZWN0b3JpemVkVmFyaWFibGVzLCBsb29wVmFyaWFibGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICBpZiAoKHZlY3Rvcml6ZWRWYXJpYWJsZXMuaGFzKG5vZGUubmFtZSkgfHwgbm9kZS5uYW1lLmluZGV4T2YoXCJfYm9wXCIpID09PSAwKSkge1xuICAgICAgICAgICAgbm9kZS5leHRyYSA9IG5vZGUuZXh0cmEgfHwge307XG4gICAgICAgICAgICBub2RlLmV4dHJhLnR5cGUgPSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgbm9kZS5leHRyYS5raW5kID0gXCJWZWM0XCI7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IGxvb3BWYXJpYWJsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0VXRpbHMuY3JlYXRlTmV3RXhwcmVzc2lvbihcIlZlYzRcIiwgW1xuICAgICAgICAgICAgICAgICAgICBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUsIDAsIFwiK1wiKS5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUsIDEsIFwiK1wiKS5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUsIDIsIFwiK1wiKS5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG5vZGUsIDMsIFwiK1wiKS5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBhc3RVdGlscy5jcmVhdGVOZXdFeHByZXNzaW9uKFwiVmVjNFwiLCBbbm9kZV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnRhaW5zTG9vcFZhcmlhYmxlID0gZmFsc2U7XG4gICAgICAgIGVzdHJhdmVyc2UucmVwbGFjZShub2RlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBuLm5hbWUgPT09IGxvb3BWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluc0xvb3BWYXJpYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29udGFpbnNMb29wVmFyaWFibGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZXN0cmF2ZXJzZS5yZXBsYWNlKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobm9kZSkpLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobiwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBuLm5hbWUgPT09IGxvb3BWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3RVdGlscy5jcmVhdGVCaW5hcnlFeHByZXNzaW9uKG4sIGksIFwiK1wiKS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5fX2lnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzdFV0aWxzLmNyZWF0ZU5ld0V4cHJlc3Npb24oXCJWZWM0XCIsIGFyZ3MpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQ2FsbEV4cHJlc3Npb24gJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09IFwiTWF0aFwiICYmIG1hdGgudmVjNFtub2RlLmNhbGxlZS5wcm9wZXJ0eS5uYW1lICsgXCJTSU1EXCJdKVxuICAgICAgICAgICAgcmV0dXJuIGFzdFV0aWxzLmNyZWF0ZUZ1bmN0aW9uQ2FsbChhc3RVdGlscy5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKGFzdFV0aWxzLmNyZWF0ZUlkZW50aWZpZXIobm9kZS5hcmd1bWVudHNbMF0ubmFtZSwge3R5cGU6IFwib2JqZWN0XCIsIGtpbmQ6IFwiVmVjNFwifSksIG5vZGUuY2FsbGVlLnByb3BlcnR5Lm5hbWUpKTtcblxuICAgICAgICByZXR1cm4gYXN0VXRpbHMuY3JlYXRlTmV3RXhwcmVzc2lvbihcIlZlYzRcIiwgW2V4dHJhY3RDb21wKG5vZGUsIDApLCBleHRyYWN0Q29tcChub2RlLCAxKSwgZXh0cmFjdENvbXAobm9kZSwgMiksIGV4dHJhY3RDb21wKG5vZGUsIDMpXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0Q29tcChub2RlLCBpZHgsIGxvb3BWYXJpYWJsZSkge1xuICAgIHZhciBub2RlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShub2RlKSk7XG4gICAgcmV0dXJuIGVzdHJhdmVyc2UucmVwbGFjZShub2RlLCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBwYXJlbnQudHlwZSAhPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgbm9kZS5uYW1lICE9PSBsb29wVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4dHJhID0gbm9kZS5leHRyYSB8fCB7fTtcbiAgICAgICAgICAgICAgICBub2RlLmV4dHJhLnR5cGUgPSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgICAgIG5vZGUuZXh0cmEua2luZCA9IFwiVmVjNFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3RVdGlscy5jcmVhdGVNZW1iZXJFeHByZXNzaW9uKG5vZGUsIGNvbnN0YW50cy52ZWN0b3JJbmRleFRvU3dpenpsZU1hcFtpZHhdLCB7dHlwZTogXCJudW1iZXJcIn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpO1xuXG4gICAgdmFyIFRyYW5zZm9ybWVyID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmpzXCIpO1xuICAgIHZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dsc2wtZ2VuZXJhdGUuanNcIikuZ2VuZXJhdGU7XG5cblxuICAgIHZhciBHTFNMQ29tcGlsZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB9O1xuXG4gICAgQmFzZS5leHRlbmQoR0xTTENvbXBpbGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGNvbXBpbGVGcmFnbWVudFNoYWRlcjogZnVuY3Rpb24gKGFhc3QsIG9wdCkge1xuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIoYWFzdCwgXCJzaGFkZVwiLCBmYWxzZSwgb3B0KTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXF1aXJlKFwiZXNjb2RlZ2VuXCIpLmdlbmVyYXRlKGFhc3QpKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoYWFzdCwgMCwgXCIgXCIpKTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGFhc3QpO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGFhc3QsIDAsIFwiIFwiKSk7XG5cbiAgICAgICAgICAgIG9wdC5oZWFkZXJzID0gdHJhbnNmb3JtZWQuaGVhZGVycztcbiAgICAgICAgICAgIHZhciBjb2RlID0gZ2VuZXJhdGUodHJhbnNmb3JtZWQucHJvZ3JhbSwgZmFsc2UsIG9wdCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7c291cmNlOiBjb2RlLCB1bmlmb3JtU2V0dGVyOiB0cmFuc2Zvcm1lZC51bmlmb3JtU2V0dGVyfTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZVZlcnRleFNoYWRlcjogZnVuY3Rpb24gKGFhc3QsIG9wdCkge1xuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIoYWFzdCwgXCJnbG9iYWwubWFpblwiLCB0cnVlLCBvcHQpO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGFhc3QsIDAsIFwiIFwiKSk7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybShhYXN0KTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShhYXN0LCAwLCBcIiBcIikpO1xuXG4gICAgICAgICAgICBvcHQuaGVhZGVycyA9IHRyYW5zZm9ybWVkLmhlYWRlcnM7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGdlbmVyYXRlKHRyYW5zZm9ybWVkLnByb2dyYW0sIHRydWUsIG9wdCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7c291cmNlOiBjb2RlLCB1bmlmb3JtU2V0dGVyOiB0cmFuc2Zvcm1lZC51bmlmb3JtU2V0dGVyfTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblxuICAgIG5zLkdMU0xDb21waWxlciA9IEdMU0xDb21waWxlcjtcblxufShleHBvcnRzKSk7XG4iLCIvLyBEZXBlbmRlbmNpZXNcbnZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XG52YXIgd2FsayA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbnZhciBFeHByZXNzaW9uSGFuZGxlciA9IHJlcXVpcmUoJy4uL2Jhc2UvZXhwcmVzc2lvbi1oYW5kbGVyLmpzJykuRXhwcmVzc2lvbkhhbmRsZXIsXG4gICAgU3ludGF4ID0gd2Fsay5TeW50YXgsXG4gICAgVmlzaXRvck9wdGlvbiA9IHdhbGsuVmlzaXRvck9wdGlvbixcbiAgICBhbm5vdGF0ZSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKS5hbm5vdGF0ZTtcblxuXG4vLyBTaG9ydGN1dHNcbnZhciBUeXBlcyA9IFNoYWRlLlRZUEVTLFxuICAgIEtpbmRzID0gU2hhZGUuT0JKRUNUX0tJTkRTLFxuICAgIFNvdXJjZXMgPSBTaGFkZS5TT1VSQ0VTO1xuXG52YXIgSW50ZXJuYWxGdW5jdGlvbnMgPSB7XG4gICAgXCJNYXRDb2xcIjogZnVuY3Rpb24gKG5hbWUsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIG1hdFR5cGUgPSBkZXRhaWxzLm1hdFR5cGUsXG4gICAgICAgICAgICBjb2xUeXBlID0gZGV0YWlscy5jb2xUeXBlO1xuICAgICAgICByZXR1cm4gW21hdFR5cGUgKyBcIiBcIiArIG5hbWUgKyBcIihcIiArIG1hdFR5cGUgKyBcIiBtYXQsIGludCBpZHgsIFwiICsgY29sVHlwZSArIFwiIHZhbHVlKXtcIixcbiAgICAgICAgICAgIFwiICBcIiArIG1hdFR5cGUgKyBcIiByZXN1bHQgPSBcIiArIG1hdFR5cGUgKyBcIihtYXQpO1wiLFxuICAgICAgICAgICAgXCIgIHJlc3VsdFtpZHhdID0gdmFsdWU7XCIsXG4gICAgICAgICAgICBcIiAgcmV0dXJuIHJlc3VsdDtcIixcbiAgICAgICAgICAgIFwifVwiXTtcbiAgICB9XG59XG5cbnZhciBHTFNMID0ge1xuICAgIFN0b3JhZ2U6IHtcbiAgICAgICAgQ09OU1Q6IFwiY29uc3RcIixcbiAgICAgICAgVU5JRk9STTogXCJ1bmlmb3JtXCIsXG4gICAgICAgIFZBUllJTkc6IFwidmFyeWluZ1wiLFxuICAgICAgICBBVFRSSUJVVEU6IFwiYXR0cmlidXRlXCJcbiAgICB9XG59XG5cbnZhciBoYW5kbGVyID0gbmV3IEV4cHJlc3Npb25IYW5kbGVyKHtcbiAgICB0eXBlOiB0b0dMU0xUeXBlXG59KTtcblxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqL1xudmFyIGdldEhlYWRlciA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBpZiAob3B0Lm9taXRIZWFkZXIgPT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHZhciBoZWFkZXIgPSBbXG4gICAgICAgIFwiLy8gR2VuZXJhdGVkIGJ5IHNoYWRlLmpzXCJcbiAgICBdO1xuICAgIGlmIChvcHQuaGVhZGVycylcbiAgICAgICAgaGVhZGVyID0gaGVhZGVyLmNvbmNhdChvcHQuaGVhZGVycylcbiAgICB2YXIgZmxvYXRQcmVjaXNpb24gPSBvcHQuZmxvYXRQcmVjaXNpb24gfHwgXCJoaWdocFwiO1xuICAgIGhlYWRlci5wdXNoKFwicHJlY2lzaW9uIFwiICsgZmxvYXRQcmVjaXNpb24gKyBcIiBmbG9hdDtcIik7XG4gICAgaGVhZGVyLnB1c2goXCJcIik7XG4gICAgcmV0dXJuIGhlYWRlcjtcbn1cblxuZnVuY3Rpb24gdG9HTFNMVHlwZShpbmZvLCBvcHRpb25zKSB7XG4gICAgaWYgKCFpbmZvKSByZXR1cm4gXCI/XCI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvL2NvbnNvbGUubG9nKGluZm8pO1xuXG4gICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUeXBlcy5PQkpFQ1Q6XG4gICAgICAgICAgICBzd2l0Y2ggKGluZm8ua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJWZWM0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZlYzRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiVmVjM1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZWMzXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlZlYzJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmVjMlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJUZXh0dXJlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNhbXBsZXIyRFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJNYXQzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1hdDNcIjtcbiAgICAgICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1hdDRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIEtpbmRzLkNPTE9SX0NMT1NVUkU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZlYzRcIjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEdMU0wgc3VwcG9ydCBmb3I6XCIgKyBpbmZvLmtpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFR5cGVzLkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIHRvR0xTTFR5cGUoaW5mby5lbGVtZW50cywgb3B0aW9ucyk7XG5cbiAgICAgICAgY2FzZSBUeXBlcy5VTkRFRklORUQ6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1VuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2b2lkXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHR5cGVcIik7XG4gICAgICAgIGNhc2UgVHlwZXMuTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXRcIjtcbiAgICAgICAgY2FzZSBUeXBlcy5CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbFwiO1xuICAgICAgICBjYXNlIFR5cGVzLklOVDpcbiAgICAgICAgICAgIHJldHVybiBcImludFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJ0b0dMU0xUeXBlOiBVbmhhbmRsZWQgdHlwZTogXCIgKyBpbmZvLnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGluZm8udHlwZTtcblxuICAgIH1cbn1cblxudmFyIHRvR0xTTFN0b3JhZ2UgPSBmdW5jdGlvbiAoaW5mbywgdmVydGV4U2hhZGVyKSB7XG4gICAgaWYgKCFpbmZvLnNvdXJjZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGluZm8uc291cmNlID09IFNvdXJjZXMuVkVSVEVYKSB7XG4gICAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIgJiYgIWluZm8ub3V0cHV0KVxuICAgICAgICAgICAgcmV0dXJuIEdMU0wuU3RvcmFnZS5BVFRSSUJVVEU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBHTFNMLlN0b3JhZ2UuVkFSWUlORztcbiAgICB9XG4gICAgaWYgKGluZm8uc291cmNlID09IFNvdXJjZXMuVU5JRk9STSlcbiAgICAgICAgcmV0dXJuIEdMU0wuU3RvcmFnZS5VTklGT1JNO1xuICAgIGlmIChpbmZvLnNvdXJjZSA9PSBTb3VyY2VzLkNPTlNUQU5UKVxuICAgICAgICByZXR1cm4gR0xTTC5TdG9yYWdlLkNPTlNUO1xuICAgIHRocm93IG5ldyBFcnJvcihcInRvR0xTTFNvdXJjZTogVW5oYW5kbGVkIHR5cGU6IFwiICsgaW5mby5zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJVbmRlZmluZWQoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG4uZXh0cmEudHlwZSAhPSBUeXBlcy5VTkRFRklORUQ7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVTdGFjaygpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgYXJyLnB1c2guYXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgIHZhciBpbmRlbnQgPSBcIlwiO1xuICAgIGFyci5hcHBlbmRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgbGluZSA/IHRoaXMucHVzaChpbmRlbnQgKyBsaW5lKSA6IHRoaXMucHVzaChcIlwiKTtcbiAgICB9O1xuICAgIGFyci5jaGFuZ2VJbmRlbnRpb24gPSBmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgIHdoaWxlIChhZGQgPiAwKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gXCIgICAgXCI7XG4gICAgICAgICAgICBhZGQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkIDwgMCkge1xuICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50LnN1YnN0cigwLCBpbmRlbnQubGVuZ3RoICsgYWRkICogNCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFyci5hcHBlbmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHRoaXNbdGhpcy5sZW5ndGggLSAxXSA9IHRoaXNbdGhpcy5sZW5ndGggLSAxXSArIHN0cjtcbiAgICB9O1xuICAgIHJldHVybiBhcnI7XG59O1xuXG5cbi8qQmFzZS5leHRlbmQoTGluZVN0YWNrLnByb3RvdHlwZSwge1xuXG4gfSk7Ki9cblxudmFyIGdlbmVyYXRlID0gZnVuY3Rpb24gKGFzdCwgdmVydGV4c2hhZGVyLCBvcHQpIHtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHZhciBsaW5lcyA9IGNyZWF0ZUxpbmVTdGFjaygpO1xuXG4gICAgdHJhdmVyc2UoYXN0LCBsaW5lcywgdmVydGV4c2hhZGVyLCBvcHQpO1xuXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZEludGVybmFsRnVuY3Rpb25zKGxpbmVzLCBpbnRlcm5hbEZ1bmN0aW9ucykge1xuICAgIGlmICghaW50ZXJuYWxGdW5jdGlvbnMpIHJldHVybjtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW50ZXJuYWxGdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gaW50ZXJuYWxGdW5jdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKEludGVybmFsRnVuY3Rpb25zW2VudHJ5LnR5cGVdKSB7XG4gICAgICAgICAgICB2YXIgbGluZXNUb0FkZCA9IEludGVybmFsRnVuY3Rpb25zW2VudHJ5LnR5cGVdKGVudHJ5Lm5hbWUsIGVudHJ5LmRldGFpbHMpO1xuICAgICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgbGluZXNUb0FkZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludGVybmFsOiBJbmxpbmVGdW5jdGlvbiBvZiB0eXBlICdcIiArIGVudHJ5LnR5cGUgKyBcIicgbm90IGF2YWlsYWJsZSFcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKGFzdCwgbGluZXMsIHZlcnRleFNoYWRlciwgb3B0KSB7XG4gICAgdmFyIGluc2lkZU1haW4gPSBmYWxzZTtcblxuXG4gICAgd2Fsay50cmF2ZXJzZShhc3QsIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguUHJvZ3JhbTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRIZWFkZXIob3B0KS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRJbnRlcm5hbEZ1bmN0aW9ucyhsaW5lcywgYW5ub3RhdGUoYXN0KS5nZXRVc2VyRGF0YSgpLmludGVybmFsRnVuY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3J3YXJkRGVjbGFyYXRpb25zKGxpbmVzLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdC5uZXdMaW5lcyAmJiBsaW5lcy5hcHBlbmRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQubmFtZSA9PSBcIm1haW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlTWFpbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKGdlbmVyYXRlRnVuY3Rpb25TaWduYXR1cmUobm9kZSkgKyBcIiB7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguUmV0dXJuU3RhdGVtZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoaGFuZGxlci5zdGF0ZW1lbnQobm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1lZXAhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsID0gaGFuZGxlVmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNYWluLCB2ZXJ0ZXhTaGFkZXIsIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShkZWNsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKGhhbmRsZXIuZXhwcmVzc2lvbihub2RlKSArIFwiO1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LklmU3RhdGVtZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJpZihcIiArIGhhbmRsZXIuZXhwcmVzc2lvbihub2RlLnRlc3QsIG9wdCkgKyBcIikge1wiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShub2RlLmNvbnNlcXVlbnQsIGxpbmVzLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigtMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcIn0gZWxzZSB7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5jaGFuZ2VJbmRlbnRpb24oMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlKG5vZGUuYWx0ZXJuYXRlLCBsaW5lcywgb3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuY2hhbmdlSW5kZW50aW9uKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRm9yU3RhdGVtZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJmb3IgKFwiICsgaGFuZGxlSW5saW5lRGVjbGFyYXRpb24obm9kZS5pbml0LCBvcHQpICsgXCI7IFwiICsgaGFuZGxlci5leHByZXNzaW9uKG5vZGUudGVzdCwgb3B0KSArIFwiOyBcIiArIGhhbmRsZXIuZXhwcmVzc2lvbihub2RlLnVwZGF0ZSwgb3B0KSArIFwiKSB7XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShub2RlLmJvZHksIGxpbmVzLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTmV3U3RhdGVtZW50OlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJjb250aW51ZTtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQnJlYWtTdGF0ZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcImJyZWFrO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJVbmhhbmRsZWQ6IFwiICsgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTsvL2NvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vU2hhZGUudGhyb3dFcnJvcihub2RlLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguUHJvZ3JhbTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuY2hhbmdlSW5kZW50aW9uKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJ9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gYWRkRm9yd2FyZERlY2xhcmF0aW9ucyhsaW5lcywgbm9kZSkge1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgd2Fsay50cmF2ZXJzZShub2RlLCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlkLm5hbWUgPT0gXCJtYWluXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcIi8vIEZvcndhcmQgZGVjbGFyYXRpb25zXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKGdlbmVyYXRlRnVuY3Rpb25TaWduYXR1cmUobm9kZSkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUZ1bmN0aW9uU2lnbmF0dXJlKG5vZGUpIHtcbiAgICB2YXIgZnVuYyA9IGFubm90YXRlKG5vZGUpO1xuICAgIHZhciBtZXRob2RTdGFydCA9IFt0b0dMU0xUeXBlKGZ1bmMuZ2V0UmV0dXJuSW5mbygpLCB7YWxsb3dVbmRlZmluZWQ6IHRydWV9KV07XG4gICAgbWV0aG9kU3RhcnQucHVzaChub2RlLmlkLm5hbWUsICcoJyk7XG4gICAgaWYgKCEobm9kZS5wYXJhbXMgJiYgbm9kZS5wYXJhbXMubGVuZ3RoKSkge1xuICAgICAgICBtZXRob2RTdGFydC5wdXNoKFwidm9pZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWV0aG9kQXJncyA9IFtdO1xuICAgICAgICBub2RlLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgbWV0aG9kQXJncy5wdXNoKHRvR0xTTFR5cGUocGFyYW0uZXh0cmEpICsgXCIgXCIgKyBwYXJhbS5uYW1lKTtcbiAgICAgICAgfSlcbiAgICAgICAgbWV0aG9kU3RhcnQucHVzaChtZXRob2RBcmdzLmpvaW4oXCIsIFwiKSk7XG4gICAgfVxuICAgIG1ldGhvZFN0YXJ0LnB1c2goXCIpXCIpO1xuICAgIHJldHVybiBtZXRob2RTdGFydC5qb2luKFwiIFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGljVmFsdWUoZXh0cmEpIHtcbiAgICBpZiAoIWV4dHJhIHx8IGV4dHJhLnN0YXRpY1ZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBleHRyYS5zdGF0aWNWYWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGhhbmRsZVZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgd3JpdGVTdG9yYWdlUXVhbGlmaWVyLCB2ZXJ0ZXhTaGFkZXIsIG9wdCkge1xuICAgIHZhciBzdG9yYWdlUXVhbGlmaWVyID0gIXdyaXRlU3RvcmFnZVF1YWxpZmllciA/IHRvR0xTTFN0b3JhZ2Uobm9kZS5leHRyYSwgdmVydGV4U2hhZGVyKSA6IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IHN0b3JhZ2VRdWFsaWZpZXIgPyBzdG9yYWdlUXVhbGlmaWVyICsgXCIgXCIgOiBcIlwiO1xuICAgIHJlc3VsdCArPSB0b0dMU0xUeXBlKG5vZGUuZXh0cmEpICsgXCIgXCIgKyBub2RlLmlkLm5hbWU7XG4gICAgaWYgKG5vZGUuZXh0cmEuZWxlbWVudHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiW1wiICsgKG5vZGUuZXh0cmEuc3RhdGljU2l6ZSA/IG5vZGUuZXh0cmEuc3RhdGljU2l6ZSA6IFwiMFwiKSArIFwiXVwiO1xuICAgIH1cbiAgICBpZiAobm9kZS5pbml0KSByZXN1bHQgKz0gXCIgPSBcIiArIGhhbmRsZXIuZXhwcmVzc2lvbihub2RlLmluaXQpO1xuICAgIGlmICghbm9kZS5pbml0ICYmIHN0b3JhZ2VRdWFsaWZpZXIgPT0gR0xTTC5TdG9yYWdlLkNPTlNUKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiA9IFwiICsgZ2V0U3RhdGljVmFsdWUobm9kZS5leHRyYSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBcIjtcIjtcbn1cblxuXG5mdW5jdGlvbiBoYW5kbGVJbmxpbmVEZWNsYXJhdGlvbihub2RlLCBvcHQpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5vZGUuZGVjbGFyYXRpb25zLnJlZHVjZShmdW5jdGlvbiAoZGVjbFN0cmluZywgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBkZWNsID0gdG9HTFNMVHlwZShkZWNsYXJhdGlvbi5leHRyYSkgKyBcIiBcIiArIGRlY2xhcmF0aW9uLmlkLm5hbWU7XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24uaW5pdCkge1xuICAgICAgICAgICAgICAgIGRlY2wgKz0gXCIgPSBcIiArIGhhbmRsZXIuZXhwcmVzc2lvbihkZWNsYXJhdGlvbi5pbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNsU3RyaW5nICsgZGVjbDtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gR0xTTCBhbGxvd3Mgb25seSBkZWNsYXJhdGlvbiBpbiBpbml0LCBidXQgc2luY2UgdGhpcyBpcyBhIG5ldyBzY29wZSwgaXQgc2hvdWxkIGJlIGZpbmVcbiAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdG9HTFNMVHlwZShub2RlLmV4dHJhKSArIFwiIFwiICsgaGFuZGxlci5leHByZXNzaW9uKG5vZGUubGVmdCkgKyBcIiA9IFwiICsgaGFuZGxlci5leHByZXNzaW9uKG5vZGUucmlnaHQpO1xuICAgIH1cbiAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW50ZXJuYWwgZXJyb3IgaW4gR0xTTDo6aGFuZGxlSW5saW5lRGVjbGFyYXRpb24sIGZvdW5kIFwiICsgbm9kZS50eXBlKTtcbn1cblxuXG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG5cblxuIiwidmFyIEdMT2JqZWN0cyA9IG5ldyBNYXAoKTtcblxuR0xPYmplY3RzLnNldChcIk1hdGhcIiwgcmVxdWlyZShcIi4vbWF0aC5qc1wiKSk7XG5HTE9iamVjdHMuc2V0KFwiVmVjMlwiLCByZXF1aXJlKFwiLi92ZWMyLmpzXCIpKTtcbkdMT2JqZWN0cy5zZXQoXCJWZWMzXCIsIHJlcXVpcmUoXCIuL3ZlYzMuanNcIikpO1xuR0xPYmplY3RzLnNldChcIlZlYzRcIiwgcmVxdWlyZShcIi4vdmVjNC5qc1wiKSk7XG5HTE9iamVjdHMuc2V0KFwiU3lzdGVtXCIsIHJlcXVpcmUoXCIuL3N5c3RlbS5qc1wiKSk7XG5cbnZhciBUeXBlU3lzdGVtID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGUtc3lzdGVtL3R5cGUtc3lzdGVtLmpzXCIpO1xuXG4gICAgdmFyIFNjb3BlID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL1wiKS5TY29wZSxcbiAgICAgICAgQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2NvbnRleHQuanNcIiksXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcbiAgICAgICAgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpO1xuXG5cbiAgICB2YXIgb2JqZWN0cyA9IHtcbiAgICAgICAgU2hhZGUgOiByZXF1aXJlKFwiLi9zaGFkZS5qc1wiKSxcbiAgICAgICAgU3BhY2UgOiByZXF1aXJlKFwiLi9zcGFjZS5qc1wiKSxcbiAgICAgICAgTWF0aCA6IHJlcXVpcmUoXCIuL21hdGguanNcIiksXG4gICAgICAgIFN5c3RlbSA6IHJlcXVpcmUoXCIuL3N5c3RlbS5qc1wiKSxcbiAgICAgICAgVmVjMiA6IHJlcXVpcmUoXCIuL3ZlYzIuanNcIiksXG4gICAgICAgIFZlYzMgOiByZXF1aXJlKFwiLi92ZWMzLmpzXCIpLFxuICAgICAgICBDb2xvcjogcmVxdWlyZShcIi4vdmVjMy5qc1wiKSxcbiAgICAgICAgVmVjNCA6IHJlcXVpcmUoXCIuL3ZlYzQuanNcIiksXG4gICAgICAgIE1hdDMgOiByZXF1aXJlKFwiLi9tYXQzLmpzXCIpLFxuICAgICAgICBNYXQ0IDogcmVxdWlyZShcIi4vbWF0NC5qc1wiKSxcbiAgICAgICAgVGV4dHVyZSA6IHJlcXVpcmUoXCIuL3RleHR1cmUuanNcIilcbiAgICB9O1xuXG4gICAgdmFyIFJlZ2lzdHJ5ID0ge1xuICAgICAgICBuYW1lOiBcIkdMU0xUcmFuc2Zvcm1SZWdpc3RyeVwiLFxuICAgICAgICBnZXRCeU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3RzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbnN0YW5jZUZvcktpbmQ6IGZ1bmN0aW9uKGtpbmQpIHtcbiAgICAgICAgICAgIGZvcih2YXIgb2JqIGluIG9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0c1tvYmpdLmtpbmQgPT0ga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdHNbb2JqXS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByb290XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5XG4gICAgICogQHBhcmFtIG9wdFxuICAgICAqIEBleHRlbmRzIHtDb250ZXh0fVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBHTFRyYW5zZm9ybUNvbnRleHQgPSBmdW5jdGlvbihyb290LCBlbnRyeSwgdmVydGV4U2hhZGVyLCBvcHQpIHtcbiAgICAgICAgb3B0Lm1haW5GdW5jdGlvbiA9IGVudHJ5O1xuICAgICAgICBDb250ZXh0LmNhbGwodGhpcywgcm9vdCwgb3B0KTtcbiAgICAgICAgdGhpcy51c2VkUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIGVudmlyb25tZW50OiB7fSxcbiAgICAgICAgICAgIHN5c3RlbToge30sXG4gICAgICAgICAgICB1ZXhwOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG9wdC5vdXRwdXRzIHx8IFtcImNvbG9yXCJdO1xuICAgICAgICB0aGlzLnVuaWZvcm1FeHByZXNzaW9ucyA9IG9wdC51bmlmb3JtRXhwcmVzc2lvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIHRoaXMuc3lzdGVtUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICB0aGlzLmJsb2NrZWROYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLnRvcERlY2xhcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmludGVybmFsRnVuY3Rpb25zID0ge307XG4gICAgICAgIHRoaXMuaWROYW1lTWFwID0ge307XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IFtdOyAvLyBDb2xsZWN0aW9uIG9mIGhlYWRlciBsaW5lcyB0byBkZWZpbmVcblxuICAgICAgICB0aGlzLmdsb2JhbFBhcmFtZXRlcnMgPSByb290Lmdsb2JhbFBhcmFtZXRlcnMgJiYgcm9vdC5nbG9iYWxQYXJhbWV0ZXJzW2VudHJ5XSAmJiByb290Lmdsb2JhbFBhcmFtZXRlcnNbZW50cnldWzBdID8gcm9vdC5nbG9iYWxQYXJhbWV0ZXJzW2VudHJ5XVswXS5leHRyYS5pbmZvIDoge307XG5cblxuICAgIH07XG5cbiAgICBCYXNlLmNyZWF0ZUNsYXNzKEdMVHJhbnNmb3JtQ29udGV4dCwgQ29udGV4dCwge1xuICAgICAgICBjcmVhdGVTY29wZTogZnVuY3Rpb24obm9kZSwgcGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdMVHJhbnNmb3JtU2NvcGUobm9kZSwgcGFyZW50LCB7bmFtZTogbmFtZX0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRUeXBlSW5mbzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5nZXRUeXBlSW5mbyhub2RlLCB0aGlzLmdldFNjb3BlKCkpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlclN0cikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVycy5pbmRleE9mKGhlYWRlclN0cikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMucHVzaChoZWFkZXJTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7U2NvcGV9XG4gICAgICovXG4gICAgdmFyIEdMVHJhbnNmb3JtU2NvcGUgPSBmdW5jdGlvbihub2RlLCBwYXJlbnRTY29wZSwgb3B0KSB7XG4gICAgICAgIFNjb3BlLmNhbGwodGhpcywgbm9kZSwgcGFyZW50U2NvcGUsIG9wdCk7XG4gICAgfTtcblxuICAgIEJhc2UuY3JlYXRlQ2xhc3MoR0xUcmFuc2Zvcm1TY29wZSwgU2NvcGUsIHtcblxuICAgICAgICByZWdpc3Rlckdsb2JhbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiTWF0aFwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJNYXRoXCIpKTtcblx0XHQgICAgdGhpcy5kZWNsYXJlUHJlZGVmaW5lZChcIlZlYzJcIiwgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiVmVjMlwiKSk7XG5cdFx0ICAgIHRoaXMuZGVjbGFyZVByZWRlZmluZWQoXCJWZWMzXCIsIFR5cGVTeXN0ZW0uZ2V0UHJlZGVmaW5lZE9iamVjdChcIlZlYzNcIikpO1xuXHRcdCAgICB0aGlzLmRlY2xhcmVQcmVkZWZpbmVkKFwiVmVjNFwiLCBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJWZWM0XCIpKTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QoXCJWZWMzXCIpKTtcbiAgICAgICAgICAgIC8vdGhpcy5kZWNsYXJlUHJlZGVmaW5lZChcIlZlYzNcIiwgVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KFwiVmVjM1wiKSk7XG5cbiAgICAgICAgICAgIC8qdGhpcy5yZWdpc3Rlck9iamVjdChcIk1hdGhcIiwgb2JqZWN0cy5NYXRoKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJDb2xvclwiLCAgb2JqZWN0cy5Db2xvcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiVmVjMlwiLCBvYmplY3RzLlZlYzIpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlZlYzNcIiwgb2JqZWN0cy5WZWMzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJWZWM0XCIsIG9iamVjdHMuVmVjNCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiVGV4dHVyZVwiLCBvYmplY3RzLlRleHR1cmUpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlNoYWRlXCIsIG9iamVjdHMuU2hhZGUpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIk1hdDNcIiwgb2JqZWN0cy5NYXQzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJNYXQ0XCIsIG9iamVjdHMuTWF0NCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiU3BhY2VcIiwgb2JqZWN0cy5TcGFjZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZShcImdsX0ZyYWdDb29yZFwiLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVR5cGVJbmZvKFwiZ2xfRnJhZ0Nvb3JkXCIsIG5ldyBUeXBlSW5mbyh7XG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVHlwZXMuT0JKRUNULFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBcIlZlYzNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTsqL1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEdMVHJhbnNmb3JtU2NvcGUgOiBHTFRyYW5zZm9ybVNjb3BlLFxuICAgICAgICBHTFRyYW5zZm9ybUNvbnRleHQgOiBHTFRyYW5zZm9ybUNvbnRleHQsXG4gICAgICAgIEdMT2JqZWN0czogR0xPYmplY3RzXG4gICAgfTtcblxuIiwiKGZ1bmN0aW9uKG5zKXtcblxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xuICAgIHZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuLi8uLi90b29scy5qc1wiKTtcblxuICAgIHZhciBUWVBFUyA9IFNoYWRlLlRZUEVTLFxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcblxuICAgIHZhciBNYXQzSW5zdGFuY2UgPSB7XG4gICAgICAgIGNvbDoge1xuICAgICAgICAgICAgY2FsbEV4cDogVG9vbHMuTWF0LmdlbmVyYXRlQ29sQ2FsbC5iaW5kKG51bGwsIFwiTWF0M1wiKVxuICAgICAgICB9XG4gICAgfVxuICAgIFRvb2xzLk1hdC5hdHRhY2hPcGVyYXRvcnMoTWF0M0luc3RhbmNlLCBcIk1hdDNcIiwge1xuICAgICAgICBhZGQ6ICcrJyxcbiAgICAgICAgc3ViOiAnLScsXG4gICAgICAgIG11bDogJyonLFxuICAgICAgICBkaXY6ICcvJ1xuICAgIH0pO1xuICAgIFRvb2xzLlZlYy5hdHRhY2hPcGVyYXRvcnMoTWF0M0luc3RhbmNlLCAzLCB7XG4gICAgICAgIG11bFZlYzogJyonXG4gICAgfSk7XG5cblxuICAgIFRvb2xzLmV4dGVuZChucywge1xuICAgICAgICBpZDogXCJNYXQzXCIsXG4gICAgICAgIGtpbmQ6IEtJTkRTLk1BVFJJWDMsXG4gICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IFRvb2xzLlZlYy5nZW5lcmF0ZUNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgc3RhdGljOiB7fVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZTogTWF0M0luc3RhbmNlXG4gICAgfSk7XG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uKG5zKXtcblxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xuICAgIHZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuLi8uLi90b29scy5qc1wiKTtcblxuICAgIHZhciBUWVBFUyA9IFNoYWRlLlRZUEVTLFxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcblxuICAgIHZhciBNYXQ0SW5zdGFuY2UgPSB7XG4gICAgICAgIGNvbDoge1xuICAgICAgICAgICAgY2FsbEV4cDogVG9vbHMuTWF0LmdlbmVyYXRlQ29sQ2FsbC5iaW5kKG51bGwsIFwiTWF0NFwiKVxuICAgICAgICB9XG4gICAgfVxuICAgIFRvb2xzLk1hdC5hdHRhY2hPcGVyYXRvcnMoTWF0NEluc3RhbmNlLCBcIk1hdDRcIiwge1xuICAgICAgICBhZGQ6ICcrJyxcbiAgICAgICAgc3ViOiAnLScsXG4gICAgICAgIG11bDogJyonLFxuICAgICAgICBkaXY6ICcvJ1xuICAgIH0pO1xuICAgIFRvb2xzLlZlYy5hdHRhY2hPcGVyYXRvcnMoTWF0NEluc3RhbmNlLCA0LCB7XG4gICAgICAgIG11bFZlYzogJyonXG4gICAgfSk7XG5cblxuICAgIFRvb2xzLmV4dGVuZChucywge1xuICAgICAgICBpZDogXCJNYXQ0XCIsXG4gICAgICAgIGtpbmQ6IEtJTkRTLk1BVFJJWDQsXG4gICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IFRvb2xzLlZlYy5nZW5lcmF0ZUNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgc3RhdGljOiB7fVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZTogTWF0NEluc3RhbmNlXG4gICAgfSk7XG5cbn0oZXhwb3J0cykpO1xuIiwidmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xudmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGUtc3lzdGVtL3R5cGVpbmZvLmpzXCIpO1xuXG52YXIgTWF0aENvbnN0YW50cyA9IFtcIkVcIiwgXCJQSVwiLCBcIkxOMlwiLCBcIkxPRzJFXCIsIFwiTE9HMTBFXCIsIFwiUElcIiwgXCJTUVJUMV8yXCIsIFwiU1FSVDJcIl07XG5cbi8vIFRPRE86IEltcGxlbWVudCBzYXR1cmF0ZVxuLy8gVE9ETzogUmVuYW1lIGF0YW5cbi8vIFRPRE86IEhhbmRsZSBjZWlsP1xuXG52YXIgTWF0aENhbGwgPSBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIC8vIFJlbW92ZSBNYXRoLlxuICAgIG5vZGUuY2FsbGVlID0gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZS5jYWxsZWUpO1xuXG4gICAgLy8gQ2FzdCBhbGwgYXJndW1lbnRzIG9mIHRoZSBtYXRoIGZ1bmN0aW9uIHRvIGZsb2F0LCBhcyB0aGV5IGFyZVxuICAgIC8vIG5vdCBkZWZpbmVkIGZvciBvdGhlciB0eXBlcyAoaW50LCBib29sKVxuICAgIC8vIERvbid0IHJlcGxhY2UgdGhlIGFyZ3VtZW50cyBhcnJheSwgaXQncyBhbHJlYWR5IGNhY2hlZCBieSB0aGUgdHJhdmVyc2FsXG4gICAgbm9kZS5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnLCBpKSB7XG4gICAgICAgIHZhciB0ID0gbmV3IFR5cGVJbmZvKGFyZy5leHRyYSk7XG4gICAgICAgIGlmICh0LmlzSW50KCkpIHtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzW2ldID0gVG9vbHMuY2FzdFRvRmxvYXQobm9kZS5hcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTWF0aFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICBpZihNYXRoQ29uc3RhbnRzLmluZGV4T2YobmFtZSkgIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBNYXRoW25hbWVdLCBleHRyYToge3R5cGU6IFwibnVtYmVyXCJ9fTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjYWxsOiBNYXRoQ2FsbCxcbiAgICBwcm9wZXJ0eTogTWF0aFByb3BlcnR5XG59O1xuXG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcbiAgICB2YXIgU3ludGF4ID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLlN5bnRheDtcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XG5cbiAgICB2YXIgU2hhZGVJbnN0YW5jZSA9IHtcbiAgICAgICAgbWl4OiB7IGNhbGxFeHA6IGZ1bmN0aW9uKG5vZGUsIGFyZ3MpIHtcbiAgICAgICAgICAgIG5vZGUuY2FsbGVlID0gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZS5jYWxsZWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH19XG4gICAgfVxuXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XG4gICAgICAgIGlkOiBcIlNoYWRlXCIsXG4gICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5DT0xPUl9DTE9TVVJFLFxuICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBUb29scy5WZWMuZ2VuZXJhdGVDb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIHN0YXRpYzogU2hhZGVJbnN0YW5jZVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZTogU2hhZGVJbnN0YW5jZVxuICAgIH0pO1xuXG59KGV4cG9ydHMpKTtcbiIsIihmdW5jdGlvbihucyl7XG5cbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcbiAgICB2YXIgU3ludGF4ID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLlN5bnRheDtcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XG5cblxuICAgIGZ1bmN0aW9uIGdldFNwYWNlVHJhbnNmb3JtKHNwYWNlQXJnLCBub3JtYWwpe1xuICAgICAgICBpZiggc3BhY2VBcmcudHlwZSAhPSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiB8fFxuICAgICAgICAgICAgc3BhY2VBcmcub2JqZWN0LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgIHNwYWNlQXJnLm9iamVjdC5uYW1lICE9IFwiU3BhY2VcIiB8fFxuICAgICAgICAgICAgc3BhY2VBcmcucHJvcGVydHkudHlwZSAhPSBTeW50YXguSWRlbnRpZmllcilcbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Ioc3BhY2VBcmcsIFwiV2Ugb25seSBzdXBwb3J0IFNwYWNlIGVudW1zIGZvciB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdHJhbnNmb3JtRGlyZWN0aW9uIGFuZCB0cmFuc2Zvcm1Qb2ludFwiKTtcblxuICAgICAgICBzd2l0Y2goc3BhY2VBcmcucHJvcGVydHkubmFtZSl7XG4gICAgICAgICAgICBjYXNlIFwiVklFV1wiOiByZXR1cm4gbm9ybWFsID8gXCJtb2RlbFZpZXdNYXRyaXhOXCIgOiBcIm1vZGVsVmlld01hdHJpeFwiO1xuICAgICAgICAgICAgY2FzZSBcIldPUkxEXCI6IHJldHVybiBub3JtYWwgPyBcIm1vZGVsTWF0cml4TlwiIDogXCJtb2RlbE1hdHJpeFwiO1xuICAgICAgICAgICAgZGVmYXVsdDogU2hhZGUudGhyb3dFcnJvcihzcGFjZUFyZywgXCJVbmtub3duIFNwYWNlIFR5cGU6ICdcIiArIHNwYWNlQXJnLnByb3BlcnR5Lm5hbWUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYW5ub3RhdGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHNcIikuYW5ub3RhdGU7XG4gICAgdmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xuICAgIHZhciBTcGFjZUVudHJ5ICA9IHtcbiAgICAgICAgdHJhbnNmb3JtRGlyZWN0aW9uOiB7IGNhbGxFeHA6IGZ1bmN0aW9uKGNhbGxFeHByZXNzaW9uLCBwYXJlbnQsIGNvbnRleHQsIHN0YXRlKXtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRTcGFjZVRyYW5zZm9ybShjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMF0sIHRydWUpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLCBvcGVyYXRvcjogXCIqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogdHJhbnNmb3JtfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogY2FsbEV4cHJlc3Npb24uYXJndW1lbnRzWzFdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhbm5vdGF0ZShyZXN1bHQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBLSU5EUy5GTE9BVDMpO1xuICAgICAgICAgICAgYW5ub3RhdGUocmVzdWx0LmxlZnQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBLSU5EUy5NQVRSSVgzKTtcbiAgICAgICAgICAgIGFubm90YXRlKHJlc3VsdC5yaWdodCkuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIEtJTkRTLkZMT0FUMyk7XG5cbiAgICAgICAgICAgIHZhciBzeXN0ZW1OYW1lID0gVG9vbHMuZ2V0TmFtZUZvclN5c3RlbSh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgc3RhdGUudXNlZFBhcmFtZXRlcnMuc3lzdGVtW3N5c3RlbU5hbWVdID0gc3RhdGUuc3lzdGVtUGFyYW1ldGVyc1t0cmFuc2Zvcm1dO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IH0sXG4gICAgICAgIHRyYW5zZm9ybVBvaW50OiB7IGNhbGxFeHA6IGZ1bmN0aW9uKGNhbGxFeHByZXNzaW9uLCBwYXJlbnQsIGNvbnRleHQsIHN0YXRlKXtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRTcGFjZVRyYW5zZm9ybShjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMF0sIGZhbHNlKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7ICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHsgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLCBvcGVyYXRvcjogXCIqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IHRyYW5zZm9ybX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7dHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJ2ZWM0XCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBTeW50YXguTGl0ZXJhbCwgdmFsdWU6IDEsIHJhdzogMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJ4eXpcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhbm5vdGF0ZShyZXN1bHQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBLSU5EUy5GTE9BVDMpO1xuICAgICAgICAgICAgYW5ub3RhdGUocmVzdWx0Lm9iamVjdCkuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIEtJTkRTLkZMT0FUNCk7XG4gICAgICAgICAgICBhbm5vdGF0ZShyZXN1bHQub2JqZWN0LmxlZnQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBLSU5EUy5NQVRSSVg0KTtcbiAgICAgICAgICAgIGFubm90YXRlKHJlc3VsdC5vYmplY3QucmlnaHQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBLSU5EUy5GTE9BVDQpO1xuICAgICAgICAgICAgYW5ub3RhdGUocmVzdWx0Lm9iamVjdC5yaWdodC5hcmd1bWVudHNbMV0pLnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcblxuXG4gICAgICAgICAgICB2YXIgc3lzdGVtTmFtZSA9IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHN0YXRlLnVzZWRQYXJhbWV0ZXJzLnN5c3RlbVtzeXN0ZW1OYW1lXSA9IHN0YXRlLnN5c3RlbVBhcmFtZXRlcnNbdHJhbnNmb3JtXTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSB9LFxuICAgICAgICBWSUVXOiB7XG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKG1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH19LFxuICAgICAgICBXT1JMRDoge1xuICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uIChtZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICBtZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgfX1cbiAgICB9O1xuXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XG4gICAgICAgIGlkOiBcIlNwYWNlXCIsXG4gICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IG51bGwsXG4gICAgICAgICAgICBzdGF0aWM6IFNwYWNlRW50cnlcbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2U6IFNwYWNlRW50cnlcbiAgICB9KTtcblxufShleHBvcnRzKSk7XG4iLCIvLyBEZXBlbmRlbmNpZXNcbnZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xudmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xudmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XG5cbi8vIFNob3J0Y3V0c1xudmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXG4gICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XG5cblxudmFyIFN5c3RlbURlZmluZXMgPSB7fTtcblN5c3RlbURlZmluZXMuQ0FOVkFTX0RJTUVOU0lPTlMgPSBcImNvb3Jkc1wiO1xuU3lzdGVtRGVmaW5lcy5ERVJJVkFURV9FWFRFTlNJT04gPSBcIiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXCI7XG5cbnZhciBDb29yZHNUeXBlID0ge1xuICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcbiAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQzLFxuICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXG59O1xuXG5cbnZhciBTeXN0ZW1Qcm9wZXJ0aWVzID0ge1xuICAgIGNvb3JkczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkubmFtZSA9IFwiZ2xfRnJhZ0Nvb3JkXCI7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0eTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZWRDb29yZHM6ICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJWZWMzXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZ2xfRnJhZ0Nvb3JkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInh5elwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogU3lzdGVtRGVmaW5lcy5DQU5WQVNfRElNRU5TSU9OU1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIi9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuT0JKRUNULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiVmVjM1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogXCJWZWMzXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfSxcbiAgICBoZWlnaHQ6ICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBUb29scy5nZXROYW1lRm9yU3lzdGVtKFN5c3RlbURlZmluZXMuQ0FOVkFTX0RJTUVOU0lPTlMpO1xuICAgICAgICAgICAgc3RhdGUudXNlZFBhcmFtZXRlcnMuc3lzdGVtW3BhcmFtZXRlck5hbWVdID0gc3RhdGUuc3lzdGVtUGFyYW1ldGVyc1tTeXN0ZW1EZWZpbmVzLkNBTlZBU19ESU1FTlNJT05TXTtcblxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eS5uYW1lID0gcGFyYW1ldGVyTmFtZSArIFwiLnlcIjtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByb3BlcnR5O1xuICAgIH0sXG4gICAgd2lkdGg6ICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBUb29scy5nZXROYW1lRm9yU3lzdGVtKFN5c3RlbURlZmluZXMuQ0FOVkFTX0RJTUVOU0lPTlMpO1xuICAgICAgICAgICAgc3RhdGUudXNlZFBhcmFtZXRlcnMuc3lzdGVtW3BhcmFtZXRlck5hbWVdID0gc3RhdGUuc3lzdGVtUGFyYW1ldGVyc1tTeXN0ZW1EZWZpbmVzLkNBTlZBU19ESU1FTlNJT05TXTtcblxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eS5uYW1lID0gcGFyYW1ldGVyTmFtZSArIFwiLnhcIjtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByb3BlcnR5O1xuICAgIH0sXG4gICAgZndpZHRoOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5hZGRIZWFkZXIoU3lzdGVtRGVmaW5lcy5ERVJJVkFURV9FWFRFTlNJT04pO1xuICAgICAgICAgICAgcmV0dXJuIFRvb2xzLnJlbW92ZU1lbWJlckZyb21FeHByZXNzaW9uKG5vZGUpO1xuICAgIH0sXG4gICAgZHg6IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmFkZEhlYWRlcihTeXN0ZW1EZWZpbmVzLkRFUklWQVRFX0VYVEVOU0lPTik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IFwiZEZkeFwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGR5OiAgZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWRkSGVhZGVyKFN5c3RlbURlZmluZXMuREVSSVZBVEVfRVhURU5TSU9OKTtcbiAgICAgICAgICAgIHZhciBzID0gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICByZXN1bHQubmFtZSA9IFwiZEZkeVwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNhbGw6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7fSxcbiAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYoU3lzdGVtUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbVByb3BlcnRpZXNbbmFtZV0obm9kZSwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgIH1cbn07XG4iLCIoZnVuY3Rpb24obnMpe1xuXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XG4gICAgdmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xuXG4gICAgdmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xuXG4gICAgdmFyIFRleHR1cmVJbnN0YW5jZSA9IHtcbiAgICAgICAgc2FtcGxlMkQ6IHtcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAndGV4dHVyZTJEJywgMilcbiAgICAgICAgfSxcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJOYW1lID0gbm9kZS5vYmplY3QubmFtZTtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnR5Lm5hbWUgPSBwYXJhbWV0ZXJOYW1lICsgXCJfd2lkdGhcIjtcbiAgICAgICAgICAgICAgICBzdGF0ZS51c2VkUGFyYW1ldGVycy5zaGFkZXJbcGFyYW1ldGVyTmFtZSArIFwiX3dpZHRoXCJdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTaGFkZS5UWVBFUy5JTlQsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5JTlQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IG5vZGUub2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eS5uYW1lID0gcGFyYW1ldGVyTmFtZSArIFwiX2hlaWdodFwiO1xuICAgICAgICAgICAgICAgIHN0YXRlLnVzZWRQYXJhbWV0ZXJzLnNoYWRlcltwYXJhbWV0ZXJOYW1lICsgXCJfaGVpZ2h0XCJdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTaGFkZS5UWVBFUy5JTlQsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5JTlQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFRvb2xzLmV4dGVuZChucywge1xuICAgICAgICBpZDogXCJUZXh0dXJlXCIsXG4gICAgICAgIGtpbmQ6IEtJTkRTLlRFWFRVUkUsXG4gICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IG51bGwsXG4gICAgICAgICAgICBzdGF0aWM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlOiBUZXh0dXJlSW5zdGFuY2VcbiAgICB9KTtcblxufShleHBvcnRzKSk7XG4iLCJ2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xudmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xuXG52YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcbiAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcblxudmFyIFZlYzJJbnN0YW5jZSA9IHtcbiAgICBub3JtYWxpemU6IHtcbiAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICdub3JtYWxpemUnLCAwKVxuICAgIH0sXG4gICAgZmxpcDoge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJy0nLCAwKVxuICAgIH0sXG4gICAgZG90OiB7XG4gICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAnZG90JywgMilcbiAgICB9LFxuICAgIHJlZmxlY3Q6IHtcbiAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICdyZWZsZWN0JywgMilcbiAgICB9LFxuICAgIGxlbmd0aDoge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuZ2VuZXJhdGVMZW5ndGhDYWxsXG4gICAgfVxufTtcblxuVG9vbHMuVmVjLmF0dGFjaFN3aXp6bGVzKFZlYzJJbnN0YW5jZSwgMiwgVG9vbHMuVmVjLmNyZWF0ZVN3aXp6bGUsIFRvb2xzLlZlYy5jcmVhdGVTd2l6emxlT3BlcmF0b3IpO1xuXG5Ub29scy5WZWMuYXR0YWNoT3BlcmF0b3JzKFZlYzJJbnN0YW5jZSwgMiwge1xuICAgIGFkZDogJysnLFxuICAgIHN1YjogJy0nLFxuICAgIG11bDogJyonLFxuICAgIGRpdjogJy8nLFxuICAgIG1vZDogJyUnXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjYWxsOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgICBpZiAoVmVjMkluc3RhbmNlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjMkluc3RhbmNlW25hbWVdLmNhbGxFeHAobm9kZSlcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB9XG59O1xuIiwidmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xudmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGUtc3lzdGVtL3R5cGVpbmZvLmpzXCIpO1xuXG5cbnZhciBWZWMzSW5zdGFuY2UgPSB7XG4gICAgbm9ybWFsaXplOiB7XG4gICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAnbm9ybWFsaXplJywgMClcbiAgICB9LFxuICAgIGZsaXA6IHtcbiAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICctJywgMClcbiAgICB9LFxuICAgIGRvdDoge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ2RvdCcsIDMpXG4gICAgfSxcbiAgICByZWZsZWN0OiB7XG4gICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAncmVmbGVjdCcsIDMpXG4gICAgfSxcbiAgICByZWZyYWN0OiB7XG4gICAgICAgIGNhbGxFeHA6IGZ1bmN0aW9uIChub2RlLCBhcmdzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBldGEgPSBub2RlLmFyZ3VtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsKFwicmVmcmFjdFwiLCAzLCBub2RlKTtcbiAgICAgICAgICAgIG5ldyBUeXBlSW5mbyhldGEuZXh0cmEpLnNldFR5cGUoXCJudW1iZXJcIik7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzLnB1c2goZXRhKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxlbmd0aDoge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuZ2VuZXJhdGVMZW5ndGhDYWxsXG4gICAgfSxcbiAgICBjcm9zczoge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgXCJjcm9zc1wiLCAzKVxuICAgIH1cbn07XG5cblRvb2xzLlZlYy5hdHRhY2hTd2l6emxlcyhWZWMzSW5zdGFuY2UsIDMsIFRvb2xzLlZlYy5jcmVhdGVTd2l6emxlLCBUb29scy5WZWMuY3JlYXRlU3dpenpsZU9wZXJhdG9yKTtcblRvb2xzLlZlYy5hdHRhY2hPcGVyYXRvcnMoVmVjM0luc3RhbmNlLCAzLCB7XG4gICAgYWRkOiAnKycsXG4gICAgc3ViOiAnLScsXG4gICAgbXVsOiAnKicsXG4gICAgZGl2OiAnLycsXG4gICAgbW9kOiAnJSdcbn0pO1xuXG5cbmZ1bmN0aW9uIFZlYzNDYWxsKG5vZGUsIG5hbWUpIHtcbiAgICBpZiAoVmVjM0luc3RhbmNlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBWZWMzSW5zdGFuY2VbbmFtZV0uY2FsbEV4cChub2RlKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2FsbDogVmVjM0NhbGwsXG4gICAgcHJvcGVydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB9XG59O1xuIiwidmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xuXG52YXIgVmVjNEluc3RhbmNlID0ge1xuICAgIG5vcm1hbGl6ZToge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ25vcm1hbGl6ZScsIDApXG4gICAgfSxcbiAgICBmbGlwOiB7XG4gICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAnLScsIDApXG4gICAgfSxcbiAgICBkb3Q6IHtcbiAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICdkb3QnLCA0KVxuICAgIH0sXG4gICAgcmVmbGVjdDoge1xuICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ3JlZmxlY3QnLCA0KVxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5nZW5lcmF0ZUxlbmd0aENhbGxcbiAgICB9XG59XG5Ub29scy5WZWMuYXR0YWNoU3dpenpsZXMoVmVjNEluc3RhbmNlLCA0LCBUb29scy5WZWMuY3JlYXRlU3dpenpsZSwgVG9vbHMuVmVjLmNyZWF0ZVN3aXp6bGVPcGVyYXRvcik7XG5Ub29scy5WZWMuYXR0YWNoT3BlcmF0b3JzKFZlYzRJbnN0YW5jZSwgNCwge1xuICAgIGFkZDogJysnLFxuICAgIHN1YjogJy0nLFxuICAgIG11bDogJyonLFxuICAgIGRpdjogJy8nLFxuICAgIG1vZDogJyUnXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNhbGw6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICAgIGlmIChWZWM0SW5zdGFuY2UuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWM0SW5zdGFuY2VbbmFtZV0uY2FsbEV4cChub2RlKVxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIH1cbn07XG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxuICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcbiAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXG4gICAgVHlwZXMgPSBTaGFkZS5UWVBFUyxcbiAgICBhbmFseXNlcyA9IHJlcXVpcmUoJ2FuYWx5c2VzJyksXG4gICAgVG9vbHMgPSByZXF1aXJlKCcuLi90b29scy5qcycpLFxuICAgIFN5c3RlbSA9IHJlcXVpcmUoJy4vcmVnaXN0cnkvc3lzdGVtLmpzJyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JyksXG4gICAgVHlwZUluZm8gPSByZXF1aXJlKFwiLi4vLi4vdHlwZS1zeXN0ZW0vdHlwZWluZm8uanNcIik7XG5cblxudmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi9yZWdpc3RyeS9cIikuR0xUcmFuc2Zvcm1Db250ZXh0O1xudmFyIEdMT2JqZWN0cyA9IHJlcXVpcmUoXCIuL3JlZ2lzdHJ5L1wiKS5HTE9iamVjdHM7XG5cblxudmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG52YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XG52YXIgQU5OTyA9IGNvbW1vbi5BTk5PO1xudmFyIFNldCA9IGFuYWx5c2VzLlNldDtcblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIEpTIEFTVCB0byBhbiBBU1QgcmVwcmVzZW50YXRpb24gY29udmVuaWVudFxuICogZm9yIGNvZGUgZ2VuZXJhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBHTEFTVFRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKHJvb3QsIG1haW5JZCwgdmVydGV4U2hhZGVyLCBvcHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgQ29udGV4dChyb290LCBtYWluSWQsIHZlcnRleFNoYWRlciwgb3B0KTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1EZXBlbmRlbmN5TWFwKHVuaWZvcm1FeHByZXNzaW9ucykge1xuICAgIHZhciBuYW1lLCB1ZXhwU2V0LCBkZXBlbmRlbmNpZXMsIGRlcGVuZGVuY3ksIGRsLCBkZXBlbmRlbmN5TWFwID0gbmV3IE1hcCgpO1xuICAgIGZvciAobmFtZSBpbiB1bmlmb3JtRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzID0gdW5pZm9ybUV4cHJlc3Npb25zW25hbWVdLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgZGwgPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoZGwtLSkge1xuICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tkbF07XG4gICAgICAgICAgICBpZiAoZGVwZW5kZW5jeU1hcC5oYXMoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICB1ZXhwU2V0ID0gZGVwZW5kZW5jeU1hcC5nZXQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVleHBTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeU1hcC5zZXQoZGVwZW5kZW5jeSwgdWV4cFNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ZXhwU2V0LmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jeU1hcDtcbn1cblxuQmFzZS5leHRlbmQoR0xBU1RUcmFuc2Zvcm1lci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7R0xUcmFuc2Zvcm1TY29wZX0gc2NvcGVcbiAgICAgKi9cbiAgICByZWdpc3RlclRoaXNPYmplY3Q6IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICAvKnZhciB0aGlzT2JqZWN0ID0gc2NvcGUuZ2V0QmluZGluZ0J5TmFtZShcInRoaXNcIik7XG4gICAgICAgICBpZiAodGhpc09iamVjdCAmJiB0aGlzT2JqZWN0LmlzT2JqZWN0KCkpIHtcbiAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpc09iamVjdC5nZXROb2RlSW5mbygpO1xuICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICB2YXIgcHJvcCA9IEFOTk8oe30sIHByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgICAgaWYgKCFwcm9wLmlzRGVyaXZlZCgpKVxuICAgICAgICAgdGhpcy5jb250ZXh0LmJsb2NrZWROYW1lcy5wdXNoKFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0obmFtZSkpO1xuICAgICAgICAgfVxuICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gU3lzdGVtLmRlcml2ZWRQYXJhbWV0ZXJzKSB7XG4gICAgICAgICBpZihwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgQmFzZS5kZWVwRXh0ZW5kKHByb3BlcnRpZXNbcHJvcGVydHldLCBTeXN0ZW0uZGVyaXZlZFBhcmFtZXRlcnNbcHJvcGVydHldKTtcbiAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIEJhc2UuZXh0ZW5kKHRoaXMuY29udGV4dC5zeXN0ZW1QYXJhbWV0ZXJzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgIH0gKi9cbiAgICB9LFxuXG5cbiAgICBjcmVhdGVVbmlmb3JtU2V0dGVyRnVuY3Rpb246IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIC8vIFJldmVyc2UgdW5pZm9ybSBleHByZXNzaW9uIGRlcGVuZGVuY2llc1xuICAgICAgICB2YXIgY19kZXBlbmRlbmN5TWFwID0gY3JlYXRlVW5pZm9ybURlcGVuZGVuY3lNYXAocGFyYW1ldGVycy51ZXhwKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVudk5hbWVzLCBzeXNOYW1lcywgaW5wdXRDb2xsZWN0aW9uLCBjYikge1xuICAgICAgICAgICAgdmFyIGksIGJhc2UsIG92ZXJyaWRlLCBzcmNOYW1lLCBkZXN0TmFtZSwgdWwsIHVuaWZvcm1MaXN0O1xuICAgICAgICAgICAgaWYgKGVudk5hbWVzICYmIGlucHV0Q29sbGVjdGlvbi5lbnZCYXNlKSB7XG4gICAgICAgICAgICAgICAgaSA9IGVudk5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBiYXNlID0gaW5wdXRDb2xsZWN0aW9uLmVudkJhc2U7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGUgPSBpbnB1dENvbGxlY3Rpb24uZW52T3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBzcmNOYW1lID0gZW52TmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjX2RlcGVuZGVuY3lNYXAuaGFzKHNyY05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtTGlzdCA9IGNfZGVwZW5kZW5jeU1hcC5nZXQoc3JjTmFtZSkudmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bCA9IHVuaWZvcm1MaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh1bC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cE5hbWUgPSB1bmlmb3JtTGlzdFt1bF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJhbWV0ZXJzLnVleHBbZXhwTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXhwcmVzc2lvbi5zZXR0ZXIuY2FsbChTaGFkZSwgaW5wdXRDb2xsZWN0aW9uLmVudkJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKGV4cE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXN0TmFtZSA9IFRvb2xzLmdldE5hbWVGb3JHbG9iYWwoZW52TmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMuc2hhZGVyW2Rlc3ROYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjYihkZXN0TmFtZSwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbc3JjTmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW3NyY05hbWVdIDogYmFzZVtzcmNOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLnNoYWRlcltkZXN0TmFtZV0ua2luZCA9PT0gU2hhZGUuT0JKRUNUX0tJTkRTLlRFWFRVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGRlc3ROYW1lICsgXCJfd2lkdGhcIiwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbc3JjTmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW3NyY05hbWVdLndpZHRoIDogYmFzZVtzcmNOYW1lXSAmJiBiYXNlW3NyY05hbWVdWzBdLndpZHRoIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZGVzdE5hbWUgKyBcIl9oZWlnaHRcIiwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbc3JjTmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW3NyY05hbWVdLmhlaWdodCA6IGJhc2Vbc3JjTmFtZV0gJiYgYmFzZVtzcmNOYW1lXVswXS5oZWlnaHQgfHwgMClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzeXNOYW1lcyAmJiBpbnB1dENvbGxlY3Rpb24uc3lzQmFzZSkge1xuICAgICAgICAgICAgICAgIGkgPSBzeXNOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGlucHV0Q29sbGVjdGlvbi5zeXNCYXNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjTmFtZSA9IHN5c05hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBkZXN0TmFtZSA9IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0oc3lzTmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjYihkZXN0TmFtZSwgYmFzZVtzcmNOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgcHJvZ3JhbSA9IGNvbnRleHQucm9vdCxcbiAgICAgICAgICAgIHNjb3BlID0gY29udGV4dC5jcmVhdGVTY29wZShwcm9ncmFtLCBudWxsLCBcImdsb2JhbFwiKSxcbiAgICAgICAgICAgIG5hbWUsIGRlY2xhcmF0aW9uO1xuXG4gICAgICAgIHNjb3BlLnJlZ2lzdGVyR2xvYmFscygpO1xuICAgICAgICBjb250ZXh0LnB1c2hTY29wZShzY29wZSk7XG5cbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGFsc28gYmxvY2sgc3lzdGVtUGFyYW1ldGVycyBoZXJlLiBXZSBjYW4gYmxvY2sgYWxsIHN5c3RlbSBuYW1lcywgZXZlbiBpZiBub3QgdXNlZC5cbiAgICAgICAgZm9yIChuYW1lIGluIGNvbnRleHQuZ2xvYmFsUGFyYW1ldGVycykge1xuICAgICAgICAgICAgY29udGV4dC5ibG9ja2VkTmFtZXMucHVzaChUb29scy5nZXROYW1lRm9yR2xvYmFsKG5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVwbGFjZShwcm9ncmFtKTtcblxuICAgICAgICB2YXIgdXNlZFBhcmFtZXRlcnMgPSBjb250ZXh0LnVzZWRQYXJhbWV0ZXJzO1xuICAgICAgICBmb3IgKHZhciBjb250YWluZXIgaW4gdXNlZFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiB1c2VkUGFyYW1ldGVyc1tjb250YWluZXJdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0gdXNlZFBhcmFtZXRlcnNbY29udGFpbmVyXVtuYW1lXTtcbiAgICAgICAgICAgICAgICBhc3NlcnQodHlwZUluZm8gaW5zdGFuY2VvZiBUeXBlSW5mbyk7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBjcmVhdGVUb3BEZWNsYXJhdGlvbihuYW1lLCB0eXBlSW5mbyk7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gJiYgcHJvZ3JhbS5ib2R5LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaWZvcm1TZXR0ZXIgPSB0aGlzLmNyZWF0ZVVuaWZvcm1TZXR0ZXJGdW5jdGlvbih1c2VkUGFyYW1ldGVycyk7XG5cbiAgICAgICAgdmFyIHVzZXJEYXRhID0gQU5OTyhwcm9ncmFtKS5nZXRVc2VyRGF0YSgpO1xuICAgICAgICB1c2VyRGF0YS5pbnRlcm5hbEZ1bmN0aW9ucyA9IGNvbnRleHQuaW50ZXJuYWxGdW5jdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIHtwcm9ncmFtOiBwcm9ncmFtLCB1bmlmb3JtU2V0dGVyOiB1bmlmb3JtU2V0dGVyLCBoZWFkZXJzOiBjb250ZXh0LmhlYWRlcnN9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdCF9IGFzdFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgd2Fsay5Db250cm9sbGVyKCksXG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgYXN0ID0gY29udHJvbGxlci5yZXBsYWNlKGFzdCwge1xuXG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRlcklkZW50aWZpZXIobm9kZSwgcGFyZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWZTdGF0ZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50ZXJJZlN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRlckZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlYXZlTWVtYmVyRXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5OZXdFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlYXZlTmV3RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTG9naWNhbEV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVMb2dpY2FsRXhwcmVzc2lvbihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ2FsbEV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVDYWxsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5VbmFyeUV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVVbmFyeUV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVSZXR1cm5TdGF0ZW1lbnQobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkJpbmFyeUV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQmluYXJ5RXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVJbmZvXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudmFyIGNyZWF0ZVRvcERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVJbmZvKSB7XG4gICAgdmFyIHByb3BlcnR5TGl0ZXJhbCA9IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbmFtZX07XG4gICAgdmFyIHByb3BlcnR5QW5ub3RhdGlvbiA9IEFOTk8ocHJvcGVydHlMaXRlcmFsKTtcbiAgICBwcm9wZXJ0eUFubm90YXRpb24uY29weUZyb20odHlwZUluZm8pO1xuXG4gICAgaWYgKHByb3BlcnR5QW5ub3RhdGlvbi5pc051bGxPclVuZGVmaW5lZCgpIHx8IHByb3BlcnR5QW5ub3RhdGlvbi5pc0Rlcml2ZWQoKSB8fCBwcm9wZXJ0eUFubm90YXRpb24uaXNGdW5jdGlvbigpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAocHJvcGVydHlBbm5vdGF0aW9uLmlzT2ZUeXBlKFR5cGVzLkFSUkFZKSAmJiB0eXBlSW5mby5zdGF0aWNTaXplID09IDApXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBkZWNsID0ge1xuICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcixcbiAgICAgICAgICAgICAgICBpZDogcHJvcGVydHlMaXRlcmFsLFxuICAgICAgICAgICAgICAgIGluaXQ6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAga2luZDogXCJ2YXJcIlxuICAgIH07XG4gICAgdmFyIGRlY2xBbm5vdGF0aW9uID0gQU5OTyhkZWNsLmRlY2xhcmF0aW9uc1swXSk7XG4gICAgZGVjbEFubm90YXRpb24uY29weUZyb20ocHJvcGVydHlBbm5vdGF0aW9uKTtcbiAgICByZXR1cm4gZGVjbDtcbn07XG5cbnZhciBlbnRlcklkZW50aWZpZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzdGF0ZSkge1xuICAgIHZhciBibG9ja2VkTmFtZXMgPSBzdGF0ZS5ibG9ja2VkTmFtZXM7XG4gICAgdmFyIGlkTmFtZU1hcCA9IHN0YXRlLmlkTmFtZU1hcDtcblxuICAgIGlmIChwYXJlbnQudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKGlkTmFtZU1hcFtuYW1lXSkge1xuICAgICAgICBub2RlLm5hbWUgPSBpZE5hbWVNYXBbbmFtZV07XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2YXIgbmV3TmFtZSA9IFRvb2xzLmdlbmVyYXRlRnJlZU5hbWUobmFtZSwgYmxvY2tlZE5hbWVzKTtcbiAgICBpZE5hbWVNYXBbbmFtZV0gPSBuZXdOYW1lO1xuICAgIG5vZGUubmFtZSA9IG5ld05hbWU7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgIW51bWJlciBleHByZXNzaW9uIGludG8gYW4gYmluYXJ5IGV4cHJlc3Npb24sIG51bWJlciA9PSAwXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBsZWF2ZVVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUub3BlcmF0b3IgPT0gXCIhXCIpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gQU5OTyhub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnQuZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFR5cGVzLklOVDpcbiAgICAgICAgICAgIGNhc2UgVHlwZXMuTlVNQkVSOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9PVwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBub2RlLmFyZ3VtZW50LFxuICAgICAgICAgICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXJndW1lbnQuZ2V0VHlwZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHJldHVybiBpbiB0aGUgbWFpbiBmdW5jdGlvbnMgc2V0cyBnbF9GcmFnQ29sb3Igb3IgZGlzY2FyZCBpZiB0aGVcbiAqIG1haW4gbWV0aG9kIHJldHVybnMgd2l0aG91dCBhcmd1bWVudFxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSB7R0xUcmFuc2Zvcm1Db250ZXh0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudmFyIGxlYXZlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gY29udGV4dC5nZXRTY29wZSgpLCBmcmFnQ29sb3JzO1xuXG4gICAgICAgIGlmICghY29udGV4dC5pbk1haW5GdW5jdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgICAgICAgdmFyIGFyZ3VtZW50ID0gQU5OTyhub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudC5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFkZEhlYWRlcihcIiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcIik7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9ycyA9IHt0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsIGJvZHk6IFtdfTtcbiAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50LmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdDb2xvcnMuYm9keS5wdXNoKGNyZWF0ZUdMRnJhZ0NvbG9yKFRvb2xzLmNhc3RUb1ZlYzQoZWxlbWVudCwgc2NvcGUpLCBpbmRleCwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghYXJndW1lbnQuZ2V0S2luZCgpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuYXJndW1lbnQudHlwZSA9PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbiwgXCJHTFNMIGN1cnJlbnRseSBzdXBwb3J0IG9iamVjdCBleHByZXNzaW9ucyBhcyBvdXRwdXQgb25seS5cIik7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0cyA9IG5vZGUuYXJndW1lbnQucHJvcGVydGllcy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAua2V5LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgY29udGV4dC5vdXRwdXRzLmluZGV4T2YocC5rZXkubmFtZSkgIT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmcmFnQ29sb3JzID0ge3R5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCB9O1xuICAgICAgICAgICAgICAgIGZyYWdDb2xvcnMuYm9keSA9IG91dHB1dHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVHTEZyYWdDb2xvcihUb29scy5jYXN0VG9WZWM0KHAudmFsdWUsIHNjb3BlKSwgY29udGV4dC5vdXRwdXRzLmluZGV4T2YocC5rZXkubmFtZSkgLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KVxuXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9ycyA9IGNyZWF0ZUdMRnJhZ0NvbG9yKFRvb2xzLmNhc3RUb1ZlYzQobm9kZS5hcmd1bWVudCwgc2NvcGUpLCB1bmRlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgYm9keTogW2ZyYWdDb2xvcnMsIHt0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50fV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJkaXNjYXJkXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgbWFpbiBmdW5jdGlvbiBpbnRvIGEgR0xTTCBjb25mb3JtIG1haW4gZnVuY3Rpb25cbiAqIHdpdGggc2lnbmF0dXJlICd2b2lkIG1haW4odm9pZCknXG4gKiBAcGFyYW0gbm9kZVxuICovXG52YXIgbGVhdmVNYWluRnVuY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBhbm5vID0gbmV3IFR5cGVJbmZvKG5vZGUuZXh0cmEpO1xuICAgIGFubm8uc2V0UmV0dXJuSW5mbyh7dHlwZTogVHlwZXMuVU5ERUZJTkVEfSk7XG5cbiAgICAvLyBNYWluIGhhcyBubyBwYXJhbWV0ZXJzXG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICAvLyBSZW5hbWUgdG8gJ21haW4nXG4gICAgbm9kZS5pZC5uYW1lID0gXCJtYWluXCI7XG4gICAgLy9jb25zb2xlLmxvZyhub2RlKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUdMRnJhZ0NvbG9yKHJlc3VsdCwgaW5kZXgsIGNvbnRleHQpIHtcbiAgICB2YXIgbmFtZTtcbiAgICBpZiAoY29udGV4dC52ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgICAgbmFtZSA9IFwiZ2xfUG9zaXRpb25cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuYW1lID0gXCJnbF9GcmFnRGF0YVtcIiArIGluZGV4ICsgXCJdXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYW1lID0gXCJnbF9GcmFnQ29sb3JcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiByZXN1bHRcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXROYW1lT2ZOb2RlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgICAgICAgY2FzZSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJldHVybiBnZXROYW1lT2ZOb2RlKG5vZGUub2JqZWN0KSArIFwiLlwiICsgZ2V0TmFtZU9mTm9kZShub2RlLnByb3BlcnR5KTtcbiAgICAgICAgY2FzZSBTeW50YXguTmV3RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJldHVybiBnZXROYW1lT2ZOb2RlKG5vZGUuY2FsbGVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcInVua25vd24oXCIgKyBub2RlLnR5cGUgKyBcIilcIjtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge0dMVHJhbnNmb3JtQ29udGV4dH0gY29udGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBsZWF2ZUNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIHZhciBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKTtcblxuICAgIC8qKiBGaWx0ZXIgb3V0IHVuZGVmaW5lZCBhcmd1bWVudHMsIHdlIGRvIHRoZSBzYW1lIGZvciB0aGUgZGVjbGFyYXRpb24gKi9cbiAgICBub2RlLmFyZ3VtZW50cyA9IG5vZGUuYXJndW1lbnRzLmZpbHRlcih2YWxpZFBhcmFtZXRlcnMpO1xuXG4gICAgLy8gSXMgdGhpcyBhIGNhbGwgb24gYW4gb2JqZWN0P1xuICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBjYWxsZWVSZWZlcmVuY2UgPSBjb21tb24uZ2V0VHlwZUluZm8obm9kZS5jYWxsZWUsIHNjb3BlKTtcbiAgICAgICAgYXNzZXJ0KGNhbGxlZVJlZmVyZW5jZSAmJiBjYWxsZWVSZWZlcmVuY2UuaXNGdW5jdGlvbigpLCBcIkV4cGVjdGVkIGZ1bmN0aW9uIGJ1dCBmb3VuZDogXCIgKyBjYWxsZWVSZWZlcmVuY2UpO1xuXG4gICAgICAgIHZhciBvYmplY3QgPSBub2RlLmNhbGxlZS5vYmplY3QsXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBub2RlLmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xuXG4gICAgICAgIHZhciBvYmplY3RSZWZlcmVuY2UgPSBjb21tb24uZ2V0VHlwZUluZm8ob2JqZWN0LCBzY29wZSk7XG4gICAgICAgIGFzc2VydChvYmplY3RSZWZlcmVuY2UgJiYgb2JqZWN0UmVmZXJlbmNlLmlzT2JqZWN0KCksIFwiRXhwZWN0ZWQgb2JqZWN0IHRvIGNhbGwgYnV0IGZvdW5kOiBcIiArIG9iamVjdFJlZmVyZW5jZSk7XG4gICAgICAgIGFzc2VydChvYmplY3RSZWZlcmVuY2UuaGFzUHJvcGVydHkocHJvcGVydHlOYW1lKSwgXCJFeHBlY3RlZCBvYmplY3QgdG8gaGF2ZSBhIHByb3BlcnR5OiBcIiArIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVNZXRob2RDYWxsKG5vZGUsIG9iamVjdFJlZmVyZW5jZSwgcHJvcGVydHlOYW1lKTtcbiAgICB9XG59O1xuXG52YXIgbGVhdmVOZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5ld0V4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgICB2YXIgc2NvcGUgPSBjb250ZXh0LmdldFNjb3BlKCk7XG4gICAgaWYgKCFuZXdFeHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFRvb2xzLlZlYy5nZW5lcmF0ZUNvbnN0cnVjdG9yKG5ld0V4cHJlc3Npb24pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSB7R0xUcmFuc2Zvcm1Db250ZXh0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudmFyIGxlYXZlTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gbm9kZS5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKTtcblxuICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVDb21wdXRlZE1lbWJlckV4cHJlc3Npb24obm9kZSwgcGFyZW50LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoQU5OTyhub2RlKS5pc1VuaWZvcm1FeHByZXNzaW9uKCkpIHtcbiAgICAgICAgdmFyIHVleHAgPSBoYW5kbGVVbmlmb3JtRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHVleHApXG4gICAgICAgICAgICByZXR1cm4gdWV4cDtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0UmVmZXJlbmNlID0gY29tbW9uLmdldFR5cGVJbmZvKG5vZGUub2JqZWN0LCBzY29wZSk7XG4gICAgYXNzZXJ0KG9iamVjdFJlZmVyZW5jZSAmJiBvYmplY3RSZWZlcmVuY2UuaXNPYmplY3QoKSwgXCJPYmplY3Qgb2YgTWVtYmVyIGV4cHJlc3Npb24gaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgYXNzZXJ0KG9iamVjdFJlZmVyZW5jZS5oYXNQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpLCBcIk9iamVjdCBvZiBNZW1iZXIgZXhwcmVzc2lvbiBoYXMgbm8gcHJvcGVydHkgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInXCIpO1xuICAgIHJldHVybiBoYW5kbGVTdGF0aWNNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9iamVjdFJlZmVyZW5jZSwgcHJvcGVydHlOYW1lLCBjb250ZXh0KTtcblxuICAgIC8vIFRoZXJlIGlzIGEgc3BlY3VhbCBoYW5kbGluZyBkZWZpbmVkIGZvciB0aGUgb2JqZWN0XG4gICAgLyppZiAob2JqZWN0SW5mby5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgIHZhciBwcm9wZXJ0eUhhbmRsZXIgPSBvYmplY3RJbmZvW3Byb3BlcnR5TmFtZV07XG4gICAgIGlmICh0eXBlb2YgcHJvcGVydHlIYW5kbGVyLnByb3BlcnR5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICByZXR1cm4gcHJvcGVydHlIYW5kbGVyLnByb3BlcnR5KG5vZGUsIHBhcmVudCwgc2NvcGUsIGNvbnRleHQpO1xuICAgICB9XG4gICAgIH1cblxuXG4gICAgIGlmIChub2RlLm9iamVjdC50eXBlID09IFN5bnRheC5UaGlzRXhwcmVzc2lvbikge1xuICAgICBwYXJhbWV0ZXJOYW1lID0gVG9vbHMuZ2V0TmFtZUZvclN5c3RlbShwcm9wZXJ0eU5hbWUpO1xuICAgICBpZiAoIXVzZWRQYXJhbWV0ZXJzLnN5c3RlbS5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXJOYW1lKSkge1xuICAgICB1c2VkUGFyYW1ldGVycy5zeXN0ZW1bcGFyYW1ldGVyTmFtZV0gPSBjb250ZXh0LnN5c3RlbVBhcmFtZXRlcnNbcHJvcGVydHlOYW1lXTtcbiAgICAgfVxuXG4gICAgIHByb3BlcnR5TGl0ZXJhbCA9IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogcGFyYW1ldGVyTmFtZX07XG4gICAgIEFOTk8ocHJvcGVydHlMaXRlcmFsKS5jb3B5KEFOTk8obm9kZSkpO1xuICAgICByZXR1cm4gcHJvcGVydHlMaXRlcmFsO1xuICAgICB9ICovXG5cbn07XG5cbnZhciBoYW5kbGVTdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIG9iamVjdCwgcHJvcGVydHlOYW1lLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iamVjdC5pc1ByZWRlZmluZWRPYmplY3QoKSkge1xuICAgICAgICBpZiAoR0xPYmplY3RzLmhhcyhvYmplY3QuZ2V0S2luZCgpKSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdEhhbmRsZXIgPSBHTE9iamVjdHMuZ2V0KG9iamVjdC5nZXRLaW5kKCkpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdEhhbmRsZXIucHJvcGVydHkobm9kZSwgcHJvcGVydHlOYW1lLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIlVuaGFuZGxlZCBwcm9wZXJ0eVwiLCBvYmplY3QuZ2V0S2luZCgpLCBwcm9wZXJ0eU5hbWUpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmlzR2xvYmFsKCkpIHtcbiAgICAgICAgdmFyIHVzZWRQYXJhbWV0ZXJzID0gY29udGV4dC51c2VkUGFyYW1ldGVycztcbiAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBUb29scy5nZXROYW1lRm9yR2xvYmFsKHByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgaWYgKCF1c2VkUGFyYW1ldGVycy5lbnZpcm9ubWVudC5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXJOYW1lKSkge1xuICAgICAgICAgICAgdXNlZFBhcmFtZXRlcnMuZW52aXJvbm1lbnRbcGFyYW1ldGVyTmFtZV0gPSBBTk5PKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BlcnR5TGl0ZXJhbCA9IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogcGFyYW1ldGVyTmFtZX07XG4gICAgICAgIEFOTk8ocHJvcGVydHlMaXRlcmFsKS5jb3B5RnJvbShBTk5PKG5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5TGl0ZXJhbDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgaGFuZGxlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChub2RlLCBvYmplY3QsIG1ldGhvZE5hbWUpIHtcbiAgICBpZiAob2JqZWN0LmlzUHJlZGVmaW5lZE9iamVjdCgpKSB7XG4gICAgICAgIGlmIChHTE9iamVjdHMuaGFzKG9iamVjdC5nZXRLaW5kKCkpKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0SGFuZGxlciA9IEdMT2JqZWN0cy5nZXQob2JqZWN0LmdldEtpbmQoKSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0SGFuZGxlci5jYWxsKG5vZGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5oYW5kbGVkIGNhbGxcIiwgb2JqZWN0LmdldEtpbmQoKSwgbWV0aG9kTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtHTEFTVFRyYW5zZm9ybWVyfSBjb250ZXh0XG4gKi9cbnZhciBoYW5kbGVDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIG9iamVjdFJlZmVyZW5jZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5vYmplY3QpO1xuICAgIGlmICghb2JqZWN0UmVmZXJlbmNlLmlzQXJyYXkoKSkge1xuICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW4gc2hhZGUuanMsIFtdIGFjY2VzcyBpcyBvbmx5IGFsbG93ZWQgb24gYXJyYXlzLlwiKTtcbiAgICB9XG4gICAgdmFyIHByb3BlcnR5VHlwZSA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5wcm9wZXJ0eSk7XG4gICAgaWYgKCFwcm9wZXJ0eVR5cGUuY2FuSW50KCkpIHtcbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgIGNhbGxlZToge3R5cGU6IFwiSWRlbnRpZmllclwiLCBuYW1lOiBcImludFwifSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW25vZGUucHJvcGVydHldXG4gICAgICAgIH1cbiAgICAgICAgQU5OTyhub2RlLnByb3BlcnR5KS5zZXRUeXBlKFR5cGVzLklOVCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge0dMQVNUVHJhbnNmb3JtZXJ9IGNvbnRleHRcbiAqL1xudmFyIGhhbmRsZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgLy8gSW4gR0wsIHdlIGNhbid0IG1peCB1cCBmbG9hdHMsIGludHMgYW5kIGJvb2wgZm9yIGJpbmFyeSBleHByZXNzaW9uc1xuICAgIHZhciBsZWZ0ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmxlZnQpLFxuICAgICAgICByaWdodCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5yaWdodCk7XG5cbiAgICBpZiAobGVmdC5pc051bWJlcigpICYmIHJpZ2h0LmlzSW50KCkpIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IFRvb2xzLmNhc3RUb0Zsb2F0KG5vZGUucmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaWdodC5pc051bWJlcigpICYmIGxlZnQuaXNJbnQoKSkge1xuICAgICAgICBub2RlLmxlZnQgPSBUb29scy5jYXN0VG9GbG9hdChub2RlLmxlZnQpO1xuICAgIH1cblxuICAgIGlmIChub2RlLm9wZXJhdG9yID09IFwiJVwiKSB7XG4gICAgICAgIHJldHVybiBUb29scy5iaW5hcnlFeHByZXNzaW9uMkZ1bmN0aW9uQ2FsbChub2RlLCBcIm1vZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKmZ1bmN0aW9uIGNhc3RUb0ludChhc3QsIGZvcmNlKSB7XG4gdmFyIGV4cCA9IEFOTk8oYXN0KTtcblxuIGlmICghZXhwLmlzSW50KCkgfHwgZm9yY2UpIHsgICAvLyBDYXN0XG4gcmV0dXJuIHtcbiB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gY2FsbGVlOiB7XG4gdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gbmFtZTogXCJpbnRcIlxuIH0sXG4gYXJndW1lbnRzOiBbYXN0XVxuIH07XG4gfVxuIHJldHVybiBhc3Q7XG4gfTsqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge0dMVHJhbnNmb3JtQ29udGV4dH0gY29udGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBlbnRlckZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgIHZhciBzY29wZSA9IGNvbnRleHQuY3JlYXRlU2NvcGUobm9kZSwgY29udGV4dC5nZXRTY29wZSgpLCBub2RlLmlkLm5hbWUpO1xuICAgIGNvbnRleHQucHVzaFNjb3BlKHNjb3BlKTtcblxuICAgIC8vIFJlbW92ZSBnbG9iYWwgcGFyYW1ldGVycyBhbmQgcGFyYW1ldGVycyBvZiB0eXBlIHVuZGVmaW5lZCAodGhlc2UgYXJlIG5vdCB1c2VkIGFueXdheSlcbiAgICBub2RlLnBhcmFtcyA9IG5vZGUucGFyYW1zLmZpbHRlcih2YWxpZFBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtHTFRyYW5zZm9ybUNvbnRleHR9IGNvbnRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG52YXIgbGVhdmVGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICB2YXIgd2FzTWFpbiA9IGNvbnRleHQuaW5NYWluRnVuY3Rpb24oKTtcbiAgICBjb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKHdhc01haW4pXG4gICAgICAgIHJldHVybiBsZWF2ZU1haW5GdW5jdGlvbihub2RlKTtcbn07XG5cblxudmFyIGVudGVySWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciB0ZXN0ID0gQU5OTyhub2RlLnRlc3QpO1xuXG4gICAgYXNzZXJ0KCF0ZXN0Lmhhc0NvbnN0YW50VmFsdWUoKSwgXCJTdGF0aWMgdmFsdWUgaW4gSWZTdGF0ZW1lbnQgdGVzdFwiKTtcbiAgICBhc3NlcnQoIXRlc3QuaXNPYmplY3QoKSwgXCJPYmplY3QgaW4gSWZTdGF0ZW1lbnQgdGVzdFwiKTtcblxuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAodGVzdC5nZXRUeXBlKCkpIHtcbiAgICAgICAgLy8gVHJhbnNmb3JtICdpZihudW1iZXIpJyBpbnRvICdpZihudW1iZXIgIT0gMCknXG4gICAgICAgIGNhc2UgVHlwZXMuSU5UOlxuICAgICAgICBjYXNlIFR5cGVzLk5VTUJFUjpcbiAgICAgICAgICAgIG5vZGUudGVzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhPVwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGUudGVzdCxcbiAgICAgICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0ZXN0LmdldFR5cGUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogTmVlZCB0byB0cmFuc2Zvcm0gdHJ1dGggZXhwcmVzc2lvbnMgaW4gcmVhbCBib29sZWFuIGV4cHJlc3Npb24sIGJlY2F1c2Ugc29tZXRoaW5nIGxpa2UgaWYoMCkgaXNcbiAqIG5vdCBhbGxvd2VkIGluIEdMU0xcbiAqXG4gKiBAcGFyYW0gbm9kZVxuICogQHJldHVybnMgeyp9XG4gKi9cbnZhciBsZWF2ZUxvZ2ljYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbGVmdCA9IEFOTk8obm9kZS5sZWZ0KTtcbiAgICB2YXIgcmlnaHQgPSBBTk5PKG5vZGUucmlnaHQpO1xuXG4gICAgaWYgKGxlZnQuaXNCb29sKCkgJiYgcmlnaHQuaXNCb29sKCkpIHtcbiAgICAgICAgLy8gRXZlcnl0aGluZyBpcyBva2F5LCBubyBuZWVkIHRvIG1vZGlmeSBhbnl0aGluZ1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBKUyBib29sZWFuIHNlbWFudGljIGZvciBHTFNMXG4gICAgaWYgKGxlZnQuY2FuTnVtYmVyKCkpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBub2RlLmxlZnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uLFxuICAgICAgICAgICAgdGVzdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj09XCIsXG4gICAgICAgICAgICAgICAgbGVmdDogdGVzdCxcbiAgICAgICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxlZnQuaXNOdW1iZXIoKSA/IDAuMCA6IGxlZnQuaXNJbnQoKSA/IDAgOiBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBsZWZ0LmdldFR5cGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlOiBsZWZ0LmlzTnVtYmVyKCkgPyAwLjAgOiBsZWZ0LmlzSW50KCkgPyAwIDogXCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7dHlwZTogVHlwZXMuQk9PTEVBTn1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBub2RlLnJpZ2h0LFxuICAgICAgICAgICAgYWx0ZXJuYXRlOiB0ZXN0XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBoYW5kbGVVbmlmb3JtRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgdmFyIGV4cCA9IEFOTk8obm9kZSk7XG5cbiAgICBhc3NlcnQuZXF1YWwobm9kZS50eXBlLCBTeW50YXguTWVtYmVyRXhwcmVzc2lvbik7XG5cbiAgICBpZiAoZXhwLmlzVW5pZm9ybUV4cHJlc3Npb24oKSAmJiAhKGV4cC5nZXRTb3VyY2UoKSA9PSBTaGFkZS5TT1VSQ0VTLlVOSUZPUk0pKSB7XG4gICAgICAgIHZhciB1bmlmb3JtTmFtZSA9IG5vZGUucHJvcGVydHkubmFtZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdW5pZm9ybU5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29udGV4dC51c2VkUGFyYW1ldGVycy51ZXhwLmhhc093blByb3BlcnR5KHVuaWZvcm1OYW1lKSkgeyAvLyBSZXVzZVxuICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0gY29udGV4dC51c2VkUGFyYW1ldGVycy51ZXhwW3VuaWZvcm1OYW1lXTtcbiAgICAgICAgICAgIEFOTk8ocmVzdWx0KS5jb3B5RnJvbSh0eXBlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgbmV3IHVuaWZvcm0gZXhwcmVzc2lvblxuICAgICAgICBhc3NlcnQoY29udGV4dC51bmlmb3JtRXhwcmVzc2lvbnMuaGFzT3duUHJvcGVydHkodW5pZm9ybU5hbWUpLCBcIkludGVybmFsOiBObyBpbmZvcm1hdGlvbiBhYm91dCB1bmlmb3JtIGV4cHJlc3Npb24gYXZhaWxhYmxlOiBcIiArIFNoYWRlLnRvSmF2YVNjcmlwdChub2RlKSk7XG4gICAgICAgIC8vIFVzZSB0eXBlaW5mbyBmcm9tIG5vZGUgYXMgYmFzaXNcbiAgICAgICAgdmFyIHR5cGVJbmZvID0gQU5OTyhyZXN1bHQpO1xuICAgICAgICB0eXBlSW5mby5jb3B5RnJvbShleHApO1xuXG4gICAgICAgIHR5cGVJbmZvLnNldHRlciA9IGdlbmVyYXRlVW5pZm9ybVNldHRlcihleHAsIGNvbnRleHQudW5pZm9ybUV4cHJlc3Npb25zW3VuaWZvcm1OYW1lXSk7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyh1bmlmb3JtTmFtZSwgZXh0cmEuc2V0dGVyKTtcblxuICAgICAgICB0eXBlSW5mby5zZXRTb3VyY2UoU2hhZGUuU09VUkNFUy5VTklGT1JNKTtcbiAgICAgICAgdHlwZUluZm8uc2V0VW5pZm9ybURlcGVuZGVuY2llcyhleHAuZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpKTtcblxuICAgICAgICBjb250ZXh0LnVzZWRQYXJhbWV0ZXJzLnVleHBbdW5pZm9ybU5hbWVdID0gdHlwZUluZm87XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVW5pZm9ybVNldHRlcih1bmlmb3JtQW5ubywgZXhwcmVzc2lvbkluZm8pIHtcbiAgICB2YXIgY29kZSA9IGV4cHJlc3Npb25JbmZvLmNvZGU7XG4gICAgaWYgKHVuaWZvcm1Bbm5vLmlzT2JqZWN0KCkpXG4gICAgICAgIGNvZGUgPSBcIihcIiArIGV4cHJlc3Npb25JbmZvLmNvZGUgKyBcIikuX3RvRmxvYXRBcnJheSgpXCI7XG4gICAgdmFyIHNvdXJjZSA9IFwicmV0dXJuIFwiICsgY29kZSArIFwiO1wiO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnZcIiwgc291cmNlKTtcbn1cblxuZnVuY3Rpb24gYWRkRGVjbGFyYXRpb24obmFtZSwgdHlwZUluZm8sIHRhcmdldCkge1xuICAgIHZhciB0YXJnZXRDb250YWluZXIsIGRlY2xhcmF0aW9uO1xuICAgIHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguQmxvY2tTdGF0ZW1lbnQ6XG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXIgPSB0YXJnZXQuYm9keTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWw6IGFkZERlY2xhcmF0aW9uIHRvIFwiICsgdGFyZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Q29udGFpbmVyLmxlbmd0aCAmJiB0YXJnZXRDb250YWluZXJbMF0udHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICBkZWNsYXJhdGlvbiA9IHRhcmdldENvbnRhaW5lclswXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMucHVzaChkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnNbMF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsYXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAga2luZDogXCJ2YXJcIixcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW11cbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRDb250YWluZXIudW5zaGlmdChkZWNsYXJhdGlvbik7XG4gICAgfVxuICAgIHZhciBkZWNsYXJhdG9yID0ge1xuICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yLFxuICAgICAgICBpZDoge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGluaXQ6IG51bGxcbiAgICB9O1xuICAgIEFOTk8oZGVjbGFyYXRvcikuY29weSh0eXBlSW5mbyk7XG4gICAgZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRvcik7XG59XG5cbmZ1bmN0aW9uIHZhbGlkUGFyYW1ldGVycyhwKSB7XG4gICAgdmFyIGFwID0gQU5OTyhwKTtcbiAgICByZXR1cm4gIShhcC5pc1VuZGVmaW5lZCgpIHx8IGFwLmlzR2xvYmFsKCkpO1xufVxuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IEdMQVNUVHJhbnNmb3JtZXI7XG5cblxuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyksXG4gICAgICAgIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIiksXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcbiAgICAgICAgY29tbW9uID0gcmVxdWlyZShcIi4vLi4vLi4vYmFzZS9jb21tb24uanNcIik7XG5cbiAgICB2YXIgU25pcHBldExpc3QgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICB9XG5cbiAgICBCYXNlLmV4dGVuZChTbmlwcGV0TGlzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgYWRkRW50cnk6IGZ1bmN0aW9uKGVudHJ5KXtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIFNuaXBwZXRFbnRyeSA9IGZ1bmN0aW9uKGFzdCl7XG4gICAgICAgIHRoaXMuaW5wdXRJbmZvID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0SW5mbyA9IFtdO1xuICAgICAgICB0aGlzLmFzdCA9IGFzdCB8fCBudWxsO1xuICAgIH1cbiBcbiAgICBcbiAgICBCYXNlLmV4dGVuZChTbmlwcGV0RW50cnkucHJvdG90eXBlLCB7XG4gICAgICAgIHNldEFzdDogZnVuY3Rpb24oYXN0KXtcbiAgICAgICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB9LFxuICAgICAgICBhZGRWZXJ0ZXhJbnB1dDogZnVuY3Rpb24odHlwZSwgZGlyZWN0SW5wdXRJbmRleCl7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBuZXcgU25pcHBldElucHV0KHR5cGUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlucHV0LnNldERpcmVjdElucHV0KGRpcmVjdElucHV0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEluZm8ucHVzaChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFVuaWZvcm1JbnB1dDogZnVuY3Rpb24odHlwZSwgZGlyZWN0SW5wdXRJbmRleCl7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBuZXcgU25pcHBldElucHV0KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICBpbnB1dC5zZXREaXJlY3RJbnB1dChkaXJlY3RJbnB1dEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRJbmZvLnB1c2goaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRVbmlmb3JtQXJyYXk6IGZ1bmN0aW9uKHR5cGUsIGRpcmVjdElucHV0SW5kZXgsIGFycmF5U2l6ZSl7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBuZXcgU25pcHBldElucHV0KHR5cGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlucHV0LnNldERpcmVjdElucHV0KGRpcmVjdElucHV0SW5kZXgsIGFycmF5U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0SW5mby5wdXNoKGlucHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkVHJhbnNmZXJJbnB1dDogZnVuY3Rpb24odHlwZSwgdHJhbnNmZXJPcGVyYXRvckluZGV4LCB0cmFuc2Zlck91dHB1dEluZGV4KXtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IG5ldyBTbmlwcGV0SW5wdXQodHlwZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5wdXQuc2V0VHJhbnNmZXJJbnB1dCh0cmFuc2Zlck9wZXJhdG9ySW5kZXgsIHRyYW5zZmVyT3V0cHV0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEluZm8ucHVzaChpbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZExvc3RPdXRwdXQ6IGZ1bmN0aW9uKHR5cGUsIG5hbWUpe1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBTbmlwcGV0T3V0cHV0KHR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRJbmZvLnB1c2gob3V0cHV0KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkRmluYWxPdXRwdXQ6IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGluZGV4KXtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBuZXcgU25pcHBldE91dHB1dCh0eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIG91dHB1dC5zZXRGaW5hbE91dHB1dEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0SW5mby5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgdmFyIFNuaXBwZXRJbnB1dCA9IGZ1bmN0aW9uKHR5cGUsIGl0ZXJhdGUsIGFycmF5QWNjZXNzKXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pdGVyYXRlID0gaXRlcmF0ZTtcbiAgICAgICAgdGhpcy5hcnJheUFjY2VzcyA9IGFycmF5QWNjZXNzO1xuICAgICAgICB0aGlzLnRyYW5zZmVyT3BlcmF0b3JJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmFuc2Zlck91dHB1dEluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpcmVjdElucHV0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYXJyYXlTaXplID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIEJhc2UuZXh0ZW5kKFNuaXBwZXRJbnB1dC5wcm90b3R5cGUsIHtcbiAgICAgICAgc2V0RGlyZWN0SW5wdXQ6IGZ1bmN0aW9uKGRpcmVjdElucHV0SW5kZXgsIGFycmF5U2l6ZSl7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZmVyT3BlcmF0b3JJbmRleCA9IHRoaXMudHJhbnNmZXJPdXRwdXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0SW5wdXRJbmRleCA9IGRpcmVjdElucHV0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmFycmF5U2l6ZSA9IGFycmF5U2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNmZXJJbnB1dDogZnVuY3Rpb24odHJhbnNmZXJPcGVyYXRvckluZGV4LCB0cmFuc2Zlck91dHB1dEluZGV4KXtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmZXJPcGVyYXRvckluZGV4ID0gdHJhbnNmZXJPcGVyYXRvckluZGV4O1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zlck91dHB1dEluZGV4ID0gdHJhbnNmZXJPdXRwdXRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0SW5wdXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNUcmFuc2ZlcklucHV0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmZXJPcGVyYXRvckluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRyYW5zZmVySW5wdXRLZXk6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zlck9wZXJhdG9ySW5kZXggKyBcIl9cIiArIHRoaXMudHJhbnNmZXJPdXRwdXRJbmRleDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIFNuaXBwZXRPdXRwdXQgPSBmdW5jdGlvbih0eXBlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZmluYWxPdXRwdXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBCYXNlLmV4dGVuZChTbmlwcGV0T3V0cHV0LnByb3RvdHlwZSwge1xuICAgICAgICBzZXRGaW5hbE91dHB1dEluZGV4OiBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgICAgICB0aGlzLmZpbmFsT3V0cHV0SW5kZXggPSBpbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNGaW5hbDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsT3V0cHV0SW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbnMuU25pcHBldExpc3QgPSBTbmlwcGV0TGlzdDtcbiAgICBucy5TbmlwcGV0RW50cnkgPSBTbmlwcGV0RW50cnk7XG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxuICAgICAgICBUeXBlcyA9IFNoYWRlLlRZUEVTLFxuICAgICAgICBLaW5kcyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcbiAgICAgICAgU3BhY2VUeXBlID0gU2hhZGUuU3BhY2VUeXBlLFxuICAgICAgICBWZWN0b3JUeXBlID0gU2hhZGUuVmVjdG9yVHlwZTtcbiAgICB2YXIgd2FsayA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbiAgICB2YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XG4gICAgdmFyIEFOTk8gPSBjb21tb24uQU5OTztcblxuXG4gICAgbnMuZ2V0U3BhY2VUcmFuc2Zvcm1DYWxsID0gZnVuY3Rpb24oYXN0LCBzcGFjZSl7XG4gICAgICAgIHZhciBjYWxsRXhwcmVzc2lvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgIGNhbGxlZTogdGhpcy5nZXRTcGFjZUNvbnZlcnRGdW5jdGlvbihzcGFjZSksXG4gICAgICAgICAgICBhcmd1bWVudHM6IFsgdGhpcy5nZXRTcGFjZUNvbnZlcnRBcmcoc3BhY2UpLCBhc3QgXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbEV4cHJlc3Npb247XG4gICAgfTtcblxuICAgIG5zLmdldFNwYWNlQ29udmVydEZ1bmN0aW9uID0gZnVuY3Rpb24oc3BhY2Upe1xuICAgICAgICB2YXIgdmVjdG9yVHlwZSA9IFNoYWRlLmdldFZlY3RvckZyb21TcGFjZVZlY3RvcihzcGFjZSk7XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWU7XG4gICAgICAgIHN3aXRjaCh2ZWN0b3JUeXBlKXtcbiAgICAgICAgICAgIGNhc2UgVmVjdG9yVHlwZS5QT0lOVDogZnVuY3Rpb25OYW1lID0gXCJ0cmFuc2Zvcm1Qb2ludFwiOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVjdG9yVHlwZS5OT1JNQUw6IGZ1bmN0aW9uTmFtZSA9IFwidHJhbnNmb3JtRGlyZWN0aW9uXCI7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgIG9iamVjdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIlNwYWNlXCJ9LFxuICAgICAgICAgICAgcHJvcGVydHk6IHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGZ1bmN0aW9uTmFtZSB9XG4gICAgICAgIH07XG4gICAgICAgIEFOTk8ocmVzdWx0KS5zZXRUeXBlKFR5cGVzLkZVTkNUSU9OKTtcbiAgICAgICAgQU5OTyhyZXN1bHQub2JqZWN0KS5zZXRUeXBlKFR5cGVzLk9CSkVDVCwgS2luZHMuQU5ZKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBucy5nZXRTcGFjZUNvbnZlcnRBcmcgPSBmdW5jdGlvbihzcGFjZSl7XG4gICAgICAgIHZhciBzcGFjZVR5cGUgPSBTaGFkZS5nZXRTcGFjZUZyb21TcGFjZVZlY3RvcihzcGFjZSk7XG4gICAgICAgIHZhciBzcGFjZU5hbWU7XG4gICAgICAgIHN3aXRjaChzcGFjZVR5cGUpe1xuICAgICAgICAgICAgY2FzZSBTcGFjZVR5cGUuVklFVzogc3BhY2VOYW1lID0gXCJWSUVXXCI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTcGFjZVR5cGUuV09STEQ6IHNwYWNlTmFtZSA9IFwiV09STERcIjsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIlNwYWNlXCIgIH0sXG4gICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogc3BhY2VOYW1lIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcbiAgICAgICAgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxuICAgICAgICBUeXBlSW5mbyA9IHJlcXVpcmUoXCIuLi8uLi90eXBlLXN5c3RlbS90eXBlaW5mby5qc1wiKSxcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxuICAgICAgICBlc2dyYXBoID0gcmVxdWlyZSgnZXNncmFwaCcpLFxuICAgICAgICBUeXBlcyA9IFNoYWRlLlRZUEVTLFxuICAgICAgICBLaW5kcyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcbiAgICB2YXIgc3BhY2VBbmFseXplciA9IHJlcXVpcmUoXCIuLi8uLi9hbmFseXplL3NwYWNlX2FuYWx5emVyLmpzXCIpLFxuICAgICAgICBTcGFjZVZlY3RvclR5cGUgPSBTaGFkZS5TcGFjZVZlY3RvclR5cGUsXG4gICAgICAgIFNwYWNlVHlwZSA9IFNoYWRlLlNwYWNlVHlwZSxcbiAgICAgICAgVmVjdG9yVHlwZSA9IFNoYWRlLlZlY3RvclR5cGU7XG4gICAgdmFyIFNwYWNlVHJhbnNmb3JtVG9vbHMgPSByZXF1aXJlKFwiLi9zcGFjZS10cmFuc2Zvcm0tdG9vbHMuanNcIik7XG5cblxuXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XG4gICAgdmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xuICAgIHZhciBBTk5PID0gY29tbW9uLkFOTk87XG5cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIEpTIEFTVCB0byBhbiBBU1QgcmVwcmVzZW50YXRpb24gY29udmVuaWVudFxuICAgICAqIGZvciBjb2RlIGdlbmVyYXRpb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgU3BhY2VUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChtYWluSWQpIHtcbiAgICAgICAgdGhpcy5tYWluSWQgPSBtYWluSWQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNwYWNlSW5mbyhhc3Qpe1xuICAgICAgICByZXR1cm4gYXN0LnNwYWNlSW5mbyB8fCB7fTtcbiAgICB9XG5cbiAgICBCYXNlLmV4dGVuZChTcGFjZVRyYW5zZm9ybWVyLnByb3RvdHlwZSwge1xuICAgICAgICB0cmFuc2Zvcm1BYXN0OiBmdW5jdGlvbiAoYWFzdCwgb3B0KSB7XG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBhYXN0O1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvblNwYWNlSW5mbyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvblRyYW5mc2VySW5mbyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxJZGVudGlmaWVycyA9IHRoaXMuZ2V0R2xvYmFsSWRlbnRpZmllcnMoYWFzdCk7XG4gICAgICAgICAgICB0aGlzLmVudlNwYWNlcyA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9ucyhhYXN0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2xvYmFsT2JqZWN0KGFhc3QsIHRoaXMuZW52U3BhY2VzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudlNwYWNlcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0IX0gYXN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0IX0gc3RhdGVcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1GdW5jdGlvbnM6IGZ1bmN0aW9uKGFhc3QpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGFhc3QgPSB3YWxrLnJlcGxhY2UoYWFzdCwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXBsYWNlRnVuY3Rpb25JbnZvY2F0aW9ucyhub2RlLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXh0cmFjdFNwYWNlVHJhbnNmb3Jtcyhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFhc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGxhY2VGdW5jdGlvbkludm9jYXRpb25zOiBmdW5jdGlvbihmdW5jdGlvbkJvZHlBYXN0KXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHdhbGsucmVwbGFjZShmdW5jdGlvbkJvZHlBYXN0LCB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5DYWxsRXhwcmVzc2lvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyICYmIHNlbGYuZnVuY3Rpb25TcGFjZUluZm9bbm9kZS5jYWxsZWUubmFtZV0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbVRyYW5zaXRpb25zID0gc2VsZi5mdW5jdGlvblNwYWNlSW5mb1tub2RlLmNhbGxlZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQXJncyA9IG5vZGUuYXJndW1lbnRzLCBuZXdBcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcmFtVHJhbnNpdGlvbnMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1UID0gcGFyYW1UcmFuc2l0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXBhcmFtVC5zcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEFyZ3NbcGFyYW1ULmlkeF0gIT09IHVuZGVmaW5lZCAmJiBuZXdBcmdzLnB1c2gob2xkQXJnc1twYXJhbVQuaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBcmdzLnB1c2goU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwob2xkQXJnc1twYXJhbVQuaWR4XSwgcGFyYW1ULnNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBuZXdBcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0cmFjdFNwYWNlVHJhbnNmb3JtczogZnVuY3Rpb24oZnVuY3Rpb25BYXN0KXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudXNlZElkZW50aWZpZXJzID0gdGhpcy5nZXRVc2VkSWRlbnRpZmllcnMoZnVuY3Rpb25BYXN0KTtcblxuICAgICAgICAgICAgdmFyIGFuYWx5emVSZXN1bHQgPSBzcGFjZUFuYWx5emVyLmFuYWx5emUoZnVuY3Rpb25BYXN0LCB0aGlzLmZ1bmN0aW9uVHJhbmZzZXJJbmZvKTtcbiAgICAgICAgICAgIHZhciBuYW1lTWFwID0ge30sIGFkZERlY2xhcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5leHRyYWN0RW52U3BhY2VzKGFuYWx5emVSZXN1bHQsIG5hbWVNYXApO1xuICAgICAgICAgICAgdGhpcy5pbml0RnVuY3Rpb25IZWFkZXIoZnVuY3Rpb25BYXN0LCBhbmFseXplUmVzdWx0LCBuYW1lTWFwLCBhZGREZWNsYXJhdGlvbnMpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbkFhc3QuYm9keSA9IHdhbGsucmVwbGFjZShmdW5jdGlvbkFhc3QuYm9keSwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZW1lbnQgPSBzZWxmLmR1cGxpY2F0ZVNwYWNlU3RhdGVtZW50KG5vZGUsIG5hbWVNYXAsIGFkZERlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXdTdGF0ZW1lbnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzcGFjZUluZm8obm9kZSkuaGFzU3BhY2VPdmVycmlkZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNvbHZlU3BhY2VVc2FnZShub2RlLCBTcGFjZVZlY3RvclR5cGUuT0JKRUNULCBuYW1lTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZERlY2xhcmF0aW9ucyhmdW5jdGlvbkFhc3QsIGFkZERlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXBEZWNsYXJhdGlvbnMoZnVuY3Rpb25BYXN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRyYWN0RW52U3BhY2VzOiBmdW5jdGlvbihhbmFseXplUmVzdWx0LCBuYW1lTWFwKXtcbiAgICAgICAgICAgIGZvcih2YXIgbmFtZSBpbiBhbmFseXplUmVzdWx0KXtcbiAgICAgICAgICAgICAgICBpZihuYW1lLmluZGV4T2YoXCJlbnYuXCIpID09IDApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBuYW1lLnN1YnN0cig0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBhbmFseXplUmVzdWx0W25hbWVdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoai0tKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IGFuYWx5emVSZXN1bHRbbmFtZV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VOYW1lID0gdGhpcy5nZXRTcGFjZU5hbWUobmFtZSwgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuZW52U3BhY2VzW3Byb3BlcnR5XSkgdGhpcy5lbnZTcGFjZXNbcHJvcGVydHldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggIXRoaXMuZW52U3BhY2VzW3Byb3BlcnR5XS5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwYWNlID09IHNwYWNlfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnZTcGFjZXNbcHJvcGVydHldLnB1c2goeyBuYW1lOiBzcGFjZU5hbWUuc3BsaXQoXCIuXCIpWzFdLCBzcGFjZTogc3BhY2UgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW5hbWVNYXBbbmFtZV0pIG5hbWVNYXBbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVNYXBbbmFtZV1bc3BhY2VdID0gdGhpcy5nZXRTcGFjZU5hbWUobmFtZSwgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRGdW5jdGlvbkhlYWRlcjogZnVuY3Rpb24oZnVuY3Rpb25BYXN0LCBhbmFseXplUmVzdWx0LCBuYW1lTWFwLCBhZGREZWNsYXJhdGlvbnMpe1xuICAgICAgICAgICAgdmFyIG5ld1BhcmFtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBhcmFtVHJhbnNpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbkFhc3QucGFyYW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBmdW5jdGlvbkFhc3QucGFyYW1zW2ldLCBwYXJhbU5hbWUgPSBwYXJhbS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmKGFuYWx5emVSZXN1bHRbcGFyYW1OYW1lXSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gYW5hbHl6ZVJlc3VsdFtwYXJhbU5hbWVdLmxlbmd0aCwgaGFzT2JqZWN0U3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoai0tKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IGFuYWx5emVSZXN1bHRbcGFyYW1OYW1lXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNwYWNlICE9IFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFuYW1lTWFwW3BhcmFtTmFtZV0pIG5hbWVNYXBbcGFyYW1OYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVNYXBbcGFyYW1OYW1lXVtzcGFjZV0gPSB0aGlzLmdldFNwYWNlTmFtZShwYXJhbU5hbWUsIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UGFyYW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lTWFwW3BhcmFtTmFtZV1bc3BhY2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBTk5PKG5ld1BhcmFtKS5jb3B5RnJvbShBTk5PKHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zLnB1c2gobmV3UGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVHJhbnNpdGlvbnMucHVzaCh7aWR4OiBpLCBzcGFjZTogc3BhY2V9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT2JqZWN0U3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVRyYW5zaXRpb25zLnB1c2goe2lkeDogaX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKCFoYXNPYmplY3RTcGFjZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZWNsYXJhdGlvbnMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1UcmFuc2l0aW9ucy5wdXNoKHtpZHg6IGl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbkFhc3QucGFyYW1zID0gbmV3UGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvblNwYWNlSW5mb1tmdW5jdGlvbkFhc3QuaWQubmFtZV0gPSBwYXJhbVRyYW5zaXRpb25zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGR1cGxpY2F0ZVNwYWNlU3RhdGVtZW50OiBmdW5jdGlvbihzdGF0ZW1lbnRBYXN0LCBuYW1lTWFwLCBhZGRlZERlY2xhcmF0aW9ucyl7XG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlZFN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlbWVudEFhc3QuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHZhciBzSW5mbyA9IHNwYWNlSW5mbyhjaGlsZCk7XG5cbiAgICAgICAgICAgIHZhciBuZXdTcGFjZU5hbWVFbnRyaWVzID0ge307XG4gICAgICAgICAgICBpZighc0luZm8uZmluYWxTcGFjZXMpe1xuICAgICAgICAgICAgICAgIG5hbWVNYXBbc0luZm8uZGVmXSA9IG5ld1NwYWNlTmFtZUVudHJpZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzSW5mby5maW5hbFNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKXtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbkNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgaWYoc3BhY2UgIT0gU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCAmJiAhdGhpcy5pc1NwYWNlUHJvcGFncmF0aW9uUG9zc2libGUoc0luZm8sIHNwYWNlKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVNwYWNlVXNhZ2UoZXhwcmVzc2lvbkNvcHksIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QsIG5hbWVNYXApO1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29weS5yaWdodCA9IFNwYWNlVHJhbnNmb3JtVG9vbHMuZ2V0U3BhY2VUcmFuc2Zvcm1DYWxsKGV4cHJlc3Npb25Db3B5LnJpZ2h0LCBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVNwYWNlVXNhZ2UoZXhwcmVzc2lvbkNvcHksIHNwYWNlLCBuYW1lTWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlZFN0YXRlbWVudHMucHVzaCh7IHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LCBleHByZXNzaW9uOiBleHByZXNzaW9uQ29weSB9KTtcbiAgICAgICAgICAgICAgICBpZihzcGFjZSAhPSBTcGFjZVZlY3RvclR5cGUuT0JKRUNUKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYWNlTmFtZSA9IHRoaXMuZ2V0U3BhY2VOYW1lKHNJbmZvLmRlZiwgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZihhZGRlZERlY2xhcmF0aW9ucy5pbmRleE9mKHNwYWNlTmFtZSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZERlY2xhcmF0aW9ucy5wdXNoKHNwYWNlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NwYWNlTmFtZUVudHJpZXNbc3BhY2VdID0gc3BhY2VOYW1lO1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29weS5sZWZ0Lm5hbWUgPSBzcGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgbmFtZU1hcFtzSW5mby5kZWZdID0gbmV3U3BhY2VOYW1lRW50cmllcztcblxuICAgICAgICAgICAgaWYoZHVwbGljYXRlZFN0YXRlbWVudHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYoZHVwbGljYXRlZFN0YXRlbWVudHMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZWRTdGF0ZW1lbnRzWzBdO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2tTdGF0ZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IGR1cGxpY2F0ZWRTdGF0ZW1lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrU3RhdGVtZW50XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZGREZWNsYXJhdGlvbnM6IGZ1bmN0aW9uKGZ1bmN0aW9uQWFzdCwgYWRkRGVjbGFyYXRpb25zKXtcbiAgICAgICAgICAgIHZhciBpID0gZnVuY3Rpb25BYXN0LnBhcmFtcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZShpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYWRkRGVjbGFyYXRpb25zLmluZGV4T2YoZnVuY3Rpb25BYXN0LnBhcmFtc1tpXS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZihpZHggIT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFkZERlY2xhcmF0aW9ucy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0geyB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiwga2luZDogXCJ2YXJcIiwgZGVjbGFyYXRpb25zOiBbXX07XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhZGREZWNsYXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlKGktLSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYWRkRGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbCA9IHt0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yLCBpZDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBuYW1lfSwgaW5pdDogbnVsbH07XG4gICAgICAgICAgICAgICAgICAgIEFOTk8oZGVjbCkuc2V0VHlwZShUeXBlcy5PQkpFQ1QsIFwiVmVjM1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLmRlY2xhcmF0aW9ucy5wdXNoKGRlY2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbkFhc3QuYm9keS5ib2R5LnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc1NwYWNlUHJvcGFncmF0aW9uUG9zc2libGU6IGZ1bmN0aW9uKHNJbmZvLCB0YXJnZXRTcGFjZSl7XG4gICAgICAgICAgICBpZihzSW5mby5wcm9wYWdhdGVTZXQubGVuZ3RoID09IDApIC8vIFdlIG5lZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZGVwZW5kZW5jeS4gT3RoZXJ3aXNlIHdlIGNhbid0IHByb3BhZ2F0ZSB0aGUgc3BhY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdmVjdG9yVHlwZSA9IFNoYWRlLmdldFZlY3RvckZyb21TcGFjZVZlY3Rvcih0YXJnZXRTcGFjZSlcbiAgICAgICAgICAgIGlmKHZlY3RvclR5cGUgPT0gVmVjdG9yVHlwZS5OT1JNQUwgJiYgc0luZm8ubm9ybWFsU3BhY2VWaW9sYXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYodmVjdG9yVHlwZSA9PSBWZWN0b3JUeXBlLlBPSU5UICYmIHNJbmZvLnBvaW50U3BhY2VWaW9sYXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNvbHZlU3BhY2VVc2FnZTogZnVuY3Rpb24oYWFzdCwgdGFyZ2V0U3BhY2UsIG5hbWVNYXApe1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgYWFzdCA9IHdhbGsucmVwbGFjZShhYXN0LCB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVudGVyOlwiLCBub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXRTcGFjZSAhPSBTcGFjZVZlY3RvclR5cGUuT0JKRUNUICYmIHNwYWNlSW5mbyhub2RlKS5wcm9wYWdhdGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBuYW1lTWFwW25vZGUubmFtZV1bdGFyZ2V0U3BhY2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGFyZ2V0U3BhY2UgIT0gU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCAmJiBzcGFjZUluZm8obm9kZSkucHJvcGFnYXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVLZXkgPSBcImVudi5cIiArIG5vZGUucHJvcGVydHkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lTWFwW25hbWVLZXldW3RhcmdldFNwYWNlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydHkubmFtZSA9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzSW5mbyA9IHNwYWNlSW5mbyhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzSW5mby5zcGFjZU92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNTcGFjZVByb3BhZ3JhdGlvblBvc3NpYmxlKHNJbmZvLCBzSW5mby5zcGFjZU92ZXJyaWRlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZWxmLnJlc29sdmVTcGFjZVVzYWdlKG5vZGUuYXJndW1lbnRzWzFdLCBzSW5mby5zcGFjZU92ZXJyaWRlLCBuYW1lTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWFzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTcGFjZU5hbWU6IGZ1bmN0aW9uKG5hbWUsIHNwYWNlKXtcbiAgICAgICAgICAgIGlmKHNwYWNlID09IFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG5cbiAgICAgICAgICAgIHZhciBjaGVja0dsb2JhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYobmFtZS5pbmRleE9mKFwiZW52LlwiKSA9PSAwKXtcbiAgICAgICAgICAgICAgICBjaGVja0dsb2JhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoKHNwYWNlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFNwYWNlVmVjdG9yVHlwZS5WSUVXX1BPSU5UIDogbmFtZSArPSBcIl92cHNcIjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTcGFjZVZlY3RvclR5cGUuV09STERfUE9JTlQgOiBuYW1lICs9IFwiX3dwc1wiOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCA6IG5hbWUgKz0gXCJfdm5zXCI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3BhY2VWZWN0b3JUeXBlLldPUkxEX05PUk1BTCA6IG5hbWUgKz0gXCJfd25zXCI7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5hbWU7XG4gICAgICAgICAgICB2YXIgaSA9IDI7XG4gICAgICAgICAgICB3aGlsZSggKGNoZWNrR2xvYmFsID8gdGhpcy5nbG9iYWxJZGVudGlmaWVycyA6IHRoaXMudXNlZElkZW50aWZpZXJzICkuaW5kZXhPZihyZXN1bHQpICE9IC0xKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuYW1lICsgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoY2hlY2tHbG9iYWwpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJlbnYuXCIgKyByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFVzZWRJZGVudGlmaWVycyA6IGZ1bmN0aW9uKGZ1bmN0aW9uQWFzdCl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB3YWxrLnRyYXZlcnNlKGZ1bmN0aW9uQWFzdCwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBwYXJlbnQudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBwYXJlbnQucHJvcGVydHkgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuaW5kZXhPZihub2RlLm5hbWUpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEdsb2JhbElkZW50aWZpZXJzIDogZnVuY3Rpb24ocHJvZ3JhbUFhc3Qpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgd2Fsay50cmF2ZXJzZShwcm9ncmFtQWFzdCwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIG5vZGUub2JqZWN0LmV4dHJhLmdsb2JhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuaW5kZXhPZihub2RlLnByb3BlcnR5Lm5hbWUpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUucHJvcGVydHkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuVXBEZWNsYXJhdGlvbnM6IGZ1bmN0aW9uKGZ1bmN0aW9uQWFzdCl7XG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBib2R5ID0gZnVuY3Rpb25BYXN0LmJvZHkuYm9keTtcbiAgICAgICAgICAgIHZhciBpID0gYm9keS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgICAgIGlmKGJvZHlbaV0udHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0b3JzLnB1c2guYXBwbHkoZGVjbGFyYXRvcnMsIGJvZHlbaV0uZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5zcGxpY2UoaSwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXNlZElkZW50aWZpZXJzID0gdGhpcy5nZXRVc2VkSWRlbnRpZmllcnMoZnVuY3Rpb25BYXN0LmJvZHkpO1xuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0geyB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiwga2luZDogXCJ2YXJcIiwgZGVjbGFyYXRpb25zOiBbXX07XG4gICAgICAgICAgICBpID0gZGVjbGFyYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgICAgICBpZih1c2VkSWRlbnRpZmllcnMuaW5kZXhPZihkZWNsYXJhdG9yc1tpXS5pZC5uYW1lKSAhPSAtMSl7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBib2R5LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUdsb2JhbE9iamVjdDogZnVuY3Rpb24oYWFzdCwgZW52U3BhY2VzKXtcbiAgICAgICAgICAgIGlmKCFhYXN0Lmdsb2JhbFBhcmFtZXRlcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGdsb2JhbE9iamVjdDtcbiAgICAgICAgICAgIGZvcih2YXIgZnVuY05hbWUgaW4gYWFzdC5nbG9iYWxQYXJhbWV0ZXJzKXtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFhc3QuZ2xvYmFsUGFyYW1ldGVyc1tmdW5jTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgICAgICAgICBpZihhcmdzW2ldLmV4dHJhLmdsb2JhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE9iamVjdCA9IGFyZ3NbaV0uZXh0cmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWdsb2JhbE9iamVjdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbmV3SW5mbyA9IHt9O1xuICAgICAgICAgICAgZm9yKHZhciBwcm9wTmFtZSBpbiBnbG9iYWxPYmplY3QuaW5mbyl7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBnbG9iYWxPYmplY3QuaW5mb1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYoIWVudlNwYWNlc1twcm9wTmFtZV0pe1xuICAgICAgICAgICAgICAgICAgICBuZXdJbmZvW3Byb3BOYW1lXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW50cnlMaXN0ID0gZW52U3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cnlMaXN0Lmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcHlEYXRhID0gQmFzZS5kZWVwRXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5mb1tlbnRyeUxpc3RbaV0ubmFtZV09IGNvcHlEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsb2JhbE9iamVjdC5pbmZvID0gbmV3SW5mbztcbiAgICAgICAgICAgIHdhbGsudHJhdmVyc2UoYWFzdCwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5leHRyYSAmJiBub2RlLmV4dHJhLmdsb2JhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV4dHJhLmluZm8gPSBuZXdJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUuc2NvcGUgJiYgbm9kZS5zY29wZS5iaW5kaW5ncyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIG5hbWUgaW4gbm9kZS5zY29wZS5iaW5kaW5ncyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5zY29wZS5iaW5kaW5nc1tuYW1lXS5leHRyYS5nbG9iYWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNjb3BlLmJpbmRpbmdzW25hbWVdLmV4dHJhLmluZm8gPSBuZXdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgIH0pO1xuXG4gICAgLy8gRXhwb3J0c1xuICAgIG5zLlNwYWNlVHJhbnNmb3JtZXIgPSBuZXcgU3BhY2VUcmFuc2Zvcm1lcigpO1xuXG5cbn0oZXhwb3J0cykpO1xuIiwidmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XG52YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlL2luZGV4LmpzXCIpO1xudmFyIGFubm90YXRlID0gcmVxdWlyZShcIi4uL3V0aWxzL1wiKS5hbm5vdGF0ZTtcbnZhciBUeXBlSW5mbyA9IHJlcXVpcmUoXCIuLi90eXBlLXN5c3RlbS90eXBlaW5mby5qc1wiKTtcbnZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2VzLmpzXCIpO1xudmFyIFZlY0Jhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS92ZWMuanNcIik7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxudmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXG4gICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XG5cbnZhciBucyA9IHt9O1xuXG5ucy5yZW1vdmVNZW1iZXJGcm9tRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgIG5hbWU6IG5vZGUucHJvcGVydHkubmFtZVxuICAgIH1cbn1cblxubnMuZ2VuZXJhdGVGcmVlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBibG9ja2VkTmFtZXMpIHtcbiAgICB2YXIgbmV3TmFtZSA9IG5hbWUucmVwbGFjZSgvXysvZywgXCJfXCIpLCBpID0gMTtcbiAgICB3aGlsZSAoYmxvY2tlZE5hbWVzLmluZGV4T2YobmV3TmFtZSkgIT0gLTEpIHtcbiAgICAgICAgbmV3TmFtZSA9IChuYW1lICsgXCJfXCIgKyAoKytpKSkucmVwbGFjZSgvXysvZywgXCJfXCIpO1xuICAgIH1cbiAgICBibG9ja2VkTmFtZXMucHVzaChuZXdOYW1lKTtcbiAgICByZXR1cm4gbmV3TmFtZTtcbn1cblxubnMuZ2V0SW50ZXJuYWxGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiAoc3RhdGUsIGtleSwgdHlwZSwgZGV0YWlscykge1xuICAgIGlmICghc3RhdGUuaW50ZXJuYWxGdW5jdGlvbnNba2V5XSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5zLmdlbmVyYXRlRnJlZU5hbWUoa2V5LCBzdGF0ZS5ibG9ja2VkTmFtZXMpO1xuICAgICAgICBzdGF0ZS5pbnRlcm5hbEZ1bmN0aW9uc1trZXldID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5pbnRlcm5hbEZ1bmN0aW9uc1trZXldLm5hbWU7XG59O1xuXG5cbm5zLmJpbmFyeUV4cHJlc3Npb24yRnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICBub2RlLnJpZ2h0ID0gbnMuY2FzdFRvRmxvYXQobm9kZS5yaWdodCk7XG4gICAgbm9kZS5sZWZ0ID0gbnMuY2FzdFRvRmxvYXQobm9kZS5sZWZ0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3VtZW50czogW1xuICAgICAgICAgICAgbm9kZS5sZWZ0LFxuICAgICAgICAgICAgbm9kZS5yaWdodFxuICAgICAgICBdLFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgdHlwZTogVFlQRVMuTlVNQkVSXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgVmVjID0ge1xuICAgIGdldFZlY0FyZ3M6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIjBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBhbm5vdGF0ZShyZXN1bHRbMF0pLnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZW5lcmF0ZVZlY0Zyb21BcmdzOiBmdW5jdGlvbiAodmVjQ291bnQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHZlY0NvdW50ID09IDEpXG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGFyZ3MgPSBWZWMuZ2V0VmVjQXJncyhhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxICYmIGFubm90YXRlKGFyZ3NbMF0pLmlzT2ZLaW5kKFwiVmVjXCIgKyB2ZWNDb3VudCkpXG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJWZWNcIiArIHZlY0NvdW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzXG4gICAgICAgIH07XG4gICAgICAgIGFubm90YXRlKHJlc3VsdCkuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIFwiVmVjXCIgKyB2ZWNDb3VudCk7XG4gICAgICAgIGFubm90YXRlKHJlc3VsdC5jYWxsZWUpLnNldFR5cGUoVFlQRVMuRlVOQ1RJT04pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjcmVhdGVTd2l6emxlOiBmdW5jdGlvbiAodmVjQ291bnQsIHN3aXp6bGUsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBub2RlLmNhbGxlZS5leHRyYSA9IG5vZGUuZXh0cmE7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jYWxsZWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpbmd1bGFyID0gc3dpenpsZS5sZW5ndGggPT0gMTtcbiAgICAgICAgdmFyIGFyZ09iamVjdCA9IHNpbmd1bGFyID8gbm9kZS5hcmd1bWVudHNbMF0gOiBWZWMuZ2VuZXJhdGVWZWNGcm9tQXJncyhzd2l6emxlLmxlbmd0aCwgbm9kZS5hcmd1bWVudHMpO1xuICAgICAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJWZWNcIiArIHZlY0NvdW50XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN3aXp6bGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBWZWNCYXNlLnN3aXp6bGVUb0luZGV4KHN3aXp6bGUuY2hhckF0KGkpKTtcbiAgICAgICAgICAgIGluZGljZXNbaWR4XSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlY0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlLmFyZ3VtZW50c1tpXSA9IHNpbmd1bGFyID8gYXJnT2JqZWN0IDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBhcmdPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFZlY0Jhc2UuaW5kZXhUb1N3aXp6bGUoaW5kaWNlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlLmFyZ3VtZW50c1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbm9kZS5jYWxsZWUub2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBWZWNCYXNlLmluZGV4VG9Td2l6emxlKGkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFubm90YXRlKHJlcGxhY2UpLmNvcHlGcm9tKGFubm90YXRlKG5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2U7XG4gICAgfSxcbiAgICBjcmVhdGVTd2l6emxlT3BlcmF0b3I6IGZ1bmN0aW9uICh2ZWNDb3VudCwgc3dpenpsZSwgb3BlcmF0b3IsIG5vZGUsIGFyZ3MsIHBhcmVudCkge1xuICAgICAgICB2YXIgc2luZ3VsYXIgPSBzd2l6emxlLmxlbmd0aCA9PSAxO1xuICAgICAgICB2YXIgYXJnT2JqZWN0ID0gc2luZ3VsYXIgPyBub2RlLmFyZ3VtZW50c1swXSA6IFZlYy5nZW5lcmF0ZVZlY0Zyb21BcmdzKHN3aXp6bGUubGVuZ3RoLCBub2RlLmFyZ3VtZW50cyk7XG4gICAgICAgIHZhciByZXBsYWNlID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sXG4gICAgICAgICAgICBjYWxsZWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlZlY1wiICsgdmVjQ291bnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3dpenpsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IFZlY0Jhc2Uuc3dpenpsZVRvSW5kZXgoc3dpenpsZS5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgaW5kaWNlc1tpZHhdID0gaTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlY0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0aGlzVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBub2RlLmNhbGxlZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFZlY0Jhc2UuaW5kZXhUb1N3aXp6bGUoaSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGluZGljZXNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2UuYXJndW1lbnRzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzaW5ndWxhciA/IGFyZ09iamVjdCA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBhcmdPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFZlY0Jhc2UuaW5kZXhUb1N3aXp6bGUoaW5kaWNlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcGxhY2UuYXJndW1lbnRzW2ldID0gdGhpc1ZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYW5ub3RhdGUocmVwbGFjZSkuY29weShhbm5vdGF0ZShub2RlKSk7XG4gICAgICAgIHJldHVybiByZXBsYWNlO1xuICAgIH0sXG5cbiAgICBhdHRhY2hTd2l6emxlczogZnVuY3Rpb24gKGluc3RhbmNlLCB2ZWNDb3VudCwgY2FsbEV4cCwgY2FsbE9wZXJhdG9yRXhwKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVmVjQmFzZS5zd2l6emxlU2V0cy5sZW5ndGg7ICsrcykge1xuICAgICAgICAgICAgZm9yICh2YXIgY291bnQgPSAxOyBjb3VudCA8PSA0OyArK2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgucG93KHZlY0NvdW50LCBjb3VudCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW10sIHdpdGhTZXR0ZXIgPSAoY291bnQgPD0gdmVjQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSB2YWwgJSB2ZWNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gdmVjQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICs9IFZlY0Jhc2Uuc3dpenpsZVNldHNbc11baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzW2lkeF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aFNldHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNbaWR4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxFeHA6IGNhbGxFeHAuYmluZChudWxsLCB2ZWNDb3VudCwga2V5KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAod2l0aFNldHRlciAmJiBjYWxsT3BlcmF0b3JFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG9wZXJhdG9yIGluIFZlY0Jhc2Uuc3dpenpsZU9wZXJhdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcFN5bWJvbCA9IFZlY0Jhc2Uuc3dpenpsZU9wZXJhdG9yc1tvcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5ICsgb3BlcmF0b3JdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXhwOiBjYWxsT3BlcmF0b3JFeHAuYmluZChudWxsLCB2ZWNDb3VudCwga2V5LCBvcFN5bWJvbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZU9wZXJhdG9yOiBmdW5jdGlvbiAodmVjQ291bnQsIG9wZXJhdG9yLCBub2RlLCBhcmdzLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIG90aGVyID0gVmVjLmdlbmVyYXRlVmVjRnJvbUFyZ3ModmVjQ291bnQsIG5vZGUuYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICAgICAgICAgIGxlZnQ6IG5vZGUuY2FsbGVlLm9iamVjdCxcbiAgICAgICAgICAgIHJpZ2h0OiBvdGhlclxuICAgICAgICB9O1xuICAgICAgICBhbm5vdGF0ZShyZXBsYWNlKS5jb3B5RnJvbShhbm5vdGF0ZShub2RlKSk7XG4gICAgICAgIHJldHVybiByZXBsYWNlO1xuICAgIH0sXG5cbiAgICBhdHRhY2hPcGVyYXRvcnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmVjQ291bnQsIG9wZXJhdG9ycykge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wZXJhdG9ycykge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gb3BlcmF0b3JzW25hbWVdO1xuICAgICAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgY2FsbEV4cDogVmVjLmNyZWF0ZU9wZXJhdG9yLmJpbmQobnVsbCwgdmVjQ291bnQsIG9wZXJhdG9yKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUZ1bmN0aW9uQ2FsbDogZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSwgc2Vjb25kVmVjU2l6ZSwgbm9kZSkge1xuICAgICAgICBhc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PSAzKTtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICBjYWxsZWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICAgICAgICBub2RlLmNhbGxlZS5vYmplY3RcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNlY29uZFZlY1NpemUpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IFZlYy5nZW5lcmF0ZVZlY0Zyb21BcmdzKHNlY29uZFZlY1NpemUsIG5vZGUuYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJlcGxhY2UuYXJndW1lbnRzLnB1c2gob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGFubm90YXRlKHJlcGxhY2UpLmNvcHlGcm9tKGFubm90YXRlKG5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2U7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlTGVuZ3RoQ2FsbDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbCgnbGVuZ3RoJywgMCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyonLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGUuY2FsbGVlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcvJyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbm9kZS5hcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBWZWMuY3JlYXRlRnVuY3Rpb25DYWxsKCdsZW5ndGgnLCAwLCBub2RlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhbm5vdGF0ZShyZXBsYWNlLnJpZ2h0KS5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XG4gICAgICAgICAgICBhbm5vdGF0ZShyZXBsYWNlKS5jb3B5RnJvbShhbm5vdGF0ZShub2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZW5lcmF0ZUNvbnN0cnVjdG9yOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IFZlYy5nZXRWZWNBcmdzKG5vZGUuYXJndW1lbnRzKTtcbiAgICB9XG59O1xuXG52YXIgTWF0ID0ge1xuICAgIFRZUEVTOiB7XG4gICAgICAgIFwiTWF0M1wiOiB7a2luZDogS0lORFMuTUFUUklYMywgY29sS2luZDogS0lORFMuRkxPQVQzLCBjb2xDb3VudDogMywgZ2xzbFR5cGU6IFwibWF0M1wifSxcbiAgICAgICAgXCJNYXQ0XCI6IHtraW5kOiBLSU5EUy5NQVRSSVg0LCBjb2xLaW5kOiBLSU5EUy5GTE9BVDQsIGNvbENvdW50OiA0LCBnbHNsVHlwZTogXCJtYXQzXCJ9XG4gICAgfSxcblxuICAgIGdlbmVyYXRlTWF0RnJvbUFyZ3M6IGZ1bmN0aW9uIChtYXROYW1lLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBhcmdzID0gVmVjLmdldFZlY0FyZ3MoYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMSAmJiBhbm5vdGF0ZShhcmdzWzBdKS5pc09mS2luZChNYXQuVFlQRVNbbWF0TmFtZV0ua2luZCkpXG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgbmFtZTogbWF0TmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgICAgICB9O1xuICAgICAgICBhbm5vdGF0ZShyZXN1bHQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBNYXQuVFlQRVNbbWF0TmFtZV0ua2luZCk7XG4gICAgICAgIGFubm90YXRlKHJlc3VsdC5jYWxsZWUpLnNldFR5cGUoVFlQRVMuRlVOQ1RJT04pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjcmVhdGVPcGVyYXRvcjogZnVuY3Rpb24gKG1hdE5hbWUsIG9wZXJhdG9yLCBub2RlLCBhcmdzLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIG90aGVyID0gTWF0LmdlbmVyYXRlTWF0RnJvbUFyZ3MobWF0TmFtZSwgbm9kZS5hcmd1bWVudHMpO1xuICAgICAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgICAgICAgICAgbGVmdDogbm9kZS5jYWxsZWUub2JqZWN0LFxuICAgICAgICAgICAgcmlnaHQ6IG90aGVyXG4gICAgICAgIH07XG4gICAgICAgIGFubm90YXRlKHJlcGxhY2UpLmNvcHkoYW5ub3RhdGUobm9kZSkpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZTtcbiAgICB9LFxuXG4gICAgYXR0YWNoT3BlcmF0b3JzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hdE5hbWUsIG9wZXJhdG9ycykge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wZXJhdG9ycykge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gb3BlcmF0b3JzW25hbWVdO1xuICAgICAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgY2FsbEV4cDogTWF0LmNyZWF0ZU9wZXJhdG9yLmJpbmQobnVsbCwgbWF0TmFtZSwgb3BlcmF0b3IpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVDb2xDYWxsOiBmdW5jdGlvbiAobWF0TmFtZSwgbm9kZSwgYXJncywgcGFyZW50LCBzdGF0ZSkge1xuICAgICAgICB2YXIgbWVtYmVyQWNjZXNzID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICBvYmplY3Q6IG5vZGUuY2FsbGVlLm9iamVjdCxcbiAgICAgICAgICAgIHByb3BlcnR5OiBub2RlLmFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGFubm90YXRlKG1lbWJlckFjY2Vzcykuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIE1hdC5UWVBFU1ttYXROYW1lXS5jb2xLaW5kKTtcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlckFjY2VzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RLZXkgPSBcIl9cIiArIG1hdE5hbWUgKyBcIl9jb2xcIjtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbnMuZ2V0SW50ZXJuYWxGdW5jdGlvbk5hbWUoc3RhdGUsIG1ldGhvZEtleSxcbiAgICAgICAgICAgICAgICBcIk1hdENvbFwiLCB7Y29sVHlwZTogXCJ2ZWNcIiArIE1hdC5UWVBFU1ttYXROYW1lXS5jb2xDb3VudCwgbWF0VHlwZTogTWF0LlRZUEVTW21hdE5hbWVdLmdsc2xUeXBlfSk7XG5cbiAgICAgICAgICAgIHZhciByZXBsYWNlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbWV0aG9kTmFtZX0sXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2FsbGVlLm9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzWzFdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFubm90YXRlKHJlcGxhY2UpLmNvcHkoYW5ub3RhdGUobm9kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5ucy5WZWMgPSBWZWM7XG5ucy5NYXQgPSBNYXQ7XG5cbm5zLmNhc3RUb0Zsb2F0ID0gZnVuY3Rpb24gKGFzdCkge1xuICAgIHZhciBleHAgPSBhbm5vdGF0ZShhc3QpO1xuXG4gICAgaWYgKCFleHAuaXNOdW1iZXIoKSkgeyAgIC8vIENhc3RcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgIGNhbGxlZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZmxvYXRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW2FzdF1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXN0O1xufVxuXG5ucy5nZXROYW1lRm9yU3lzdGVtID0gZnVuY3Rpb24gKGJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIGJhc2VOYW1lO1xufVxuXG5ucy5nZXROYW1lRm9yR2xvYmFsID0gZnVuY3Rpb24gKGJhc2VOYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBcIl9lbnZfXCIgKyBiYXNlTmFtZTtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9fKy9nLCBcIl9cIik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEBwYXJhbSAge0dMVHJhbnNmb3JtQ29udGV4dH0gY29udGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbm5zLmNhc3RUb1ZlYzQgPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgIHZhciBleHAgPSBUeXBlSW5mby5jcmVhdGVGb3JDb250ZXh0KG5vZGUsIGNvbnRleHQpO1xuXG4gICAgaWYgKGV4cC5pc09mS2luZChcIlZlYzRcIikgfHwgZXhwLmlzT2ZLaW5kKFwiQ2xvc3VyZVwiKSlcbiAgICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICBpZiAoZXhwLmlzT2ZLaW5kKFwiVmVjM1wiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ2ZWM0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtub2RlLCB7dHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiAxLjAsIGV4dHJhOiB7dHlwZTogVFlQRVMuTlVNQkVSfX1dXG4gICAgICAgIH1cbiAgICB9XG4gICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkNhbid0IGNhc3QgZnJvbSAnXCIgKyBleHAuZ2V0VHlwZVN0cmluZygpICsgXCInIHRvIHZlYzRcIik7XG59XG5cbm5zLmV4dGVuZCA9IEJhc2UuZXh0ZW5kO1xubnMuY3JlYXRlQ2xhc3MgPSBCYXNlLmNyZWF0ZUNsYXNzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKFwiZXNwcmltYVwiKTtcbnZhciBjb2RlZ2VuID0gcmVxdWlyZShcImVzY29kZWdlblwiKTtcbnZhciBleHRyYWN0UGFyYW1ldGVycyA9IHJlcXVpcmUoXCIuL2FuYWx5emUvZXh0cmFjdF9wYXJhbWV0ZXJzXCIpO1xudmFyIGludGVyZmFjZXMgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VzLmpzXCIpO1xudmFyIHNhbml0aXplciA9IHJlcXVpcmUoXCIuL2FuYWx5emUvc2FuaXRpemVyL3Nhbml0aXplci5qc1wiKTtcbnZhciBCYXNlID0gcmVxdWlyZShcIi4vYmFzZS9pbmRleC5qc1wiKTtcbnZhciBHTFNMQ29tcGlsZXIgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZS9nbHNsL2NvbXBpbGVyLmpzXCIpLkdMU0xDb21waWxlcjtcbnZhciByZXNvbHZlciA9IHJlcXVpcmUoXCIuL3Jlc29sdmUvcmVzb2x2ZS5qc1wiKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKFwiLi9hbmFseXplL3ZhbGlkYXRpb25cIik7XG52YXIgYW5hbHl6ZXIgPSByZXF1aXJlKFwiLi9hbmFseXplXCIpO1xudmFyIFNwYWNlVmVjdG9yVHlwZSA9IGludGVyZmFjZXMuU3BhY2VWZWN0b3JUeXBlO1xudmFyIFNuaXBwZXRMaXN0ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUvc25pcHBldHMvc25pcHBldC1saXN0LmpzXCIpLlNuaXBwZXRMaXN0O1xudmFyIFNuaXBwZXRFbnRyeSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlL3NuaXBwZXRzL3NuaXBwZXQtbGlzdC5qc1wiKS5TbmlwcGV0RW50cnk7XG52YXIgVHlwZVN5c3RlbSA9IHJlcXVpcmUoXCIuL3R5cGUtc3lzdGVtL3R5cGUtc3lzdGVtLmpzXCIpO1xudmFyIFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vcGx1Z2luX3JlZ2lzdHJ5XCIpO1xuZnVuY3Rpb24gV29ya2luZ1NldCgpIHtcblx0dGhpcy5hc3QgPSBudWxsO1xuXHR0aGlzLmFhc3QgPSBudWxsO1xuXHR0aGlzLnJlc3VsdCA9IG51bGw7XG5cdHRoaXMucHJvY2Vzc2luZ0RhdGEgPSB7fTtcblx0dGhpcy5pbmplY3QgPSBudWxsO1xufVxuXG5Xb3JraW5nU2V0LnByb3RvdHlwZS5zZXRBc3QgPSBmdW5jdGlvbihhc3QpIHtcblx0dGhpcy5hc3QgPSBhc3Q7XG59O1xuXG5Xb3JraW5nU2V0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNvZGUsIG9wdCkge1xuXHRvcHQgPSBvcHQgfHwge307XG5cdHRoaXMuYXN0ID0gcGFyc2UoY29kZSwgb3B0KTtcbn07XG5cbldvcmtpbmdTZXQucHJvdG90eXBlLmFuYWx5emUgPSBmdW5jdGlvbihpbmplY3QsIGltcGxlbWVudGF0aW9uLCBvcHQpIHtcblx0b3B0ID0gb3B0IHx8IHt9O1xuXHRvcHQuZW50cnkgPSBvcHQuZW50cnkgfHwgXCJzaGFkZVwiO1xuXHRvcHQudmFsaWRhdGUgPSBvcHQudmFsaWRhdGUgIT09IHVuZGVmaW5lZCA/IG9wdC52YWxpZGF0ZSA6IHRydWU7XG5cdG9wdC50aHJvd09uRXJyb3IgPSBvcHQudGhyb3dPbkVycm9yICE9PSB1bmRlZmluZWQgPyBvcHQudGhyb3dPbkVycm9yIDogdHJ1ZTtcblx0b3B0LmltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XG5cdHRoaXMuaW5qZWN0ID0gb3B0LmluamVjdCA9IGluamVjdDtcblx0dGhpcy5hYXN0ID0gYW5hbHl6ZXIuYW5hbHl6ZSh0aGlzLmFzdCwgdGhpcy5wcm9jZXNzaW5nRGF0YSwgb3B0KTtcblx0cmV0dXJuIHRoaXMuYWFzdDtcbn07XG5cbldvcmtpbmdTZXQucHJvdG90eXBlLmluamVjdE1lbW9yeSA9IGZ1bmN0aW9uIChtZW0pIHtcblx0dGhpcy5hYXN0ID0gYW5hbHl6ZXIuaW5qZWN0TWVtb3J5KHRoaXMuYWFzdCwgbWVtLCB7XG5cdFx0aW5qZWN0OiB0aGlzLmluamVjdCxcblx0XHRlbnRyeTogXCJldmFsdWF0ZVwiXG5cdH0pO1xufTtcblxuV29ya2luZ1NldC5wcm90b3R5cGUuZ2V0UHJvY2Vzc2luZ0RhdGEgPSBmdW5jdGlvbihrZXkpIHtcblx0cmV0dXJuIHRoaXMucHJvY2Vzc2luZ0RhdGFba2V5XTtcbn07XG5cbldvcmtpbmdTZXQucHJvdG90eXBlLmNvbXBpbGVGcmFnbWVudFNoYWRlciA9IGZ1bmN0aW9uKG9wdCkge1xuXHR0aGlzLnJlc3VsdCA9IGNvbXBpbGVGcmFnbWVudFNoYWRlcih0aGlzLmFhc3QsIG9wdCk7XG5cdHJldHVybiB0aGlzLnJlc3VsdDtcbn07XG5cbldvcmtpbmdTZXQucHJvdG90eXBlLmNvbXBpbGVUb0Zhc3RsYW5lID0gZnVuY3Rpb24gKG9wdCkge1xuXHR2YXIgY29tcGlsZXIgPSBuZXcgKHJlcXVpcmUoXCIuL2dlbmVyYXRlL2Zhc3RsYW5lL2NvbXBpbGVyXCIpKShvcHQpO1xuXG5cdHJldHVybiBjb21waWxlci5jb21waWxlKHRoaXMuYWFzdCwgb3B0KTtcbn07XG5cbmZ1bmN0aW9uIGV4dHJhY3RQYXJhbXMoYXN0LCBvcHQpIHtcblx0b3B0ID0gb3B0IHx8IHt9O1xuXHRvcHQuZW50cnkgPSBvcHQuZW50cnkgfHwgXCJzaGFkZVwiO1xuXHRyZXR1cm4gZXh0cmFjdFBhcmFtZXRlcnMoYXN0LCBvcHQpO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVVc2VkUGFyYW1ldGVycyhjb2RlLCBvcHQpIHtcblx0b3B0ID0gb3B0IHx8IHt9O1xuXHRvcHQuZW50cnkgPSBvcHQuZW50cnkgfHwgXCJzaGFkZVwiO1xuXHR2YXIgYXN0ID0gcGFyc2UoY29kZSwgb3B0KTtcblx0dmFyIGFhc3QgPSBhbmFseXplKGFzdCwgb3B0KTtcblx0cmV0dXJuIGV4dHJhY3RQYXJhbWV0ZXJzKGFhc3QsIG9wdCk7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVJldHVyblR5cGUoY29kZSwgb3B0KSB7XG5cdG9wdCA9IG9wdCB8fCB7fTtcblx0b3B0LmVudHJ5ID0gb3B0LmVudHJ5IHx8IFwic2hhZGVcIjtcblx0dmFyIGFzdCA9IHBhcnNlKGNvZGUsIG9wdCk7XG5cdHZhciBhYXN0ID0gYW5hbHl6ZShhc3QsIG9wdCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWFzdC5ib2R5Lmxlbmd0aDsgKytpKVxuXHRcdGlmIChhYXN0LmJvZHlbaV0uaWQubmFtZSA9PT0gb3B0LmVudHJ5KVxuXHRcdFx0cmV0dXJuIGFhc3QuYm9keVtpXS5leHRyYS5yZXR1cm5JbmZvO1xufVxuXG5mdW5jdGlvbiBwYXJzZShhc3QsIG9wdCkge1xuXHRvcHQgPSBvcHQgfHwge307XG5cdGlmICh0eXBlb2YgYXN0ID09IFwiZnVuY3Rpb25cIilcblx0XHRhc3QgPSBhc3QudG9TdHJpbmcoKTtcblxuXHRpZiAodHlwZW9mIGFzdCA9PSBcInN0cmluZ1wiKVxuXHRcdHJldHVybiBwYXJzZXIucGFyc2UoYXN0LCB7cmF3OiB0cnVlLCBsb2M6IG9wdC5sb2MgfHwgZmFsc2V9KTtcblxuXHRyZXR1cm4gYXN0O1xufVxuXG5mdW5jdGlvbiBhbmFseXplKGFzdCwgb3B0KSB7XG5cdG9wdCA9IG9wdCB8fCB7fTtcblx0b3B0LmVudHJ5ID0gb3B0LmVudHJ5IHx8IFwic2hhZGVcIjtcblx0b3B0LnZhbGlkYXRlID0gb3B0LnZhbGlkYXRlICE9PSB1bmRlZmluZWQgPyBvcHQudmFsaWRhdGUgOiB0cnVlO1xuXHRvcHQudGhyb3dPbkVycm9yID0gb3B0LnRocm93T25FcnJvciAhPT0gdW5kZWZpbmVkID8gb3B0LnRocm93T25FcnJvciA6IHRydWU7XG5cdHJldHVybiBhbmFseXplci5hbmFseXplKHBhcnNlKGFzdCksIHt9LCBvcHQpO1xufVxuXG5mdW5jdGlvbiBnZXRTYW5pdGl6ZWRBc3Qoc3RyLCBvcHQpIHtcblx0dmFyIGFzdCA9IHBhcnNlKHN0ciwgb3B0KTtcblx0cmV0dXJuIHNhbml0aXplci5zYW5pdGl6ZShhc3QsIG9wdCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQW5kSW5mZXJlbmNlRXhwcmVzc2lvbihhc3QsIG9wdCkge1xuXHRhc3QgPSBwYXJzZShhc3QsIG9wdCk7XG5cdHJldHVybiBhbmFseXplKGFzdCwgb3B0KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNsb3N1cmVzKGFzdCwgaW1wbGVtZW50YXRpb24sIHByb2Nlc3NEYXRhLCBvcHQpIHtcblx0b3B0ID0gb3B0IHx8IHt9O1xuXHRwcm9jZXNzRGF0YSA9IHByb2Nlc3NEYXRhIHx8IHt9O1xuXHRyZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZUNsb3N1cmVzUHJlVHlwZUluZmVyZW5jZShhc3QsIGltcGxlbWVudGF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzRGF0YSwgb3B0KTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUZyYWdtZW50U2hhZGVyKGFhc3QsIG9wdCkge1xuXHRyZXR1cm4gbmV3IEdMU0xDb21waWxlcigpLmNvbXBpbGVGcmFnbWVudFNoYWRlcihhYXN0LCBvcHQpO1xufVxuXG5mdW5jdGlvbiB0b0phdmFTY3JpcHQoYWFzdCwgb3B0KSB7XG5cdHJldHVybiBjb2RlZ2VuLmdlbmVyYXRlKGFhc3QsIG9wdCk7XG59XG5cbmZ1bmN0aW9uIGdldFN5c3RlbSgpIHtcblx0cmV0dXJuIFR5cGVTeXN0ZW0uZ2V0UHJlZGVmaW5lZE9iamVjdChcIlN5c3RlbVwiKTtcbn1cblxuLy8gdmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuLy8gUGx1Z2luUmVnaXN0cnkucmVnaXN0ZXJNb2R1bGUoXCJzaGFkZVwiLCBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgXCIvbW9kdWxlcy9zaGFkZS5qc1wiKSk7XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuZXh0cmFjdFBhcmFtZXRlcnMgPSBleHRyYWN0UGFyYW1zO1xuZXhwb3J0cy5kZXRlcm1pbmVVc2VkUGFyYW1ldGVycyA9IGRldGVybWluZVVzZWRQYXJhbWV0ZXJzO1xuZXhwb3J0cy5kZXRlcm1pbmVSZXR1cm5UeXBlID0gZGV0ZXJtaW5lUmV0dXJuVHlwZTtcbmV4cG9ydHMucGFyc2VBbmRJbmZlcmVuY2VFeHByZXNzaW9uID0gcGFyc2VBbmRJbmZlcmVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5hbmFseXplID0gYW5hbHl6ZTtcbmV4cG9ydHMuZ2V0U3lzdGVtID0gZ2V0U3lzdGVtO1xuZXhwb3J0cy5yZXNvbHZlQ2xvc3VyZXMgPSByZXNvbHZlQ2xvc3VyZXM7XG5leHBvcnRzLnRvSmF2YVNjcmlwdCA9IHRvSmF2YVNjcmlwdDtcbmV4cG9ydHMuZ2V0U2FuaXRpemVkQXN0ID0gZ2V0U2FuaXRpemVkQXN0O1xuXG5leHBvcnRzLlRZUEVTID0gaW50ZXJmYWNlcy5UWVBFUztcbmV4cG9ydHMuT0JKRUNUX0tJTkRTID0gaW50ZXJmYWNlcy5PQkpFQ1RfS0lORFM7XG5leHBvcnRzLlNPVVJDRVMgPSBpbnRlcmZhY2VzLlNPVVJDRVM7XG5leHBvcnRzLlNQQUNFX1ZFQ1RPUl9UWVBFUyA9IFNwYWNlVmVjdG9yVHlwZTtcbmV4cG9ydHMuVmVjMiA9IGludGVyZmFjZXMuVmVjMjtcbmV4cG9ydHMuVmVjMyA9IGludGVyZmFjZXMuVmVjMztcbmV4cG9ydHMuVmVjNCA9IGludGVyZmFjZXMuVmVjNDtcbmV4cG9ydHMuVGV4dHVyZSA9IGludGVyZmFjZXMuVGV4dHVyZTtcbmV4cG9ydHMuQ29sb3IgPSBpbnRlcmZhY2VzLkNvbG9yO1xuZXhwb3J0cy5NYXQzID0gaW50ZXJmYWNlcy5NYXQzO1xuZXhwb3J0cy5NYXQ0ID0gaW50ZXJmYWNlcy5NYXQ0O1xuZXhwb3J0cy5Xb3JraW5nU2V0ID0gV29ya2luZ1NldDtcbmV4cG9ydHMuU25pcHBldExpc3QgPSBTbmlwcGV0TGlzdDtcbmV4cG9ydHMuU25pcHBldEVudHJ5ID0gU25pcHBldEVudHJ5O1xuXG5leHBvcnRzLnZlcnNpb24gPSBcIjAuMC4wXCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuTWF0aC5jbGFtcCA9IGZ1bmN0aW9uKHgsIG1pblZhbCwgbWF4VmFsKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHgsIG1pblZhbCksIG1heFZhbCk7XG59O1xuXG5NYXRoLnNtb290aHN0ZXAgPSBmdW5jdGlvbihlZGdlMSwgZWRnZTIsIHgpIHtcbiAgICB2YXIgdCA9IE1hdGguY2xhbXAoKHggLSBlZGdlMSkgLyAoZWRnZTIgLSBlZGdlMSksIDAuMCwgMS4wKTtcbiAgICByZXR1cm4gdCAqIHQgKiAoMy4wIC0gMi4wICogdCk7XG59O1xuXG5NYXRoLnN0ZXAgPSBmdW5jdGlvbihlZGdlLCB4KSB7XG4gICAgcmV0dXJuIHggPCBlZGdlID8gMCA6IDE7XG59O1xuXG5NYXRoLmZyYWN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IC0gTWF0aC5mbG9vcih4KTtcbn07XG5cbk1hdGgubWl4ID0gZnVuY3Rpb24oeCwgeSwgYSkge1xuICAgIHZhciBzaW1wbGUgPSB0eXBlb2YgeCA9PSBcIm51bWJlclwiO1xuICAgIHZhciBhc2ltcGxlID0gdHlwZW9mIGEgPT0gXCJudW1iZXJcIjtcbiAgICBpZihzaW1wbGUgJiYgYXNpbXBsZSlcbiAgICAgICAgcmV0dXJuIHggKiAoMSAtIGEpICsgeSAqIGE7XG4gICAgaWYgKGFzaW1wbGUpXG4gICAgICAgIHJldHVybiB4Lm11bCgxIC0gYSkuYWRkKHkubXVsKGEpKTtcbiAgICByZXR1cm4geC5tdWwoYS5tdWwoLTEpLmFkZCgxKSkuYWRkKHkubXVsKGEpKTtcbn07XG5cbk1hdGguc2F0dXJhdGUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBNYXRoLmNsYW1wKHgsIDAuMCwgMS4wKTtcbn07XG5cblxuXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKTtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgdmVjdG9yID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xudmFyIFZlYzIgPSB2ZWN0b3IuVmVjMjtcbnZhciBWZWMzID0gdmVjdG9yLlZlYzM7XG52YXIgVmVjNCA9IHZlY3Rvci5WZWM0O1xuXG5mdW5jdGlvbiBNYXQyKCkge1xuXHRjb25zdHJ1Y3RNYXRyaXgodGhpcywgTWF0MiwgMiwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gTWF0MygpIHtcblx0Y29uc3RydWN0TWF0cml4KHRoaXMsIE1hdDMsIDMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIE1hdDQoKSB7XG5cdGNvbnN0cnVjdE1hdHJpeCh0aGlzLCBNYXQ0LCA0LCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RNYXRyaXgodGhhdCwgdHlwZSwgY29sdW1uU2l6ZSwgYXJncykge1xuXHRpZiAoISh0aGF0IGluc3RhbmNlb2YgdHlwZSkpXG5cdFx0dGhhdCA9IE9iamVjdC5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXG5cdGlmIChhcmdzWzBdIGluc3RhbmNlb2YgdHlwZSlcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XCJDb3B5IGNvbnN0cnVjdGlvbiBvZiBhbiBpbW11dGFibGUgdHlwZSBpcyBtZWFuaW5nbGVzcyFcIik7XG5cblx0dmFyIGZsYXRTaXplID0gY29sdW1uU2l6ZSAqIGNvbHVtblNpemU7XG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLkJZVEVTX1BFUl9FTEVNRU5UKSB7XG5cdFx0dmFyIGFycmF5ID0gYXJnc1swXTtcblx0XHRpZiAoYXJyYXkubGVuZ3RoICE9PSBmbGF0U2l6ZSlcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJUeXBlZCBhcnJheSBmb3IgY29uc3RydWN0aW9uIG9mIE1hdFwiXG5cdFx0XHRcdFx0XHRcdFx0KyBjb2x1bW5TaXplXG5cdFx0XHRcdFx0XHRcdFx0KyBcIiBoYXMgdG8gaGF2ZSB0aGUgY29ycmVjdCBzaXplIVwiKTtcblx0XHR0aGF0LmRhdGEgPSBhcnJheTtcblx0fSBlbHNlIHtcblx0XHR0aGF0LmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRTaXplKTtcblx0XHRmaWxsTWF0cml4KHRoYXQsIGNvbHVtblNpemUsIGFyZ3MpO1xuXHR9XG5cblx0cmV0dXJuIHRoYXQ7XG59XG5cbmZ1bmN0aW9uIGZpbGxNYXRyaXgoZGVzdCwgY29sdW1uU2l6ZSwgYXJncykge1xuXHR2YXIgZGlhZ29uYWxFbnRyeSA9IDE7XG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSlcblx0XHRkaWFnb25hbEVudHJ5ID0gYXJnc1swXTtcblxuXHRpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPT09IDEpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtblNpemU7ICsraSlcblx0XHRcdGRlc3QuZGF0YVtpICogY29sdW1uU2l6ZSArIGldID0gZGlhZ29uYWxFbnRyeTtcblx0XHRyZXR1cm4gZGVzdDtcblx0fVxuXG5cdHZhciBzaXplID0gY29sdW1uU2l6ZSAqIGNvbHVtblNpemU7XG5cdHZhciBjb21wb25lbnRJZHggPSAwO1xuXHRmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdzLmxlbmd0aDsgKythcmdJZHgpIHtcblx0XHR2YXIgYXJnID0gYXJnc1thcmdJZHhdO1xuXHRcdHZhciBhcmdDb21wb25lbnRDb3VudCA9IGFyZy5kYXRhID8gYXJnLmRhdGEubGVuZ3RoIDogMTtcblxuXHRcdGlmIChhcmdDb21wb25lbnRDb3VudCA+IGNvbHVtblNpemUpXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XHRcIlZlY3RvciBvZiBzaXplIFwiICsgYXJnQ29tcG9uZW50Q291bnRcblx0XHRcdFx0KyBcIiB0b28gbGFyZ2UgdG8gaW5pdGlhbGl6ZSBhIG1hdHJpeCBvZiBjb2x1bW4gc2l6ZSBcIlxuXHRcdFx0XHQrIGNvbHVtblNpemUgKyBcIiFcIik7XG5cblx0XHRpZiAoYXJnQ29tcG9uZW50Q291bnQgKyBjb21wb25lbnRJZHggJSBjb2x1bW5TaXplID4gY29sdW1uU2l6ZSlcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdFx0XHRcdFwiVG9vIG1hbnkgYXJndW1lbnRzIGZvciBjb2x1bW4gY29uc3RydWN0aW9uIG9mIE1hdFwiICsgY29sdW1uU2l6ZVxuXHRcdFx0XHQrIFwiIVwiKTtcblxuXHRcdGlmIChhcmdDb21wb25lbnRDb3VudCArIGNvbXBvbmVudElkeCA+IHNpemUpXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVG9vIG1hbnkgYXJndW1lbnRzIGZvciBNYXRcIiArIGNvbHVtblNpemVcblx0XHRcdFx0XHRcdFx0XHQrIFwiIGNvbnN0cnVjdGlvbiAhXCIpO1xuXG5cdFx0aWYgKGFyZ0NvbXBvbmVudENvdW50ID09PSAxKVxuXHRcdFx0ZGVzdC5kYXRhW2NvbXBvbmVudElkeCsrXSA9IGFyZztcblx0XHRlbHNlXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvbXBvbmVudENvdW50OyArK2kpXG5cdFx0XHRcdGRlc3QuZGF0YVtjb21wb25lbnRJZHgrK10gPSBhcmcuZGF0YVtpXTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRJZHggPCBzaXplKVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3IgTWF0IFwiICsgY29sdW1uU2l6ZSArIFwiIVwiKTtcblxuXHRyZXR1cm4gZGVzdDtcbn1cblxudmFyIG1ldGhvZHMgPSB7XG5cdHVuYXJ5U2NhbGFyUmVzdWx0OiBbXCJkZXRlcm1pbmFudFwiXSxcblx0dW5hcnk6IFtcImludmVydFwiLCBcInRyYW5zcG9zZVwiXVxufTtcblxudXRpbHMuZm9yd2FyZFByb3RvdHlwZU1ldGhvZHNUb0dMTWF0cml4KE1hdDIsIGdsTWF0cml4Lm1hdDIsIG1ldGhvZHMpO1xudXRpbHMuZm9yd2FyZFByb3RvdHlwZU1ldGhvZHNUb0dMTWF0cml4KE1hdDMsIGdsTWF0cml4Lm1hdDMsIG1ldGhvZHMpO1xudXRpbHMuZm9yd2FyZFByb3RvdHlwZU1ldGhvZHNUb0dMTWF0cml4KE1hdDQsIGdsTWF0cml4Lm1hdDQsIG1ldGhvZHMpO1xuXG4vLyB3ZSBoYW5kbGUgbXVsIHNwZWNpYWwgYmVjYXVzZSB3ZSBvdmVybG9hZCBpdCBmb3IgdmVjdG9yIGFuZCBtYXRyaWNlc1xuLy8gd2UgY291bGQgYWxzbyBoYW5kbGUgc2NhbGFyIG11bHRpcGxpY2F0aW9uIGhlcmUgaWYgbmVlZGVkXG5NYXQyLnByb3RvdHlwZS5tdWwgPSBjcmVhdGVNdWxGdW5jdGlvbihNYXQyLCA0LCBWZWMyLCBnbE1hdHJpeC5tYXQyLm11bCxcblx0XHRcdFx0XHRcdFx0XHRcdCAgIGdsTWF0cml4LnZlYzIudHJhbnNmb3JtTWF0Mik7XG5NYXQzLnByb3RvdHlwZS5tdWwgPSBjcmVhdGVNdWxGdW5jdGlvbihNYXQzLCA5LCBWZWMzLCBnbE1hdHJpeC5tYXQzLm11bCxcblx0XHRcdFx0XHRcdFx0XHRcdCAgIGdsTWF0cml4LnZlYzMudHJhbnNmb3JtTWF0Myk7XG5NYXQ0LnByb3RvdHlwZS5tdWwgPSBjcmVhdGVNdWxGdW5jdGlvbihNYXQ0LCAxNiwgVmVjNCwgZ2xNYXRyaXgubWF0NC5tdWwsXG5cdFx0XHRcdFx0XHRcdFx0XHQgICBnbE1hdHJpeC52ZWM0LnRyYW5zZm9ybU1hdDQpO1xuXG5mdW5jdGlvbiBjcmVhdGVNdWxGdW5jdGlvbihtYXRUeXBlLCBjb21wb25lbnRTaXplLCB2ZWNUeXBlLCBnbE1hdHJpeE1hdE11bCxcblx0XHRcdFx0XHRcdCAgIGdsTWF0cml4VmVjVHJhbnMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXguZGF0YS5sZW5ndGggPT09IGNvbXBvbmVudFNpemUpIHtcblx0XHRcdHZhciByZXN1bHQgPSBuZXcgbWF0VHlwZSgpO1xuXHRcdFx0Z2xNYXRyaXhNYXRNdWwocmVzdWx0LmRhdGEsIHRoaXMuZGF0YSwgbWF0cml4LmRhdGEpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0Ly8gaXRzIG5vdCBhIG1hdHJpeCBzbyB3ZSB0cnkgdG8gYnVpbGQgYSB2ZWN0b3IgZnJvbSBhbGwgYXJndW1lbnRzIHRoYXRcblx0XHQvLyBmaXRzIHRoZSByb3cgc2l6ZSAoYmVjYXVzZSB3ZSBvbmx5IGhhbmRsZSBzcXVhcmUgbWF0cmljZXMgaXRzIGVxdWFsXG5cdFx0Ly8gdG8gdGhlIGNvbHVtbiBzaXplKVxuXHRcdHZhciByaHMgPSB1dGlscy50b1R5cGUodmVjVHlwZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IHZlY1R5cGUoKTtcblx0XHRnbE1hdHJpeFZlY1RyYW5zKHJlc3VsdC5kYXRhLCByaHMuZGF0YSwgdGhpcy5kYXRhKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59XG5cbmdlbmVyYXRlUm93Q29sdW1uQWNjZXNzb3JzKE1hdDIsIDIpO1xuZ2VuZXJhdGVSb3dDb2x1bW5BY2Nlc3NvcnMoTWF0MywgMyk7XG5nZW5lcmF0ZVJvd0NvbHVtbkFjY2Vzc29ycyhNYXQ0LCA0KTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVSb3dDb2x1bW5BY2Nlc3NvcnModHlwZSwgY29sdW1uU2l6ZSkge1xuXHRmb3IgKHZhciByb3dJZHggPSAxOyByb3dJZHggPD0gY29sdW1uU2l6ZTsgKytyb3dJZHgpXG5cdFx0Zm9yICh2YXIgY29sdW1uSWR4ID0gMTsgY29sdW1uSWR4IDw9IGNvbHVtblNpemU7ICsrY29sdW1uSWR4KVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFxuXHRcdFx0XHR0eXBlLnByb3RvdHlwZSwgXCJtXCIgKyByb3dJZHggKyBcIlwiICsgY29sdW1uSWR4LCB7XG5cdFx0XHRcdFx0Z2V0OiAoZnVuY3Rpb24ocm93SWR4LCBjb2x1bW5JZHgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGF0YVtyb3dJZHggKyBjb2x1bW5JZHggKiBjb2x1bW5TaXplXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KShyb3dJZHggLSAxLCBjb2x1bW5JZHggLSAxKSxcblx0XHRcdFx0XHRzZXQ6IChmdW5jdGlvbihyb3dJZHgsIGNvbHVtbklkeCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmRhdGFbcm93SWR4ICsgY29sdW1uSWR4ICogY29sdW1uU2l6ZV1cblx0XHRcdFx0XHRcdFx0XHQgICA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKHJvd0lkeCAtIDEsIGNvbHVtbklkeCAtIDEpXG5cdFx0XHRcdH0pO1xufVxuXG5nZW5lcmF0ZUNvbHVtbkFjY2Vzc29ycyhNYXQyLCAyLCBWZWMyKTtcbmdlbmVyYXRlQ29sdW1uQWNjZXNzb3JzKE1hdDMsIDMsIFZlYzMpO1xuZ2VuZXJhdGVDb2x1bW5BY2Nlc3NvcnMoTWF0NCwgNCwgVmVjNCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sdW1uQWNjZXNzb3JzKHR5cGUsIGNvbHVtblNpemUsIHZlY1R5cGUpIHtcblx0Zm9yICh2YXIgY29sdW1uSWR4ID0gMTsgY29sdW1uSWR4IDw9IGNvbHVtblNpemU7ICsrY29sdW1uSWR4KSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUucHJvdG90eXBlLCBcImNcIiArIGNvbHVtbklkeCwge1xuXHRcdFx0Z2V0OiAoZnVuY3Rpb24oY29sdW1uSWR4KSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmVjVHlwZShuZXcgdGhpcy5kYXRhLmNvbnN0cnVjdG9yKHRoaXMuZGF0YS5zdWJhcnJheShcblx0XHRcdFx0XHRcdGNvbHVtbklkeCAqIGNvbHVtblNpemUsXG5cdFx0XHRcdFx0XHRjb2x1bW5JZHggKiBjb2x1bW5TaXplICsgY29sdW1uU2l6ZSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkoY29sdW1uSWR4IC0gMSksXG5cdFx0XHRzZXQ6IChmdW5jdGlvbihjb2x1bW5JZHgpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5ld0NvbHVtbikge1xuXHRcdFx0XHRcdGlmICghKG5ld0NvbHVtbiBpbnN0YW5jZW9mIHZlY1R5cGUpKVxuXHRcdFx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiQ29sdW1ucyBvZiBhIE1hdFwiICsgY29sdW1uU2l6ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrIFwiIGNhbiBvbmx5IGJlIHNldCB3aXRoIGEgXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0KyB2ZWNUeXBlLm5hbWUpO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSBuZXdDb2x1bW4uZGF0YS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyArK2lkeClcblx0XHRcdFx0XHRcdHRoaXMuZGF0YVtjb2x1bW5JZHggKiBjb2x1bW5TaXplICsgaWR4XVxuXHRcdFx0XHRcdFx0XHQ9IG5ld0NvbHVtbi5kYXRhW2lkeF07XG5cdFx0XHRcdH1cblx0XHRcdH0pKGNvbHVtbklkeCAtIDEpXG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0cy5NYXQyID0gTWF0MjtcbmV4cG9ydHMuTWF0MyA9IE1hdDM7XG5leHBvcnRzLk1hdDQgPSBNYXQ0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGZvcndhcmRQcm90b3R5cGVNZXRob2RzVG9HTE1hdHJpeCh0eXBlLCBnbE1hdHJpeFR5cGUsIGZ1bmN0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uTGlzdC51bmFyeVNjYWxhclJlc3VsdCA9IGZ1bmN0aW9uTGlzdC51bmFyeVNjYWxhclJlc3VsdCB8fCBbXTtcbiAgICBmdW5jdGlvbkxpc3QudW5hcnlTY2FsYXJSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHR5cGUucHJvdG90eXBlW2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xNYXRyaXhUeXBlW2Z1bmN0aW9uTmFtZV0odGhpcy5kYXRhKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uTGlzdC5iaW5hcnlTY2FsYXJSZXN1bHQgPSBmdW5jdGlvbkxpc3QuYmluYXJ5U2NhbGFyUmVzdWx0IHx8IFtdO1xuICAgIGZ1bmN0aW9uTGlzdC5iaW5hcnlTY2FsYXJSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHR5cGUucHJvdG90eXBlW2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xNYXRyaXhUeXBlW2Z1bmN0aW9uTmFtZV0odGhpcy5kYXRhLCB0b1R5cGUuY2FsbChudWxsLCB0eXBlLCBhcmd1bWVudHMpLmRhdGEpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb25MaXN0LnVuYXJ5ID0gZnVuY3Rpb25MaXN0LnVuYXJ5IHx8IFtdO1xuICAgIGZ1bmN0aW9uTGlzdC51bmFyeS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgdHlwZS5wcm90b3R5cGVbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgZ2xNYXRyaXhUeXBlW2Z1bmN0aW9uTmFtZV0ocmVzdWx0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb25MaXN0LmJpbmFyeSA9IGZ1bmN0aW9uTGlzdC5iaW5hcnkgfHwgW107XG4gICAgZnVuY3Rpb25MaXN0LmJpbmFyeS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgdHlwZS5wcm90b3R5cGVbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByaHMgPSB0b1R5cGUuY2FsbChudWxsLCB0eXBlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0eXBlKCk7XG4gICAgICAgICAgICBnbE1hdHJpeFR5cGVbZnVuY3Rpb25OYW1lXShyZXN1bHQuZGF0YSwgdGhpcy5kYXRhLCByaHMuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0b1R5cGUodHlwZSwgYXJncykge1xuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG5cbiAgICByZXR1cm4gdHlwZS5hcHBseShudWxsLCBhcmdzKTtcbn1cblxudmFyIHZlY3RvckNvbXBvbmVudE5hbWVDYXRlZ29yaWVzXG4gICAgPSBbW1wieFwiLCBcInlcIiwgXCJ6XCIsIFwid1wiXSwgW1wiclwiLCBcImdcIiwgXCJiXCIsIFwiYVwiXSwgW1wic1wiLCBcInRcIiwgXCJwXCIsIFwicVwiXV07XG5cbmZ1bmN0aW9uIGF0dGFjaFN3aXp6bGVzKHZlY0xlbmd0aCwgZXZhbHVhdG9yKSB7XG4gICAgYWRkU2luZ2xlUHJvcGVydGllcyh2ZWNMZW5ndGgsIGV2YWx1YXRvcik7XG4gICAgdmVjdG9yQ29tcG9uZW50TmFtZUNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbihjb21wb25lbnROYW1lcykge1xuICAgICAgICB2YXIgYWxsb3dlZENvbXBvbmVudE5hbWVzID0gY29tcG9uZW50TmFtZXMuc2xpY2UoMCwgdmVjTGVuZ3RoKTtcbiAgICAgICAgWzIsIDMsIDRdLmZvckVhY2goZnVuY3Rpb24obWFza0xlbmd0aCkge1xuICAgICAgICAgICAgZ2VuZXJhdGVTd2l6emxlQ29tYmluYXRpb25zKGFsbG93ZWRDb21wb25lbnROYW1lcywgbWFza0xlbmd0aClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChldmFsdWF0b3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkU2luZ2xlUHJvcGVydGllcyh2ZWNMZW5ndGgsIGV2YWx1YXRvcikge1xuICAgIHZlY3RvckNvbXBvbmVudE5hbWVDYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24oY29tcG9uZW50TmFtZXMpIHtcbiAgICAgICAgY29tcG9uZW50TmFtZXMuc2xpY2UoMCwgdmVjTGVuZ3RoKS5mb3JFYWNoKGZ1bmN0aW9uIChzd2l6emxlLCBpZHgpIHtcbiAgICAgICAgICAgIGV2YWx1YXRvcihbc3dpenpsZV0sIGlkeClcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3dpenpsZUNvbWJpbmF0aW9ucyhhdmFpbGFibGVDb21wb25lbnRzLCBjb21iaW5hdGlvblNpemUpIHtcbiAgICB2YXIgc2V0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluYXRpb25TaXplOyArK2kpXG4gICAgICAgIHNldHNbaV0gPSBhdmFpbGFibGVDb21wb25lbnRzO1xuXG4gICAgcmV0dXJuIHNldHMucmVkdWNlKGZ1bmN0aW9uKGN1cnJlbnRDb21iaW5hdGlvbnMsIGN1cnJlbnRTZXQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb21iaW5hdGlvbnMubWFwKGZ1bmN0aW9uKGNvbWJpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZXQubWFwKGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluYXRpb24uY29uY2F0KFtjb21wb25lbnRdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICAgICAgICB9KTtcbiAgICB9LCBbW11dKTtcbn1cblxuZXhwb3J0cy5mb3J3YXJkUHJvdG90eXBlTWV0aG9kc1RvR0xNYXRyaXggPSBmb3J3YXJkUHJvdG90eXBlTWV0aG9kc1RvR0xNYXRyaXg7XG5leHBvcnRzLnRvVHlwZSA9IHRvVHlwZTtcbmV4cG9ydHMuYXR0YWNoU3dpenpsZXMgPSBhdHRhY2hTd2l6emxlczsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBWZWMyKHgsIHkpIHtcblx0cmV0dXJuIGNvbnN0cnVjdFZlY3Rvcih0aGlzLCBWZWMyLCAyLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBWZWMzKHgsIHksIHopIHtcblx0cmV0dXJuIGNvbnN0cnVjdFZlY3Rvcih0aGlzLCBWZWMzLCAzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBWZWM0KHgsIHksIHosIHcpIHtcblx0cmV0dXJuIGNvbnN0cnVjdFZlY3Rvcih0aGlzLCBWZWM0LCA0LCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RWZWN0b3IodGhhdCwgdHlwZSwgc2l6ZSwgYXJncykge1xuXHRpZiAoISh0aGF0IGluc3RhbmNlb2YgdHlwZSkpXG5cdFx0dGhhdCA9IE9iamVjdC5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pKVxuXHRcdGFyZ3MgPSBhcmdzWzBdO1xuXG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLmRhdGEgPT09IDEgJiYgYXJnc1swXS5kYXRhLmxlbmd0aCA+PSBzaXplKVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdFx0XHRcIkNvcHkgY29uc3RydWN0aW9uIG9mIGFuIGltbXV0YWJsZSB0eXBlIG9yIGNvbnN0cnVjdGlvbiBmcm9tIGEgdmVjdG9yIG9mIGdyZWF0ZXIgc2l6ZSBpcyBub3QgYWxsb3dlZCFcIik7XG5cblx0aWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0uQllURVNfUEVSX0VMRU1FTlQpIHtcblx0XHR2YXIgYXJyYXkgPSBhcmdzWzBdO1xuXHRcdGlmIChhcnJheS5sZW5ndGggIT09IHNpemUpXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHlwZWQgYXJyYXkgZm9yIGNvbnN0cnVjdGlvbiBvZiBWZWNcIiArIHNpemVcblx0XHRcdFx0XHRcdFx0XHQrIFwiIGhhcyB0byBoYXZlIHRoZSBjb3JyZWN0IHNpemUhXCIpO1xuXHRcdHRoYXQuZGF0YSA9IGFycmF5O1xuXHR9IGVsc2Uge1xuXHRcdHRoYXQuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG5cdFx0ZmlsbFZlY1godGhhdCwgc2l6ZSwgYXJncyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0LnNlYWwodGhhdCk7XG59XG5cbmZ1bmN0aW9uIGZpbGxWZWNYKGRlc3QsIHNpemUsIGFyZ3MpIHtcblx0aWYgKGFyZ3MubGVuZ3RoID09PSAwKVxuXHRcdHJldHVybiBkZXN0O1xuXG5cdGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHRcdGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHNpemU7ICsraWR4KVxuXHRcdFx0ZGVzdC5kYXRhW2lkeF0gPSBhcmdzWzBdO1xuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0dmFyIGNvbXBvbmVudElkeCA9IDA7XG5cdGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ3MubGVuZ3RoOyArK2FyZ0lkeCkge1xuXHRcdHZhciBhcmcgPSBhcmdzW2FyZ0lkeF07XG5cdFx0dmFyIGFyZ0NvbXBvbmVudENvdW50ID0gYXJnLmRhdGEgPyBhcmcuZGF0YS5sZW5ndGggOiAxO1xuXHRcdGlmIChhcmdDb21wb25lbnRDb3VudCArIGNvbXBvbmVudElkeCA+IHNpemUpXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVG9vIG1hbnkgYXJndW1lbnRzIGZvciBWZWNcIiArIHNpemVcblx0XHRcdFx0XHRcdFx0XHQrIFwiIGNvbnN0cnVjdGlvbiFcIik7XG5cblx0XHRpZiAoYXJnQ29tcG9uZW50Q291bnQgPT09IDEpXG5cdFx0XHRkZXN0LmRhdGFbY29tcG9uZW50SWR4KytdID0gYXJnO1xuXHRcdGVsc2Vcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ29tcG9uZW50Q291bnQ7ICsraSlcblx0XHRcdFx0ZGVzdC5kYXRhW2NvbXBvbmVudElkeCsrXSA9IGFyZy5kYXRhW2ldO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudElkeCA8IHNpemUpXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBlbm91Z2ggYXJndW1lbnRzIGZvciBWZWNcIiArIHNpemVcblx0XHRcdFx0XHRcdFx0KyBcIiBjb25zdHJ1Y3Rpb24hXCIpO1xuXG5cdHJldHVybiBkZXN0O1xufVxuXG52YXIgbWV0aG9kcyA9IHtcblx0dW5hcnlTY2FsYXJSZXN1bHQ6IFtcImxlbmd0aFwiXSxcblx0YmluYXJ5U2NhbGFyUmVzdWx0OiBbXCJkb3RcIl0sXG5cdHVuYXJ5OiBbXCJub3JtYWxpemVcIiwgXCJuZWdhdGVcIl0sXG5cdGJpbmFyeTogW1wiYWRkXCIsIFwic3ViXCIsIFwibXVsXCIsIFwiZGl2XCJdXG59O1xuXG52YXIgdmVjdG9yQ29tcG9uZW50TmFtZUNhdGVnb3JpZXNcblx0PSBbW1wieFwiLCBcInlcIiwgXCJ6XCIsIFwid1wiXSwgW1wiclwiLCBcImdcIiwgXCJiXCIsIFwiYVwiXSwgW1wic1wiLCBcInRcIiwgXCJwXCIsIFwicVwiXV07XG5cbnZhciBzaXplVHlwZU1hcHBpbmcgPSB7XG5cdDI6IFZlYzIsXG5cdDM6IFZlYzMsXG5cdDQ6IFZlYzRcbn07XG5cbnV0aWxzLmZvcndhcmRQcm90b3R5cGVNZXRob2RzVG9HTE1hdHJpeChWZWMyLCBnbE1hdHJpeC52ZWMyLCBtZXRob2RzKTtcbnV0aWxzLmF0dGFjaFN3aXp6bGVzKDIsIGFkZFN3aXp6bGVHZXR0ZXIuYmluZCh1bmRlZmluZWQsIFZlYzIucHJvdG90eXBlKSk7XG5cbnV0aWxzLmZvcndhcmRQcm90b3R5cGVNZXRob2RzVG9HTE1hdHJpeChWZWM0LCBnbE1hdHJpeC52ZWM0LCBtZXRob2RzKTtcbnV0aWxzLmF0dGFjaFN3aXp6bGVzKDMsIGFkZFN3aXp6bGVHZXR0ZXIuYmluZCh1bmRlZmluZWQsIFZlYzMucHJvdG90eXBlKSk7XG5cbi8vIGFkZCBjcm9zcyBwcm9kdWN0IGZvciB2ZWMzIG9ubHlcbm1ldGhvZHMuYmluYXJ5LnB1c2goXCJjcm9zc1wiKTtcbnV0aWxzLmZvcndhcmRQcm90b3R5cGVNZXRob2RzVG9HTE1hdHJpeChWZWMzLCBnbE1hdHJpeC52ZWMzLCBtZXRob2RzKTtcbnV0aWxzLmF0dGFjaFN3aXp6bGVzKDQsIGFkZFN3aXp6bGVHZXR0ZXIuYmluZCh1bmRlZmluZWQsIFZlYzQucHJvdG90eXBlKSk7XG5cblxuZnVuY3Rpb24gYWRkU3dpenpsZUdldHRlcih0eXBlLCBzd2l6emxlLCBpZHgpIHtcblx0aWYgKHN3aXp6bGUubGVuZ3RoID4gMSkge1xuXHRcdHZhciByZXN1bHRUeXBlID0gc2l6ZVR5cGVNYXBwaW5nW3N3aXp6bGUubGVuZ3RoXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgc3dpenpsZS5qb2luKFwiXCIpLCB7XG5cdFx0XHRnZXQ6IChmdW5jdGlvbiAoc3dpenpsZSwgcmVzdWx0VHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gbmV3IHRoaXMuZGF0YS5jb25zdHJ1Y3Rvcihzd2l6emxlLmxlbmd0aCk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzd2l6emxlLmxlbmd0aDsgKytpKVxuXHRcdFx0XHRcdFx0YXJnc1tpXSA9IHRoaXNbc3dpenpsZVtpXV07XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0VHlwZShhcmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkoc3dpenpsZSwgcmVzdWx0VHlwZSlcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgc3dpenpsZS5qb2luKFwiXCIpLCB7XG5cdFx0XHRnZXQ6IChmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGF0YVtpZHhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9KShpZHgpXG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0cy5WZWMyID0gVmVjMjtcbmV4cG9ydHMuVmVjMyA9IFZlYzM7XG5leHBvcnRzLlZlYzQgPSBWZWM0O1xuIiwiKGZ1bmN0aW9uIChucykge1xuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4vYmFzZS9pbmRleC5qc1wiKTtcbiAgICB2YXIgQ29kZUdlbiA9IHJlcXVpcmUoXCJlc2NvZGVnZW5cIik7XG4gICAgdmFyIFZlY01hdGggPSByZXF1aXJlKFwiLi9iYXNlL3ZlY21hdGguanNcIikuVmVjTWF0aDtcblxuXG4gICAgLyoqXG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKi9cbiAgICB2YXIgVHlwZXMgPSBucy5UWVBFUyA9IHtcbiAgICAgICAgQU5ZOiBcImFueVwiLFxuICAgICAgICBJTlQ6IFwiaW50XCIsXG4gICAgICAgIE5VTUJFUjogXCJudW1iZXJcIixcbiAgICAgICAgQk9PTEVBTjogXCJib29sZWFuXCIsXG4gICAgICAgIE9CSkVDVDogXCJvYmplY3RcIixcbiAgICAgICAgQVJSQVk6IFwiYXJyYXlcIixcbiAgICAgICAgTlVMTDogXCJudWxsXCIsXG4gICAgICAgIFVOREVGSU5FRDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgRlVOQ1RJT046IFwiZnVuY3Rpb25cIixcbiAgICAgICAgU1RSSU5HOiBcInN0cmluZ1wiLFxuICAgICAgICBJTlZBTElEOiBcImludmFsaWRcIlxuICAgIH1cblxuICAgIHZhciBLaW5kcyA9IG5zLk9CSkVDVF9LSU5EUyA9IHtcbiAgICAgICAgQU5ZOiBcImFueVwiLFxuICAgICAgICBWRUMyOiBcIlZlYzJcIiwgLy8gdmlydHVhbCBraW5kc1xuICAgICAgICBWRUMzOiBcIlZlYzNcIiwgLy8gdmlydHVhbCBraW5kc1xuICAgICAgICBWRUM0OiBcIlZlYzRcIiwgLy8gdmlydHVhbCBraW5kc1xuICAgICAgICBNQVRSSVgzOiBcIk1hdDNcIixcbiAgICAgICAgTUFUUklYNDogXCJNYXQ0XCIsXG4gICAgICAgIFRFWFRVUkU6IFwiVGV4dHVyZVwiLFxuICAgICAgICBDT0xPUl9DTE9TVVJFOiBcImNvbG9yX2Nsb3N1cmVcIlxuICAgIH1cblxuICAgIHZhciBTZW1hbnRpY3MgPSBucy5TRU1BTlRJQ1MgPSB7XG4gICAgICAgIENPTE9SOiAnY29sb3InLFxuICAgICAgICBOT1JNQUw6ICdub3JtYWwnLFxuICAgICAgICBTQ0FMQVJfMF9UT18xOiAnc2NhbGFyMFRvMScsXG4gICAgICAgIFVOS05PV046ICd1bmtub3duJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc3NpYmxlIFNwYWNlc1xuICAgICAqIEBlbnVtXG4gICAgICovXG4gICAgdmFyIFNwYWNlVHlwZSA9IG5zLlNwYWNlVHlwZSA9IHtcbiAgICAgICAgT0JKRUNUOiAwLFxuICAgICAgICBWSUVXOiAxLFxuICAgICAgICBXT1JMRDogMixcbiAgICAgICAgUkVTVUxUOiA1XG4gICAgfTtcbiAgICB2YXIgVmVjdG9yVHlwZSA9IG5zLlZlY3RvclR5cGUgPSB7XG4gICAgICAgIE5PTkU6IDAsXG4gICAgICAgIFBPSU5UOiAxLFxuICAgICAgICBOT1JNQUw6IDJcbiAgICB9O1xuICAgIG5zLlNwYWNlVmVjdG9yVHlwZSA9IHtcbiAgICAgICAgT0JKRUNUOiBTcGFjZVR5cGUuT0JKRUNULFxuICAgICAgICBWSUVXX1BPSU5UIDogU3BhY2VUeXBlLlZJRVcgKyAoVmVjdG9yVHlwZS5QT0lOVCA8PCAzKSxcbiAgICAgICAgV09STERfUE9JTlQgOiBTcGFjZVR5cGUuV09STEQgKyAoVmVjdG9yVHlwZS5QT0lOVCA8PCAzKSxcbiAgICAgICAgVklFV19OT1JNQUwgOiBTcGFjZVR5cGUuVklFVyArIChWZWN0b3JUeXBlLk5PUk1BTCA8PCAzKSxcbiAgICAgICAgV09STERfTk9STUFMIDogU3BhY2VUeXBlLldPUkxEICsgKFZlY3RvclR5cGUuTk9STUFMIDw8IDMpLFxuICAgICAgICBSRVNVTFRfUE9JTlQgOiBTcGFjZVR5cGUuUkVTVUxUICsgKFZlY3RvclR5cGUuUE9JTlQgPDwgMyksXG4gICAgICAgIFJFU1VMVF9OT1JNQUwgOiBTcGFjZVR5cGUuUkVTVUxUICsgKFZlY3RvclR5cGUuTk9STUFMIDw8IDMpXG4gICAgfTtcbiAgICBucy5nZXRWZWN0b3JGcm9tU3BhY2VWZWN0b3IgPSBmdW5jdGlvbihzcGFjZVR5cGUpe1xuICAgICAgICByZXR1cm4gc3BhY2VUeXBlID4+IDM7XG4gICAgfVxuICAgIG5zLmdldFNwYWNlRnJvbVNwYWNlVmVjdG9yID0gZnVuY3Rpb24oc3BhY2VUeXBlKXtcbiAgICAgICAgcmV0dXJuIHNwYWNlVHlwZSAlIDg7XG4gICAgfVxuXG4gICAgbnMuU09VUkNFUyA9IHtcbiAgICAgICAgVU5JRk9STTogXCJ1bmlmb3JtXCIsXG4gICAgICAgIFZFUlRFWDogXCJ2ZXJ0ZXhcIixcbiAgICAgICAgQ09OU1RBTlQ6IFwiY29uc3RhbnRcIlxuICAgIH1cblxuICAgIG5zLkNvbG9yQ2xvc3VyZXMgPSB7XG4gICAgICAgIFwiZW1pc3NpdmVcIiA6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcImRpZmZ1c2VcIiA6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogXCJWZWMzXCIsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInBob25nXCIgOiB7XG4gICAgICAgICAgICBpbnB1dDogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBcIlZlYzNcIiwgc2VtYW50aWM6IFNlbWFudGljcy5DT0xPUn0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLk5PUk1BTH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAwfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBjb29rVG9ycmFuY2U6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogXCJWZWMzXCIsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDAuMH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAwLjB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHdhcmQ6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogXCJWZWMzXCIsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogXCJWZWMzXCIsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDAuMH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAwLjB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNjYXR0ZXI6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogXCJWZWMzXCIsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJyZWZsZWN0XCIgOiB7XG4gICAgICAgICAgICBpbnB1dDogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBcIlZlYzNcIiwgc2VtYW50aWM6IFNlbWFudGljcy5OT1JNQUx9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInJlZnJhY3RcIiA6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wiLCBzZW1hbnRpYzogU2VtYW50aWNzLk5PUk1BTH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAxIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuVU5LTk9XTiwgZGVmYXVsdFZhbHVlOiAxIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwidHJhbnNwYXJlbnRcIiA6IHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAwIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5zLnRvSmF2YVNjcmlwdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIENvZGVHZW4uZ2VuZXJhdGUobm9kZSk7XG4gICAgfTtcblxuICAgIG5zLlZlY01hdGggPSBWZWNNYXRoO1xuICAgIHJlcXVpcmUoXCIuL2ludGVyZmFjZS9tYXRoXCIpXG4gICAgbnMuVmVjMiA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZS92ZWN0b3JcIikuVmVjMjtcbiAgICBucy5WZWMzID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlL3ZlY3RvclwiKS5WZWMzO1xuICAgIG5zLlZlYzQgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2UvdmVjdG9yXCIpLlZlYzQ7XG4gICAgbnMuTWF0MiA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZS9tYXRyaXhcIikuTWF0MjtcbiAgICBucy5NYXQzID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlL21hdHJpeFwiKS5NYXQzO1xuICAgIG5zLk1hdDQgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2UvbWF0cml4XCIpLk1hdDQ7XG5cbn0oZXhwb3J0cykpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIFBsdWdpblJlZ2lzdHJ5KCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRQbHVnaW5zID0ge1xuXG4gICAgfVxufVxuXG5QbHVnaW5SZWdpc3RyeS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChzdWJzeXN0ZW0sIG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2hhcyhzdWJzeXN0ZW0sIG5hbWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3Vic3lzdGVtICsgXCI6IFwiICsgbmFtZSArIFwiIG5vdCBmb3VuZCFcIilcblxuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkUGx1Z2luc1tzdWJzeXN0ZW1dLmdldChuYW1lKTtcbn07XG5cblBsdWdpblJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzID0gZnVuY3Rpb24gKHN1YnN5c3RlbSwgbmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkUGx1Z2luc1tzdWJzeXN0ZW1dICYmIHRoaXMuX3JlZ2lzdGVyZWRQbHVnaW5zW3N1YnN5c3RlbV0uaGFzKG5hbWUpO1xufTtcblxuUGx1Z2luUmVnaXN0cnkucHJvdG90eXBlLl9yZWdpc3RlciA9IGZ1bmN0aW9uIChzdWJzeXN0ZW0sIG5hbWUsIHBsdWdpbikge1xuICAgIGlmICghdGhpcy5fcmVnaXN0ZXJlZFBsdWdpbnNbc3Vic3lzdGVtXSlcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZFBsdWdpbnNbc3Vic3lzdGVtXSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkUGx1Z2luc1tzdWJzeXN0ZW1dLnNldChuYW1lLCBwbHVnaW4pXG59O1xuXG5mdW5jdGlvbiBlc3RhYmxpc2hTdWJzeXN0ZW0oc3Vic3lzdGVtTmFtZSkge1xuICAgIHN1YnN5c3RlbU5hbWUgPSBzdWJzeXN0ZW1OYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3Vic3lzdGVtTmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgUGx1Z2luUmVnaXN0cnkucHJvdG90eXBlW1wiaGFzXCIgKyBzdWJzeXN0ZW1OYW1lXSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXMoc3Vic3lzdGVtTmFtZSwgbmFtZSk7XG4gICAgfTtcbiAgICBQbHVnaW5SZWdpc3RyeS5wcm90b3R5cGVbXCJnZXRcIiArIHN1YnN5c3RlbU5hbWVdID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChzdWJzeXN0ZW1OYW1lLCBuYW1lKTtcbiAgICB9O1xuICAgIFBsdWdpblJlZ2lzdHJ5LnByb3RvdHlwZVtcInJlZ2lzdGVyXCIgKyBzdWJzeXN0ZW1OYW1lXSA9IGZ1bmN0aW9uIChuYW1lLCBwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyKHN1YnN5c3RlbU5hbWUsIG5hbWUsIHBsdWdpbik7XG4gICAgfTtcbn1cblxuZXN0YWJsaXNoU3Vic3lzdGVtKFwibW9kdWxlXCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgUGx1Z2luUmVnaXN0cnkoKTsiLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICB2YXIgVHJhdmVyc2FsID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxuICAgICAgICBTeW50YXggPSBUcmF2ZXJzYWwuU3ludGF4LFxuICAgICAgICBwYXJzZXIgPSByZXF1aXJlKCdlc3ByaW1hJyksXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZXMuanNcIiksXG4gICAgICAgIGFubm90YXRlID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpLmFubm90YXRlO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICB2YXIgY2FsbGVlID0gYW5ub3RhdGUobm9kZS5jYWxsZWUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNhbGxcIiwgbm9kZS5jYWxsZWUucHJvcGVydHksIGNhbGxlZS5nZXRUeXBlU3RyaW5nKCksIG5vZGUuY2FsbGVlLm9iamVjdClcbiAgICAgICAgaWYoY2FsbGVlLmlzT2ZLaW5kKFNoYWRlLk9CSkVDVF9LSU5EUy5DT0xPUl9DTE9TVVJFKSkge1xuICAgICAgICAgICAgYW5ub3RhdGUobm9kZSkuY29weUZyb20oY2FsbGVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gYW5ub3RhdGUobm9kZS5vYmplY3QpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gYW5ub3RhdGUobm9kZSk7XG4gICAgICAgIGlmIChub2RlLm9iamVjdC5uYW1lID09IFwiU2hhZGVcIiB8fCBvYmplY3QuaXNPZktpbmQoU2hhZGUuT0JKRUNUX0tJTkRTLkNPTE9SX0NMT1NVUkUpKSB7XG4gICAgICAgICAgICB2YXIgY2xvc3VyZU5hbWUgPSBub2RlLnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgICBpZiAoIVNoYWRlLkNvbG9yQ2xvc3VyZXMuaGFzT3duUHJvcGVydHkoY2xvc3VyZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFNoYWRlLlRZUEVTLk9CSkVDVCwgU2hhZGUuT0JKRUNUX0tJTkRTLkNPTE9SX0NMT1NVUkUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbnMubWFya0NvbG9yQ2xvc3VyZXMgPSBmdW5jdGlvbihwcm9ncmFtQWFzdCl7XG4gICAgICAgIFRyYXZlcnNhbC50cmF2ZXJzZShwcm9ncmFtQWFzdCwge1xuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XG4gICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1lbWJlckV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn0oZXhwb3J0cykpO1xuIiwiLyoqXG4gKiBTaW1wbGUgcmVwbGFjZXIgdGhhdCBjb2xsZWN0cyBhbGwgY2xvc3VyZSBjYWxscyBvZiBhIGNvbG9yIGNsb3N1cmUgZXhwcmVzc2lvbiBhbmQgcGFzc2VzIHRoZW0gdG8gdGhlXG4gKiBwcm92aWRlZCBjYWxsYmFja1xuICogQHR5cGUge2V4cG9ydHN9XG4gKi9cblxudmFyIFRyYXZlcnNhbCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbnZhciBhbm5vdGF0ZSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKS5hbm5vdGF0ZTtcbnZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2VzLmpzXCIpO1xuXG52YXIgU3ludGF4ID0gVHJhdmVyc2FsLlN5bnRheDtcblxuZnVuY3Rpb24gaXNDb2xvckNsb3N1cmUobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhbm5vdGF0ZShub2RlKS5pc09mS2luZChTaGFkZS5PQkpFQ1RfS0lORFMuQ09MT1JfQ0xPU1VSRSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNhbGxFeHByZXNzaW9uKG5vZGUsIGNvbG9yQ2xvc3VyZUxpc3QpIHtcbiAgICB2YXIgY2FsbGVlID0gYW5ub3RhdGUobm9kZS5jYWxsZWUpO1xuICAgIC8vIGNvbnNvbGUubG9nKFwiQ2FsbFwiLCBub2RlLmNhbGxlZS5wcm9wZXJ0eSwgY2FsbGVlLmdldFR5cGVTdHJpbmcoKSwgbm9kZS5jYWxsZWUub2JqZWN0KVxuICAgIGlmIChjYWxsZWUuaXNPZktpbmQoU2hhZGUuT0JKRUNUX0tJTkRTLkNPTE9SX0NMT1NVUkUpKSB7XG4gICAgICAgIGNvbG9yQ2xvc3VyZUxpc3QucHVzaCh7bmFtZTogbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSwgYXJnczogbm9kZS5hcmd1bWVudHN9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENsb3N1cmVMaXN0KGNsb3N1cmVFeHByZXNzaW9uKSB7XG4gICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY2xvc3VyZUV4cHJlc3Npb24sIG51bGwsIFwiIFwiKSlcbiAgICB2YXIgY29sb3JDbG9zdXJlTGlzdCA9IFtdO1xuICAgIFRyYXZlcnNhbC50cmF2ZXJzZShjbG9zdXJlRXhwcmVzc2lvbiwge1xuICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxFeHByZXNzaW9uKG5vZGUsIGNvbG9yQ2xvc3VyZUxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29sb3JDbG9zdXJlTGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IGEubmFtZSA+IGIubmFtZSA/IDEgOiAwXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbG9yQ2xvc3VyZUxpc3Q7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbG9yQ2xvc3VyZShjbG9zdXJlRXhwcmVzc2lvbiwgcmVwbGFjZXIpIHtcbiAgICB2YXIgbGlzdCA9IGdldENsb3N1cmVMaXN0KGNsb3N1cmVFeHByZXNzaW9uKTtcbiAgICByZXR1cm4gcmVwbGFjZXIobGlzdCk7XG59XG5cbnZhciByZXBsYWNlID0gZnVuY3Rpb24gKGFzdCwgcmVwbGFjZXIpIHtcbiAgICByZXR1cm4gVHJhdmVyc2FsLnJlcGxhY2UoYXN0LCB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGlzQ29sb3JDbG9zdXJlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNvbG9yQ2xvc3VyZShub2RlLCByZXBsYWNlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcGxhY2U7XG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICB2YXIgVHJhdmVyc2FsID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxuICAgICAgICBTeW50YXggPSBUcmF2ZXJzYWwuU3ludGF4LFxuICAgICAgICBwYXJzZXIgPSByZXF1aXJlKCdlc3ByaW1hJyk7XG5cbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKSxcbiAgICBTcGFjZVZlY3RvclR5cGUgPSBTaGFkZS5TcGFjZVZlY3RvclR5cGUsXG4gICAgVHlwZXMgPSBTaGFkZS5UWVBFUyxcbiAgICBLaW5kcyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcblxuICAgIG5zLmdldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uKGNjSW5wdXREZWZpbml0aW9uKXtcbiAgICAgICAgaWYoY2NJbnB1dERlZmluaXRpb24uZGVmYXVsdFZhbHVlID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbG9yQ2xvc3VyZSBpbnB1dCBoYXMgbm90IGRlZmF1bHQgdmFsdWUhXCIpO1xuXG4gICAgICAgIGlmKGNjSW5wdXREZWZpbml0aW9uLnR5cGUgPT0gVHlwZXMuTlVNQkVSIHx8IGNjSW5wdXREZWZpbml0aW9uLnR5cGUgPT0gVHlwZXMuSU5UKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNjSW5wdXREZWZpbml0aW9uLmRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VycmVudGx0eSBkb24ndCBzdXBwb3J0IGRlZmF1bHQgdmFsdWVzIG9mIHR5cGUgXCIgKyBjY0lucHV0RGVmaW5pdGlvbi50eXBlICsgXCIgYW5kIGtpbmQgXCIgKyBjY0lucHV0RGVmaW5pdGlvbi5raW5kKTtcbiAgICAgICAgfVxuICAgIH1cblxufShleHBvcnRzKSk7XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBDb2xvckNsb3N1cmVNYXJrZXIgPSByZXF1aXJlKFwiLi9jb2xvcmNsb3N1cmUtbWFya2VyLmpzXCIpO1xuXG52YXIgY19pbXBsZW1lbnRhdGlvbnMgPSB7fTtcblxudmFyIHJlZ2lzdGVyTGlnaHRpbmdJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBvYmopIHtcbiAgICBjX2ltcGxlbWVudGF0aW9uc1tuYW1lXSA9IG9iajtcbn07XG5cbnZhciByZXNvbHZlQ2xvc3VyZXNQcmVUeXBlSW5mZXJlbmNlID0gZnVuY3Rpb24gKGFhc3QsIGltcGxlbWVudGF0aW9uTmFtZSwgcHJvY2Vzc2luZ0RhdGEsIG9wdCkge1xuICAgIGlmICghaW1wbGVtZW50YXRpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBhYXN0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzb2x2ZXJJbXBsID0gY19pbXBsZW1lbnRhdGlvbnNbaW1wbGVtZW50YXRpb25OYW1lXTtcbiAgICAgICAgYXNzZXJ0KHJlc29sdmVySW1wbCwgXCJJbXBsZW1lbnRhdGlvbiBub3QgZm91bmQ6IFwiICsgaW1wbGVtZW50YXRpb25OYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVySW1wbC5yZXNvbHZlUHJlVHlwZUluZmVyZW5jZSkge1xuICAgICAgICAgICAgQ29sb3JDbG9zdXJlTWFya2VyLm1hcmtDb2xvckNsb3N1cmVzKGFhc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVySW1wbC5yZXNvbHZlUHJlVHlwZUluZmVyZW5jZShhYXN0LCBwcm9jZXNzaW5nRGF0YSwgb3B0KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZXR1cm4gYWFzdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHJldHVybiBhYXN0O1xufTtcblxudmFyIHJlc29sdmVDbG9zdXJlc1Bvc3RUeXBlSW5mZXJlbmNlID0gZnVuY3Rpb24gKGFhc3QsIGltcGxlbWVudGF0aW9uTmFtZSwgcHJvY2Vzc2luZ0RhdGEsIG9wdCkge1xuICAgIGlmICghaW1wbGVtZW50YXRpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBhYXN0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzb2x2ZXJJbXBsID0gY19pbXBsZW1lbnRhdGlvbnNbaW1wbGVtZW50YXRpb25OYW1lXTtcbiAgICAgICAgaWYgKHJlc29sdmVySW1wbC5yZXNvbHZlUG9zdFR5cGVJbmZlcmVuY2UpXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXJJbXBsLnJlc29sdmVQb3N0VHlwZUluZmVyZW5jZShhYXN0LCBwcm9jZXNzaW5nRGF0YSwgb3B0KTsgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGFhc3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgICByZXR1cm4gYWFzdDtcbn07XG5cbnJlZ2lzdGVyTGlnaHRpbmdJbXBsZW1lbnRhdGlvbihcInhtbDNkLWdsc2wtZm9yd2FyZFwiLCByZXF1aXJlKFwiLi94bWwzZC1nbHNsLWZvcndhcmRcIikpO1xucmVnaXN0ZXJMaWdodGluZ0ltcGxlbWVudGF0aW9uKFwieG1sM2QtZ2xzbC1kZWZlcnJlZFwiLCByZXF1aXJlKFwiLi94bWwzZC1nbHNsLWRlZmVycmVkXCIpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlZ2lzdGVyTGlnaHRpbmdJbXBsZW1lbnRhdGlvbjogcmVnaXN0ZXJMaWdodGluZ0ltcGxlbWVudGF0aW9uLFxuICByZXNvbHZlQ2xvc3VyZXNQcmVUeXBlSW5mZXJlbmNlOiByZXNvbHZlQ2xvc3VyZXNQcmVUeXBlSW5mZXJlbmNlLFxuICByZXNvbHZlQ2xvc3VyZXNQb3N0VHlwZUluZmVyZW5jZTogcmVzb2x2ZUNsb3N1cmVzUG9zdFR5cGVJbmZlcmVuY2Vcbn07XG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxuICAgICAgICBUcmF2ZXJzYWwgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyksXG4gICAgICAgIFN5bnRheCA9IFRyYXZlcnNhbC5TeW50YXgsXG4gICAgICAgIGFubm90YXRlID0gcmVxdWlyZShcIi4vLi4vLi4vdXRpbHNcIikuYW5ub3RhdGUsXG4gICAgICAgIERlZmVycmVkSW5mbyA9IHJlcXVpcmUoXCIuL3htbDNkLWRlZmVycmVkLmpzXCIpO1xuXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXG4gICAgICAgIFNwYWNlVmVjdG9yVHlwZSA9IFNoYWRlLlNwYWNlVmVjdG9yVHlwZSxcbiAgICAgICAgVHlwZXMgPSBTaGFkZS5UWVBFUyxcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XG5cbiAgICB2YXIgU3BhY2VUcmFuc2Zvcm1Ub29scyA9IHJlcXVpcmUoXCIuLi8uLi9nZW5lcmF0ZS9zcGFjZS9zcGFjZS10cmFuc2Zvcm0tdG9vbHMuanNcIiksXG4gICAgICAgIENvbG9yQ2xvc3VyZVRvb2xzID0gcmVxdWlyZShcIi4uL2NvbG9yY2xvc3VyZS10b29scy5qc1wiKTtcblxuICAgIHZhciBBRERfUE9TSVRJT05fVE9fQVJHUyA9IHRydWU7XG5cbiAgICB2YXIgQXJnU3RvcmFnZVR5cGUgPSBucy5BcmdTdG9yYWdlVHlwZSA9IHtcbiAgICAgICAgRkxPQVQgOiAnZmxvYXQnLFxuICAgICAgICBGTE9BVF9CWVRFOiAnZmxvYXRCeXRlJyxcbiAgICAgICAgRkxPQVRfVUJZVEU6ICdmbG9hdFVCeXRlJyxcbiAgICAgICAgRkxPQVQyOiAnZmxvYXQyJyxcbiAgICAgICAgRkxPQVQzOiAnZmxvYXQzJyxcbiAgICAgICAgRkxPQVQzX05PUk1BTDogJ2Zsb2F0M05vcm1hbCcsXG4gICAgICAgIEZMT0FUNDogJ2Zsb2F0NCdcbiAgICB9XG5cbiAgICB2YXIgQU1CSUVOVF9ERUZJTklUSU9OID0ge3R5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNoYWRlLlNFTUFOVElDUy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDAgfTtcblxuXG4gICAgbnMuQ29sb3JDbG9zdXJlU2lnbmF0dXJlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5pZCA9IDA7XG4gICAgICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5hcmdzID0gW107XG4gICAgICAgIHRoaXMuY29sb3JDbG9zdXJlcyA9IFtdO1xuICAgIH07XG4gICAgQmFzZS5leHRlbmQobnMuQ29sb3JDbG9zdXJlU2lnbmF0dXJlLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHJldHVybkFhc3QsIHNjb3BlKXtcbiAgICAgICAgICAgIHZhciBjbG9zdXJlSW5mbyA9IGNvbGxlY3RDbG9zdXJlSW5mbyhyZXR1cm5BYXN0KTtcbiAgICAgICAgICAgIHZhciBhcmdBYXN0ID0gZ2F0aGVyQ2xvc3VyZUFyZ3ModGhpcywgY2xvc3VyZUluZm8sIHNjb3BlKTtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlcyA9IGFsbG9jYXRlQXJndW1lbnRzVG9UZXh0dXJlcyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBnZXRTaWduYXR1cmVJZCh0aGlzKTtcbiAgICAgICAgICAgIGFyZ0Fhc3RbMF0udmFsdWUgPSB0aGlzLmlkOyAvLyBTZXQgSUQgZm9yIHNoYWRlciBpZCBhc3NpZ25tZW50XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVBYXN0KHRleHR1cmVzLCBhcmdBYXN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQmFzaWMgQ29sb3JDbG9zdXJlU2lnbmF0dXJlIENyZWF0ZWlvblxuXG4gICAgZnVuY3Rpb24gYWRkQ29sb3JDbG9zdXJlKGNjU2lnLCBjb2xvckNsb3N1cmVOYW1lLCBhcmdJbmRpY2VzLCBlbnZJbmRpY2VzKXtcbiAgICAgICAgY2NTaWcuY29sb3JDbG9zdXJlcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGNvbG9yQ2xvc3VyZU5hbWUsXG4gICAgICAgICAgICBhcmdJbmRpY2VzOiBhcmdJbmRpY2VzLFxuICAgICAgICAgICAgZW52SW5kaWNlczogZW52SW5kaWNlc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRBcmd1bWVudChjY1NpZywgdHlwZSwga2luZCwgc3RvcmVUeXBlKXtcbiAgICAgICAgdmFyIGlkID0gY2NTaWcuYXJncy5sZW5ndGg7XG4gICAgICAgIGNjU2lnLmFyZ3MucHVzaCh7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHN0b3JlVHlwZTogc3RvcmVUeXBlLFxuICAgICAgICAgICAgdGV4SWR4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb21wb25lbnRJZHg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJpdElkeDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgLy8gQXJndW1lbnQgQ29sbGVjdGlvblxuXG4gICAgZnVuY3Rpb24gY29sbGVjdENsb3N1cmVJbmZvKHJldHVybkFhc3Qpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIFRyYXZlcnNhbC50cmF2ZXJzZShyZXR1cm5BYXN0LCB7XG4gICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYW5ub3RhdGUobm9kZS5jYWxsZWUub2JqZWN0KS5pc09mS2luZChLaW5kcy5DT0xPUl9DTE9TVVJFKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUuY2FsbGVlLnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBub2RlLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5uYW1lIDwgYi5uYW1lID8gLTEgOiBhLm5hbWUgPiBiLm5hbWUgPyAxIDogMH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhdGhlckNsb3N1cmVBcmdzKGNjU2lnLCBjbG9zdXJlSW5mbywgc2NvcGUpe1xuICAgICAgICB2YXIgYXJnQ2FjaGUgPSB7fSwgYXJnQWFzdCA9IFtdO1xuXG4gICAgICAgIC8vIEFkZCBhcmd1bWVudCBmb3Igc2lnbmF0dXJlIGlkO1xuICAgICAgICBnZXRDYWNoZWRBcmd1bWVudChjY1NpZywge3R5cGU6IFR5cGVzLklOVH0sIHt0eXBlOiBcIkxpdGVyYWxcIiwgdmFsdWU6IFwiSURfVU5TUEVDSUZJRURcIn0sIGFyZ0NhY2hlLCBhcmdBYXN0KTtcbiAgICAgICAgaWYoQUREX1BPU0lUSU9OX1RPX0FSR1MpXG4gICAgICAgICAgICBhZGRQb3NpdGlvbkFyZ3VtZW50KGNjU2lnLCBhcmdDYWNoZSwgYXJnQWFzdCk7XG4gICAgICAgIHZhciBhbWJpZW50VmFsdWUgPSB7IHR5cGU6IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiwgb3BlcmF0b3IgOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBnZXRFbnZBY2Nlc3MoXCJhbWJpZW50SW50ZW5zaXR5XCIsIEFNQklFTlRfREVGSU5JVElPTiksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogQ29sb3JDbG9zdXJlVG9vbHMuZ2V0RGVmYXVsdFZhbHVlKEFNQklFTlRfREVGSU5JVElPTikgfTtcblxuICAgICAgICBnZXRDYWNoZWRBcmd1bWVudChjY1NpZywgQU1CSUVOVF9ERUZJTklUSU9OLCBhbWJpZW50VmFsdWUsIGFyZ0NhY2hlLCBhcmdBYXN0KTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2xvc3VyZUluZm8ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGNJbmZvID0gY2xvc3VyZUluZm9baV07XG4gICAgICAgICAgICB2YXIgY2xvc3VyZURlZmluaXRpb24gPSBTaGFkZS5Db2xvckNsb3N1cmVzW2NJbmZvLm5hbWVdO1xuICAgICAgICAgICAgaWYoIWNsb3N1cmVEZWZpbml0aW9uKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQ29sb3IgY2xvc3VyZSAnXCIgKyBjSW5mby5uYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgdmFyIGFyZ0luZGljZXMgPSBbXSwgdmFsdWU7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY2xvc3VyZURlZmluaXRpb24uaW5wdXQubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dERlZmluaXRpb24gPSBjbG9zdXJlRGVmaW5pdGlvbi5pbnB1dFtqXTtcbiAgICAgICAgICAgICAgICBpZihqIDwgY0luZm8uYXJncy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY0luZm8uYXJnc1tqXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQ29sb3JDbG9zdXJlVG9vbHMuZ2V0RGVmYXVsdFZhbHVlKGlucHV0RGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlID0gRGVmZXJyZWRJbmZvW2NJbmZvLm5hbWVdICYmIERlZmVycmVkSW5mb1tjSW5mby5uYW1lXS5pbnB1dFNwYWNlc1tqXTtcbiAgICAgICAgICAgICAgICBhcmdJbmRpY2VzLnB1c2goZ2V0Q2FjaGVkQXJndW1lbnQoY2NTaWcsIGlucHV0RGVmaW5pdGlvbiwgdmFsdWUsIGFyZ0NhY2hlLCBhcmdBYXN0LCBzcGFjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVudkluZGljZXMgPSB7fTtcbiAgICAgICAgICAgIGZvcih2YXIgcHJvcGVydHkgaW4gY2xvc3VyZURlZmluaXRpb24uZW52KXtcbiAgICAgICAgICAgICAgICB2YXIgZW52RGVmaW5pdGlvbiA9IGNsb3N1cmVEZWZpbml0aW9uLmVudltwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRGV0ZXJtaW5lIGlmIGVudiBwcm9wZXJ0eSBpcyB1bmRlZmluZWQgYW5kIHVzZSBkZWZhdWx0VmFsdWUgaW4gdGhpcyBjYXNlO1xuICAgICAgICAgICAgICAgIHZhbHVlID0geyB0eXBlOiBTeW50YXguTG9naWNhbEV4cHJlc3Npb24sIG9wZXJhdG9yIDogXCJ8fFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZ2V0RW52QWNjZXNzKHByb3BlcnR5LCBlbnZEZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBDb2xvckNsb3N1cmVUb29scy5nZXREZWZhdWx0VmFsdWUoZW52RGVmaW5pdGlvbikgfTtcbiAgICAgICAgICAgICAgICBlbnZJbmRpY2VzW3Byb3BlcnR5XSA9IGdldENhY2hlZEFyZ3VtZW50KGNjU2lnLCBlbnZEZWZpbml0aW9uLCB2YWx1ZSwgYXJnQ2FjaGUsIGFyZ0Fhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ29sb3JDbG9zdXJlKGNjU2lnLCBjSW5mby5uYW1lLCBhcmdJbmRpY2VzLCBlbnZJbmRpY2VzKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGFyZ0Fhc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUG9zaXRpb25Bcmd1bWVudChjY1NpZywgYXJnQ2FjaGUsIGFyZ0Fhc3Qpe1xuICAgICAgICB2YXIgcG9zaXRpb25Mb29rdXAgPSB7IHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIl9lbnZcIn0sXG4gICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJwb3NpdGlvblwifVxuICAgICAgICB9XG4gICAgICAgIC8vIEFOTk8ocG9zaXRpb25Mb29rdXApLnNldFR5cGUoVHlwZXMuT0JKRUNULCBcIlZlYzNcIik7XG4gICAgICAgIC8vIEFOTk8ocG9zaXRpb25Mb29rdXAub2JqZWN0KS5zZXRUeXBlKFR5cGVzLk9CSkVDVCwgS2luZHMuQU5ZKTtcbiAgICAgICAgLy8gQU5OTyhwb3NpdGlvbkxvb2t1cC5vYmplY3QpLnNldEdsb2JhbCh0cnVlKTtcbiAgICAgICAgZ2V0Q2FjaGVkQXJndW1lbnQoY2NTaWcsIHt0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IFwiVmVjM1wifSwgcG9zaXRpb25Mb29rdXAsIGFyZ0NhY2hlLCBhcmdBYXN0LFxuICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLlZJRVdfUE9JTlQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhY2hlZEFyZ3VtZW50KGNjU2lnLCBpbnB1dERlZmluaXRpb24sIGlucHV0QWFzdCwgYXJnQ2FjaGUsIGFyZ0Fhc3QsIHNwYWNlKXtcbiAgICAgICAgc3BhY2UgPSBzcGFjZSB8fCBTcGFjZVZlY3RvclR5cGUuT0JKRUNUO1xuICAgICAgICBpbnB1dEFhc3QgPSBzcGFjZSA/IFNwYWNlVHJhbnNmb3JtVG9vbHMuZ2V0U3BhY2VUcmFuc2Zvcm1DYWxsKGlucHV0QWFzdCwgc3BhY2UpIDogaW5wdXRBYXN0O1xuICAgICAgICB2YXIga2V5QWFzdCA9IEJhc2UuZGVlcEV4dGVuZCh7fSwgaW5wdXRBYXN0KTtcbiAgICAgICAgY2xlYW5BYXN0KGtleUFhc3QpO1xuICAgICAgICB2YXIgc3RvcmFnZVR5cGUgPSBnZXRTdG9yYWdlVHlwZShpbnB1dERlZmluaXRpb24pO1xuICAgICAgICB2YXIga2V5ID0gc3RvcmFnZVR5cGUgKyBcIjtcIiArIEpTT04uc3RyaW5naWZ5KGtleUFhc3QpO1xuICAgICAgICBpZihhcmdDYWNoZVtrZXldID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdmFyIGFyZ0lkID0gYWRkQXJndW1lbnQoY2NTaWcsIGlucHV0RGVmaW5pdGlvbi50eXBlLCBpbnB1dERlZmluaXRpb24ua2luZCwgc3RvcmFnZVR5cGUpO1xuICAgICAgICAgICAgYXJnQ2FjaGVba2V5XSA9IGFyZ0lkO1xuICAgICAgICAgICAgYXJnQWFzdC5wdXNoKGlucHV0QWFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ0NhY2hlW2tleV07XG4gICAgfVxuICAgIC8qIFJlbW92ZSBhbGwgcmFuZ2UgcHJvcGVydGllcyBmcm9tIHRoZSBhYXN0ICovXG4gICAgZnVuY3Rpb24gY2xlYW5BYXN0KGFhc3Qpe1xuICAgICAgICBmb3IodmFyIGkgaW4gYWFzdCl7XG4gICAgICAgICAgICBpZihpID09IFwicmFuZ2VcIiB8fCBpID09IFwibG9jXCIpe1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhYXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0eXBlb2YgYWFzdFtpXSA9PSBcIm9iamVjdFwiKXtcbiAgICAgICAgICAgICAgICBjbGVhbkFhc3QoYWFzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdG9yYWdlVHlwZShjbG9zdXJlSW5wdXRUeXBlKXtcbiAgICAgICAgaWYoY2xvc3VyZUlucHV0VHlwZS50eXBlID09IFR5cGVzLk5VTUJFUiB8fCBjbG9zdXJlSW5wdXRUeXBlLnR5cGUgPT0gVHlwZXMuSU5UKXtcbiAgICAgICAgICAgIHJldHVybiBBcmdTdG9yYWdlVHlwZS5GTE9BVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNsb3N1cmVJbnB1dFR5cGUudHlwZSA9PSBUeXBlcy5PQkpFQ1Qpe1xuICAgICAgICAgICAgc3dpdGNoKGNsb3N1cmVJbnB1dFR5cGUua2luZCl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlZlYzJcIjogcmV0dXJuIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUMjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiVmVjM1wiOiByZXR1cm4gQXJnU3RvcmFnZVR5cGUuRkxPQVQzO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJWZWM0XCI6IHJldHVybiBBcmdTdG9yYWdlVHlwZS5GTE9BVDQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmZXJyZWQgaW5wdXQgb2YgdGhpcyBraW5kIG5vdCBzdXBwb3J0ZWQ6IFwiICsgY2xvc3VyZUlucHV0VHlwZS5raW5kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmVycmVkIGlucHV0IG9mIHRoaXMgdHlwZSBub3Qgc3VwcG9ydGVkOiBcIiArIGNsb3N1cmVJbnB1dFR5cGUudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbnZBY2Nlc3MocHJvcGVydHksIGRlZmluaXRpb24pe1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICBvYmplY3Q6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJfZW52XCIgfSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IHByb3BlcnR5IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBTk5PKHJlc3VsdCkuc2V0VHlwZShkZWZpbml0aW9uLnR5cGUsIGRlZmluaXRpb24ua2luZCk7XG4gICAgICAgIC8vIHZhciBvYmpBbm5vID0gQU5OTyhyZXN1bHQub2JqZWN0KTtcbiAgICAgICAgLy8gb2JqQW5uby5zZXRUeXBlKFR5cGVzLk9CSkVDVCwgS2luZHMuQU5ZKTtcbiAgICAgICAgLy8gb2JqQW5uby5zZXRHbG9iYWwodHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG5cbiAgICAvLyBBcmd1bWVudCBBbGxvY2F0aW9uXG5cblxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlQXJndW1lbnRzVG9UZXh0dXJlcyhjY1NpZyl7XG4gICAgICAgIHZhciBhcmdDb3B5ID0gY2NTaWcuYXJncy5zbGljZSggQUREX1BPU0lUSU9OX1RPX0FSR1MgPyAzIDogMik7XG4gICAgICAgIGFyZ0NvcHkuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdG9yYWdlU2l6ZShhLnN0b3JlVHlwZSkgLSBnZXRTdG9yYWdlU2l6ZShiLnN0b3JlVHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhcmdDb3B5LnB1c2goY2NTaWcuYXJnc1tBRERfUE9TSVRJT05fVE9fQVJHUyA/IDIgOiAxXSk7IC8vIEFtYmllbnQgY29tZXMgdGhpcmQuXG4gICAgICAgIGlmKEFERF9QT1NJVElPTl9UT19BUkdTKVxuICAgICAgICAgICAgYXJnQ29weS5wdXNoKGNjU2lnLmFyZ3NbMV0pOyAvLyBQT1NJVElPTiBjb21lcyBzZWNvbmQuXG4gICAgICAgIGFyZ0NvcHkucHVzaChjY1NpZy5hcmdzWzBdKTsgLy8gSUQgYXJndW1lbnQgYWx3YXlzIGNvbWVzIGZpcnN0IChhbmQgdGh1czogbGFzdCBpbiB0aGlzIGFycmF5KVxuICAgICAgICB2YXIgdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdmFyIGkgPSBhcmdDb3B5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdDb3B5W2ldO1xuICAgICAgICAgICAgYXNzaWduVGV4dHVyZVNsb3QoYXJnLCB0ZXh0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2NTaWcudGV4dHVyZUNvdW50ID0gdGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGV4dHVyZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnblRleHR1cmVTbG90KGFyZywgdGV4dHVyZXMpe1xuICAgICAgICB2YXIgc2l6ZSA9IGdldFN0b3JhZ2VTaXplKGFyZy5zdG9yZVR5cGUpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHRleCA9IHRleHR1cmVzW2ldO1xuICAgICAgICAgICAgaWYoc2l6ZSA8IDMyKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjdXJyZW50bHkgZG9uJ3Qgc3VwcG9ydCBzdG9yaW5nIG9mIHZhbHVlcyBzbWFsbGVyIHRoYW4gMzIgYml0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0ZXgudXNlZENvbXBvbmVudHMgKyBzaXplIC8gMzIgPD0gNCl7XG4gICAgICAgICAgICAgICAgYXJnLnRleElkeCA9IGk7XG4gICAgICAgICAgICAgICAgYXJnLmNvbXBvbmVudElkeCA9IHRleC51c2VkQ29tcG9uZW50cztcbiAgICAgICAgICAgICAgICBhcmcuYml0SWR4ID0gMDtcbiAgICAgICAgICAgICAgICB0ZXgudXNlZENvbXBvbmVudHMgKz0gc2l6ZSAvIDMyO1xuICAgICAgICAgICAgICAgIHRleC51c2VkQml0cyA9IDA7XG4gICAgICAgICAgICAgICAgdGV4LnN0b3JlZEFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmcudGV4SWR4ID0gdGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICBhcmcuY29tcG9uZW50SWR4ID0gMDtcbiAgICAgICAgYXJnLmJpdElkeCA9IDA7XG4gICAgICAgIGlmKHNpemUgPCAzMil7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjdXJyZW50bHkgZG9uJ3Qgc3VwcG9ydCBzdG9yaW5nIG9mIHZhbHVlcyBzbWFsbGVyIHRoYW4gMzIgYml0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB1c2VkQ29tcG9uZW50czogc2l6ZSAvIDMyLFxuICAgICAgICAgICAgICAgIHVzZWRCaXRzOiAwLFxuICAgICAgICAgICAgICAgIHN0b3JlZEFyZ3M6IFthcmddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0b3JhZ2VTaXplKHN0b3JlVHlwZSl7XG4gICAgICAgIHN3aXRjaChzdG9yZVR5cGUpe1xuICAgICAgICAgICAgY2FzZSBBcmdTdG9yYWdlVHlwZS5GTE9BVDogcmV0dXJuIDMyO1xuICAgICAgICAgICAgY2FzZSBBcmdTdG9yYWdlVHlwZS5GTE9BVF9CWVRFOiByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgQXJnU3RvcmFnZVR5cGUuRkxPQVRfVUJZVEU6IHJldHVybiA4O1xuICAgICAgICAgICAgY2FzZSBBcmdTdG9yYWdlVHlwZS5GTE9BVDI6IHJldHVybiA2NDtcbiAgICAgICAgICAgIGNhc2UgQXJnU3RvcmFnZVR5cGUuRkxPQVQzOiByZXR1cm4gOTY7XG4gICAgICAgICAgICBjYXNlIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUM19OT1JNQUw6IHJldHVybiAyNDtcbiAgICAgICAgICAgIGNhc2UgQXJnU3RvcmFnZVR5cGUuRkxPQVQ0OiByZXR1cm4gMTI4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IENvbG9yQ2xvc3VyZVNpZ25hdHVyZSBJRFxuXG4gICAgdmFyIGNfU2lnbmF0dXJlTmV4dElkID0gMDtcbiAgICB2YXIgY19TaWduYXR1cmVJRENhY2hlID0ge307XG5cbiAgICBucy5Db2xvckNsb3N1cmVTaWduYXR1cmUuY2xlYXJJZENhY2hlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgY19TaWduYXR1cmVOZXh0SWQgPSAwO1xuICAgICAgICBjX1NpZ25hdHVyZUlEQ2FjaGUgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTaWduYXR1cmVJZChjY1NpZyl7XG4gICAgICAgIHZhciBrZXkgPSBcIlwiO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2NTaWcuYXJncy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgYXJnID0gY2NTaWcuYXJnc1tpXTtcbiAgICAgICAgICAgIGtleSArPSBnZXRBcmd1bWVudEtleShhcmcpICsgXCI7XCJcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBjY1NpZy5jb2xvckNsb3N1cmVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBjbG9zdXJlID0gY2NTaWcuY29sb3JDbG9zdXJlc1tpXTtcbiAgICAgICAgICAgIGtleSArPSBjbG9zdXJlLm5hbWUgKyBcIixcIiArIGNsb3N1cmUuYXJnSW5kaWNlcy5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIGZvcih2YXIgcHJvcCBpbiBjbG9zdXJlLmVudkluZGljZXMpe1xuICAgICAgICAgICAgICAgIGtleSArPSBcIixcIiArIHByb3AgKyBcIj5cIiArIGNsb3N1cmUuZW52SW5kaWNlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihjX1NpZ25hdHVyZUlEQ2FjaGVba2V5XSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGNfU2lnbmF0dXJlSURDYWNoZVtrZXldID0gY19TaWduYXR1cmVOZXh0SWQ7XG4gICAgICAgICAgICBjX1NpZ25hdHVyZU5leHRJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjX1NpZ25hdHVyZUlEQ2FjaGVba2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBcmd1bWVudEtleShhcmcpe1xuICAgICAgICByZXR1cm4gYXJnLnR5cGUgKyBcIixcIiArIGFyZy5raW5kICsgXCIsXCIgKyBhcmcuc3RvcmVUeXBlICsgXCIsXCIgKyBhcmcudGV4SWR4ICsgXCIsXCJcbiAgICAgICAgICAgICsgYXJnLmNvbXBvbmVudElkeCArIFwiLFwiICsgYXJnLmJpdElkeDtcbiAgICB9XG5cbiAgICAvLyBBYXN0IGdlbmVyYXRpb25cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQWFzdCh0ZXh0dXJlcywgYXJnQWFzdCl7XG4gICAgICAgIHZhciBhcnJheUV4cHJlc3Npb24gPSB7IHR5cGU6IFN5bnRheC5BcnJheUV4cHJlc3Npb24sIGVsZW1lbnRzOiBbXX07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgdmVjdG9yRXhwcmVzc2lvbiA9IGdlbmVyYXRlVmVjdG9yQWFzdCh0ZXh0dXJlc1tpXSwgYXJnQWFzdCk7XG4gICAgICAgICAgICBhcnJheUV4cHJlc3Npb24uZWxlbWVudHMucHVzaCh2ZWN0b3JFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBTk5PKGFycmF5RXhwcmVzc2lvbikuc2V0VHlwZShUeXBlcy5BUlJBWSk7XG5cbiAgICAgICAgdmFyIHJldHVyblN0YXRlbWVudCA9IHt0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50LCBhcmd1bWVudDogYXJyYXlFeHByZXNzaW9ufTtcbiAgICAgICAgcmV0dXJuIHJldHVyblN0YXRlbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlY3RvckFhc3QodGV4dHVyZSwgYXJnQWFzdCl7XG4gICAgICAgIHZhciB2ZWNBcmdzID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlLnN0b3JlZEFyZ3MubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGFyZyA9IHRleHR1cmUuc3RvcmVkQXJnc1tpXTtcbiAgICAgICAgICAgIHZhciBzaXplID0gZ2V0U3RvcmFnZVNpemUoYXJnLnN0b3JlVHlwZSk7XG4gICAgICAgICAgICBpZihzaXplIDwgMzIpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlIGN1cnJlbnRseSBkb24ndCBzdXBwb3J0IHN0b3Jpbmcgb2YgdmFsdWVzIHNtYWxsZXIgdGhhbiAzMiBiaXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHZlY0FyZ3MucHVzaChhcmdBYXN0W2FyZy5pZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gdGV4dHVyZS51c2VkQ29tcG9uZW50czsgaSA8IDQ7ICsraSl7XG4gICAgICAgICAgICB2YXIgemVyb0xpdGVyYWwgPSB7IHR5cGU6IFN5bnRheC5MaXRlcmFsLCB2YWx1ZTogXCIwXCIgfTtcbiAgICAgICAgICAgIC8vIEFOTk8oemVyb0xpdGVyYWwpLnNldFR5cGUoVHlwZXMuSU5UKTtcbiAgICAgICAgICAgIHZlY0FyZ3MucHVzaCh6ZXJvTGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sIGNhbGxlZTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJWZWM0XCJ9LCBhcmd1bWVudHM6IHZlY0FyZ3N9O1xuICAgICAgICAvLyBBTk5PKHJlc3VsdCkuc2V0VHlwZShUeXBlcy5PQkpFQ1QsIFwiVmVjNFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxufShleHBvcnRzKSk7XG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICB2YXIgQ2xvc3VyZXMgPSByZXF1aXJlKFwiLi94bWwzZC1kZWZlcnJlZC5qc1wiKSxcbiAgICAgICAgVHJhdmVyc2FsID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxuICAgICAgICBTeW50YXggPSBUcmF2ZXJzYWwuU3ludGF4LFxuICAgICAgICBwYXJzZXIgPSByZXF1aXJlKCdlc3ByaW1hJyksXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXG5cbiAgICAgICAgc2FuaXRpemVyID0gcmVxdWlyZShcIi4vLi4vLi4vYW5hbHl6ZS9zYW5pdGl6ZXIvc2FuaXRpemVyLmpzXCIpLFxuICAgICAgICBDb2xvckNsb3N1cmVTaWduYXR1cmUgPSByZXF1aXJlKFwiLi9jb2xvci1jbG9zdXJlLXNpZ25hdHVyZS5qc1wiKS5Db2xvckNsb3N1cmVTaWduYXR1cmU7XG5cblxuICAgIG5zLnJlc29sdmVQcmVUeXBlSW5mZXJlbmNlID0gZnVuY3Rpb24gKGFhc3QsIHByb2Nlc3NEYXRhLCBvcHQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgY29sb3JDbG9zdXJlU2lnbmF0dXJlczogW10sXG4gICAgICAgICAgICBpbk1haW46IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBnbG9iYWxTY3JvcGUgPSBhYXN0LnNjb3BlO1xuICAgICAgICBhYXN0ID0gVHJhdmVyc2FsLnJlcGxhY2UoYWFzdCwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XG4gICAgICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBQcm9wZXJseSBkZXRlcm1pbmUgaWYgd2UgYXJlIGluIG1haW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQubmFtZSA9PSBcInNoYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5NYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24obm9kZSwgcGFyZW50KXtcbiAgICAgICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFByb3Blcmx5IGRldGVybWluZSBpZiB3ZSBhcmUgaW4gbWFpbiBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5pZC5uYW1lID09IFwic2hhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pbk1haW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdGF0ZS5pbk1haW4pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBuZXcgQ29sb3JDbG9zdXJlU2lnbmF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gc2lnbmF0dXJlLmNvbnN0cnVjdChub2RlLCBnbG9iYWxTY3JvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcHJvY2Vzc0RhdGFbJ2NvbG9yQ2xvc3VyZVNpZ25hdHVyZXMnXSA9IHN0YXRlLmNvbG9yQ2xvc3VyZVNpZ25hdHVyZXM7XG5cbiAgICAgICAgcmV0dXJuIGFhc3Q7XG4gICAgfVxuXG59KGV4cG9ydHMpKTtcbiIsIihmdW5jdGlvbiAobnMpIHtcblxuICAgICAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcbiAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZSA9IFNoYWRlLlNwYWNlVmVjdG9yVHlwZTtcblxuICAgICAgICBucy5lbWlzc2l2ZSA9IHtcbiAgICAgICAgICAgIGlucHV0U3BhY2VzOiBbXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgbnMuZGlmZnVzZSA9IHtcbiAgICAgICAgICAgIGlucHV0U3BhY2VzOiBbXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwsXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgbnMucGhvbmcgPSB7XG4gICAgICAgICAgICBpbnB1dFNwYWNlczogW1xuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QsXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLlZJRVdfTk9STUFMLFxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1RcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIG5zLmNvb2tUb3JyYW5jZSA9IHtcbiAgICAgICAgICAgIGlucHV0U3BhY2VzOiBbXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwsXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNUXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICBucy53YXJkID0ge1xuICAgICAgICAgICAgaW5wdXRTcGFjZXM6IFtcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNULFxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCxcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwsXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNUXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICBucy5zY2F0dGVyID0ge1xuICAgICAgICAgICAgaW5wdXRTcGFjZXM6IFtcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNULFxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCxcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNUXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICBucy5yZWZsZWN0ID0ge1xuICAgICAgICAgICAgaW5wdXRTcGFjZXM6IFtcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwsXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgbnMucmVmcmFjdCA9IHtcbiAgICAgICAgICAgIGlucHV0U3BhY2VzOiBbXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLlZJRVdfTk9STUFMLFxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QsXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG5cbn0oZXhwb3J0cykpO1xuIiwiKGZ1bmN0aW9uIChucykge1xuXG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4gICAgdmFyIENsb3N1cmVzSW1wbCA9IHJlcXVpcmUoXCIuL3htbDNkLWZvcndhcmQuanNcIiksXG4gICAgICAgIExpZ2h0TG9vcCA9IHJlcXVpcmUoXCIuL2xpZ2h0LWxvb3AuanNcIikuTGlnaHRMb29wLFxuICAgICAgICBUcmF2ZXJzYWwgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyksXG4gICAgICAgIFN5bnRheCA9IFRyYXZlcnNhbC5TeW50YXgsXG4gICAgICAgIHBhcnNlciA9IHJlcXVpcmUoJ2VzcHJpbWEnKSxcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcbiAgICAgICAgc2FuaXRpemVyID0gcmVxdWlyZShcIi4vLi4vLi4vYW5hbHl6ZS9zYW5pdGl6ZXIvc2FuaXRpemVyLmpzXCIpO1xuICAgIHZhciByZXBsYWNlciA9IHJlcXVpcmUoXCIuLi9jb2xvcmNsb3N1cmUtcmVwbGFjZXIuanNcIik7XG5cbiAgICB2YXIgU3BhY2VUcmFuc2Zvcm1Ub29scyA9IHJlcXVpcmUoXCIuLi8uLi9nZW5lcmF0ZS9zcGFjZS9zcGFjZS10cmFuc2Zvcm0tdG9vbHMuanNcIiksXG4gICAgICAgIENvbG9yQ2xvc3VyZVRvb2xzID0gcmVxdWlyZShcIi4uL2NvbG9yY2xvc3VyZS10b29scy5qc1wiKTtcblxuXG5cbiAgICBmdW5jdGlvbiBjb250YWluc0Nsb3N1cmUoYXJyLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBhcnIuc29tZShmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuaWQubmFtZSA9PSBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbmplY3RBZGRpdGlvbihkZXN0TmFtZSwgZnVuY3Rpb25OYW1lLCBpbnB1dFByZSwgY2NOYW1lLCBjb2xvckNsb3N1cmVJbmRleCApe1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXRQcmUubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGlucHV0UHJlW2ldfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0c0NudCA9IFNoYWRlLkNvbG9yQ2xvc3VyZXNbY2NOYW1lXS5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dHNDbnQ7ICsraSl7XG4gICAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogZ2V0Q29sb3JDbG9zdXJlSW5wdXRBcmcoY29sb3JDbG9zdXJlSW5kZXgsIGkpfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogeyB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGRlc3ROYW1lfSxcbiAgICAgICAgICAgICAgICByaWdodDogeyB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZTogeyB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBkZXN0TmFtZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImFkZFwifVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt7IHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBmdW5jdGlvbk5hbWV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgIH19XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JDbG9zdXJlSW5qZWN0KGNjTmFtZSwgZnVuY3Rpb25NZW1iZXIsIHN0YXRlKXtcbiAgICAgICAgaWYoIUNsb3N1cmVzSW1wbFtjY05hbWVdKVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgQ29sb3JDbG9zdXJlICdcIiArIGNjTmFtZSArIFwiJ1wiICk7XG4gICAgICAgIGlmKCFDbG9zdXJlc0ltcGxbY2NOYW1lXVtmdW5jdGlvbk1lbWJlcl0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGNjTmFtZSArIFwiX1wiICsgZnVuY3Rpb25NZW1iZXI7XG4gICAgICAgIGlmICghY29udGFpbnNDbG9zdXJlKHN0YXRlLm5ld0Z1bmN0aW9ucywgZnVuY3Rpb25OYW1lKSl7XG4gICAgICAgICAgICB2YXIgY2xvc3VyZUltcGxlbWVudGF0aW9uID0gQ2xvc3VyZXNJbXBsW2NjTmFtZV1bZnVuY3Rpb25NZW1iZXJdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc3VyZUFTVCA9IHBhcnNlci5wYXJzZShjbG9zdXJlSW1wbGVtZW50YXRpb24udG9TdHJpbmcoKSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY2xvc3VyZUFTVCA9IHNhbml0aXplci5zYW5pdGl6ZShjbG9zdXJlQVNUKTtcbiAgICAgICAgICAgICAgICBjbG9zdXJlQVNULmJvZHlbMF0uaWQubmFtZSA9IGZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5uZXdGdW5jdGlvbnMucHVzaChjbG9zdXJlQVNULmJvZHlbMF0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBhbmFseXNpcyBvZiBjbG9zdXJlICdcIiwgY2NOYW1lICsgXCI+XCIgKyBmdW5jdGlvbk1lbWJlciwgXCInXCIsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gaW5qZWN0QnJkZkVudHJ5KGNjTmFtZXMsIHN0YXRlKXtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcbiAgICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjY05hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBmTmFtZSwgY2NOYW1lID0gY2NOYW1lc1tpXTtcbiAgICAgICAgICAgIGlmKGZOYW1lID0gZ2V0Q29sb3JDbG9zdXJlSW5qZWN0KGNjTmFtZSwgXCJnZXREaWZmdXNlXCIsIHN0YXRlKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJvZHkucHVzaChnZXRJbmplY3RBZGRpdGlvbihcImtkXCIsIGZOYW1lLCBbXCJMXCIsIFwiVlwiXSwgY2NOYW1lLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihmTmFtZSA9IGdldENvbG9yQ2xvc3VyZUluamVjdChjY05hbWUsIFwiZ2V0U3BlY3VsYXJcIiwgc3RhdGUpKXtcbiAgICAgICAgICAgICAgICByZXN1bHQuYm9keS5wdXNoKGdldEluamVjdEFkZGl0aW9uKFwia3NcIiwgZk5hbWUsIFtcIkxcIiwgXCJWXCJdLCBjY05hbWUsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluamVjdEFtYmllbnRFbnRyeShjY05hbWVzLCBzdGF0ZSl7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXG4gICAgICAgICAgICBib2R5OiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2NOYW1lcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgZk5hbWUsIGNjTmFtZSA9IGNjTmFtZXNbaV07XG4gICAgICAgICAgICBpZihmTmFtZSA9IGdldENvbG9yQ2xvc3VyZUluamVjdChjY05hbWUsIFwiZ2V0QW1iaWVudFwiLCBzdGF0ZSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goZ2V0SW5qZWN0QWRkaXRpb24oXCJhbWJpZW50Q29sb3JcIiwgZk5hbWUsIFtcImFtYmllbnRJbnRlbnNpdHlcIl0sIGNjTmFtZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5qZWN0RW1pc3NpdmVFbnRyeShjY05hbWVzLCBzdGF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogW11cbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNjTmFtZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGZOYW1lLCBjY05hbWUgPSBjY05hbWVzW2ldO1xuICAgICAgICAgICAgaWYoZk5hbWUgPSBnZXRDb2xvckNsb3N1cmVJbmplY3QoY2NOYW1lLCBcImdldEVtaXNzaXZlXCIsIHN0YXRlKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJvZHkucHVzaChnZXRJbmplY3RBZGRpdGlvbihcImVtaXNzaXZlQ29sb3JcIiwgZk5hbWUsIFtdLCBjY05hbWUsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluamVjdFJlZnJhY3RSZWZsZWN0RW50cnkoY2NOYW1lcywgc3RhdGUpe1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogW11cbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNjTmFtZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGZOYW1lLCBjY05hbWUgPSBjY05hbWVzW2ldO1xuICAgICAgICAgICAgaWYoZk5hbWUgPSBnZXRDb2xvckNsb3N1cmVJbmplY3QoY2NOYW1lLCBcImdldFJlZnJhY3RcIiwgc3RhdGUpKXtcbiAgICAgICAgICAgICAgICByZXN1bHQuYm9keS5wdXNoKGdldEluamVjdEFkZGl0aW9uKFwicmVmcmFjdENvbG9yXCIsIGZOYW1lLCBbXCJwb3NpdGlvblwiXSwgY2NOYW1lLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihmTmFtZSA9IGdldENvbG9yQ2xvc3VyZUluamVjdChjY05hbWUsIFwiZ2V0UmVmbGVjdFwiLCBzdGF0ZSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goZ2V0SW5qZWN0QWRkaXRpb24oXCJyZWZsZWN0Q29sb3JcIiwgZk5hbWUsIFtcInBvc2l0aW9uXCJdLCBjY05hbWUsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluamVjdFRyYW5zcGFyZW5jeShjY05hbWVzLCBzdGF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogW11cbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuaXNUcmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjY05hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBmTmFtZSwgY2NOYW1lID0gY2NOYW1lc1tpXTtcbiAgICAgICAgICAgIGlmKGZOYW1lID0gZ2V0Q29sb3JDbG9zdXJlSW5qZWN0KGNjTmFtZSwgXCJnZXRUcmFuc3BhcmVuY3lcIiwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJvZHkucHVzaChnZXRJbmplY3RBZGRpdGlvbihcInRyYW5zcGFyZW5jeVwiLCBmTmFtZSwgW1wicG9zaXRpb25cIl0sIGNjTmFtZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIHRyYW5zcGFyZW5jeSBjbG9zdXJlIGZvcmNlIG9wYXF1ZVxuICAgICAgICBpZiAocmVzdWx0LmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYm9keS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IFwidHJhbnNwYXJlbmN5XCJ9LFxuICAgICAgICAgICAgICAgICAgICByaWdodDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIm9wYXF1ZVwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGUuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmplY3RDb2xvckNsb3N1cmVDYWxscyhsaWdodExvb3BGdW5jdGlvbiwgY2NOYW1lcywgc3RhdGUpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gVHJhdmVyc2FsLnJlcGxhY2UobGlnaHRMb29wRnVuY3Rpb24uYm9keSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XG4gICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50ICYmIG5vZGUuZXhwcmVzc2lvbi50eXBlID09IFN5bnRheC5MaXRlcmFsKXtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG5vZGUuZXhwcmVzc2lvbi52YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQlJERl9FTlRSWVwiOiByZXR1cm4gaW5qZWN0QnJkZkVudHJ5KGNjTmFtZXMsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBTUJJRU5UX0VOVFJZXCI6IHJldHVybiBpbmplY3RBbWJpZW50RW50cnkoY2NOYW1lcywgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVNSVNTSVZFX0VOVFJZXCI6IHJldHVybiBpbmplY3RFbWlzc2l2ZUVudHJ5KGNjTmFtZXMsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSRUZSQUNUX1JFRkxFQ1RfRU5UUllcIjogcmV0dXJuIGluamVjdFJlZnJhY3RSZWZsZWN0RW50cnkoY2NOYW1lcywgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRSQU5TUEFSRU5DWVwiOiByZXR1cm4gaW5qZWN0VHJhbnNwYXJlbmN5KGNjTmFtZXMsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JDbG9zdXJlSW5wdXRBcmcoY2NJbmRleCwgaW5wdXRJbmRleCl7XG4gICAgICAgIHJldHVybiBcIl9jY1wiICsgY2NJbmRleCArIFwiSW5wdXRcIiArIGlucHV0SW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlnaHRMb29wRnVuY3Rpb24obGlnaHRMb29wRnVuY3Rpb25OYW1lLCBjY05hbWVzLCBzdGF0ZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbGlnaHRMb29wQXN0ID0gcGFyc2VyLnBhcnNlKExpZ2h0TG9vcC50b1N0cmluZygpLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGFuYWx5c2lzIG9mIHRoZSBsaWdodExvb3BcIiwgZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmN0aW9uQWFzdCA9IGxpZ2h0TG9vcEFzdC5ib2R5WzBdO1xuICAgICAgICBmdW5jdGlvbkFhc3QuaWQubmFtZSA9IGxpZ2h0TG9vcEZ1bmN0aW9uTmFtZTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2NOYW1lcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgY2NOYW1lID0gY2NOYW1lc1tpXTtcbiAgICAgICAgICAgIHZhciBjY0lucHV0ID0gU2hhZGUuQ29sb3JDbG9zdXJlc1tjY05hbWVdLmlucHV0O1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNjSW5wdXQubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQWFzdC5wYXJhbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXRDb2xvckNsb3N1cmVJbnB1dEFyZyhpLGopXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5qZWN0Q29sb3JDbG9zdXJlQ2FsbHMoZnVuY3Rpb25BYXN0LCBjY05hbWVzLCBzdGF0ZSk7XG5cbiAgICAgICAgbGlnaHRMb29wQXN0ID0gc2FuaXRpemVyLnNhbml0aXplKGxpZ2h0TG9vcEFzdCk7XG4gICAgICAgIHJldHVybiBsaWdodExvb3BBc3QuYm9keVswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMaWdodExvb3BGdW5jdGlvbihjb2xvckNsb3N1cmVMaXN0LCBzdGF0ZSl7XG4gICAgICAgIHZhciBjY05hbWVzID0gW107XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb2xvckNsb3N1cmVMaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgY2NOYW1lcy5wdXNoKGNvbG9yQ2xvc3VyZUxpc3RbaV0ubmFtZSk7XG4gICAgICAgIHZhciBsaWdodExvb3BGdW5jdGlvbk5hbWUgPSBcImxpZ2h0TG9vcF9cIiArIGNjTmFtZXMuam9pbihcIl9cIik7XG4gICAgICAgIGlmICghY29udGFpbnNDbG9zdXJlKHN0YXRlLm5ld0Z1bmN0aW9ucywgbGlnaHRMb29wRnVuY3Rpb25OYW1lKSl7XG4gICAgICAgICAgICBzdGF0ZS5uZXdGdW5jdGlvbnMucHVzaChjcmVhdGVMaWdodExvb3BGdW5jdGlvbihsaWdodExvb3BGdW5jdGlvbk5hbWUsIGNjTmFtZXMsIHN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpZ2h0TG9vcEZ1bmN0aW9uTmFtZTtcbiAgICB9XG5cblxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVMaWdodExvb3BDYWxsKGxpZ2h0TG9vcEZ1bmN0aW9uLCBjb2xvckNsb3N1cmVMaXN0LCBzdGF0ZSl7XG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgdmFyIHBvc0FyZyA9IHN0YXRlLnBvc2l0aW9uQXJnO1xuICAgICAgICBpZighc3RhdGUubm9TcGFjZVRyYW5zZm9ybSlcbiAgICAgICAgICAgIHBvc0FyZyA9IFNwYWNlVHJhbnNmb3JtVG9vbHMuZ2V0U3BhY2VUcmFuc2Zvcm1DYWxsKHBvc0FyZywgU2hhZGUuU3BhY2VWZWN0b3JUeXBlLlZJRVdfUE9JTlQpO1xuICAgICAgICBhcmdzLnB1c2gocG9zQXJnKVxuICAgICAgICBhcmdzLnB1c2goc3RhdGUuYW1iaWVudEFyZyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb2xvckNsb3N1cmVMaXN0Lmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBjY0VudHJ5ID0gY29sb3JDbG9zdXJlTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBjY0lucHV0ID0gU2hhZGUuQ29sb3JDbG9zdXJlc1tjY0VudHJ5Lm5hbWVdLmlucHV0O1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNjSW5wdXQubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBjY0VudHJ5LmFyZ3Nbal07XG4gICAgICAgICAgICAgICAgaWYoIWFyZylcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gQ29sb3JDbG9zdXJlVG9vbHMuZ2V0RGVmYXVsdFZhbHVlKGNjSW5wdXRbal0pO1xuICAgICAgICAgICAgICAgIGlmKGNjSW5wdXRbal0uc2VtYW50aWMgPT0gU2hhZGUuU0VNQU5USUNTLk5PUk1BTCAmJiAhc3RhdGUubm9TcGFjZVRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwoYXJnLCBTaGFkZS5TcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbGlnaHRMb29wRnVuY3Rpb259LFxuICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmV0dXJuU3RhdGVtZW50KHJldHVybkFhc3QsIHN0YXRlKXtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRDbG9zdXJlTGlzdChyZXR1cm5BYXN0LCBzdGF0ZSk7XG4gICAgICAgIGlmKGxpc3QubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuQWFzdC5hcmd1bWVudCA9IGxpZ2hMb29wQ2FsbDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVudlBhcmFtZXRlcihwcm9wZXJ0eSl7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9iamVjdDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJfZW52XCIgfSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogcHJvcGVydHl9fTtcbiAgICB9XG5cbiAgICBucy5yZXNvbHZlUHJlVHlwZUluZmVyZW5jZSA9IGZ1bmN0aW9uIChhc3QsIHByb2Nlc3NEYXRhLCBvcHQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgcG9zaXRpb25Bcmc6IG9wdCAmJiBvcHQubGlnaHRMb29wUG9zaXRpb25BcmcgfHwgbnVsbCxcbiAgICAgICAgICAgIGFtYmllbnRBcmc6IG9wdCAmJiBvcHQubGlnaHRMb29wQW1iaWVudEFyZyB8fCBudWxsLFxuICAgICAgICAgICAgbm9TcGFjZVRyYW5zZm9ybTogb3B0ICYmIG9wdC5saWdodExvb3BOb1NwYWNlVHJhbnNmb3JtIHx8IGZhbHNlLFxuICAgICAgICAgICAgcHJvZ3JhbTogYXN0LFxuICAgICAgICAgICAgbmV3RnVuY3Rpb25zOiBbXVxuICAgICAgICB9XG4gICAgICAgIGlmKCFzdGF0ZS5wb3NpdGlvbkFyZylcbiAgICAgICAgICAgIHN0YXRlLnBvc2l0aW9uQXJnID0gZ2V0RW52UGFyYW1ldGVyKFwicG9zaXRpb25cIik7XG4gICAgICAgIGlmKCFzdGF0ZS5hbWJpZW50QXJnKVxuICAgICAgICAgICAgc3RhdGUuYW1iaWVudEFyZyA9IHsgdHlwZTogU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uLCBvcGVyYXRvcjogXCJ8fFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZ2V0RW52UGFyYW1ldGVyKFwiYW1iaWVudEludGVuc2l0eVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7dHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiAwfSB9O1xuXG4gICAgICAgIGFzdCA9IHJlcGxhY2VyKGFzdCwgZnVuY3Rpb24oY2xvc3VyZXMpIHtcbiAgICAgICAgICAgIGFzc2VydChjbG9zdXJlcy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGxpZ2h0TG9vcEZ1bmN0aW9uID0gZ2V0TGlnaHRMb29wRnVuY3Rpb24oY2xvc3VyZXMsIHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBsaWdoTG9vcENhbGwgPSBnZW5lcmF0ZUxpZ2h0TG9vcENhbGwobGlnaHRMb29wRnVuY3Rpb24sIGNsb3N1cmVzLCBzdGF0ZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiaGVyZVwiLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2hMb29wQ2FsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhdGUubmV3RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obmV3RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHN0YXRlLnByb2dyYW0uYm9keS51bnNoaWZ0KG5ld0Z1bmN0aW9uKTtcbiAgICAgICAgfSlcblxuICAgICAgICBwcm9jZXNzRGF0YVtcImlzVHJhbnNwYXJlbnRcIl0gPSAhIXN0YXRlLmlzVHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG5cbn0oZXhwb3J0cykpO1xuIiwiLyoqXG4gKiBDcmVhdGVkIHdpdGggSmV0QnJhaW5zIFdlYlN0b3JtLlxuICogVXNlcjogbGFjaHNlblxuICogRGF0ZTogMTIvMTcvMTNcbiAqIFRpbWU6IDE6MjEgUE1cbiAqIFRvIGNoYW5nZSB0aGlzIHRlbXBsYXRlIHVzZSBGaWxlIHwgU2V0dGluZ3MgfCBGaWxlIFRlbXBsYXRlcy5cbiAqL1xuKGZ1bmN0aW9uIChucykge1xuXG5ucy5MaWdodExvb3AgPSBmdW5jdGlvbiBMaWdodExvb3AocG9zaXRpb24sIGFtYmllbnRJbnRlbnNpdHkpe1xuICAgIHZhciBWID0gcG9zaXRpb24uZmxpcCgpLm5vcm1hbGl6ZSgpLCBkaXN0LCBhdHRlbjtcbiAgICB2YXIga2RDb21wbGV0ZSA9IG5ldyBWZWMzKDAsMCwwKSwga3NDb21wbGV0ZSA9IG5ldyBWZWMzKDAsMCwwKTtcbiAgICBpZiAodGhpcy5NQVhfUE9JTlRMSUdIVFMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk1BWF9QT0lOVExJR0hUUzsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5wb2ludExpZ2h0T25baV0pXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgTCA9IHRoaXMudmlld01hdHJpeC5tdWxWZWModGhpcy5wb2ludExpZ2h0UG9zaXRpb25baV0sIDEuMCkueHl6KCk7XG4gICAgICAgIEwgPSBMLnN1Yihwb3NpdGlvbik7XG4gICAgICAgIGRpc3QgPSBMLmxlbmd0aCgpO1xuICAgICAgICBMID0gTC5ub3JtYWxpemUoKTtcblxuICAgICAgICB2YXIga2QgPSBuZXcgVmVjMygwLDAsMCksIGtzID0gbmV3IFZlYzMoMCwwLDApO1xuICAgICAgICBcIkJSREZfRU5UUllcIjtcblxuICAgICAgICBhdHRlbiA9IDEuMCAvICh0aGlzLnBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS54KCkgKyB0aGlzLnBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS55KCkgKiBkaXN0ICsgdGhpcy5wb2ludExpZ2h0QXR0ZW51YXRpb25baV0ueigpICogZGlzdCAqIGRpc3QpO1xuICAgICAgICBrZCA9IGtkLm11bCh0aGlzLnBvaW50TGlnaHRJbnRlbnNpdHlbaV0pLm11bChhdHRlbik7XG4gICAgICAgIGtzID0ga3MubXVsKHRoaXMucG9pbnRMaWdodEludGVuc2l0eVtpXSkubXVsKGF0dGVuKTtcbiAgICAgICAga2RDb21wbGV0ZSA9IGtkQ29tcGxldGUuYWRkKGtkKTtcbiAgICAgICAga3NDb21wbGV0ZSA9IGtzQ29tcGxldGUuYWRkKGtzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuTUFYX0RJUkVDVElPTkFMTElHSFRTKVxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLk1BWF9ESVJFQ1RJT05BTExJR0hUUzsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXJlY3Rpb25hbExpZ2h0T25baV0pXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBMID0gdGhpcy52aWV3TWF0cml4Lm11bFZlYyh0aGlzLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25baV0sIDApLnh5eigpO1xuICAgICAgICBMID0gTC5mbGlwKCkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdmFyIGtkID0gbmV3IFZlYzMoMCwwLDApLCBrcyA9IG5ldyBWZWMzKDAsMCwwKTtcbiAgICAgICAgXCJCUkRGX0VOVFJZXCI7XG5cbiAgICAgICAga2QgPSBrZC5tdWwodGhpcy5kaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W2ldKTtcbiAgICAgICAga3MgPSBrcy5tdWwodGhpcy5kaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W2ldKTtcbiAgICAgICAga2RDb21wbGV0ZSA9IGtkQ29tcGxldGUuYWRkKGtkKTtcbiAgICAgICAga3NDb21wbGV0ZSA9IGtzQ29tcGxldGUuYWRkKGtzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuTUFYX1NQT1RMSUdIVFMpXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuTUFYX1NQT1RMSUdIVFM7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5zcG90TGlnaHRPbltpXSkge1xuICAgICAgICAgICAgTCA9IHRoaXMudmlld01hdHJpeC5tdWxWZWModGhpcy5zcG90TGlnaHRQb3NpdGlvbltpXSwgMS4wKS54eXooKTtcbiAgICAgICAgICAgIEwgPSBMLnN1Yihwb3NpdGlvbik7XG4gICAgICAgICAgICBkaXN0ID0gTC5sZW5ndGgoKTtcbiAgICAgICAgICAgIEwgPSBMLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB2YXIgbERpcmVjdGlvbiA9IHRoaXMudmlld01hdHJpeC5tdWxWZWModGhpcy5zcG90TGlnaHREaXJlY3Rpb25baV0uZmxpcCgpLCAwKS54eXooKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IEwuZG90KGxEaXJlY3Rpb24pO1xuICAgICAgICAgICAgaWYoYW5nbGUgPiB0aGlzLnNwb3RMaWdodENvc0N1dG9mZkFuZ2xlW2ldKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtkID0gbmV3IFZlYzMoMCwwLDApLCBrcyA9IG5ldyBWZWMzKDAsMCwwKTtcbiAgICAgICAgICAgICAgICBcIkJSREZfRU5UUllcIjtcblxuICAgICAgICAgICAgICAgIHZhciBjID0gMS4wO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNwb3RMaWdodFNoYWRvd01hcCAmJiB0aGlzLnNwb3RMaWdodENhc3RTaGFkb3dbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdwb3MgPSB0aGlzLnZpZXdJbnZlcnNlTWF0cml4Lm11bFZlYyhwb3NpdGlvbiwgMS4wKS54eXooKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbHNQb3MgPSB0aGlzLnNwb3RMaWdodE1hdHJpeFtpXS5tdWxWZWMobmV3IFZlYzQod3BvcywgMSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc3BlY3RpdmVEaXZQb3MgPSBsc1Bvcy54eXooKS5kaXYobHNQb3MudygpKS5tdWwoMC41KS5hZGQoMC41KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxzRGVwdGggPSBwZXJzcGVjdGl2ZURpdlBvcy56KCkgLSB0aGlzLnNwb3RMaWdodFNoYWRvd0JpYXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpZ2h0dXYgPSBwZXJzcGVjdGl2ZURpdlBvcy54eSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0U2hpZnQgPSBuZXcgVmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChsaWdodHV2KS5kb3QoYml0U2hpZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZihsc0RlcHRoID49IGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qdmFyIHRleFNpemUgPSBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgKiAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4ZWxTaXplID0gMSAvIHRleFNpemU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gTWF0aC5mcmFjdChsaWdodHV2Lm11bCh0ZXhTaXplKS5hZGQoMC41KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50cm9pZFVWID0gTWF0aC5mbG9vcihsaWdodHV2Lm11bCh0ZXhTaXplKS5hZGQoMC41KSk7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkVVYgPSBjZW50cm9pZFVWLmRpdih0ZXhTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGIgPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChjZW50cm9pZFVWKS5kb3QoYml0U2hpZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGIgPj0gbHNEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxiID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBsYiA9IDAuMDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbHQgPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChjZW50cm9pZFVWLmFkZChuZXcgVmVjMigwLjAsIDEuMCkubXVsKHRleGVsU2l6ZSkpKS5kb3QoYml0U2hpZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobHQgPj0gbHNEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBsdCA9IDAuMDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmIgPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChjZW50cm9pZFVWLmFkZChuZXcgVmVjMigxLjAsIDAuMCkubXVsKHRleGVsU2l6ZSkpKS5kb3QoYml0U2hpZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmIgPj0gbHNEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJiID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByYiA9IDAuMDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcnQgPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChjZW50cm9pZFVWLmFkZChuZXcgVmVjMigxLjAsIDEuMCkubXVsKHRleGVsU2l6ZSkpKS5kb3QoYml0U2hpZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnQgPj0gbHNEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0ID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBydCA9IDAuMDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IE1hdGgubWl4KGxiLCBsdCwgZi55KCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IE1hdGgubWl4KHJiLCBydCwgZi55KCkpO1xuICAgICAgICAgICAgICAgICAgICBjID0gTWF0aC5taXgoYSwgYiwgZi54KCkpOyovXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNvZnRuZXNzID0gMS4wO1xuICAgICAgICAgICAgICAgIGlmKGFuZ2xlIDwgdGhpcy5zcG90TGlnaHRDb3NTb2Z0Q3V0b2ZmQW5nbGVbaV0pXG4gICAgICAgICAgICAgICAgICAgIHNvZnRuZXNzID0gKGFuZ2xlIC0gdGhpcy5zcG90TGlnaHRDb3NDdXRvZmZBbmdsZVtpXSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3BvdExpZ2h0Q29zU29mdEN1dG9mZkFuZ2xlW2ldIC0gIHRoaXMuc3BvdExpZ2h0Q29zQ3V0b2ZmQW5nbGVbaV0pO1xuXG4gICAgICAgICAgICAgICAgYXR0ZW4gPSAxLjAgLyAodGhpcy5zcG90TGlnaHRBdHRlbnVhdGlvbltpXS54KCkgKyB0aGlzLnNwb3RMaWdodEF0dGVudWF0aW9uW2ldLnkoKSAqIGRpc3QgKyB0aGlzLnNwb3RMaWdodEF0dGVudWF0aW9uW2ldLnooKSAqIGRpc3QgKiBkaXN0KTtcbiAgICAgICAgICAgICAgICBrZCA9IGtkLm11bCh0aGlzLnNwb3RMaWdodEludGVuc2l0eVtpXSkubXVsKGF0dGVuICogc29mdG5lc3MgKiBjKTtcbiAgICAgICAgICAgICAgICBrcyA9IGtzLm11bCh0aGlzLnNwb3RMaWdodEludGVuc2l0eVtpXSkubXVsKGF0dGVuICogc29mdG5lc3MgKiBjKTtcbiAgICAgICAgICAgICAgICBrZENvbXBsZXRlID0ga2RDb21wbGV0ZS5hZGQoa2QpO1xuICAgICAgICAgICAgICAgIGtzQ29tcGxldGUgPSBrc0NvbXBsZXRlLmFkZChrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFtYmllbnRDb2xvciA9IG5ldyBWZWMzKDAsMCwwKTtcbiAgICBcIkFNQklFTlRfRU5UUllcIjtcbiAgICBrZENvbXBsZXRlID0ga2RDb21wbGV0ZS5hZGQoYW1iaWVudENvbG9yKTtcbiAgICB2YXIgZW1pc3NpdmVDb2xvciA9IG5ldyBWZWMzKDAsIDAsIDApO1xuICAgIFwiRU1JU1NJVkVfRU5UUllcIlxuICAgIC8qaWYgKHRoaXMuc3Nhb01hcCkge1xuICAgICAgICBrZENvbXBsZXRlID0ga2RDb21wbGV0ZS5tdWwoMSAtIHRoaXMuc3Nhb01hcC5zYW1wbGUyRCh0aGlzLm5vcm1hbGl6ZWRDb29yZHMpLnIoKSk7XG4gICAgfSAqL1xuICAgIHZhciByZWZyYWN0Q29sb3IgPSBuZXcgVmVjMygwLCAwLCAwKTtcbiAgICB2YXIgcmVmbGVjdENvbG9yID0gbmV3IFZlYzMoMCwgMCwgMCk7XG4gICAgXCJSRUZSQUNUX1JFRkxFQ1RfRU5UUllcIlxuICAgIHZhciBvcGFxdWUgPSBuZXcgVmVjMygxLCAxLCAxKTtcbiAgICB2YXIgdHJhbnNwYXJlbmN5ID0gbmV3IFZlYzMoMCwgMCwgMCk7XG4gICAgXCJUUkFOU1BBUkVOQ1lcIlxuICAgIHJldHVybiBuZXcgVmVjNChNYXRoLnBvdyhuZXcgVmVjMyhlbWlzc2l2ZUNvbG9yLmFkZChrZENvbXBsZXRlLmFkZChrc0NvbXBsZXRlKSkuYWRkKHJlZnJhY3RDb2xvcikuYWRkKHJlZmxlY3RDb2xvcikpLCBuZXcgVmVjMygxLzIuMikpLCB0cmFuc3BhcmVuY3kueCgpKTtcbn1cblxufShleHBvcnRzKSk7XG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICAgICAgbnMuZW1pc3NpdmUgPSB7XG4gICAgICAgICAgICBnZXRFbWlzc2l2ZTogZnVuY3Rpb24gZ2V0RW1pc3NpdmUoY29sb3Ipe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBucy5kaWZmdXNlID0ge1xuICAgICAgICAgICAgZ2V0RGlmZnVzZTogZnVuY3Rpb24gZ2V0RGlmZnVzZShMLCBWLCBjb2xvciwgTiwgcm91Z2huZXNzKXtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHJvdWdobmVzcyBpcyBkZWZpbmVkIHdlIHVzZSBPcmVuIE5heWFyIGJyZGYuXG4gICAgICAgICAgICAgICAgdmFyIGEsIGIsIE5kb3RWLCB0aGV0YU91dCwgcGhpT3V0LCB0aGV0YUluO1xuICAgICAgICAgICAgICAgIHZhciBjb3NQaGlEaWZmLCBhbHBoYSwgYmV0YTtcbiAgICAgICAgICAgICAgICB2YXIgTmRvdEwgPSBNYXRoLnNhdHVyYXRlKE4uZG90KEwpKTtcblxuICAgICAgICAgICAgICAgIC8vIExhbWJlcnRpYW4gcmVmbGVjdGlvbiBpcyBjb25zdGFudCBvdmVyIHRoZSBoZW1pc3BoZXJlLlxuICAgICAgICAgICAgICAgIHZhciBicmRmID0gMS4wO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdWdobmVzcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IDEuMCAtIChyb3VnaG5lc3MgKiByb3VnaG5lc3MpIC8gKDIgKiAocm91Z2huZXNzICogcm91Z2huZXNzICsgMC4zMykpO1xuICAgICAgICAgICAgICAgICAgICBiID0gMC40NSAqIChyb3VnaG5lc3MgKiByb3VnaG5lc3MpIC8gKHJvdWdobmVzcyAqIHJvdWdobmVzcyArIDAuMDkpO1xuICAgICAgICAgICAgICAgICAgICBOZG90ViA9IE4uZG90KFYpO1xuICAgICAgICAgICAgICAgICAgICB0aGV0YU91dCA9IE1hdGguYWNvcyhOZG90Vik7XG4gICAgICAgICAgICAgICAgICAgIHBoaU91dCA9IFYuc3ViKE4ubXVsKE5kb3RWKSkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoZXRhSW4gPSBNYXRoLmFjb3MoTmRvdEwpO1xuICAgICAgICAgICAgICAgICAgICBjb3NQaGlEaWZmID0gcGhpT3V0LmRvdChMLnN1YihOLm11bChOZG90TCkpLm5vcm1hbGl6ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBNYXRoLm1heCh0aGV0YU91dCwgdGhldGFJbik7XG4gICAgICAgICAgICAgICAgICAgIGJldGEgPSBNYXRoLm1pbih0aGV0YU91dCwgdGhldGFJbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZGYgPSAoYSArIGIgKiBNYXRoLnNhdHVyYXRlKGNvc1BoaURpZmYpICogTWF0aC5zaW4oYWxwaGEpICogTWF0aC50YW4oYmV0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmRmICo9IE5kb3RMO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoYnJkZik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRBbWJpZW50OiBmdW5jdGlvbiBnZXRBbWJpZW50KGFtYmllbnRJbnRlbnNpdHksIGNvbG9yLCBOLCByb3VnaG5lc3Mpe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoYW1iaWVudEludGVuc2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbnMucGhvbmcgPSB7XG4gICAgICAgICAgICBnZXRTcGVjdWxhcjogZnVuY3Rpb24gZ2V0U3BlY3VsYXIoTCwgViwgY29sb3IsIE4sIHNoaW5pbmVzcyl7XG4gICAgICAgICAgICAgICAgdmFyIFIgPSBMLnJlZmxlY3QoTikubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV5ZVZlY3RvciA9IFYuZmxpcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoTWF0aC5wb3coTWF0aC5tYXgoUi5kb3QoZXllVmVjdG9yKSwwLjApLCBzaGluaW5lc3MqMTI4LjApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBucy5jb29rVG9ycmFuY2UgPSB7XG4gICAgICAgICAgICBnZXRTcGVjdWxhcjogZnVuY3Rpb24gZ2V0U3BlY3VsYXIoTCwgViwgY29sb3IsIE4sIGlvciwgcm91Z2huZXNzKXtcbiAgICAgICAgICAgICAgICB2YXIgUjAgPSBNYXRoLnBvdygoMSAtIGlvcikgLyAoMSArIGlvciksIDIpO1xuICAgICAgICAgICAgICAgIHZhciBIID0gVi5hZGQoTCkubm9ybWFsaXplKCksXG4gICAgICAgICAgICAgICAgICAgIE5kb3RIID0gTi5kb3QoSCksXG4gICAgICAgICAgICAgICAgICAgIE5kb3RMID0gTWF0aC5zYXR1cmF0ZShOLmRvdChMKSksXG4gICAgICAgICAgICAgICAgICAgIEhkb3ROID0gSC5kb3QoTiksXG4gICAgICAgICAgICAgICAgICAgIEhkb3RMID0gSC5kb3QoTCksXG4gICAgICAgICAgICAgICAgICAgIEhkb3RWID0gSC5kb3QoViksXG4gICAgICAgICAgICAgICAgICAgIE5kb3RWID0gTi5kb3QoVik7XG5cbiAgICAgICAgICAgICAgICAvLyBCZWNrbWFubiBkaXN0cmlidXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLmFjb3MoTmRvdEgpLFxuICAgICAgICAgICAgICAgICAgICBudW1lcmF0b3IgPSBNYXRoLmV4cCgtTWF0aC5wb3coTWF0aC50YW4oYWxwaGEpIC8gcm91Z2huZXNzLCAyKSksXG4gICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gTWF0aC5wb3cocm91Z2huZXNzLCAyKSAqIE1hdGgucG93KE5kb3RILCA0KSxcbiAgICAgICAgICAgICAgICAgICAgZCA9ICBNYXRoLm1heCgwLCBudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XG5cbiAgICAgICAgICAgICAgICAvLyBHZW9tZXRyaWMgYXR0ZW51YXRpb25cbiAgICAgICAgICAgICAgICB2YXIgRzEgPSAyICogSGRvdE4gKiBOZG90ViAvIEhkb3RWLFxuICAgICAgICAgICAgICAgICAgICBHMiA9IDIgKiBIZG90TiAqIE5kb3RMIC8gSGRvdFYsXG4gICAgICAgICAgICAgICAgICAgIGcgPSAgTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oRzEsIEcyKSkpLFxuICAgICAgICAgICAgICAgICAgICBmID0gTWF0aC5tYXgoMCwgUjAgKyAoMSAtIFIwKSAqIE1hdGgucG93KDEgLSBOZG90SCwgNSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJyZGYgPSBkICogZyAqIGYgLyAoTWF0aC5QSSAqIE5kb3RWKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IubXVsKGJyZGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG5zLndhcmQgPSB7XG4gICAgICAgICAgICBnZXRTcGVjdWxhcjogZnVuY3Rpb24gZ2V0U3BlY3VsYXIoTCwgViwgY29sb3IsIE4sIFQsIGF4LCBheSl7XG4gICAgICAgICAgICAgICAgdmFyIEggPSBMLmFkZChWKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB2YXIgQiA9IE4uY3Jvc3MoVCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgdmFyIE5kb3RWID0gTWF0aC5zYXR1cmF0ZShOLmRvdChWKSk7XG4gICAgICAgICAgICAgICAgdmFyIE5kb3RMID0gTWF0aC5zYXR1cmF0ZShOLmRvdChMKSkgKyAwLjAwMTtcbiAgICAgICAgICAgICAgICB2YXIgTmRvdEggPSBOLmRvdChIKSArIDAuMDAxO1xuICAgICAgICAgICAgICAgIHZhciBIZG90VCA9IEguZG90KFQpO1xuICAgICAgICAgICAgICAgIHZhciBIZG90QiA9IEguZG90KEIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gMSAvICg0ICogTWF0aC5QSSAqIGF4ICogYXkgKiBNYXRoLnNxcnQoTmRvdEwgKiBOZG90VikpO1xuICAgICAgICAgICAgICAgIHZhciBiZXRhID0gLShNYXRoLnBvdyhIZG90VCAvIGF4LCAyKSArIE1hdGgucG93KEhkb3RCIC8gYXksIDIpKSAvIChOZG90SCAqIE5kb3RIKTtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kID0gTWF0aC5leHAoYmV0YSk7XG4gICAgICAgICAgICAgICAgdmFyIGJyZGYgPSBNYXRoLm1heCgwLCBmaXJzdCAqIHNlY29uZCkgKiBOZG90TDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoYnJkZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbnMuc2NhdHRlciA9IHtcbiAgICAgICAgICAgIGdldFNwZWN1bGFyOiBmdW5jdGlvbiBnZXRTcGVjdWxhcihMLCBWLCBjb2xvciwgTiwgd3JhcCwgc2NhdHRlcldpZHRoKXtcbiAgICAgICAgICAgICAgICB2YXIgTmRvdEwgPSBNYXRoLnNhdHVyYXRlKE4uZG90KEwpKTtcblxuICAgICAgICAgICAgICAgIHZhciBOZG90TFdyYXAgPSAoTmRvdEwgKyB3cmFwKSAvICgxICsgd3JhcCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjYXR0ZXIgPSBNYXRoLnNtb290aHN0ZXAoMC4wLCBzY2F0dGVyV2lkdGgsIE5kb3RMV3JhcCkgKiBNYXRoLnNtb290aHN0ZXAoc2NhdHRlcldpZHRoICogMi4wLCBzY2F0dGVyV2lkdGgsIE5kb3RMV3JhcCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IubXVsKHNjYXR0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG5zLnJlZmxlY3QgPSB7XG4gICAgICAgICAgICBnZXRSZWZsZWN0OiBmdW5jdGlvbiBnZXRSZWZsZWN0KHBvc2l0aW9uLCBOLCBmYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBOID0gdGhpcy52aWV3SW52ZXJzZU1hdHJpeC5tdWxWZWMoTiwgMCkueHl6KCk7XG4gICAgICAgICAgICAgICAgdmFyIEkgPSB0aGlzLnZpZXdJbnZlcnNlTWF0cml4Lm11bFZlYyhwb3NpdGlvbiwgMS4wKS54eXooKS5zdWIodGhpcy5jYW1lcmFQb3NpdGlvbikubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpb24zRCA9IEkucmVmbGVjdChOKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmbGVjdGlvbjJEID0gbmV3IFZlYzIoKE1hdGguYXRhbjIoLXJlZmxlY3Rpb24zRC56KCksIHJlZmxlY3Rpb24zRC54KCkpICsgTWF0aC5QSSkgLyAoMiAqIE1hdGguUEkpLCAoTWF0aC5hc2luKHJlZmxlY3Rpb24zRC55KCkpICsgTWF0aC5QSSAvIDIuMCkgLyBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy5lbnZpcm9ubWVudC5zYW1wbGUyRChyZWZsZWN0aW9uMkQpLnJnYigpLCBuZXcgVmVjMygyLjIpKS5tdWwoZmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBucy5yZWZyYWN0ID0ge1xuICAgICAgICAgICAgZ2V0UmVmcmFjdDogZnVuY3Rpb24gZ2V0UmVmcmFjdChwb3NpdGlvbiwgTiwgZXRhLCBmYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBOID0gdGhpcy52aWV3SW52ZXJzZU1hdHJpeC5tdWxWZWMoTiwgMCkueHl6KCk7XG4gICAgICAgICAgICAgICAgdmFyIEkgPSB0aGlzLnZpZXdJbnZlcnNlTWF0cml4Lm11bFZlYyhwb3NpdGlvbiwgMS4wKS54eXooKS5zdWIodGhpcy5jYW1lcmFQb3NpdGlvbikubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZnJhY3Rpb24zRCA9IEkucmVmcmFjdChOLCBldGEpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHZhciByZWZyYWN0aW9uMkQgPSBuZXcgVmVjMigoTWF0aC5hdGFuMigtcmVmcmFjdGlvbjNELnooKSwgcmVmcmFjdGlvbjNELngoKSkgKyBNYXRoLlBJKSAvICgyICogTWF0aC5QSSksIChNYXRoLmFzaW4ocmVmcmFjdGlvbjNELnkoKSkgKyBNYXRoLlBJIC8gMi4wKSAvIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLmVudmlyb25tZW50LnNhbXBsZTJEKHJlZnJhY3Rpb24yRCkucmdiKCksIG5ldyBWZWMzKDIuMikpLm11bChmYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG5zLnRyYW5zcGFyZW50ID0ge1xuICAgICAgICAgICAgZ2V0VHJhbnNwYXJlbmN5OiBmdW5jdGlvbiBnZXRUcmFuc3BhcmVuY3kocG9zaXRpb24sIGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGFscGhhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxufShleHBvcnRzKSk7XG4iLCIvKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzLlRZUEVTID0ge1xuICAgIEFOWTogXCJhbnlcIixcbiAgICBJTlQ6IFwiaW50XCIsXG4gICAgTlVNQkVSOiBcIm51bWJlclwiLFxuICAgIEJPT0xFQU46IFwiYm9vbGVhblwiLFxuICAgIE9CSkVDVDogXCJvYmplY3RcIixcbiAgICBBUlJBWTogXCJhcnJheVwiLFxuICAgIE5VTEw6IFwibnVsbFwiLFxuICAgIFVOREVGSU5FRDogXCJ1bmRlZmluZWRcIixcbiAgICBGVU5DVElPTjogXCJmdW5jdGlvblwiLFxuICAgIFNUUklORzogXCJzdHJpbmdcIixcbiAgICBJTlZBTElEOiBcImludmFsaWRcIixcbiAgICBSRUZFUkVOQ0U6IFwicmVmZXJlbmNlXCJcbn07XG4iLCIvLyBEZXBlbmRlbmNpZXNcbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XG5cbnZhciBFcnJvckhhbmRsZXIgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7Li4uKn0gbWVzc2FnZVxuICogQHJldHVybnMge3ttZXNzYWdlOiBzdHJpbmcsIGxvYzogKn19XG4gKi9cbkVycm9ySGFuZGxlci5nZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgdHlwZSwgbWVzc2FnZSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zcGxpY2UoMiksXG4gICAgICAgIGxvYyA9IG5vZGUubG9jLFxuICAgICAgICBjb2RlSW5mbyA9IFwiXCI7XG5cbiAgICBjb2RlSW5mbyArPSBjb2RlZ2VuLmdlbmVyYXRlKG5vZGUpO1xuICAgIGlmIChsb2MgJiYgbG9jLnN0YXJ0LmxpbmUpIHtcbiAgICAgICAgY29kZUluZm8gKz0gXCIgKExpbmUgXCIgKyBsb2Muc3RhcnQubGluZSArIFwiKVwiO1xuICAgIH1cbiAgICBtZXNzYWdlID0gYXJncy5sZW5ndGggPyBhcmdzLmpvaW4oXCIgXCIpICsgXCI6IFwiIDogXCJcIjtcbiAgICByZXR1cm4ge21lc3NhZ2U6IHR5cGUgKyBcIjogXCIgKyBtZXNzYWdlICsgY29kZUluZm8sIGxvYzogbG9jfTtcbn07XG5cbkVycm9ySGFuZGxlci50aHJvd0Vycm9yID0gZnVuY3Rpb24obm9kZSwgbXNnKSB7XG4gICAgdmFyIGxvYyA9IG5vZGUgJiYgbm9kZS5sb2M7XG4gICAgaWYgKGxvYyAmJiBsb2Muc3RhcnQubGluZSkge1xuICAgICAgICBtc2cgPSBcIkxpbmUgXCIgKyBsb2Muc3RhcnQubGluZSArIFwiOiBcIiArIG1zZztcbiAgICB9XG4gICAgbXNnICs9IFwiOiBcIiArIGNvZGVnZW4uZ2VuZXJhdGUobm9kZSk7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcbiAgICBlcnJvci5sb2MgPSBsb2M7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuXG5FcnJvckhhbmRsZXIuRVJST1JfVFlQRVMgPSB7XG4gICAgVFlQRV9FUlJPUjogXCJUeXBlRXJyb3JcIixcbiAgICBSRUZFUkVOQ0VfRVJST1I6IFwiUmVmZXJlbmNlRXJyb3JcIixcbiAgICBOQU5fRVJST1I6IFwiTm90QU51bWJlckVycm9yXCIsXG4gICAgU0hBREVKU19FUlJPUjogXCJTaGFkZUpTRXJyb3JcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFcnJvckhhbmRsZXI7XG5cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG52YXIgVHlwZVN5c3RlbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHJlZ2lzdGVyUHJlZGVmaW5lZE9iamVjdDogZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcblx0XHRcdGFzc2VydChkZWZpbml0aW9uLm5hbWUsIFwiQ2FuJ3QgcmVnaXN0ZXIgb2JqZWN0IHdpdGhvdXQgbmFtZVwiKTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnNldChkZWZpbml0aW9uLm5hbWUsIGRlZmluaXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFByZWRlZmluZWRPYmplY3Q6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gcmVnaXN0cnkuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KG9iaiwgXCJDYW4ndCBmaW5kIG9iamVjdCAnXCIgKyBuYW1lICsgXCInIGluIFR5cGVTeXN0ZW0uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVzdWx0LnJlZ2lzdGVyUHJlZGVmaW5lZE9iamVjdChyZXF1aXJlKFwiLi4vYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L21hdGguanNcIikpO1xuXHRyZXN1bHQucmVnaXN0ZXJQcmVkZWZpbmVkT2JqZWN0KHJlcXVpcmUoXCIuLi9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvdmVjMi5qc1wiKSk7XG5cdHJlc3VsdC5yZWdpc3RlclByZWRlZmluZWRPYmplY3QocmVxdWlyZShcIi4uL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS92ZWMzLmpzXCIpKTtcblx0cmVzdWx0LnJlZ2lzdGVyUHJlZGVmaW5lZE9iamVjdChyZXF1aXJlKFwiLi4vYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3ZlYzQuanNcIikpO1xuICAgIHJlc3VsdC5yZWdpc3RlclByZWRlZmluZWRPYmplY3QocmVxdWlyZShcIi4uL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9tYXQzLmpzXCIpKTtcbiAgICByZXN1bHQucmVnaXN0ZXJQcmVkZWZpbmVkT2JqZWN0KHJlcXVpcmUoXCIuLi9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvbWF0NC5qc1wiKSk7XG4gICAgcmVzdWx0LnJlZ2lzdGVyUHJlZGVmaW5lZE9iamVjdChyZXF1aXJlKFwiLi4vYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3N5c3RlbS5qc1wiKSk7XG4gICAgcmVzdWx0LnJlZ2lzdGVyUHJlZGVmaW5lZE9iamVjdChyZXF1aXJlKFwiLi4vYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3NwYWNlLmpzXCIpKTtcbiAgICByZXN1bHQucmVnaXN0ZXJQcmVkZWZpbmVkT2JqZWN0KHJlcXVpcmUoXCIuLi9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvb2JqZWN0LmpzXCIpKTtcbiAgICByZXN1bHQucmVnaXN0ZXJQcmVkZWZpbmVkT2JqZWN0KHJlcXVpcmUoXCIuLi9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvc2hhZGUuanNcIikpO1xuICAgIHJlc3VsdC5yZWdpc3RlclByZWRlZmluZWRPYmplY3QocmVxdWlyZShcIi4uL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9hcnJheS5qc1wiKSk7XG4gICAgcmVzdWx0LnJlZ2lzdGVyUHJlZGVmaW5lZE9iamVjdChyZXF1aXJlKFwiLi4vYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3RleHR1cmUuanNcIikpO1xuICAgIHJldHVybiByZXN1bHQ7XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVTeXN0ZW07XG4iLCIvLyBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbnZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xudmFyIFNldCA9IHJlcXVpcmUoJ2FuYWx5c2VzJykuU2V0O1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoXCJsb2Rhc2guYXNzaWduXCIpO1xudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC5jbG9uZVwiKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBUeXBlU3lzdGVtID0gcmVxdWlyZSgnLi90eXBlLXN5c3RlbS5qcycpO1xuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbnZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2VzLmpzXCIpOyAvLyBUT0RPKGtzb25zKTogRWxpbWluYXRlIHRoaXMgZGVwZW5kZW5jeVxudmFyIFRZUEVTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpLlRZUEVTO1xuXG4vLyBUT0RPKGtzb25zKTogTmV3IG1lY2hhbmlzbSBmb3IgcHJlZGVmaW5lZCB0eXBlc1xudmFyIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gaW5mbyBDYXJyaWVyIG9iamVjdCBmb3IgdGhlIHR5cGUgaW5mbywgb25seSBub2RlLmV4dHJhIGdldHMgcG9sbHV0ZWRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVHlwZUluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGFzc2VydChpbmZvLnR5cGUpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICB0eXBlOiB7Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGluZm8udHlwZSB9LCBzZXQ6IGZ1bmN0aW9uKGUpIHsgaW5mby50eXBlID0gZTsgfX0sXG4gICAgICAgIGVycm9yOiB7Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGluZm8uZXJyb3IgfSwgc2V0OiBmdW5jdGlvbihlKSB7IGluZm8uZXJyb3IgPSBlOyB9fSxcbiAgICAgICAgY3Rvcjoge2dldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighc2VsZi5pc0Z1bmN0aW9uKCkgfHwgIXNlbGYuZ2V0S2luZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzIG5vIGNvbnN0cnVjdG9yOlwiICsgc2VsZik7XG4gICAgICAgICAgICB9XG5cdFx0XHR2YXIgcHJlZGVmaW5lZFR5cGUgPSBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QodGhpcy5nZXRLaW5kKCkpO1xuXHRcdFx0cmV0dXJuIHByZWRlZmluZWRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5UeXBlSW5mby5jcmVhdGVGb3JDb250ZXh0ID0gZnVuY3Rpb24gKG5vZGUsIGN0eCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgVHlwZUluZm8obm9kZS5leHRyYSk7XG4gICAgaWYgKHJlc3VsdC5nZXRUeXBlKCkgIT09IFRZUEVTLkFOWSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgIHZhciB2YXJpYWJsZSA9IGN0eC5nZXRCaW5kaW5nQnlOYW1lKG5hbWUpO1xuICAgICAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb3B5KHZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1R5cGVJbmZvfSB0eXBlSW5mb1xuICogQHBhcmFtIHtPYmplY3Q/fSB2YWx1ZVxuICovXG5UeXBlSW5mby5jb3B5U3RhdGljVmFsdWUgPSBmdW5jdGlvbiAodHlwZUluZm8sIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSB8fCB0eXBlSW5mby5nZXRDb25zdGFudFZhbHVlKCk7XG4gICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byBjb3B5IHByaW1pdGl2ZSB0eXBlc1xuICAgIC8vaWYgKCF0eXBlSW5mby5pc09iamVjdCgpKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgLy9zd2l0Y2ggKHR5cGVJbmZvLmdldEtpbmQoKSkge1xuICAgIC8vICAgIGNhc2UgXCJWZWMyXCI6XG4gICAgLy8gICAgICAgIHJldHVybiBuZXcgU2hhZGUuVmVjMih2YWx1ZSk7XG4gICAgLy8gICAgY2FzZSBcIlZlYzNcIjpcbiAgICAvLyAgICAgICAgcmV0dXJuIG5ldyBTaGFkZS5WZWMzKHZhbHVlKTtcbiAgICAvLyAgICBjYXNlIFwiVmVjNFwiOlxuICAgIC8vICAgICAgICByZXR1cm4gbmV3IFNoYWRlLlZlYzQodmFsdWUpO1xuICAgIC8vICAgIGNhc2UgXCJNYXQzXCI6XG4gICAgLy8gICAgICAgIHJldHVybiBuZXcgU2hhZGUuTWF0Myh2YWx1ZSk7XG4gICAgLy8gICAgY2FzZSBcIk1hdDRcIjpcbiAgICAvLyAgICAgICAgcmV0dXJuIG5ldyBTaGFkZS5NYXQ0KHZhbHVlKTtcbiAgICAvLyAgICBkZWZhdWx0OlxuICAgIC8vICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb3B5IHN0YXRpYyB2YWx1ZSBvZiBraW5kOiBcIiArIHR5cGVJbmZvLmdldEtpbmQoKSk7XG4gICAgLy99XG59O1xuXG5UeXBlSW5mby5wcm90b3R5cGUgPSB7XG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH0sXG5cbiAgICBzZXRLaW5kOiBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICB0aGlzLmluZm8ua2luZCA9IGtpbmQ7XG4gICAgfSxcblxuICAgIGdldEtpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKVxuICAgICAgICAgICAgcmV0dXJuIFwiQXJyYXlcIjtcbiAgICAgICAgaWYgKCEodGhpcy5pc09iamVjdCgpIHx8IHRoaXMuaXNGdW5jdGlvbigpKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmtpbmQgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0VXNlckRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBpZiAoIWV4dHJhLnVzZXJEYXRhKSBleHRyYS51c2VyRGF0YSA9IHt9O1xuICAgICAgICByZXR1cm4gZXh0cmEudXNlckRhdGE7XG4gICAgfSxcblxuICAgIGdldEFycmF5RWxlbWVudFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXJyYXkoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBnZXRBcnJheUVsZW1lbnRUeXBlIG9uIFwiICsgdGhpcy5nZXRUeXBlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmVsZW1lbnRzO1xuICAgIH0sXG5cbiAgICBzZXRBcnJheVNpemU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FycmF5KCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgc2V0QXJyYXlTaXplIG9uIFwiICsgdGhpcy5nZXRUeXBlKCkpO1xuICAgICAgICBhc3NlcnQoc2l6ZSA+PSAwKTtcbiAgICAgICAgdGhpcy5pbmZvLnN0YXRpY1NpemUgPSBzaXplO1xuICAgIH0sXG5cbiAgICBnZXRBcnJheVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXJyYXkoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBnZXRBcnJheVNpemUgb24gXCIgKyB0aGlzLmdldFR5cGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uc3RhdGljU2l6ZTtcbiAgICB9LFxuXG4gICAgaXNPZktpbmQ6IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgIGlmICghdGhpcy5pc09iamVjdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2luZCgpID09IGtpbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmc/fSBraW5kXG4gICAgICovXG4gICAgc2V0VHlwZTogZnVuY3Rpb24gKHR5cGUsIGtpbmQpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBleHRyYS50eXBlID0gdHlwZTtcbiAgICAgICAgaWYgKGtpbmQpXG4gICAgICAgICAgICB0aGlzLnNldEtpbmQoa2luZCk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSlcbiAgICAgICAgICAgIHRoaXMuY2xlYXJFcnJvcigpO1xuICAgIH0sXG4gICAgc2V0RnVuY3Rpb25OYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmluZm8uZnVuY3Rpb25OYW1lID0gbmFtZTtcbiAgICB9LFxuICAgIGdldEZ1bmN0aW9uTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmZ1bmN0aW9uTmFtZTtcbiAgICB9LFxuICAgIHNldEludmFsaWQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0VHlwZShUWVBFUy5JTlZBTElEKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpXG4gICAgICAgICAgICB0aGlzLnNldEVycm9yKG1lc3NhZ2UpO1xuICAgIH0sXG5cbiAgICBpc09mVHlwZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09IHR5cGU7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSA9PSBvdGhlci5nZXRUeXBlKCkgJiYgdGhpcy5nZXRLaW5kKCkgPT0gb3RoZXIuZ2V0S2luZCgpO1xuICAgIH0sXG5cbiAgICBpc0ludDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09mVHlwZShUWVBFUy5JTlQpO1xuICAgIH0sXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZlR5cGUoVFlQRVMuTlVNQkVSKTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzT2ZUeXBlKFRZUEVTLklOVkFMSUQpO1xuICAgIH0sXG4gICAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOdWxsKCkgfHwgdGhpcy5pc1VuZGVmaW5lZCgpO1xuICAgIH0sXG4gICAgaXNOdWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLk5VTEwpO1xuICAgIH0sXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZlR5cGUoVFlQRVMuVU5ERUZJTkVEKTtcbiAgICB9LFxuICAgIGlzQm9vbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09mVHlwZShUWVBFUy5CT09MRUFOKTtcbiAgICB9LFxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLlNUUklORyk7XG4gICAgfSxcbiAgICBpc0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLkFSUkFZKTtcbiAgICB9LFxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZlR5cGUoVFlQRVMuRlVOQ1RJT04pO1xuICAgIH0sXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZlR5cGUoVFlQRVMuT0JKRUNUKSB8fCB0aGlzLmlzT2ZUeXBlKFRZUEVTLkFSUkFZKTtcbiAgICB9LFxuICAgIGlzVmVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT2JqZWN0KCkgJiYgdGhpcy5pc09mS2luZChcIlZlYzJcIikgfHwgdGhpcy5pc09mS2luZChcIlZlYzNcIikgfHwgdGhpcy5pc09mS2luZChcIlZlYzRcIik7XG4gICAgfSxcbiAgICBpc1RleHR1cmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QoKSAmJiB0aGlzLmlzT2ZLaW5kKFwiVGV4dHVyZVwiKVxuICAgIH0sXG4gICAgaXNNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QoKSAmJiB0aGlzLmlzT2ZLaW5kKFwiTWF0MlwiKSB8fCB0aGlzLmlzT2ZLaW5kKFwiTWF0M1wiKSB8fCB0aGlzLmlzT2ZLaW5kKFwiTWF0NFwiKTtcbiAgICB9LFxuICAgIGlzR2xvYmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuaW5mby5nbG9iYWw7XG4gICAgfSxcbiAgICBzZXRHbG9iYWw6IGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBleHRyYS5nbG9iYWwgPSBnbG9iYWw7XG4gICAgfSxcbiAgICBpc091dHB1dDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmluZm8ub3V0cHV0O1xuICAgIH0sXG4gICAgc2V0T3V0cHV0OiBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgIHZhciBleHRyYSA9IHRoaXMuaW5mbztcbiAgICAgICAgZXh0cmEub3V0cHV0ID0gb3V0cHV0O1xuICAgIH0sXG4gICAgY2FuTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTnVtYmVyKCkgfHwgdGhpcy5pc0ludCgpIHx8IHRoaXMuaXNCb29sKCk7XG4gICAgfSxcbiAgICBjYW5JbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbnQoKSB8fCB0aGlzLmlzQm9vbCgpO1xuICAgIH0sXG4gICAgY2FuT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT2JqZWN0KCkgfHwgdGhpcy5pc0FycmF5KCkgfHwgdGhpcy5pc0Z1bmN0aW9uKCk7XG4gICAgfSxcbiAgICBzZXRDb21tb25UeXBlOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5lcXVhbHMoYikpIHtcbiAgICAgICAgICAgIHRoaXMuY29weUZyb20oYSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5jYW5OdW1iZXIoKSAmJiBiLmNhbk51bWJlcigpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGhhc0NvbnN0YW50VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBpZiAodGhpcy5pc051bGxPclVuZGVmaW5lZCgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBleHRyYS5oYXNPd25Qcm9wZXJ0eShcImNvbnN0YW50VmFsdWVcIik7XG4gICAgfSxcblx0Z2V0Q29uc3RhbnRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29uc3RhbnRWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhcyBubyBzdGF0aWMgdmFsdWU6IFwiICsgdGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc051bGwoKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCgpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5jb25zdGFudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0Q29uc3RhbnRWYWx1ZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBpZiAodGhpcy5pc051bGxPclVuZGVmaW5lZCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBhbmQgdW5kZWZpbmVkIGhhdmUgcHJlZGVmaW5lZCB2YWx1ZXMuXCIpO1xuICAgICAgICBleHRyYS5jb25zdGFudFZhbHVlID0gdjtcbiAgICB9LFxuICAgIGNhblVuaWZvcm1FeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NvbnN0YW50VmFsdWUoKSB8fCB0aGlzLmlzVW5pZm9ybUV4cHJlc3Npb24oKTtcbiAgICB9LFxuXG4gICAgaXNVbmlmb3JtRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmluZm87XG4gICAgICAgIHJldHVybiBleHRyYS5oYXNPd25Qcm9wZXJ0eShcInVuaWZvcm1EZXBlbmRlbmNpZXNcIilcbiAgICB9LFxuICAgIHNldFVuaWZvcm1EZXBlbmRlbmNpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKVxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IFNldC51bmlvbihkZXBlbmRlbmNpZXMsIGFyZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChhcmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXh0cmEudW5pZm9ybURlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcy52YWx1ZXMoKTtcbiAgICB9LFxuICAgIGdldFVuaWZvcm1EZXBlbmRlbmNpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICByZXR1cm4gZXh0cmEudW5pZm9ybURlcGVuZGVuY2llcyB8fCBbXTtcbiAgICB9LFxuICAgIGdldFVuaWZvcm1Db3N0czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmluZm87XG4gICAgICAgIHJldHVybiBleHRyYS51bmlmb3JtQ29zdHMgfCAwO1xuICAgIH0sXG4gICAgc2V0VW5pZm9ybUNvc3RzOiBmdW5jdGlvbiAoY29zdHMpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBleHRyYS51bmlmb3JtQ29zdHMgPSBjb3N0cztcbiAgICB9LFxuICAgIGNsZWFyVW5pZm9ybURlcGVuZGVuY2llczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmluZm87XG4gICAgICAgIGRlbGV0ZSBleHRyYS51bmlmb3JtRGVwZW5kZW5jaWVzO1xuICAgIH0sXG5cbiAgICBzZXREeW5hbWljVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5mby5jb25zdGFudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0Q2FsbDogZnVuY3Rpb24gKGNhbGwpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBleHRyYS5ldmFsdWF0ZSA9IGNhbGw7XG4gICAgfSxcbiAgICBnZXRDYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uZXZhbHVhdGU7XG4gICAgfSxcbiAgICBjbGVhckNhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBkZWxldGUgZXh0cmEuZXZhbHVhdGU7XG4gICAgfSxcbiAgICBjb3B5RnJvbTogZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0YXNzZXJ0KG90aGVyIGluc3RhbmNlb2YgVHlwZUluZm8pO1xuICAgICAgICBleHRlbmQodGhpcy5pbmZvLCBvdGhlci5pbmZvKTtcbiAgICB9LFxuICAgIHN0cjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmluZm87XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShleHRyYSwgbnVsbCwgMSk7XG4gICAgfSxcbiAgICBjYW5Ob3JtYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QoKSAmJiAodGhpcy5pc09mS2luZChLSU5EUy5OT1JNQUwpIHx8IHRoaXMuaXNPZktpbmQoS0lORFMuVkVDMykpO1xuICAgIH0sXG4gICAgY2FuQ29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QoKSAmJiAodGhpcy5pc09mS2luZChLSU5EUy5WRUM0KSB8fCB0aGlzLmlzT2ZLaW5kKEtJTkRTLlZFQzMpKTtcbiAgICB9LFxuICAgIGhhc0Vycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVycm9yKCkgIT0gbnVsbDtcbiAgICB9LFxuICAgIGdldEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleHRyYSA9IHRoaXMuaW5mbztcbiAgICAgICAgcmV0dXJuIGV4dHJhLmVycm9yO1xuICAgIH0sXG4gICAgc2V0RXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBleHRyYS5lcnJvciA9IGVycjtcbiAgICB9LFxuICAgIGNsZWFyRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5pbmZvO1xuICAgICAgICBleHRyYS5lcnJvciA9IG51bGw7XG4gICAgfSxcbiAgICBzZXRGcm9tRXh0cmE6IGZ1bmN0aW9uIChleHRyYSkge1xuICAgICAgICBleHRlbmQodGhpcy5pbmZvLCBleHRyYSk7XG4gICAgICAgIC8vIFNldCBzdGF0aWMgb2JqZWN0IGV4dHJhOiBUaGlzIG1pZ2h0IGJlIGFuIG9iamVjdFxuICAgICAgICBpZiAoZXh0cmEuY29uc3RhbnRWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29uc3RhbnRWYWx1ZShUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUodGhpcywgZXh0cmEuY29uc3RhbnRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuXHRoYXNQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPYmplY3QoKSB8fCB0aGlzLmlzRnVuY3Rpb24oKSkge1xuICAgICAgICAgICAgIHZhciBvYmo7XG4gICAgICAgICAgICAgaWYodGhpcy5nZXRLaW5kKCkpIHtcbiAgICAgICAgICAgICAgICAgb2JqID0gVHlwZVN5c3RlbS5nZXRQcmVkZWZpbmVkT2JqZWN0KHRoaXMuZ2V0S2luZCgpKTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMuaW5mbztcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKG9iai5wcm9wZXJ0aWVzICYmIG9iai5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB8fCAob2JqLnByb3RvdHlwZSAmJiBvYmoucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuXG4gICAgaXNQcmVkZWZpbmVkT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QoKSAmJiB0aGlzLmdldEtpbmQoKTtcbiAgICB9LFxuXG4gICAgZ2V0UHJvcGVydHlJbmZvOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBhc3NlcnQodGhpcy5oYXNQcm9wZXJ0eShuYW1lKSk7XG4gICAgICAgIGlmICh0aGlzLmlzUHJlZGVmaW5lZE9iamVjdCgpKSB7IC8vIFByZWRlZmluZWQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcHJlZGVmaW5lZFR5cGUgPSBUeXBlU3lzdGVtLmdldFByZWRlZmluZWRPYmplY3QodGhpcy5nZXRLaW5kKCkpO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJlZGVmaW5lZFR5cGUucHJvcGVydGllcyA/IHByZWRlZmluZWRUeXBlLnByb3BlcnRpZXNbbmFtZV0gOiAocHJlZGVmaW5lZFR5cGUucHJvdG90eXBlID8gcHJlZGVmaW5lZFR5cGUucHJvdG90eXBlW25hbWVdIDogbnVsbCk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVJbmZvKHt0eXBlOiBcImZ1bmN0aW9uXCIsIGV2YWx1YXRlOiBwcm9wZXJ0eX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR5cGVJbmZvKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZUluZm8odGhpcy5pbmZvLnByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfSxcbiAgICBzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzT2JqZWN0KCkpO1xuICAgICAgICB0aGlzLmluZm8ucHJvcGVydGllcyA9IHA7XG4gICAgfSxcblxuICAgIHNldFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCBwKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzT2JqZWN0KCkpO1xuICAgICAgICB0aGlzLmluZm8ucHJvcGVydGllc1tuYW1lXSA9IHA7XG4gICAgfSxcblxuICAgIGNhbkV2YWx1YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRnVuY3Rpb24oKSAmJiB0eXBlb2YgdGhpcy5pbmZvLmV2YWx1YXRlID09IFwiZnVuY3Rpb25cIjtcbiAgICB9LFxuXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChub2RlLCBhcmdzLCBzY29wZSwgb2JqZWN0UmVmZXJlbmNlKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmNhbkV2YWx1YXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmV2YWx1YXRlKG5vZGUsIGFyZ3MsIHNjb3BlLCBvYmplY3RSZWZlcmVuY2UpO1xuICAgIH0sXG5cbiAgICBjYW5Db21wdXRlU3RhdGljVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmluZm8uY29tcHV0ZVN0YXRpY1ZhbHVlID09IFwiZnVuY3Rpb25cIjtcbiAgICB9LFxuXG4gICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBmdW5jdGlvbiAodHlwZUluZm8sIGFyZ3MsIHNjb3BlLCBvYmplY3RSZWZlcmVuY2UpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuY2FuQ29tcHV0ZVN0YXRpY1ZhbHVlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmNvbXB1dGVTdGF0aWNWYWx1ZSh0eXBlSW5mbywgYXJncywgc2NvcGUsIG9iamVjdFJlZmVyZW5jZSk7XG4gICAgfSxcblxuICAgIGdldE5vZGVJbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmluZm87XG4gICAgfSxcbiAgICBzZXROb2RlSW5mbzogZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT2JqZWN0KCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9iamVjdHMgbWF5IGhhdmUgYSBub2RlIGluZm9cIik7XG4gICAgICAgIHRoaXMuaW5mby5pbmZvID0gaW5mbztcbiAgICB9LFxuICAgIGdldFR5cGVTdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPYmplY3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZktpbmQoS0lORFMuQU5ZKSA/IFwiT2JqZWN0XCIgOiAoXCJPYmplY3QgIzxcIiArIHRoaXMuZ2V0S2luZCgpICsgXCI+XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW50ZXJuYWwgdHlwZSBhcyBKYXZhU2NyaXB0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEphdmFTY3JpcHRUeXBlU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFRZUEVTLklOVDpcbiAgICAgICAgICAgIGNhc2UgVFlQRVMuRkxPQVQ6XG4gICAgICAgICAgICBjYXNlIFRZUEVTLk5VTUJFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIGNhc2UgVFlQRVMuT0JKRUNUOlxuICAgICAgICAgICAgY2FzZSBUWVBFUy5BUlJBWTpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgICAgICAgIGNhc2UgVFlQRVMuU1RSSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgICAgY2FzZSBUWVBFUy5VTkRFRklORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgICBjYXNlIFRZUEVTLkZVTkNUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZvciBkZWJ1ZyB3ZSB1c2UgdGhpcyBub3csIHNob3VsZCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gXCI/XCIgKyB0aGlzLmdldFR5cGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBleHRyYSA9IHRoaXMuaW5mbztcbiAgICAgICAgZXh0cmEuc291cmNlID0gc291cmNlO1xuICAgIH0sXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uc291cmNlO1xuICAgIH0sXG5cblx0aXNEZXJpdmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uZGVyaXZlZCA9PSB0cnVlO1xuICAgIH0sXG4gICAgZ2V0U3RhdGljVHJ1dGhWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAhIXVuZGVmaW5lZCA9PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNOdWxsT3JVbmRlZmluZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gISF7fSA9PSB0cnVlXG4gICAgICAgIGlmICh0aGlzLmNhbk9iamVjdCgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEluIGFsbCBvdGhlciBjYXNlcywgaXQgZGVwZW5kcyBvbiB0aGUgdmFsdWUsXG4gICAgICAgIC8vIHRodXMgd2UgY2FuIG9ubHkgZXZhbHVhdGUgdGhpcyBmb3Igc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29uc3RhbnRWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmdldENvbnN0YW50VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0U2VtYW50aWM6IGZ1bmN0aW9uIChzZW0pIHtcbiAgICAgICAgdGhpcy5pbmZvLnNlbWFudGljID0gc2VtO1xuICAgIH0sXG4gICAgZ2V0U2VtYW50aWM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5zZW1hbnRpYztcbiAgICB9LFxuXHRnZXRSZXR1cm5JbmZvOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ucmV0dXJuSW5mbztcbiAgICB9LFxuICAgIHNldFJldHVybkluZm86IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHRoaXMuaW5mby5yZXR1cm5JbmZvID0gaW5mbztcbiAgICB9XG5cbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVHlwZUluZm87XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uL3R5cGUtc3lzdGVtL3R5cGVpbmZvLmpzXCIpO1xudmFyIFRZUEVTID0gcmVxdWlyZShcIi4uL3R5cGUtc3lzdGVtL2NvbnN0YW50cy5qc1wiKS5UWVBFUztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLmV4dHJhID0gbm9kZS5leHRyYSB8fCB7dHlwZTogVFlQRVMuQU5ZfTtcbiAgICByZXR1cm4gbmV3IFR5cGVJbmZvKG5vZGUuZXh0cmEpO1xufTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIENvbnRleHQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuX3Jlc2VydmVkTmFtZXMgPSBvcHRpb25zLnJlc2VydmVkTmFtZXMgfHwgW107XG4gICAgdGhpcy5fdXNlZE5hbWVzID0gbmV3IFNldCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudFNjb3BlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlU3RhY2tbdGhpcy5fc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG59KTtcblxuQ29udGV4dC5wcm90b3R5cGUucHVzaFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgdGhpcy5fc2NvcGVTdGFjay5wdXNoKHNjb3BlKTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLnBvcFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zY29wZVN0YWNrLnBvcCgpO1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLmFubm90YXRlID0gcmVxdWlyZShcIi4vYW5ub3RhdGVcIik7XG5leHBvcnRzLlNjb3BlID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5leHBvcnRzLnRocm93RXJyb3IgPSByZXF1aXJlKFwiLi90aHJvd19lcnJvclwiKTtcbmV4cG9ydHMudG9KYXZhU2NyaXB0ID0gcmVxdWlyZShcIi4vdG9famF2YXNjcmlwdFwiKTtcbmV4cG9ydHMuQ29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIFN5bnRheCA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpLlN5bnRheDtcblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG52YXIgRXJyb3JIYW5kbGVyID0gcmVxdWlyZShcIi4vLi4vdHlwZS1zeXN0ZW0vZXJyb3JzLmpzXCIpO1xudmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4vLi4vdHlwZS1zeXN0ZW0vdHlwZWluZm8uanNcIik7XG52YXIgVFlQRVMgPSByZXF1aXJlKFwiLi8uLi90eXBlLXN5c3RlbS9jb25zdGFudHMuanNcIikuVFlQRVM7XG52YXIgYW5ub3RhdGUgPSByZXF1aXJlKFwiLi9hbm5vdGF0ZVwiKTtcblxuXG5mdW5jdGlvbiBTY29wZShub2RlLCBwYXJlbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbm9kZS5pZC5uYW1lIHx8IFwifGFub255bW91c3xcIjtcblxuICAgIGlmIChwYXJlbnQpXG4gICAgICAgIGFzc2VydChwYXJlbnQgaW5zdGFuY2VvZiBTY29wZSk7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgIHRoaXMuc2NvcGUgPSBub2RlLnNjb3BlID0gbm9kZS5zY29wZSB8fCB7fTtcbiAgICB0aGlzLnNjb3BlLmNhcHR1cmVkVmFyaWFibGVzID0gW107XG4gICAgdGhpcy5zY29wZS5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuc2NvcGUuYmluZGluZ3MgPSBub2RlLnNjb3BlLmJpbmRpbmdzIHx8IHt9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTY29wZS5wcm90b3R5cGUsIHtcbiAgICBiaW5kaW5nczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUubmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcm9vdFNjb3BlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQucm9vdFNjb3BlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXR1cm5JbmZvOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUucmV0dXJuSW5mbyB8fCB7dHlwZTogVFlQRVMuVU5ERUZJTkVEfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zY29wZS5yZXR1cm5JbmZvID0gYW5ub3RhdGlvbi5pbmZvO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblNjb3BlLnByb3RvdHlwZS5kZWNsYXJlID0gZnVuY3Rpb24obmFtZSwgdG9yZW1vdmUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5iaW5kaW5nc1tuYW1lXSA9ICB7XG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgaW5pdFBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLlVOREVGSU5FRFxuICAgICAgICB9XG4gICAgfTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5kZWNsYXJlUHJlZGVmaW5lZCA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgYXNzZXJ0KGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5uYW1lKTtcbiAgICB0aGlzLmRlY2xhcmUobmFtZSk7XG4gICAgdGhpcy51cGRhdGVUeXBlSW5mbyhuYW1lLCBuZXcgVHlwZUluZm8oe3R5cGU6IHR5cGVvZiBkZXNjcmlwdG9yLCBraW5kOiBkZXNjcmlwdG9yLm5hbWUgfSkpO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmRlY2xhcmVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1ldGVyKSB7XG4gICAgICAgIHNlbGYuZGVjbGFyZShwYXJhbWV0ZXIubmFtZSk7XG4gICAgICAgIHNlbGYudXBkYXRlVHlwZUluZm8ocGFyYW1ldGVyLm5hbWUsIG5ldyBUeXBlSW5mbyhwYXJhbWV0ZXIuZXh0cmEpKTtcbiAgICB9KTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5kZWNsYXJlcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYodGhpcy5kZWNsYXJlcyhuYW1lKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlSW5mbyh0aGlzLmJpbmRpbmdzW25hbWVdLmV4dHJhKTtcblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9IHRoaXMucGFyZW50LmdldChuYW1lKTtcbiAgICAgICAgaWYgKGluZm8gJiYgIWluZm8uaXNGdW5jdGlvbigpICYmIHRoaXMuc2NvcGUuY2FwdHVyZWRWYXJpYWJsZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpXG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNhcHR1cmVkVmFyaWFibGVzLnB1c2gobmFtZSk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUubmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBhc3NlcnQobm9kZS5uYW1lKTtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLmdldChub2RlLm5hbWUpO1xuICAgICAgICBpZighZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgRXJyb3JIYW5kbGVyLnRocm93RXJyb3Iobm9kZSwgRXJyb3JIYW5kbGVyLkVSUk9SX1RZUEVTLlJFRkVSRU5DRV9FUlJPUiArIFwiOiBcIiArIG5vZGUubmFtZSArIFwiIGlzIG5vdCBkZWZpbmVkXCIpXG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGRlZmluaXRpb24gaW5zdGFuY2VvZiBUeXBlSW5mbyk7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LlRoaXNFeHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5nZXQoXCJ0aGlzXCIpO1xuICAgICAgICBhc3NlcnQoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFR5cGVJbmZvKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGFubm90YXRlKG5vZGUpO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnVwZGF0ZVR5cGVJbmZvID0gZnVuY3Rpb24gKG5hbWUsIG5ld1R5cGVJbmZvLCBub2RlKSB7XG4gICAgaWYgKCF0aGlzLmRlY2xhcmVzKG5hbWUpKSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBuZXdUeXBlSW5mby5zZXRJbnZhbGlkKEVycm9ySGFuZGxlci5nZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRXJyb3JIYW5kbGVyLkVSUk9SX1RZUEVTLlJFRkVSRU5DRV9FUlJPUiwgbmFtZSwgXCJpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVmZXJlbmNlIGVycm9yOiBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZC5cIilcbiAgICB9XG4gICAgdmFyIHYgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgIHZhciB0eXBlID0gbmV3IFR5cGVJbmZvKHYuZXh0cmEpO1xuXG4gICAgaWYgKHYuaW5pdGlhbGl6ZWQgJiYgdHlwZS5nZXRUeXBlKCkgIT09IG5ld1R5cGVJbmZvLmdldFR5cGUoKSkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbmV3VHlwZUluZm8uc2V0SW52YWxpZChFcnJvckhhbmRsZXIuZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVycm9ySGFuZGxlci5FUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBuYW1lLCBcIm1heSBub3QgY2hhbmdlIGl0J3MgdHlwZVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbWF5IG5vdCBjaGFuZ2UgaXQncyB0eXBlOiBcIiArIG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIXYuaW5pdGlhbGl6ZWQgJiYgdi5pbml0UG9zaXRpb24pIHtcbiAgICAgICAgLy8gQW5ub3RhdGUgdGhlIGRlY2xhcmF0aW9uLCBpZiBvbmUgaXMgZ2l2ZW5cbiAgICAgICAgYW5ub3RhdGUodi5pbml0UG9zaXRpb24pLmNvcHlGcm9tKG5ld1R5cGVJbmZvKTtcbiAgICAgICAgYW5ub3RhdGUodi5pbml0UG9zaXRpb24pLnNldER5bmFtaWNWYWx1ZSgpO1xuICAgIH1cblxuICAgIHR5cGUuY29weUZyb20obmV3VHlwZUluZm8pO1xuICAgIHR5cGUuc2V0RHluYW1pY1ZhbHVlKCk7XG4gICAgdi5pbml0aWFsaXplZCA9ICF0eXBlLmlzVW5kZWZpbmVkKCk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuZ2V0U2NvcGVGb3JOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAodGhpcy5kZWNsYXJlcyhuYW1lKSlcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0U2NvcGVGb3JOYW1lKG5hbWUpO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuZ2V0U2NvcGVGb3JOYW1lKG5hbWUpO1xuICAgIGlmICghc2NvcGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzY29wZS50b1N0cmluZygpICsgXCIuXCIgKyBuYW1lO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIHdoaWxlIChjdHgpIHtcbiAgICAgICAgbmFtZXMudW5zaGlmdChjdHgubmFtZSk7XG4gICAgICAgIGN0eCA9IGN0eC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5qb2luKFwiLlwiKTtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNjb3BlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b0phdmFTY3JpcHQgPSByZXF1aXJlKFwiLi90b19qYXZhc2NyaXB0XCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihub2RlLCBtc2cpIHtcbiAgICB2YXIgbG9jID0gbm9kZSAmJiBub2RlLmxvYztcbiAgICBpZiAobG9jICYmIGxvYy5zdGFydC5saW5lKVxuICAgICAgICBtc2cgPSBcIkxpbmUgXCIgKyBsb2Muc3RhcnQubGluZSArIFwiOiBcIiArIG1zZztcblxuICAgIG1zZyArPSBcIjogXCIgKyB0b0phdmFTY3JpcHQobm9kZSk7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcbiAgICBlcnJvci5sb2MgPSBsb2M7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDb2RlR2VuZXJhdG9yID0gcmVxdWlyZShcImVzY29kZWdlblwiKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29kZUdlbmVyYXRvci5nZW5lcmF0ZShub2RlKTtcbn07Il19
